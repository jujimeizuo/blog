<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Update Error on libc and libcrypt</title>
      <link href="/2025/04/16/update-error-on-libc-and-libcrypt/"/>
      <url>/2025/04/16/update-error-on-libc-and-libcrypt/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li>因为最近有需求需要更新 libc 到 2.35，但是我的 Ubuntu 系统是 20.04，最高版本是 2.31（当时我以为是 22.04，所以可以升级到 2.35），然后就从源码中更新 libc，编译、安装，<code>make install</code> 之后，不仅发生错误，而且系统直接崩溃，命令都无法使用！！！</li><li>当我修复好系统之后，又手贱更新了 <code>libc-bin</code>，导致 libcrypt 出错，再次崩溃！！！</li><li>系统：Ubuntu 20.04，系统架构： x86_64</li></ol></blockquote><h2 id="1-系统崩溃时如何操作"><a href="#1-系统崩溃时如何操作" class="headerlink" title="1. 系统崩溃时如何操作"></a>1. 系统崩溃时如何操作</h2><p>当系统故障时，输入所有命令都无效，系统无法正常启动，此时有以下两种方法：</p><h3 id="1-1-救援模式"><a href="#1-1-救援模式" class="headerlink" title="1.1 救援模式"></a>1.1 救援模式</h3><p>开机时，按下 <code>SHIFT + ESC</code> 进入 GRUB 引导加载器页面</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">|*Ubuntu                    |</span><br><span class="line">|Advanced options for Ubuntu|</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure><p>下面有两种方式进入救援模式：</p><h4 id="1-1-1-Ubuntu"><a href="#1-1-1-Ubuntu" class="headerlink" title="1.1.1 Ubuntu"></a>1.1.1 Ubuntu</h4><ul><li>选择第一个选项并按 e 键进入编辑模式</li><li>在以 linux 开头的一行末尾，删除字符串 <code>$vt_handoff</code> 并添加字符串 <code>systemd.unit=rescue.target</code></li><li>修改完之后，按 <code>Ctrl + x</code> 或 <code>F10</code> 进入救援模式</li></ul><h4 id="1-1-2-Advanced-options-for-Ubuntu"><a href="#1-1-2-Advanced-options-for-Ubuntu" class="headerlink" title="1.1.2 Advanced options for Ubuntu"></a>1.1.2 Advanced options for Ubuntu</h4><p>选择第二个选项后继续选择内核的 <code>recover mode</code>，并选择 root 进入救援模式</p><h3 id="1-2-USB-启动盘"><a href="#1-2-USB-启动盘" class="headerlink" title="1.2 USB 启动盘"></a>1.2 USB 启动盘</h3><p>当救援模式也无法进入系统，可以使用 USB 启动盘来修复系统，制作方法如下：</p><ol><li>准备一个 U 盘，建议 8G 以上，U 盘中的文件会被格式化，确保 U 盘中的文件已备份。</li><li>下载 <a href="http://mirrors.163.com/ubuntu-releases/20.04/">Ubuntu 20.04</a> 系统镜像文件</li><li>使用 <a href="https://rufus.akeo.ie/">Rufus</a> 工具制作启动盘</li></ol><center><img src="/images/2025/04/rufus.png" width="20%"></center><ol start="4"><li>选择 Ubuntu 的 iso 文件。</li><li>然后点击开始，等待完成即可。</li><li>开机时，一直按 F2 进入 BIOS 界面，找到 USB 启动盘启动选项， 调整优先级后保存并启动。</li><li>进入 Ubuntu 系统后，选择 Try Ubuntu 进入系统。</li></ol><h3 id="1-3-挂载崩溃系统"><a href="#1-3-挂载崩溃系统" class="headerlink" title="1.3 挂载崩溃系统"></a>1.3 挂载崩溃系统</h3><p>此时通过前两种方法可以使用命令行或者图形界面进入系统，此时需要先挂载崩溃系统，然后再修复系统。</p><ol><li><p>查看崩溃系统的分区</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p> 根据自己之前分区的情况，找到崩溃系统的分区，例如我的崩溃系统是 <code>/dev/nveme0n1p7</code></p></li><li><p>挂载崩溃系统</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/nveme0n1p7 /mnt</span><br></pre></td></tr></table></figure></li><li><p>修复系统 ……</p></li><li><p>查看是否修复成功</p><p> 通过更换到崩溃系统的分区，如果没有<strong>核心已转储</strong>，能够正常进入，即修复成功。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chroot</span> /mnt</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-libc-引起的系统崩溃"><a href="#2-libc-引起的系统崩溃" class="headerlink" title="2. libc 引起的系统崩溃"></a>2. libc 引起的系统崩溃</h2><ul><li><p>当我弄一些东西的时，从源码更新 libc 到 2.35，编译、安装，<code>make install</code> 之后，系统直接崩溃，命令都无法使用！！！</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make[2]: *** [Makefile:84: da.mo] Segmentation fault (core dumped)</span><br><span class="line">make[2]: Leaving directory &#x27;/root/glibc-2.35/po&#x27;</span><br><span class="line">make[1]: *** [Makefile:215: po/subdir_install] Error 2</span><br><span class="line">make[1]: Leaving directory &#x27;/root/glibc-2.35&#x27;</span><br><span class="line">make: *** [Makefile:12: install] Error 2</span><br></pre></td></tr></table></figure></li><li><p>崩溃原因：</p><ul><li>libc.so.6 是 C 运行时库 glibc 的软链接，程序启动和运行时，是根据 libc.so.6 软链接找到glibc库</li><li>lib64&#x2F;libc.so.6 是一个软链接，指向 &#x2F;lib64&#x2F;libc.so-2.1x，2.1x 表示其对应版本，去兼容相应 Ubuntu 版本</li><li>很多基本命命令依赖 glibc，libc.so.6 链接对应版本不一致将导致系统的几乎所有程序不能工作</li></ul></li></ul><h3 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h3><ul><li><p>此时不要重启服务器，不要关闭当前终端，还有救！！！（仅限于系统中存在版本正确的 libc.so.6，不然就直接跳转到下面，）</p></li><li><p>如果系统中还有 glibc-2.31.so（<strong>此时备份的重要性</strong>），则创建软连接即可</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/lib64/libc-2.31.so /lib64/libc.so.6</span><br><span class="line"><span class="built_in">ln</span> -s /usr/lib64/ld-2.31.so /lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure></li><li><p>并且删除 2.35 相关文件</p></li></ul><h3 id="2-2-方法二"><a href="#2-2-方法二" class="headerlink" title="2.2 方法二"></a>2.2 方法二</h3><ol><li><p>进入救援模式，挂载崩溃系统</p></li><li><p>查看系统适配的 glibc 版本</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><p> 输出结果如下：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldd (Ubuntu EGLIBC 2.31-0ubuntu6.6) 2.31</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure></li><li><p>查看 libc 中 GLIBC 的版本</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep -E <span class="string">&quot;^GLIBC&quot;</span> | <span class="built_in">sort</span> -V -r | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p> 输出结果如下：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GLIBC_2.35</span><br><span class="line">GLIBC_2.34</span><br><span class="line">GLIBC_2.33</span><br><span class="line">GLIBC_2.32</span><br><span class="line">GLIBC_2.31</span><br><span class="line">GLIBC_2.30</span><br><span class="line">GLIBC_2.29</span><br><span class="line">GLIBC_2.28</span><br><span class="line">GLIBC_2.27</span><br><span class="line">GLIBC_2.26</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>发现 glibc 还是 2.35 版本，需要降级到 2.31 版本，此时崩溃系统中没有 libc-2.31.so 文件，我发现 USB 启动盘中有这个文件（所以制作启动盘时最好和崩溃系统的版本相同），此时需要将其复制到崩溃系统中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/libc-2.31.so /mnt/lib64/</span><br><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/ld-2.31.so /mnt/lib64/</span><br></pre></td></tr></table></figure></li><li><p>然后创建软链接</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /lib64/libc-2.31.so /mnt/lib64/libc.so.6</span><br><span class="line"><span class="built_in">ln</span> -s /lib64/ld-2.31.so /mnt/lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure></li><li><p><code>chroot /mnt</code> 查看是否能正常进入，到此修复成功！！！</p></li></ol><h2 id="3-libcrypt-引起的系统崩溃"><a href="#3-libcrypt-引起的系统崩溃" class="headerlink" title="3. libcrypt 引起的系统崩溃"></a>3. libcrypt 引起的系统崩溃</h2><ul><li><p>当我修复好系统之后，又手贱更新了 <code>libc-bin</code>，导致 libcrypt 出错，再次崩溃！！！</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/init: /lib/libcrypt.so.1: version `XCRYPT_2.0` not found (required by lib/systemd/lib/systemd-shared-245.so)</span><br></pre></td></tr></table></figure></li><li><p>崩溃原因：</p><ul><li>程序运行需要 libcrypt.so.1 库中的 XCRYPT_2.0 版本，但系统当前的 libcrypt.so.1 版本不支持 XCRYPT_2.0，由于库版本不兼容导致</li></ul></li><li><p>进入救援模式，挂载崩溃系统</p></li><li><p>查看 libsystemd-shared-245.so 依赖的 libcrypt.so.1 版本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd /lib/systemd/libsystemd-shared-245.so | grep libcrypt.so.1</span><br></pre></td></tr></table></figure><p>  输出结果如下：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lib/systemd/libsystemd-shared-245.so:/lib64/libcrypt.so.1:version ‘XCRYPT_2.0’ not found(required by /lib/systemd/libsystemd-shared-245.so)</span><br><span class="line">libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x00007f2636167000)</span><br></pre></td></tr></table></figure><p>  表示依赖的 libcrypt.so.1 链接于 &#x2F;lib&#x2F;libcrypt.so.1</p></li><li><p>查看 libcrypt.so.1 版本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib/libcrypt.so.1 | grep <span class="string">&quot;XCRYPT_2.0&quot;</span></span><br></pre></td></tr></table></figure><p>  没有输出，说明 &#x2F;liblibcrypt.so.1 中没有 XCRYPT_2.0 版本</p></li><li><p>发现 &#x2F;liblibcrypt.so.1 中确实没有 XCRYPT_2.0 版本，此时需要一个正确的 libcrypt.so.1 文件。</p></li></ul><h3 id="3-1-下载兼容的-libcrypt1"><a href="#3-1-下载兼容的-libcrypt1" class="headerlink" title="3.1 下载兼容的 libcrypt1"></a>3.1 下载兼容的 libcrypt1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt 可用</span></span><br><span class="line">apt download libcrypt1</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt 不可用</span></span><br><span class="line">wget http://deb.debian.org/debian/pool/main/libx/libxcrypt/libcrypt1_4.4.33-2_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i libcrypt1_4.4.33-2_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复依赖关系</span></span><br><span class="line">apt install -f</span><br></pre></td></tr></table></figure><h3 id="3-2-创建软连接"><a href="#3-2-创建软连接" class="headerlink" title="3.2 创建软连接"></a>3.2 创建软连接</h3><p>若系统存在包含 XCRYPT_2.0 版本的 libcrypt.so.1 文件（用 strings 查看），则创建软连接即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libcrypt.so.1 /lib/libcrypt.so.1</span><br></pre></td></tr></table></figure><p>此时使用 perl 命令查看是否修复（崩溃时 perl 也错误），即可大功告成！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>对于系统的库文件，一定不要轻易去修改，特别是在 root 权限下！！！<ol><li>内核级 <code>/lib64</code></li><li>系统级 <code>/usr/lib64</code></li><li>root 用户级 <code>/usr/local/lib64</code></li></ol></li><li>任何重要或不确定的文件改动不要轻易执行删除，一定要先<strong>备份</strong>，以备出现故障后能尽快恢复。</li><li>可以使用救援模式或 USB 启动盘来启动第二个系统作为备份和修复已崩溃系统的平台。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.zzstudio.net/uncategory/article_1514.html">centos7 升级 glibc2.25 踩坑记录</a></li><li><a href="https://yellowko.com/about-libc-so-6.html">关于libc.so.6</a></li><li><a href="https://www.cnblogs.com/benjamin77/p/8961037.html">安装glibc错误链接导致系统崩溃，u盘启动紧急救援模式下修复系统。</a></li><li><a href="https://blog.csdn.net/heqiang1995/article/details/133643785">升级glibc导致系统开不了机 系统文件损坏挂载u盘拷入文件 进入救援模式</a></li><li><a href="https://www.antute.com.cn/index.php?id=192">【案例分享】误删lib库导致系统崩溃的恢复</a></li><li><a href="https://developer.aliyun.com/article/1277450">覆盖libc.so.6的惨痛教训</a></li><li><a href="https://www.cnblogs.com/apanly/p/15395786.html">&#x2F;lib64&#x2F;libc.so.6 错误导致的系统崩溃</a></li><li><a href="https://blog.csdn.net/u013553529/article/details/78307520">【笔记】在 Windows 中制作 Ubuntu 系统的USB启动盘</a></li><li><a href="https://zhuanlan.zhihu.com/p/533121821">如何启动 Ubuntu 22.04 进入救援&#x2F;紧急模式 | Linux 中国</a></li><li><a href="https://blog.csdn.net/weixin_43252751/article/details/130305175">ubuntu系统崩溃，甚至Recovery模式和tty都无法进入，这个方法可以救援！</a></li><li><a href="https://blog.csdn.net/eggxo/article/details/136465370?depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-136465370-blog-103188777.235%5Ev43%5Econtrol">强行升级glibc导致Centos8崩溃6小时惊险修复</a></li><li><a href="https://blog.csdn.net/sharksmell/article/details/103188777">Ubuntu 手动更新glibc导致内核崩溃（无法正常关机&#x2F;开机启动失败）</a></li><li><a href="https://weiyan.cc/yuque/%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4/2019-07-13-hpc-experience-glibc/#21-rescue-%E6%A8%A1%E5%BC%8F%E6%AD%A5%E9%AA%A4">一次误删 GLIBC 后的系统恢复经历</a></li><li><a href="https://cloud.tencent.com/developer/ask/sof/116454423">从19.10升级到20.04失败</a></li><li><a href="https://blog.csdn.net/xibeichengf/article/details/48290297">Ubuntu下查看glibc版本</a></li><li><a href="https://unix.stackexchange.com/questions/779871/version-xcrypt-2-0-not-found-after-update-debian-10-to-debian-12">version XCRYPT_2.0 not found after Update Debian 10 to Debian 12</a></li><li><a href="https://github.com/raspberrypi/Raspberry-Pi-OS-64bit/issues/123">libcrypt.so.1: version XCRYPT_2.0 not found#123</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/04/16/update-error-on-libc-and-libcrypt/">https://blog.jujimeizuo.cn/2025/04/16/update-error-on-libc-and-libcrypt/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Batch vs. Layer vs. Group Normalization</title>
      <link href="/2025/03/17/BN-LN-GN/"/>
      <url>/2025/03/17/BN-LN-GN/</url>
      
        <content type="html"><![CDATA[<h2 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h2><ul><li>在图像预处理过程中通常会对图像进行标准化处理，这样能加速网络的收敛。</li></ul><p>$$<br>\text{image} \overset{\text{preprocess}}{\rightarrow} \text{Conv1} -&gt; \text{feature map} -&gt; \text{Conv2}<br>$$</p><ul><li>上述过程中，对于 Conv1 的输入就是满足某一分布的特征矩阵，但对于 Conv2 而言输入的 feature map 就不一定满足某一分布规律了（<strong>注意这里所说满足某一分布规律并不是指某一个 feature map 的数据要满足分布规律，理论上是指整个训练样本集所对应 feature map 的数据要满足分布规律</strong>）。</li></ul><blockquote><ul><li>Batch Normalization 的目的就是使 feature map 满足均值为 0，方差为 1 的分布规律。</li><li>让 feature map 满足某一分布规律，理论上是指整个训练样本集所对应 feature map 的数据要满足分布规律，即计算整个训练集的 feature map 然后再进行标准化处理，对于大型数据集显然不可能，所以需要使用 Batch Normalization，计算一个 Batch 数据的 feature map 然后再标准化（batch 越大越接近整个数据集的分布）。</li></ul></blockquote><ol><li>训练时要将 traning 参数设置为 True，在验证时将 trainning 参数设置为 False。在pytorch中可通过创建模型的 model.train() 和 model.eval() 方法控制。</li><li>batch size 尽可能设置大点，设置小后表现可能很糟糕，设置的越大求的均值和方差越接近整个训练集的均值和方差。</li><li>建议将 bn 层放在卷积层（Conv）和激活层（例如Relu）之间，且卷积层不要使用偏置 bias，即使使用了偏置 bias 求出的结果也是一样。</li></ol><figure class="highlight python"><figcaption><span>Batch Normalization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bn_process</span>(<span class="params">feature, mean, var</span>):</span><br><span class="line">    feature_shape = feature.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(feature_shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># [batch, channel, height, width]</span></span><br><span class="line">        feature_t = feature[:, i, :, :]</span><br><span class="line">        mean_t = feature_t.mean()</span><br><span class="line">        <span class="comment"># 总体标准差</span></span><br><span class="line">        std_t1 = feature_t.std()</span><br><span class="line">        <span class="comment"># 样本标准差</span></span><br><span class="line">        std_t2 = feature_t.std(ddof=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># bn process</span></span><br><span class="line">        <span class="comment"># 这里记得加上eps和pytorch保持一致</span></span><br><span class="line">        feature[:, i, :, :] = (feature[:, i, :, :] - mean_t) / np.sqrt(std_t1 ** <span class="number">2</span> + <span class="number">1e-5</span>)</span><br><span class="line">        <span class="comment"># update calculating mean and var</span></span><br><span class="line">        mean[i] = mean[i] * <span class="number">0.9</span> + mean_t * <span class="number">0.1</span></span><br><span class="line">        var[i] = var[i] * <span class="number">0.9</span> + (std_t2 ** <span class="number">2</span>) * <span class="number">0.1</span></span><br><span class="line">    <span class="built_in">print</span>(feature)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成一个batch为2，channel为4，height=width=2的特征向量</span></span><br><span class="line"><span class="comment"># [batch, channel, height, width]</span></span><br><span class="line">feature1 = torch.randn(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 初始化统计均值和方差</span></span><br><span class="line">calculate_mean = [<span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">calculate_var = [<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line"><span class="comment"># print(feature1.numpy())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意要使用copy()深拷贝</span></span><br><span class="line">bn_process(feature1.numpy().copy(), calculate_mean, calculate_var)</span><br><span class="line"></span><br><span class="line">bn = nn.BatchNorm2d(<span class="number">2</span>, eps=<span class="number">1e-5</span>)</span><br><span class="line">output = bn(feature1)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><h2 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h2><ul><li>Layer Normalization 针对 NLP，例如 RNN，不使用 Batch Normalization 的原因是：在 RNN 这类时序网络中，时序的长度不是一个定值，比如每句话的长短不同，很难使用 BN，所以需要使用 LN。（但 ViT 还是会涉及到 LN）</li><li>Layer Normalization 与 Batch Normalization 的区别在于：<strong>BN 是对于一个 batch 数据的每个 channel 进行 Norm，但 LN 是对单个数据的指定维度进行 Norm 处理，与 batch 无关</strong>。</li><li>LN 指定要 Norm 的维度必须从最后一维开始。</li></ul><figure class="highlight python"><figcaption><span>Layer Normalization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">layer_norm_process</span>(<span class="params">feature: torch.Tensor, beta=<span class="number">0.</span>, gamma=<span class="number">1.</span>, eps=<span class="number">1e-5</span></span>):</span><br><span class="line">    var_mean = torch.var_mean(feature, dim=[<span class="number">1</span>, <span class="number">2</span>], unbiased=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 均值</span></span><br><span class="line">    mean = var_mean[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 方差</span></span><br><span class="line">    var = var_mean[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># layer norm process</span></span><br><span class="line">    feature = (feature - mean[..., <span class="literal">None</span>]) / torch.sqrt(var[..., <span class="literal">None</span>] + eps)</span><br><span class="line">    feature = feature * gamma + beta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    t = torch.rand(<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br><span class="line">    <span class="comment"># 仅在最后一个维度上做norm处理</span></span><br><span class="line">    norm = nn.LayerNorm(normalized_shape=t.shape[-<span class="number">1</span>], eps=<span class="number">1e-5</span>)</span><br><span class="line">    <span class="comment"># 官方layer norm处理</span></span><br><span class="line">    t1 = norm(t)</span><br><span class="line">    <span class="comment"># 自己实现的layer norm处理</span></span><br><span class="line">    t2 = layer_norm_process(t, eps=<span class="number">1e-5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;t1:\n&quot;</span>, t1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;t2:\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Group-Normalization"><a href="#Group-Normalization" class="headerlink" title="Group Normalization"></a>Group Normalization</h2><ul><li>最常用的 BN 有一个缺点，Batch Size 通常较大，当 batch size 小于 16 后 error 明显升高，对于大型网络或 GPU 显存不够的情况下，可以使用 Group Normalization。</li><li>batch size 的大小对 GN 并没有影响，当 batch size 设置较小时，可以采用 GN。</li><li><strong>对于 GN，假设 num_groups &#x3D; 2（原论文默认为 32），假设某层的输出得到 x，根据 num_groups 沿 channel 方向均分成 num_groups 份，然后对每一份求均值和方差</strong>。</li></ul><figure class="highlight python"><figcaption><span>Group Normalization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group_norm</span>(<span class="params">x: torch.Tensor,</span></span><br><span class="line"><span class="params">               num_groups: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">               num_channels: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">               eps: <span class="built_in">float</span> = <span class="number">1e-5</span>,</span></span><br><span class="line"><span class="params">               gamma: <span class="built_in">float</span> = <span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">               beta: <span class="built_in">float</span> = <span class="number">0.</span></span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">divmod</span>(num_channels, num_groups)[<span class="number">1</span>] == <span class="number">0</span></span><br><span class="line">    channels_per_group = num_channels // num_groups</span><br><span class="line"></span><br><span class="line">    new_tensor = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> x.split(channels_per_group, dim=<span class="number">1</span>):</span><br><span class="line">        var_mean = torch.var_mean(t, dim=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], unbiased=<span class="literal">False</span>)</span><br><span class="line">        var = var_mean[<span class="number">0</span>]</span><br><span class="line">        mean = var_mean[<span class="number">1</span>]</span><br><span class="line">        t = (t - mean[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]) / torch.sqrt(var[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>] + eps)</span><br><span class="line">        t = t * gamma + beta</span><br><span class="line">        new_tensor.append(t)</span><br><span class="line"></span><br><span class="line">    new_tensor = torch.cat(new_tensor, dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> new_tensor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    num_groups = <span class="number">2</span></span><br><span class="line">    num_channels = <span class="number">4</span></span><br><span class="line">    eps = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">    img = torch.rand(<span class="number">2</span>, num_channels, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line">    gn = nn.GroupNorm(num_groups=num_groups, num_channels=num_channels, eps=eps)</span><br><span class="line">    r1 = gn(img)</span><br><span class="line">    <span class="built_in">print</span>(r1)</span><br><span class="line"></span><br><span class="line">    r2 = group_norm(img, num_groups, num_channels, eps)</span><br><span class="line">    <span class="built_in">print</span>(r2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.csdn.net/qq_47233366/article/details/126005692">Batch_Normalization 、Layer_Normalization 、Group_Normalization你分的清楚吗</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/104434557?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165880395216781683913421%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165880395216781683913421&biz_id=0">Batch Normalization详解</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/117653177?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165880395216781683913421%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165880395216781683913421&biz_id=0">Layer Normalization解析</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/118016048?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165880395216781683913421%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165880395216781683913421&biz_id=0">Group Normalization详解</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/03/17/BN-LN-GN/">https://blog.jujimeizuo.cn/2025/03/17/BN-LN-GN/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RGBD Camera on Astra-S</title>
      <link href="/2025/01/06/RGBD-Camera-on-Astra-S/"/>
      <url>/2025/01/06/RGBD-Camera-on-Astra-S/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>最近被导师派任务，需要自己采集数据并恢复出三维结构，所以向师兄借用了一个 Astra-S 深度相机，这里记录一下初始使用过程，包括如何安装驱动，如何使用 SDK，如何将数据转换。</li><li>我使用 Ubuntu22.04，Win11 我试过，但是出现问题，找不到驱动，估计是 Win11 的问题，Win10 应该没问题。具体可以看：<a href="https://www.bilibili.com/video/BV1QG411R7JQ/?vd_source=5e048b202705330980eefcc9a56cc5d0">https://www.bilibili.com/video/BV1QG411R7JQ/?vd_source=5e048b202705330980eefcc9a56cc5d0</a></li></ul></blockquote><h2 id="Install-SDK"><a href="#Install-SDK" class="headerlink" title="Install SDK"></a>Install SDK</h2><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><ul><li><a href="https://vcp.developer.orbbec.com.cn/documentation">3D视觉AI开放平台 Document</a></li><li><a href="https://vcp.developer.orbbec.com.cn/resourceCenter?defaultSelectedKeys=68">OpenNI2 SDK</a></li><li><a href="https://vcp.developer.orbbec.com.cn/resourceCenter?defaultSelectedKeys=72">OpenNI2 SDK Viewer</a></li></ul><p>不过 2025.01.10 之后平台下线了？？？</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这里不要用 OrbbecSDK Viewer，使用彩色和 IR 没问题，但是深度图像卡顿严重，或许是我的 Ubuntu 出现问题，但我使用 OpenNI2Viewer 没有任何问题。</li><li>如果不需要对其开发，只是用测量图像，可以直接使用 OpenNI2Viewer，不需要安装 SDK。</li></ul><h2 id="Save-RGB-D"><a href="#Save-RGB-D" class="headerlink" title="Save RGB-D"></a>Save RGB-D</h2><ul><li>当我们打开 OpenNI2Viewer 时，可以看到如下界面：</li></ul><img src="/images/2025/01/OpenNI2Viewer.jpeg"><ul><li>然后可以按右键，选择对应的功能，比如设置分辨率、截图、录制等。</li></ul><h3 id="Raw2Png"><a href="#Raw2Png" class="headerlink" title="Raw2Png"></a>Raw2Png</h3><ul><li>在 Linux 中有大量的工具可以打开 Raw，但是这些大量的工具我尝试过好多，从 apt 中安装的 ufraw，找不到，估计是不维护了，还有从源码安装的很多，还有 gimp，太大了，最后选择 ImageJ，小巧轻便，符合我的需求。</li><li>这里使用 ImageJ 进行处理，<a href="http://imagej.net/Fiji/Downloads">http://imagej.net/Fiji/Downloads</a></li><li><code>File-&gt;Import-&gt;Raw...</code><ul><li>对于深度图：<code>Image Type</code>: <code>16-bit unsigned</code></li><li>对于彩色图：<code>Image Type</code>: <code>24-bit RGB</code></li><li>宽度和高度一定要设置正确</li></ul></li><li><code>File-&gt;Save As-&gt;PNG...</code>，得到以下图像：</li></ul><table><thead><tr><th align="center">深度图</th><th align="center">彩色图</th></tr></thead><tbody><tr><td align="center"><img src="/images/2025/01/depth.jpeg"></td><td align="center"><img src="/images/2025/01/rgb.jpeg"></td></tr></tbody></table><ul><li>这只是针对单帧图像，对于大量图片如果单帧处理效率太低，可以通过 ImageJ 批量操作，具体看参考中链接。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.yahboom.com/public/upload/upload-html/1640400269/Astra%E7%9B%B8%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html">https://www.yahboom.com/public/upload/upload-html/1640400269/Astra%E7%9B%B8%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</a></li><li><a href="https://developer.orbbec.com.cn/module.html?id=4">https://developer.orbbec.com.cn/module.html?id=4</a></li><li><a href="https://blog.csdn.net/qianchuohuan3821/article/details/89498146">https://blog.csdn.net/qianchuohuan3821/article/details/89498146</a></li><li><a href="https://www.bilibili.com/opus/591919202890504930">https://www.bilibili.com/opus/591919202890504930</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/01/06/RGBD-Camera-on-Astra-S/">https://blog.jujimeizuo.cn/2025/01/06/RGBD-Camera-on-Astra-S/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Install OpenCV in Ubuntu via Source</title>
      <link href="/2025/01/06/install-opencv-in-ubuntu-via-source/"/>
      <url>/2025/01/06/install-opencv-in-ubuntu-via-source/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我在 ubuntu 22.04 中安装 OrbeecSDK 时，需要用到 OpenCV 库，而且是 C++ Version，如果是 Python Version 的话，可以直接通过 pip 安装，但是 C++ Version 的话，会比较麻烦。<br>这篇 <a href="https://zhuanlan.zhihu.com/p/392751819">在 Linux 系统中编译安装 OpenCV</a> 写得非常详细。</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>安装前需要先安装一些依赖库，根据需要安装</li><li>安装过程中会在 make 中卡住，需要等待一大段时间</li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/01/06/install-opencv-in-ubuntu-via-source/">https://blog.jujimeizuo.cn/2025/01/06/install-opencv-in-ubuntu-via-source/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activate-MathType</title>
      <link href="/2025/01/03/activate-mathtype/"/>
      <url>/2025/01/03/activate-mathtype/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 Win 中通过删除注册表项来重置 MathType 的试用期</p></blockquote><h2 id="打开注册表"><a href="#打开注册表" class="headerlink" title="打开注册表"></a>打开注册表</h2><ol><li><code>Win + R</code> -&gt; <code>regedit</code></li></ol><h2 id="删除注册表项"><a href="#删除注册表项" class="headerlink" title="删除注册表项"></a>删除注册表项</h2><ol><li>删除 <code>HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\wiris\editor\license</code></li></ol><img src="/images/2025/03/delete-mathtype-in-regedit.png" width="50%"><ol start="2"><li>删除 <code>HKEY_CURRENT_USER\Software\Install Options</code> 下的 <code>Options 7.8</code></li></ol><img src="/images/2025/01/delete-mathtype-in-regedit.png" width="50%"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.changchenghao.cn/n/725494.html">https://www.changchenghao.cn/n/725494.html</a></li><li><a href="https://www.cnblogs.com/JasonCeng/p/15710426.html">https://www.cnblogs.com/JasonCeng/p/15710426.html</a></li><li><a href="https://blog.csdn.net/m0_46667062/article/details/134808661">https://blog.csdn.net/m0_46667062/article/details/134808661</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/01/03/activate-mathtype/">https://blog.jujimeizuo.cn/2025/01/03/activate-mathtype/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Big Bug in Python</title>
      <link href="/2024/10/15/code-way-in-python/"/>
      <url>/2024/10/15/code-way-in-python/</url>
      
        <content type="html"><![CDATA[<p>找了一下午的 Bug，结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wandb.log</span><br><span class="line">(</span><br><span class="line">    &#123;</span><br><span class="line">        key=value,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>python 不是 C++，wandb.log 单独成为一行代码！！！应该写成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wandb.log(</span><br><span class="line">    &#123;</span><br><span class="line">        key=value,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/10/15/code-way-in-python/">https://blog.jujimeizuo.cn/2024/10/15/code-way-in-python/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Root-Partition Filled</title>
      <link href="/2024/10/07/root-partition-filled/"/>
      <url>/2024/10/07/root-partition-filled/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>当我在 docker 容器内 apt install 时，提示根分区即将爆满，所以查询相关内容解决问题。</li><li>以下都是在 ubuntu20.04 下实验。</li></ul></blockquote><h2 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h2><p>关于 linux 的磁盘命令，都会使用 <code>dh</code> 或 <code>df</code> 命令，如果要找导致磁盘空间满的目录或文件，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/* 2&gt;/dev/null | <span class="built_in">sort</span> -hr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><ol><li>发现 <code>/var</code> 的占空间太大，查询 <code>/var</code> 后，发现它是<strong>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</strong>，再次使用命令，查询 <code>var</code> 目录下的较大目录或文件</li><li>发现有几个目录占比非常大，<code>lib</code>, <code>cache</code>, <code>log</code>, <code>tmp</code> 等等，<code>cache</code> 可以直接删除，<code>log</code> 可以使用命令 <code>journalctl --vacuum - time=7d</code>，删除超过 7 天的旧日志，现在具体来看 <code>/var/lib</code> 目录</li><li>发现 <code>/var/lib/docker</code> 占 40 多个 G，原来镜像的位置保存在这个目录，当然很大，具体查看 <code>overlay2</code> 的性质。现在针对这个目录做一些操作。一般 <code>/home</code> 目录非常大，所以如果把 docker 里的镜像位置都放在 <code>/home</code> 目录，那么会大大减少根分区的磁盘空间，那么开始操作！</li></ol><h2 id="修改-Docker-镜像默认存储位置"><a href="#修改-Docker-镜像默认存储位置" class="headerlink" title="修改 Docker 镜像默认存储位置"></a>修改 Docker 镜像默认存储位置</h2><blockquote><p>由于系统初始分区的原因，导致操作系统中对应根分区不会太大，通过 &#x2F;var 目录不会单独分区。而 docker 镜像默认存储位置是在 <code>/var/lib/docker</code> 下，是使根分区爆炸。<br>查看 docker 容器存放位置：<code>sudo docker info | grep &quot;Docker Root Dir&quot;</code></p></blockquote><h3 id="使用软链接"><a href="#使用软链接" class="headerlink" title="使用软链接"></a>使用软链接</h3><p>解决默认存储容量不足的情况，最直接且最有效的方法就是挂载新的分区到该目录。但是在原有系统空间不变的情况下，所以采用软链接的方式，修改镜像和容器的存放路径达到同样的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /var/lib/docker /path/to/docker</span><br><span class="line"><span class="built_in">ln</span> -sf /path/to/docker /var/lib/docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="指定容器启动参数"><a href="#指定容器启动参数" class="headerlink" title="指定容器启动参数"></a>指定容器启动参数</h3><p>在配置文件中指定容器启动的参数 –graph&#x3D;&#x2F;var&#x2F;lib&#x2F;docker 来指定镜像和容器存放路径。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1835999">https://cloud.tencent.com/developer/article/1835999</a></li><li><a href="https://blog.csdn.net/BigData_Mining/article/details/104921479">https://blog.csdn.net/BigData_Mining/article/details/104921479</a></li><li><a href="https://blog.csdn.net/wjciayf/article/details/50717773">https://blog.csdn.net/wjciayf/article/details/50717773</a></li><li><a href="https://www.51cto.com/article/707120.html">https://www.51cto.com/article/707120.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1870764">https://cloud.tencent.com/developer/article/1870764</a></li><li><a href="https://www.cnblogs.com/loveer/p/11615627.html">https://www.cnblogs.com/loveer/p/11615627.html</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/10/07/root-partition-filled/">https://blog.jujimeizuo.cn/2024/10/07/root-partition-filled/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arc Sync</title>
      <link href="/2024/09/23/Arc-Sync/"/>
      <url>/2024/09/23/Arc-Sync/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 Arc 已经快 1 年，最近才发现有 Arc Sync 有在 MacOS、PC、IOS 上的同步问题（目前仅同步 SideBar，遥看未来）。<br>有什么好处？如果你在 work 的时候，突然要离开工位，如果想要在 iPhone 上继续查看电脑上的网页，那么一般情况下你会重新搜索 URL，但是 Arc Sync，可以将电脑上打开的网页直接同步到 iPhone 上，快捷方便！</p></blockquote><h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><ol><li>下载 Arc Desktop (MacOS)、ClashX Pro</li><li>Clash pro 中开启<strong>增强模式 TUN Mode</strong>，ClashX 里没有增强模式</li></ol><center><img src="/images/2024/09/arc-sync-mac-clashpro.jpg" width="20%"></center><ol start="3"><li>在 Arc Desktop 中登录账号，<code>Preferences</code> -&gt; <code>Sync SideBar</code></li></ol><center><table><tr><td><img src="/images/2024/09/arc-sync-mac.jpg"></td><td><img src="/images/2024/09/arc-sync-mac-sidebar.jpg" width="70%"></td></tr></table></center><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><ol><li>下载 Arc Desktop (Windows)、Clash for Windows</li><li>Clash for Windows 中开启<strong>增强模式 TUN Mode</strong><ol><li>Windows 无法顺利登陆，进行以下操作</li><li>旁边有一个叹号❗️，提示安装 service mode，<code>service mode</code> -&gt; <code>Manage</code> -&gt; <code>Install</code></li><li>点击 TUN Node 右边的齿轮 ⚙️，点击 DNS IPv6，Save</li><li>重启 Arc</li></ol></li><li>在 Arc Desktop 中登录账号，<code>Settings</code> -&gt; <code>SideBar Sync</code></li></ol><center><img src="/images/2024/09/arc-sync-windows.jpg" width="70%"></center><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><ol><li>从 App Store 下载 Arc Search</li><li>点击右下角 Settings，选择 <code>Sync with Arc Desktop</code>，输入账号密码即可</li><li>点击左下角即可看到同步的 SideBar，包括同时打开的标签页</li><li>记得开魔法</li></ol><center><img src="/images/2024/09/arc-sync-ios.png" width="20%"></center><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/09/23/Arc-Sync/">https://blog.jujimeizuo.cn/2024/09/23/Arc-Sync/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode BitWeek 139</title>
      <link href="/2024/09/15/LeetCode-BitWeek-139/"/>
      <url>/2024/09/15/LeetCode-BitWeek-139/</url>
      
        <content type="html"><![CDATA[<h2 id="3285-找到稳定山的下标"><a href="#3285-找到稳定山的下标" class="headerlink" title="3285. 找到稳定山的下标"></a>3285. 找到稳定山的下标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stableMountains</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stable = []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> height[i - <span class="number">1</span>] &gt; threshold:</span><br><span class="line">                stable.append(i)</span><br><span class="line">        <span class="keyword">return</span> stable</span><br></pre></td></tr></table></figure><h2 id="3286-穿越网格图的安全路径"><a href="#3286-穿越网格图的安全路径" class="headerlink" title="3286. 穿越网格图的安全路径"></a>3286. 穿越网格图的安全路径</h2><p>经典 BFS + dp，设 dp[x][y][h] 表示到达 (x, y) 时剩余 h 血量<strong>是否被走过</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findSafeWalk</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> health)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(grid.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; dx &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">const</span> <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; dy &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::vector&lt;std::vector&lt;<span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">visited</span>(n, std::vector&lt;std::vector&lt;<span class="type">bool</span>&gt;&gt;(m, std::<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(health + <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">        std::queue&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, health - grid[<span class="number">0</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>][health] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y, h] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == n - <span class="number">1</span> <span class="keyword">and</span> y == m - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt;= m <span class="keyword">or</span> h - grid[nx][ny] &lt;= <span class="number">0</span> <span class="keyword">or</span> visited[nx][ny][h - grid[nx][ny]]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;nx, ny, h - grid[nx][ny]&#125;);</span><br><span class="line">                visited[nx][ny][h - grid[nx][ny]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3287-求出数组中最大序列值"><a href="#3287-求出数组中最大序列值" class="headerlink" title="3287. 求出数组中最大序列值"></a>3287. 求出数组中最大序列值</h2><ul><li>前后缀分解 + dp</li><li>设 prefix_or[i][j][mask] 表示 1-i 个数中选 j 个数，使得这 j 个数的或值为 mask。</li><li>设 suffix_or[i][j][mask] 表示 i-n 个数中选 j 个数，使得这 j 个数的或值为 mask。</li><li>if (prefix_or[i][k][mask1] &amp;&amp; suffix_or[i + 1][k][mask2]) ans &#x3D; std::max(ans, mask1 ^ mask2)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> STATE = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"><span class="type">bool</span> prefix_or[<span class="number">402</span>][<span class="number">201</span>][STATE];</span><br><span class="line"><span class="type">bool</span> suffix_or[<span class="number">402</span>][<span class="number">201</span>][STATE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; STATE; mask += <span class="number">1</span>) &#123;</span><br><span class="line">        prefix_or[i][j][mask] = suffix_or[i][j][mask] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        prefix_or[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        suffix_or[n + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - k; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(i, k); j += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; STATE; mask += <span class="number">1</span>) &#123;</span><br><span class="line">    prefix_or[i][j][mask] = prefix_or[i][j][mask] | prefix_or[i - <span class="number">1</span>][j][mask];</span><br><span class="line">        <span class="keyword">if</span> (j)</span><br><span class="line">        prefix_or[i][j][mask | a[i - <span class="number">1</span>]] = prefix_or[i][j][mask | a[i - <span class="number">1</span>]] | prefix_or[i - <span class="number">1</span>][j - <span class="number">1</span>][mask];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= k + <span class="number">1</span>; i -= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(n - i + <span class="number">1</span>, k); j += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; STATE; mask += <span class="number">1</span>) &#123;</span><br><span class="line">        suffix_or[i][j][mask] = suffix_or[i][j][mask] | suffix_or[i + <span class="number">1</span>][j][mask];</span><br><span class="line">        <span class="keyword">if</span> (j)</span><br><span class="line">        suffix_or[i][j][mask | a[i - <span class="number">1</span>]] = suffix_or[i][j][mask | a[i - <span class="number">1</span>]] | suffix_or[i + <span class="number">1</span>][j - <span class="number">1</span>][mask];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i + k &lt;= n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask1 = <span class="number">0</span>; mask1 &lt; STATE; mask1 += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prefix_or[i][k][mask1]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask2 = <span class="number">0</span>; mask2 &lt; STATE; mask2 += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!suffix_or[i + <span class="number">1</span>][k][mask2]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, mask1 ^ mask2);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3288-最长上升路径的长度"><a href="#3288-最长上升路径的长度" class="headerlink" title="3288. 最长上升路径的长度"></a>3288. 最长上升路径的长度</h2><ul><li>二维 LIS，先按照 x 从小到大排序，对于 x 相同的点，按照 y 从大到小排序，保证计算 y 的 LIS 时，相同的 x 最多选一个 y。</li><li>选择 x &lt; kx &amp;&amp; y &lt; ky 或 x &gt; kx &amp;&amp; y &gt; ky 的点，计算 LIS。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathLength</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(coordinates.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">sort</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coordinates[i][<span class="number">0</span>] == coordinates[j][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> coordinates[i][<span class="number">1</span>] &gt; coordinates[j][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coordinates[i][<span class="number">0</span>] &lt; coordinates[j][<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((coordinates[order[i]][<span class="number">0</span>] &lt; coordinates[k][<span class="number">0</span>] <span class="keyword">and</span> coordinates[order[i]][<span class="number">1</span>] &lt; coordinates[k][<span class="number">1</span>]) </span><br><span class="line">        <span class="built_in">or</span> (coordinates[order[i]][<span class="number">0</span>] &gt; coordinates[k][<span class="number">0</span>] <span class="keyword">and</span> coordinates[order[i]][<span class="number">1</span>] &gt; coordinates[k][<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), coordinates[order[i]][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it == u.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        u.<span class="built_in">push_back</span>(coordinates[order[i]][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *it = coordinates[order[i]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) u.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/09/15/LeetCode-BitWeek-139/">https://blog.jujimeizuo.cn/2024/09/15/LeetCode-BitWeek-139/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Permissions</title>
      <link href="/2024/06/05/Linux-Permissions/"/>
      <url>/2024/06/05/Linux-Permissions/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>Linux 系统上对文件的权限有着严格的控制，如果想对某个文件执行某种操作，必须具有对应的权限方可执行成功。</li><li>Linux 下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。</li><li>Linux 下权限的粒度有<strong>拥有者</strong>、<strong>群组</strong>、<strong>其它组</strong>三种。每个文件都可以针对三个粒度，设置不同的 rwx (读写执行)权限。通常情况下，一个文件只能归属于一个用户和组，如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li><li>Linux 上通常使用 chmod 命令对文件的权限进行设置和更改。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote><p>更改文件权限，<code>chmod [Option] &lt;mode&gt; &lt;file...&gt;</code></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"> </span><br><span class="line">[Option]</span><br><span class="line">  -c, --changes          like verbose but report only when a change is made (若该档案权限确实已经更改，才显示其更改动作)</span><br><span class="line">  -f, --silent, --quiet  suppress most error messages  （若该档案权限无法被更改也不要显示错误讯息）</span><br><span class="line">  -v, --verbose          output a diagnostic for every file processed（显示权限变更的详细资料）</span><br><span class="line">       --no-preserve-root  do not treat &#x27;/&#x27; specially (the default)</span><br><span class="line">       --preserve-root    fail to operate recursively on &#x27;/&#x27;</span><br><span class="line">       --reference=RFILE  use RFILE&#x27;s mode instead of MODE values</span><br><span class="line">  -R, --recursive        change files and directories recursively （以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更)</span><br><span class="line">       --help显示此帮助信息</span><br><span class="line">       --version显示版本信息</span><br><span class="line">[mode] </span><br><span class="line">    权限设定字串，详细格式如下 ：</span><br><span class="line">    [ugoa...][[+-=][rwxX]...][,...]，</span><br><span class="line">    其中</span><br><span class="line">    [ugoa...]</span><br><span class="line">    u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示所有（包含上面三者）。</span><br><span class="line">    [+-=]</span><br><span class="line">    + 表示增加权限，- 表示取消权限，= 表示唯一设定权限。</span><br><span class="line">    [rwxX]</span><br><span class="line">    r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</span><br><span class="line"> </span><br><span class="line">[file...]</span><br><span class="line">    文件列表（单个或者多个文件、文件夹）</span><br></pre></td></tr></table></figure><h3 id="rwx"><a href="#rwx" class="headerlink" title="rwx"></a>rwx</h3><p>数字可以表示权限，规定数字 4、2、1 分别表示读、写、执行权限，即 r&#x3D;4，w&#x3D;2，x&#x3D;1。例如经常看到的 777 就是 rwxrwxrwx。</p><p>用数字权限更改格式：<code>chmod &lt;abc&gt; file...</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中</span><br><span class="line">a,b,c各为一个数字，分别代表User、Group、及Other的权限。</span><br><span class="line">相当于简化版的</span><br><span class="line">chmod u=权限,g=权限,o=权限 file...</span><br><span class="line">而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限</span><br></pre></td></tr></table></figure><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw------- (600)    只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700)    只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666)    所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777)    所有用户都有读、写、执行权限。</span><br></pre></td></tr></table></figure><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><blockquote><p>更改文件拥有者，<code>chown [Option] user[:group] file...</code></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用权限：root</span><br><span class="line"> </span><br><span class="line">说明：</span><br><span class="line">[Option] : 同上文chmod</span><br><span class="line">user : 新的文件拥有者的使用者 </span><br><span class="line">group : 新的文件拥有者的使用者群体(group)</span><br></pre></td></tr></table></figure><p>例如在普通用户下会经常看到某些文件夹&#x2F;文件“<strong>上锁</strong>”。</p><p>如果用 <code>sudo chmod -R 777</code>，递归将所有文件更改权限，当然能解锁，但是会有很大危险。<br>这个时候就可以用 chown，将文件&#x2F;文件夹的拥有者更改为任意用户，即可解锁🔓。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/u013197629/article/details/73608613">Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）</a></li><li><a href="https://www.cnblogs.com/guojiaxue/p/13084253.html">去除Ubuntu文件夹有锁标志的方法（包含目录下所有文件解锁）</a></li><li><a href="https://blog.csdn.net/weixin_44260459/article/details/122713532">Ubuntu系统下文件带小锁如何解决</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/06/05/Linux-Permissions/">https://blog.jujimeizuo.cn/2024/06/05/Linux-Permissions/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual SLAM and SfM in Dynamic Environments: A Survey</title>
      <link href="/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/"/>
      <url>/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>本文介绍 <strong>VSLAM</strong> 和 <strong>SfM</strong> 在<strong>动态环境</strong>下目前所有技术相关的综述。</p></blockquote><p>回顾动态环境中的视觉定位和 3D 重建技术：</p><ul><li>涵盖三个主要问题：<ol><li>如何做好鲁棒 VSLAM</li><li>如何在 3D 中分割和跟踪动态物体</li><li>如何实现联合运动分割和重建</li></ol></li><li>从两个角度来看：<ol><li>作为一个鲁棒性问题：相机前的动态物体导致错误的对应关系（遮挡等），可以通过分割图像中静态和动态特征，将动态部分视为异常值来实现鲁棒性，只用静态部分计算姿态估计。</li><li>作为一个标准 VSLAM 在动态环境中的扩展：将跟踪的特征分割成不同的簇，可以重建每个物体结构（形状）并跟踪轨迹，甚至可以将动态物体插入静态地图中。</li></ol></li><li>现有大致三种思路（分别对应三个主要问题）：<ol><li>排除动态特征来构建静态地图</li><li>提取动态物体而忽略静态背景</li><li>试图同时处理世界中静态和动态的组成成分</li></ol></li></ul><h2 id="综述结构"><a href="#综述结构" class="headerlink" title="综述结构"></a>综述结构</h2><ul><li>鲁棒 VSLAM<ol><li>运动分割<ol><li>背景&#x2F;前景初始化</li><li>几何约束</li><li>光流</li><li>自我运动约束</li><li>深度学习</li></ol></li><li>定位与 3D 重建<ol><li>基于特征</li><li>深度学习</li></ol></li></ol></li><li>动态物体分割与 3D 跟踪<ol><li>动态物体分割<ol><li>统计模型选择</li><li>子空间聚类</li><li>几何</li><li>深度学习</li></ol></li><li>动态物体的 3D 跟踪<ol><li>轨迹三角测量</li><li>粒子滤波</li></ol></li></ol></li><li>联合运动分割与重建<ol><li>因子分解<ol><li>多刚体运动结构（MBSfM）</li><li>非刚性运动结构（NRSfM）</li></ol></li></ol></li></ul><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-1.jpg"></center><h2 id="鲁棒-VSLAM"><a href="#鲁棒-VSLAM" class="headerlink" title="鲁棒 VSLAM"></a>鲁棒 VSLAM</h2><blockquote><p>如果仅基于静态特征计算姿态估计，就可以在动态环境中实现 Robust VSLAM。</p></blockquote><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-2.jpg"></center><h3 id="运动分割"><a href="#运动分割" class="headerlink" title="运动分割"></a>运动分割</h3><blockquote><p>将特征分为两个不同的组，即静态特征和动态特征，来检测图像中的动态部分。</p></blockquote><p>标准的 VSLAM 使用 <strong>计算几何模型（基础&#x2F;单应矩阵）</strong>、<strong>RANSAC</strong>、<strong>辛普森距离</strong> 等去除动态特征点。</p><ul><li>如果静态特征占多数，效果会很好。</li><li>如果相机前的动态物体占据较大，效果不好，其他方法可以利用 <strong>IMU</strong> 估计相机的自我运动来解决。</li></ul><h4 id="背景-前景初始化"><a href="#背景-前景初始化" class="headerlink" title="背景&#x2F;前景初始化"></a>背景&#x2F;前景初始化</h4><p>假设系统对环境有<strong>先验知识</strong>，可以利用该信息来分割。这种先验知识可以附加到背景或前景对象上。如果信息是关于前景对象的，则系统知道在相机前移动的对象的类型或形状。</p><h4 id="几何约束"><a href="#几何约束" class="headerlink" title="几何约束"></a>几何约束</h4><p>利用对极几何特性来分割静态和动态特征。动态特征违反静态场景中在多视图几何中定义的约束，可以从<strong>对极方程</strong>、<strong>三角测量</strong>、<strong>基础矩阵</strong>估计或<strong>重投影误差</strong>中推导出。</p><h4 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h4><p>光流定义了从两个连续图像计算得出的亮度模式的表观运动，对应于图像中的运动场，利用图割算法基于该运动度量来分割动态物体。还有 <strong>3D 版本的场景流</strong>。</p><h4 id="自我运动约束"><a href="#自我运动约束" class="headerlink" title="自我运动约束"></a>自我运动约束</h4><p>标准的 SfM 和 VSLAM 通过<strong>八点法</strong>或<strong>五点法</strong>来计算相机运动。另一种方法假设相机根据给定的外部信息（e.g. 车轮里程计信息）按照特定的参数化进行移动。通过这种强制自我运动约束，可以拟合与相机运动约束相匹配的特征点来对静态特征进行分类。</p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>从基于特征的运动分割中，上述可以利用光流来分割动态物体。所以可以<strong>通过监督学习来估计光流</strong>。</p><ol><li><strong>FlowNetS</strong>：通过将两张连续图像堆叠作为 CNN 的输入</li><li><strong>FlowNetC</strong>：通过引入一个相关层来比较由两个相同 CNN 流得到的两个特征图</li><li><strong>FlowNet 2.0</strong>:将  <strong>FlowNetS</strong> 和 <strong>FlowNetC</strong> 堆叠成一个更深的网络，并添加一个新的并行网络来处理小位移</li><li>使用立体图像进行场景流估计的扩展，这种光流可以输入到一个更深的网络中以发现运动特征</li><li>在图像空间中明确分割动态物体，采用重建独立成分分析自编码器来学习时空特征。然而，由于时空特征无法学习运动的 3D 几何形状，因此仍然使用几何特征来帮助分割运动。几何和时空特征都被输入到 RNN 中，以进行最终的运动分割</li><li>通过回归给定的 RGB 图像和光流的目标性的粉来分割动态物体。构建两个类似 AlexNet 的并行 CNN，处理 RGB 图像和光流，然后输入到回归网络并生成运动</li><li><strong>R-FCN</strong>：从在线图像序列中分割前景运动时结合实践数据，<strong>FCN</strong> 用于学习空间特征并生成像素稠密预测，但在应用反卷积之前，使用 <strong>GRU</strong> 来建模时间特征。</li></ol><h3 id="定位与-3D-重建"><a href="#定位与-3D-重建" class="headerlink" title="定位与 3D 重建"></a>定位与 3D 重建</h3><blockquote><p>从多张图像中估计相对相机姿态（平移和旋转）以及所观察环境的 3D 结构。</p></blockquote><ul><li>基于特征</li><li>基于深度学习</li></ul><h4 id="基于特征"><a href="#基于特征" class="headerlink" title="基于特征"></a>基于特征</h4><p>在基于特征的 VSLAM 中，提取显著特征来解决图像对应问题。现有的特征提取技术：</p><ol><li>Harris</li><li>SIFT</li><li>SURF</li><li>FAST</li></ol><p>为找到对应关系，使用特征匹配。根据两个相机的光心之间的距离（基线&#x2F;视差）分开的程度来划分。</p><ul><li>基于短基线：可以用基于光流的技术进行匹配</li><li>对于长基线：需要有高度区分度的特征描述子，例如 <strong>SIFT</strong>、<strong>SURF</strong>、<strong>BRIEF</strong>、<strong>BRISK</strong> 等，通过计算这些描述子之间的不相似性来找到对应关系，当数据包含异常值时，需要使用 <strong>RANSAC</strong>、<strong>PROSAC</strong>、<strong>MLESAC</strong> 等排除异常值。</li></ul><p>当图像对应关系已知，2-3 张图像之间的相对位姿可以恢复到一个比例因子。通过对极约束，</p><ol><li>两个视图用八点法或五点法</li><li>三个视图用三交点张量</li><li>如果已经重建了场景的一些 3D 点，可以用 P3P</li></ol><p>当相机位姿被恢复时，通过<strong>三角测量</strong>对两条投影射线进行相交，得到重建场景的 3D 点，但是由于错误的对应关系射线并不总是相交，可以用<strong>中点法</strong>或<strong>最小二乘法</strong>估计交点。为了避免漂移问题，用 <strong>BA</strong> 通过最小化重投影误差来同时相机位姿和 3D 点。另一种高斯-牛顿方法的变体 <strong>LM</strong> 优化。是联合优化场景结构和相机运动的主流方法。</p><p>实际上，有人采用<strong>局部 BA</strong> 优化最后几张图像，比如 ORB-SLAM 中就用到了。</p><h4 id="基于深度学习"><a href="#基于深度学习" class="headerlink" title="基于深度学习"></a>基于深度学习</h4><p>两种主流的方法：</p><ol><li>有监督学习</li></ol><p>监督学习通过最小化与真实姿态相比在预测自我运动时的误差来训练 CNN。在早期工作中，姿态估计被视为在相机平移和旋转的离散空间上的<strong>分类问题</strong>。但近期姿态估计技术都采用基于<strong>回归</strong>的 CNN。由于预测的连续性，回归比分类更准确。</p><p>在回归视觉里程计问题中，目标检测和分类的预训练卷机曾不适用，后续转向基于光流的网络以在不同的环境中泛化学习到的参数。</p><ul><li><strong>Flowdometry</strong>：由两个连续的 CNN 组成，第一个用于预测光流，第二个估计相机运动</li><li>计算两个视图之间自我运动的端到端 CNN，堆叠两个具有具有权重共享的并行 CNN，随后是一个空间金字塔池化 SPP 层，以处理任意输入图像，同时在特征图中保持空间信息。回归层由两个全连接层组成，用于预测相机平移和旋转</li><li><strong>DeepVO</strong>：通过 <strong>RCNN</strong>，从图像序列中学习顺序运动动力学的端到端学习框架。在输出里程计方面效果较好。</li></ul><ol start="2"><li>无监督学习</li></ol><p>在无监督的情况下，CNN 没有真实数据进行训练。相反，该网络通过最小化类似于 <strong>LSD-SLAM</strong> 的光度误差来学习预测相机位姿。</p><ul><li>利用新颖视图合成原则（给定一个源图像合成具有不同位姿的目标图像的问题）。构建两个并行的 CNN 用于预测深度和估计相机位姿。来自源图像的预测深度用于在给定相机变换矩阵和源图像的情况下合成目标图像。通过最小化光度误差，共同训练深度和相机位姿。而不是从深度预测生成目标图像。</li><li>基于深度预测、相机运动以及卷积&#x2F;反卷积网络产生的动态对象分割构建了一个 3D 场景流。场景流通过相机运动进行变换，然后反投影到当前帧以评估光度误差。</li></ul><h2 id="动态物体分割与-3D-跟踪"><a href="#动态物体分割与-3D-跟踪" class="headerlink" title="动态物体分割与 3D 跟踪"></a>动态物体分割与 3D 跟踪</h2><blockquote><p>动态对象分割和 3D 跟踪将特征对应关系基于其运动聚类到不同组中，并在 3D 中跟踪它们的轨迹。</p></blockquote><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-3.jpg"></center><h3 id="动态物体分割"><a href="#动态物体分割" class="headerlink" title="动态物体分割"></a>动态物体分割</h3><blockquote><p>动态物体分割将所有特征对应关系聚类为 n 个不同对象运动。另一个挑战是处理<strong>退化运动</strong>（当一个物体与相机运动在同一平面上且具有相同的方向和速度时）或<strong>相关运动</strong>（两个人一起移动，关节运动）。</p></blockquote><h4 id="统计模型选择"><a href="#统计模型选择" class="headerlink" title="统计模型选择"></a>统计模型选择</h4><p>用 <strong>RANSAC</strong> 或<strong>蒙特卡罗采样迭代</strong>下对数据的子集进行采样，并将运动模型拟合到采样数据中。改运动模型用于构建内点集，并将剩余数据排除为该模型的异常值。然后，对剩余数据（前一个模型的异常值）在此进行采样，以找到并拟合最能描述剩余数据的另一个模型。</p><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-4.jpg"></center><h4 id="子空间聚类"><a href="#子空间聚类" class="headerlink" title="子空间聚类"></a>子空间聚类</h4><p>许多高维数据可以用低维子空间的并集来表示。数据点的一个子空间可以由基向量和低维数据来表示。在子空间聚类框架下的 3D 运动分割问题基本上是找到与每个刚体运动相关联的每个单独子空间，并将数据拟合到这些子空间中。</p><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-5.jpg"></center><h4 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h4><p>几何方法将多视图几何的标准公式从静态场景扩展到包含独立运动物体的动态场景。虽然有一个基本矩阵描述相机相对于静态场景的一般运动，但在动态环境中，将会有 n 个基本矩阵来描述 n 个物体的运动，其中包括一个用于静态特征。</p><ul><li>通过引入多体三线性约束和多体三焦点张量，将多体运动恢复从两个视图扩展到三个视图。将静态场景中的三线性约束和三焦点张量推广到包含多个物体的动态场景。</li></ul><h4 id="深度学习-1"><a href="#深度学习-1" class="headerlink" title="深度学习"></a>深度学习</h4><p>当前用于解决动态物体分割问题的 DNN 依赖于预定义数量的刚体运动。用于生成稠密对象掩码的网络及其相关损失函数可能源自 3D 点云数据或光流。</p><ul><li><strong>SE3-Net</strong>：一种能够从 3D 点云中分割出预定义的 n 个动态对象的 DNN，在 SE(3) 变换中表示。</li><li><strong>SfM-Net</strong>：利用光流来分割动态对象。这是一个能够预测深度、相机运动和动态对象分割的具有几何感知能力的网络。</li></ul><h3 id="动态物体的-3D-跟踪"><a href="#动态物体的-3D-跟踪" class="headerlink" title="动态物体的 3D 跟踪"></a>动态物体的 3D 跟踪</h3><blockquote><p>在 3D 中跟踪动态物体，需要知道动态物体在三维的坐标位置（包括深度信息）。</p></blockquote><h4 id="轨迹三角测量"><a href="#轨迹三角测量" class="headerlink" title="轨迹三角测量"></a>轨迹三角测量</h4><p>标准三角测量，对动态物体并不起作用，因为从相应特征点反向投影的光线并不相交。<br><strong>轨迹三角测量</strong>，作为一种当物体轨迹已知或满足一个参数形式时重建运动物体三维点的技术。</p><ul><li>假设三维点沿着一条未知的三维直线移动。然后重建问题就会变成寻找一条与来自 t 个视图的投影光线相交的三维直线的问题。t 至少是 5。因为来自三个视图的相交直线集会形成一个二次曲面，使得来自第四个视图的光线在两个点相交，此时第五个视图会得出唯一解。</li><li>假设物体不是沿一条直线运动，而是在一个圆锥曲面上运动，则需要 9 个视图得到唯一解。如果圆锥类型已知，则只需要 7 个视图。</li></ul><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-6.jpg"></center><h4 id="粒子滤波"><a href="#粒子滤波" class="headerlink" title="粒子滤波"></a>粒子滤波</h4><p>由于可观测性问题（观测者与目标之间的距离无法被观测到），使用单目相机在三维中跟踪运动物体的问题可以被视为仅方位跟踪（BOT）问题。单目相机可以被视为一个仅方位跟踪传感器，因为它只能提供关于运动物体上被跟踪特征点的方位信息（例如，前一帧和当前帧中观测到的特征相对于相机中心的角度）。对于仅方位跟踪问题，基于滤波器的方法是更可取的，因为它可以对观测者和目标的位置和速度的不确定性进行建模，并且作为目标运动分析问题。</p><h2 id="联合运动分割与重建"><a href="#联合运动分割与重建" class="headerlink" title="联合运动分割与重建"></a>联合运动分割与重建</h2><blockquote><p>不是将多刚体运动分割和动态物体的三维结构重建作为单独且顺序的任务来执行，因式分解可以同时完成。给定特征对应关系，动态物体分割和重建会产生分割特征的运动以及它们的三维结构。</p></blockquote><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-7.jpg"></center><h3 id="因式分解"><a href="#因式分解" class="headerlink" title="因式分解"></a>因式分解</h3><blockquote><p>因式分解是 SfM 最突出的技术之一，可以同时解决分割和重建问题。定理：<strong>在静态场景的短序列中，一个测量矩阵，即包含所有通过所有帧跟踪的特征点的矩阵，最多为四阶（如果在欧式空间使用正交投影模型则为三阶）。</strong></p></blockquote><h4 id="多刚体运动结构（MBSfM）"><a href="#多刚体运动结构（MBSfM）" class="headerlink" title="多刚体运动结构（MBSfM）"></a>多刚体运动结构（MBSfM）</h4><p>将刚体相机运动的 SfM 推广到 n 个刚体运动。</p><h4 id="非刚性运动结构（NRSfM）"><a href="#非刚性运动结构（NRSfM）" class="headerlink" title="非刚性运动结构（NRSfM）"></a>非刚性运动结构（NRSfM）</h4><p>基于因式分解在缩放正投影相机模型下的非刚性运动。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="运动分割-1"><a href="#运动分割-1" class="headerlink" title="运动分割"></a>运动分割</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>背景&#x2F;前景初始化</td><td>当移动对象暂时静止时能够跟踪它们，无需进行新的分割。还可以处理退化运动。</td><td>1. 与背景或物体相关的信息需要事先定义<br>2. 基于检测的跟踪方案可能会阻碍实时能力</td></tr><tr><td>几何约束</td><td>不需要关于背景或动态对象的先验知识。</td><td>1. 不具备处理暂时停止的能力<br>2. 无法区分由动态对象引起的剩余误差还是由错误对应（异常值）引起的，无法处理退化运动</td></tr><tr><td>光流</td><td>不需要关于环境的先验知识，可以实时。</td><td>1. 基于亮度恒定假设，对照明条件变化很敏感<br>2. 处理退化运动困难，当物体在停止后开始移动时需要新的分割</td></tr><tr><td>自我运动约束</td><td>通过拟合符合定义的自我运动的特征，轻松地将静态特征与动态特征分割开来，可以实时，能处理退化运动</td><td>需要相机运动的先验知识，当物体暂时静止时，被视为静态场景的一部分</td></tr></tbody></table><h3 id="动态物体分割-1"><a href="#动态物体分割-1" class="headerlink" title="动态物体分割"></a>动态物体分割</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>统计模型选择</td><td>1. 只要系统允许计算低维或低自由度运动，就可以处理退化运动<br>2. 不需要关于环境的先验知识<br>3. 基于统计的方法根据内点集的基数来拟合模型，噪声和异常值会自动得到处理</td><td>从随机采样数据中拟合运动模型在计算上复杂度大。（RANSAC 的迭代次数太大）</td></tr><tr><td>子空间聚类</td><td>时间复杂度低，主要基于代数方法</td><td>1. 不能顺序&#x2F;实时运行<br>2. 需要场景中运动数量或子空间所在维度的信息<br>3. 大多数方法使用仿射相机模型，如果场景包含主要的透视效果，该模型会失败<br>4. 对长序列的实施很困难</td></tr><tr><td>几何</td><td>可以处理非线性流形中的数据</td><td>1. 仅支持基本矩阵作为运动模型，无法处理退化运动<br>2. 计算基本矩阵所需的图像相对于运动数量呈指数增长</td></tr></tbody></table><h3 id="动态物体-3D-跟踪"><a href="#动态物体-3D-跟踪" class="headerlink" title="动态物体 3D 跟踪"></a>动态物体 3D 跟踪</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>轨迹三角测量</td><td>可以逐步进行工作，尽管每次迭代需要几帧，不需要相机运动的先验知识</td><td>1. 限制是物体轨迹应该已知，或应该遵循特定的参数形式（限制了轨迹三角测量在任意物体运动中的应用）<br>2. 处理异常和缺失数据困难，需要几个图像序列才能有唯一解</td></tr><tr><td>粒子滤波</td><td>能够进行动态物体的 3D 重建和跟踪且能实时工作（严格限于少量动态物体），不需要关于物体轨迹的知识</td><td>很难扩展到非刚性重建，不符合恒定速度运动模型</td></tr></tbody></table><h3 id="联合运动分割与重建-1"><a href="#联合运动分割与重建-1" class="headerlink" title="联合运动分割与重建"></a>联合运动分割与重建</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>因式分解</td><td>1. 运动分割和重建问题可以同时解决<br>2. 不需要关于相机运动的知识<br>3. 可以扩展到非刚性重建</td><td>1. 大多数方法基于正投影或仿射相机模型工作，阻止了它在具有大透视效果条件下的实现<br>2. 不能实时，因为所有特征点轨迹必须事先可用，其次大多数方法基于 SVD，复杂度过高<br>3. 可能需要先验知识（场景中动态对象的数量、测量矩阵的秩或物体的维度）<br>4. 对噪声和异常值敏感<br>5. 缺失数据也是一个问题</td></tr></tbody></table><h3 id="深度学习-2"><a href="#深度学习-2" class="headerlink" title="深度学习"></a>深度学习</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 不需要手动特征提取，会使得特征对应问题的减少（噪声、异常值、跟踪丢失、遮挡导致的缺失数据）<br>2. 不需要指定相机模型<br>3. 学习数据非线性表示的能力提供了不同环境中良好泛化的机会，不需要针对不同环境手动微调算法参数的标准基于特征的方法</td><td>1. 动态物体分割和重建技术涉及几何计算，构建一个能理解这种几何并与标准基于特征的技术相比效果更好的 DNN 架构更难<br>2. 提取的时空特征不精确，并且不理解动态对象的几何形状</td></tr></tbody></table><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cs.ox.ac.uk/files/9926/Visual%20Slam.pdf">cs.ox.ac.uk&#x2F;files&#x2F;9926&#x2F;Visual Slam.pdf</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/">https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 3dCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile in C++</title>
      <link href="/2024/05/25/volatile/"/>
      <url>/2024/05/25/volatile/</url>
      
        <content type="html"><![CDATA[<p><strong>volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化.</strong></p><h2 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> _end;  <span class="comment">// _end是什么?</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p = &amp;_end;</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="number">0xff</span>);</span><br><span class="line">  *p = <span class="number">0x33</span>;</span><br><span class="line">  *p = <span class="number">0x34</span>;</span><br><span class="line">  *p = <span class="number">0x86</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>-O2</code> 编译代码. 尝试去掉代码中的 <code>volatile</code> 关键字, 重新使用 <code>-O2</code> 编译, 并对比去掉 <code>volatile</code> 前后反汇编结果的不同.</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><blockquote><p>如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?</p></blockquote><ol><li><strong>缓存不一致</strong>：现代计算机系统中，为了提高性能，会使用缓存来存储经常访问的数据。如果没有 <code>volatile</code> 关键字，编译器可能会将p所指向的寄存器值缓存到 CPU 的寄存器中，而不是每次都从内存中读取。这可能会导致其他线程或设备对该寄存器的修改无法及时被当前线程察觉，从而引发错误的结果。</li><li><strong>指令重排序</strong>：编译器和处理器为了提高性能，可能会对指令进行重排序。在单线程环境下，指令重排序通常不会影响程序的正确性。然而，在多线程或与设备交互的环境中，指令重排序可能会导致意外的结果。如果去掉 <code>volatile</code>，编译器可能会对与p相关的指令进行重排序，从而破坏了程序的预期行为。</li><li><strong>设备同步问题</strong>：设备寄存器通常与外部设备进行交互，这些设备可能有自己的时序 要求。如果没有 <code>volatile</code> 关键字，编译器可能会对与设备寄存器的访问进行优化，导致无法满足设备的同步要求。这可能会导致设备无法正常工作或产生错误的结果。</li></ol><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol><li>中断服务程序中修改的供其它程序检测的变量需要加 <code>volatile</code>；</li><li>多任务环境下各任务间共享的标志应该加 <code>volatile</code>；</li><li>存储器映射的硬件寄存器通常也要加 <code>volatile</code> 说明，因为每次对它的读写都可能由不同意义；</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/2.5.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">ics2023&#x2F;2.5</a></li><li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">C&#x2F;C++ 中 volatile 关键字详解</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/25/volatile/">https://blog.jujimeizuo.cn/2024/05/25/volatile/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvidia-smi unable to load driver</title>
      <link href="/2024/05/17/nvidia-smi-error/"/>
      <url>/2024/05/17/nvidia-smi-error/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>以下方法，不需要重装驱动，简单快捷。适用于Ubuntu系统下，之前已经安装过驱动，但驱动失效的问题。</li><li>否则需要重新安装驱动，参考<a href="https://blog.csdn.net/wjinjie/article/details/108512153">Ubuntu下安装nvidia显卡驱动</a>。</li></ul></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当使用 <code>nvidia-smi</code> 命令时，出现以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVIDIA-SMI has failed because it couldn&#x27;t communicate with the NVIDIA driver. </span><br><span class="line">Make sure that the latest NVIDIA driver is installed and running.</span><br></pre></td></tr></table></figure><p>估计问题出现原因是 ubuntu 系统更新了，但是 nvidia 驱动无法连接。</p><h2 id="检查驱动是否存在"><a href="#检查驱动是否存在" class="headerlink" title="检查驱动是否存在"></a>检查驱动是否存在</h2><ul><li>使用 <code>nvcc -V</code> 检查驱动和 cuda。</li></ul><center><img src="/images/2024/05/ns-1.jpg" width="50%"></center><p>发现驱动是存在的。</p><h2 id="查看已安装驱动的版本信息"><a href="#查看已安装驱动的版本信息" class="headerlink" title="查看已安装驱动的版本信息"></a>查看已安装驱动的版本信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/src | grep nvidia</span><br></pre></td></tr></table></figure><center><img src="/images/2024/05/ns-2.jpg" width="50%"></center><p>比如我这里的驱动版本为 nvidia-535.129.03。</p><h2 id="dkms"><a href="#dkms" class="headerlink" title="dkms"></a>dkms</h2><ul><li><code>dkms</code> 是一个框架，用于构建和安装内核模块。它允许你在系统中安装多个内核模块版本，并在内核升级时自动重新编译这些模块。</li><li><code>sudo apt-get install dkms</code></li><li><code>dkms install -m nvidia -v 535.129.03</code></li></ul><p>出现以下错误：</p><center><img src="/images/2024/05/ns-3.jpg" width="50%"></center><p>说明这个版本的文件不存在，需要手动更新。</p><h2 id="更新驱动"><a href="#更新驱动" class="headerlink" title="更新驱动"></a>更新驱动</h2><p>打开软件&amp;更新，根据以下操作选择对应版本（535）。</p><center><img src="/images/2024/05/ns-4.jpg" width="50%"></center><h2 id="重新-dkms"><a href="#重新-dkms" class="headerlink" title="重新 dkms"></a>重新 dkms</h2><center><img src="/images/2024/05/ns-5.jpg" width="50%"></center><p>到这里为止，再次输入 <code>nvidia-smi</code> 就可以查看 GPU 使用状态。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/">https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manhattan and Chebyshev</title>
      <link href="/2024/04/01/Manhattan-and-Chebyshev-switch/"/>
      <url>/2024/04/01/Manhattan-and-Chebyshev-switch/</url>
      
        <content type="html"><![CDATA[<h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的曼哈顿距离为：</p><p>$$<br>d(A, B) &#x3D; |x_1 - x_2| + |y_1 - y_2|<br>$$</p><blockquote><p>性质</p><ol><li>对称性：$d(A,B)&#x3D;d(B,A)$</li><li>三角不等式：$d(A,C) \le d(A,B)+d(B,C)$</li></ol></blockquote><p><strong>距离原点的曼哈顿距离为 1 组成的点：</strong></p><center><img src="/images/2024/04/manhattan.png" alt="曼哈顿"></center><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><p>定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的切比雪夫距离为：</p><p>$$<br>d(A, B) &#x3D; \max ( |x_1 - x_2|, |y_1 - y_2| )<br>$$</p><p><strong>距离原点的切比雪夫距离为 1 组成的点：</strong></p><center><img src="/images/2024/04/chebyshev.png" alt="切比雪夫"></center><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="曼哈顿转切比雪夫"><a href="#曼哈顿转切比雪夫" class="headerlink" title="曼哈顿转切比雪夫"></a>曼哈顿转切比雪夫</h3><p>将代表曼哈顿距离的正方形绕原点逆时针旋转 $\frac{\pi}{4}$，发现两个正方形是相似的，只需要把代表曼哈顿距离的正方形扩大 $\sqrt{2}$ 倍。</p><p>发现原来在代表曼哈顿距离的正方形的四条边上的点 $A(x,y)$ 的坐标由旋转之后变为了<br>$$(x * \cos{\frac{\pi}{4}}-y * \sin{\frac{\pi}{4}}, y * \cos{\frac{\pi}{4}} + x * \sin{\frac{\pi}{4}})$$<br>然后扩大后变为<br>$$A^\prime(\sqrt{2}(x * \cos{\frac{\pi}{4}}-y * \sin{\frac{\pi}{4}}), \sqrt{2}(y * \cos{\frac{\pi}{4}} + x * \sin{\frac{\pi}{4}})) \to A^\prime (x-y, x+y)$$<br>这里的旋转事实上可以理解为坐标轴的旋转。</p><h3 id="切比雪夫转曼哈顿"><a href="#切比雪夫转曼哈顿" class="headerlink" title="切比雪夫转曼哈顿"></a>切比雪夫转曼哈顿</h3><p>通过图形旋转，原来的点 $A(x,y) \to A^\prime(\frac{x+y}{2}, \frac{x-y}{2})$。（由上述逆变换证明）</p><h3 id="恒等式"><a href="#恒等式" class="headerlink" title="恒等式"></a>恒等式</h3><p>$$<br>|x_1 - x_2| + |y_1 - y_2| &#x3D; \max(|x_1^\prime - x_2^\prime|, |y_1^\prime - y_2^\prime|)<br>$$</p><p>其中等式左侧为 $(x_1,y_1)$ 和 $(x_2, y_2)$ 的<strong>曼哈顿距离</strong>，等式右侧 $(x^\prime - y^\prime)&#x3D;(x+y,y-x)$，计算的是 $(x_1^\prime - y_1^\prime)$ 和 $(x_2^\prime - y_2^\prime)$ 两点的曼哈顿距离投影到 $x^\prime$ 轴和 $y^\prime$  轴的线段长度的最大值，即<strong>切比雪夫距离</strong>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">3102. 最小化曼哈顿距离</a></li><li><a href="https://zhuanlan.zhihu.com/p/32878257">曼哈顿距离与切比雪夫距离的转换 - 知乎</a></li><li><a href="https://tom0727.github.io/post/063-%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/">曼哈顿距离 和 切比雪夫距离 - tom0727’s blog</a></li><li><a href="https://www.luogu.com/article/hxr7p6po">常用距离算法详解 - 洛谷专栏</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/">https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Custom Embeddings based on LangChain</title>
      <link href="/2024/01/29/custom-embeddings-based-on-langchain/"/>
      <url>/2024/01/29/custom-embeddings-based-on-langchain/</url>
      
        <content type="html"><![CDATA[<h2 id="基于-LangChain-自定义-Embeddings"><a href="#基于-LangChain-自定义-Embeddings" class="headerlink" title="基于 LangChain 自定义 Embeddings"></a>基于 LangChain 自定义 Embeddings</h2><blockquote><p>在 LangChain 中支持 OpenAI、LLAMA 等大模型 Embeddings 的调用接口，不过没有内置所有大模型，但是允许用户自定义 Embeddings 类型。 接下来以 ZhipuAI 为例，基于 LangChain 自定义 Embeddings。</p></blockquote><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul><li>要实现自定义 Embeddings，需要定义一个自定义类继承自 LangChain 的 Embeddings 基类，然后定义三个函数<ul><li><code>_embed</code>: 接受一个字符串，并返回一个存放 Embeddings 的 List[float]，即模型的核心调用</li><li><code>embed_query</code>: 用于对单个字符串 (query) 进行 embedding</li><li><code>embed_documents</code>: 用于对字符串列表 (documents) 进行 embedding</li></ul></li></ul><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, <span class="type">Dict</span>, <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.base <span class="keyword">import</span> Embeddings</span><br><span class="line"><span class="keyword">from</span> langchain.pydantic_v1 <span class="keyword">import</span> BaseModel, root_validator</span><br><span class="line"><span class="keyword">from</span> langchain.utils <span class="keyword">import</span> get_from_dict_or_env</span><br></pre></td></tr></table></figure><h3 id="自定义-Embedding"><a href="#自定义-Embedding" class="headerlink" title="自定义 Embedding"></a>自定义 Embedding</h3><h3 id="ZhipuAIEmbeddings"><a href="#ZhipuAIEmbeddings" class="headerlink" title="ZhipuAIEmbeddings"></a>ZhipuAIEmbeddings</h3><p>定义一个继承自 Embeddings 类的自定义 Embeddings 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZhipuAIEmbeddings</span>(BaseModel, Embeddings):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;`Zhipuai Embeddings` embedding models.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    zhipuai_api_key: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Zhipuai application apikey&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>root_validator</code> 接收一个函数作为参数，该函数包含需要校验的逻辑。函数应该返回一个字典，其中包含经过校验的数据。如果校验失败，则抛出一个 <code>ValueError</code> 异常。</p><p>装饰器 <code>root_validator</code> 确保导入了相关的包和并配置了相关的 API_Key 这里取巧，在确保导入 zhipuai model 后直接将 <code>zhipuai.model_api</code> 绑定到 client 上，减少和其他 Embeddings 类的差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@root_validator()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate_environment</span>(<span class="params">cls, values: <span class="type">Dict</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    验证环境变量或配置文件中的zhipuai_api_key是否可用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        values (Dict): 包含配置信息的字典，必须包含 zhipuai_api_key 的字段</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        values (Dict): 包含配置信息的字典。如果环境变量或配置文件中未提供 zhipuai_api_key，则将返回原始值；否则将返回包含 zhipuai_api_key 的值。</span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ValueError: zhipuai package not found, please install it with `pip install</span></span><br><span class="line"><span class="string">        zhipuai`</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    values[<span class="string">&quot;zhipuai_api_key&quot;</span>] = get_from_dict_or_env(</span><br><span class="line">        values,</span><br><span class="line">        <span class="string">&quot;zhipuai_api_key&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ZHIPUAI_API_KEY&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> zhipuai</span><br><span class="line">        zhipuai.api_key = values[<span class="string">&quot;zhipuai_api_key&quot;</span>]</span><br><span class="line">        values[<span class="string">&quot;client&quot;</span>] = zhipuai.model_api</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Zhipuai package not found, please install it with &quot;</span></span><br><span class="line">            <span class="string">&quot;`pip install zhipuai`&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h3 id="Override-embed"><a href="#Override-embed" class="headerlink" title="Override _embed"></a>Override _embed</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_embed</span>(<span class="params">self, texts: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本的 embedding。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        texts (str): 要生成 embedding 的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        embeddings (List[float]): 输入文本的 embedding，一个浮点数值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.client.invoke(</span><br><span class="line">            model=<span class="string">&quot;text_embedding&quot;</span>,</span><br><span class="line">            prompt=texts</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Error raised by inference endpoint: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp[<span class="string">&quot;code&quot;</span>] != <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Error raised by inference API HTTP code: %s, %s&quot;</span></span><br><span class="line">            % (resp[<span class="string">&quot;code&quot;</span>], resp[<span class="string">&quot;msg&quot;</span>])</span><br><span class="line">        )</span><br><span class="line">    embeddings = resp[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;embedding&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> embeddings</span><br></pre></td></tr></table></figure><h3 id="Override-embed-documents"><a href="#Override-embed-documents" class="headerlink" title="Override embed_documents"></a>Override embed_documents</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">embed_documents</span>(<span class="params">self, texts: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本列表的 embedding。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        texts (List[str]): 要生成 embedding 的文本列表.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List[List[float]]: 输入列表中每个文档的 embedding 列表。每个 embedding 都表示为一个浮点值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [self._embed(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br></pre></td></tr></table></figure><h3 id="Override-embed-query"><a href="#Override-embed-query" class="headerlink" title="Override embed_query"></a>Override embed_query</h3><p><code>embed_query</code> 是对单个文本计算 embedding 的方法，因为我们已经定义好对文档列表计算 embedding 的方法 <code>embed_documents</code> 了，这里可以直接将单个文本组装成 list 的形式传给 <code>embed_documents</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">embed_query</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本的 embedding。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        text (str): 要生成 embedding 的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        List [float]: 输入文本的 embedding，一个浮点数值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    resp = self.embed_documents([text])</span><br><span class="line">    <span class="keyword">return</span> resp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/">https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 5383. 收集饰品</title>
      <link href="/2024/01/06/acwing-5383/"/>
      <url>/2024/01/06/acwing-5383/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.acwing.com/problem/content/5386/">5383. 收集饰品</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>背包dp + 状压dp，非常巧妙的做法</p><p>现按照 k 从小到达排序，将每个饰品看成一个二进制位，每个宝箱可以让几个二进制位为 1，现在问题变成，选择若干宝箱，让每个二进制位变成 1 的最小花费，这是个典型的背包。</p><p>状态转移方程：</p><p>$$ dp[j | mask[i]] &#x3D; std::min(dp[j | mask[i]], dp[j] + x[i]); $$</p><p>复杂度：$O(n2^m)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2024-01-06 20:35:26</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, b;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span>, <span class="title">k</span><span class="params">(n)</span>, <span class="title">mask</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        std::cin &gt;&gt; x[i] &gt;&gt; k[i] &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            std::cin &gt;&gt; id;</span><br><span class="line">            mask[i] = <span class="number">1</span> &lt;&lt; (id - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> k[i] &lt; k[j];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int64_t</span> inf = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">max</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int64_t</span> ans = inf;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int64_t</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; m, inf)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j += <span class="number">1</span>) &#123;</span><br><span class="line">            dp[j | mask[order[i]]] = std::<span class="built_in">min</span>(dp[j | mask[order[i]]], dp[j] + x[order[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] + <span class="built_in">int64_t</span>(<span class="number">1</span>) * k[order[i]] * b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == inf) &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/">https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gosper&#39;s Hack Optimization</title>
      <link href="/2024/01/04/gospers-hack/"/>
      <url>/2024/01/04/gospers-hack/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们在n个数中选择m个数字，通常的做法是回溯法、状态压缩（二进制枚举）等等。这样的复杂度是 $O(2^n)$，而 Gosper’s Hack 可以在O(1)的时间内找到下一个枚举状态。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>从后往前找到第一个降序（即”01”），然后将其变为”10”，</li><li>最后将该”10”后面的序列逆转即可。</li></ol><p>假设当前状态 cur 为 0110(01)1000，那么下一个状态为 0110(10)0001</p><ol><li>cur + lowbit &#x3D; r, 前半部分，0110(10)xxxx</li><li>r ^ cur，记录变化的位数（例如一位就是0001，两位就是0011），移除”01”变为”10”的2次。”10”后面就是变化次数-2。xxxxxx(10)0001</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">next_status</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lowbit = cur &amp; -cur;</span><br><span class="line">    <span class="type">int</span> r = cur + lowbit;</span><br><span class="line">    <span class="keyword">return</span> (((r ^ cur) &gt;&gt; <span class="number">2</span>) / lowbit)  r;</span><br><span class="line">    <span class="comment">// return ((r ^ cur) &gt;&gt; __builtin_ctz(lowbit) + 2)  r;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_status</span>(<span class="params">cur: <span class="built_in">int</span></span>):</span><br><span class="line">    lowbit = cur &amp; -cur</span><br><span class="line">    r = cur + lowbit</span><br><span class="line">    <span class="keyword">return</span> (((r ^ cur) &gt;&gt; <span class="number">2</span>) // lowbit)  r</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    def count_trailing_zeros(x):</span></span><br><span class="line"><span class="string">        return (x &amp; -x).bit_length() - 1</span></span><br><span class="line"><span class="string">    return ((r ^ cur) &gt;&gt; count_trailing_zeros(lowbit) + 2)  r</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://programmingforinsomniacs.blogspot.com/2018/03/gospers-hack-explained.html">ProgrammingForInsomniacs</a></li><li><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/?envType=daily-question&envId=2024-01-04">2397. 被列覆盖的最多行数</a></li><li><a href="https://leetcode.cn/problems/next-permutation/description/">31. 下一个排列</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/">https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clash for linux</title>
      <link href="/2023/11/24/clash-for-linux/"/>
      <url>/2023/11/24/clash-for-linux/</url>
      
        <content type="html"><![CDATA[<p>由于作者已经跑路，所以使用下面的备份仓库：</p><center><div class="github-card" data-github="Elegybackup/clash-for-linux-backup" data-width="400" data-height="" data-theme="default"></div><script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></center><h2 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h2><ul><li>运行本项目建议使用root用户，或者使用 sudo 提权。</li><li>使用过程中如遇到问题，请优先查已有的 <a href="https://github.com/Elegybackup/clash-for-linux-backup/issues">issues</a>。</li><li>在进行issues提交前，请替换提交内容中是敏感信息（例如：订阅地址）。</li><li>本项目是基于 <a href="https://github.com/Dreamacro/clash">clash（已跑路）</a> 、<a href="https://github.com/haishanh/yacd">yacd</a> 进行的配置整合，关于clash、yacd的详细配置请去原项目查看。</li><li>此项目不提供任何订阅信息，请自行准备Clash订阅地址。</li><li>运行前请手动更改<code>.env</code>文件中的<code>CLASH_URL</code>变量值，否则无法正常运行。</li><li>当前在RHEL系列和Debian,Kali Linux,ubuntu以及Linux系统中测试过，其他系列可能需要适当修改脚本。</li><li>支持 x86_64&#x2F;aarch64 平台</li><li>【注意：kali Linux需要在浏览器设置代理！否则有可能无法使用！】</li></ul><blockquote><p><strong>注意</strong>：当你在使用此项目时，遇到任何无法独自解决的问题请优先前往 <a href="https://github.com/wanhebin/clash-for-linux/issues">Issues</a> 寻找解决方法。由于空闲时间有限，后续将不再对Issues中 “已经解答”、“已有解决方案” 的问题进行重复性的回答。</p></blockquote><br><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><p>下载项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Elegybackup/clash-for-linux-backup.git</span><br></pre></td></tr></table></figure><p>进入到项目目录，编辑<code>.env</code>文件，修改变量<code>CLASH_URL</code>的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br><span class="line">$ vim .<span class="built_in">env</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> <code>.env</code> 文件中的变量 <code>CLASH_SECRET</code> 为自定义 Clash Secret，值为空时，脚本将自动生成随机字符串。</p></blockquote><br><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><p>直接运行脚本文件<code>start.sh</code></p><ul><li>进入项目目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure><ul><li>运行启动脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash start.sh</span><br><span class="line"></span><br><span class="line">正在检测订阅地址...</span><br><span class="line">Clash订阅地址可访问！                                      [  OK  ]</span><br><span class="line"></span><br><span class="line">正在下载Clash配置文件...</span><br><span class="line">配置文件config.yaml下载成功！                              [  OK  ]</span><br><span class="line"></span><br><span class="line">正在启动Clash服务...</span><br><span class="line">服务启动成功！                                             [  OK  ]</span><br><span class="line"></span><br><span class="line">Clash Dashboard 访问地址：http://&lt;ip&gt;:9090/ui</span><br><span class="line">Secret：xxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">请执行以下命令加载环境变量: <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line"></span><br><span class="line">请执行以下命令开启系统代理: proxy_on</span><br><span class="line"></span><br><span class="line">若要临时关闭系统代理，请执行: proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line">$ proxy_on</span><br></pre></td></tr></table></figure><ul><li>检查服务端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -tln | grep -E <span class="string">&#x27;9090|789.&#x27;</span></span><br><span class="line">tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 :::7890                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7891                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7892                 :::*                    LISTEN</span><br></pre></td></tr></table></figure><ul><li>检查环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">env</span> | grep -E <span class="string">&#x27;http_proxy|https_proxy&#x27;</span></span><br><span class="line">http_proxy=http://127.0.0.1:7890</span><br><span class="line">https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>以上步鄹如果正常，说明服务clash程序启动成功，现在就可以体验高速下载github资源了。</p><br><h2 id="重启程序"><a href="#重启程序" class="headerlink" title="重启程序"></a>重启程序</h2><p>如果需要对Clash配置进行修改，请修改 <code>conf/config.yaml</code> 文件。然后运行 <code>restart.sh</code> 脚本进行重启。</p><blockquote><p><strong>注意：</strong><br>重启脚本 <code>restart.sh</code> 不会更新订阅信息。</p></blockquote><br><h3 id="停止程序"><a href="#停止程序" class="headerlink" title="停止程序"></a>停止程序</h3><ul><li>进入项目目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure><ul><li>关闭服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash shutdown.sh</span><br><span class="line"></span><br><span class="line">服务关闭成功，请执行以下命令关闭系统代理：proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ proxy_off</span><br></pre></td></tr></table></figure><p>然后检查程序端口、进程以及环境变量<code>http_proxy|https_proxy</code>，若都没则说明服务正常关闭。</p><br><h3 id="Clash-Dashboard"><a href="#Clash-Dashboard" class="headerlink" title="Clash Dashboard"></a>Clash Dashboard</h3><ul><li>访问 Clash Dashboard</li></ul><p>通过浏览器访问 <code>start.sh</code> 执行成功后输出的地址，例如：<a href="http://192.168.0.1:9090/ui">http://192.168.0.1:9090/ui</a></p><ul><li>登录管理界面</li></ul><p>在<code>API Base URL</code>一栏中输入：http:&#x2F;&#x2F;&lt;ip&gt;:9090 ，在<code>Secret(optional)</code>一栏中输入启动成功后输出的Secret。</p><p>点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置。</p><ul><li>更多教程</li></ul><p>此 Clash Dashboard 使用的是<a href="https://github.com/haishanh/yacd">yacd</a>项目，详细使用方法请移步到yacd上查询。</p><br><h3 id="终端界面选择代理节点"><a href="#终端界面选择代理节点" class="headerlink" title="终端界面选择代理节点"></a>终端界面选择代理节点</h3><p>部分用户无法通过浏览器使用 Clash Dashboard 进行节点选择、代理模式修改等操作，为了方便用户可以在Linux终端进行操作，下面提供了一个功能简单的脚本以便用户可以临时通过终端界面进行配置。</p><p>脚本存放位置：<code>scripts/clash_proxy-selector.sh</code></p><blockquote><p><strong>注意：</strong></p><p>使用脚本前，需要修改脚本中的 <strong>Secret</strong> 变量值为上述启动脚本输出的值，或者与 <code>.env</code> 文件中定义的 <strong>CLASH_SECRET</strong> 变量值保持一致。</p></blockquote><br><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/">https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 iOS 的快捷指令配合 GitHub Actions 实现自动化</title>
      <link href="/2023/10/06/shortcut-github-actions-automation/"/>
      <url>/2023/10/06/shortcut-github-actions-automation/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要通过快捷指令实现自动化"><a href="#为什么需要通过快捷指令实现自动化" class="headerlink" title="为什么需要通过快捷指令实现自动化"></a>为什么需要通过快捷指令实现自动化</h2><ul><li>最初的 Github Actions 需要 crontab 来定时进行自动化，这样做不仅消耗过多资源，而且在完成某个任务时不会立即获取新生成的数据。</li><li>如果我可以完成某个特定动作，例如关闭闹钟、充电、关闭 APP 时自动进行 Actions时，这样做非常高效，方法是可以利用快捷指令触发 Actions 同步数据</li><li>下面拿跑步举例，一般会用 app（我用的是 keep）来记录跑步数据，实现的操作是当关闭 keep 时会自动进行 Actions，更新数据</li></ul><h2 id="如何触发-Actions"><a href="#如何触发-Actions" class="headerlink" title="如何触发 Actions"></a>如何触发 Actions</h2><ul><li><p>首先在 yml 文件中增加 <code>workflow_dispatch</code>: 可以手动触发</p><p><img src="/images/2023/10/workflow_dispatch.jpg" alt="srcworkflow_dispatch"></p></li><li><p>先拿到这个项目的 actions id (需要自行申请 token)</p><ul><li><p>在个人的 settings 中申请 项目的token，然后在项目里的 Secrets and variables 里的 Actions 设置密钥，内容为刚刚申请的 token</p></li><li><p>执行下面代码获取 actionid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.github.com/repos/jujimeizuo/running_page/actions/workflows -H &quot;Authorization: token d8xxxxxxxxxx&quot; ## change to your config</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/2023/10/get-action-id.jpg" alt="get-action-id"></p></li><li><p>拿到 action id 就可以利用 api post 触发 action 啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;inputs&quot;: &#123;&#125;, &quot;ref&quot;:&quot;master&quot;&#125;&#x27; https://api.github.com/repos/jujimeizu/running_page/actions/workflows/: $&#123;actionid&#125;/dispatches -H &quot;Authorization: token d8e03d6xxxxxxxxxxxx&quot;  ## change to your config</span><br></pre></td></tr></table></figure></li></ul><h2 id="结合快捷指令"><a href="#结合快捷指令" class="headerlink" title="结合快捷指令"></a>结合快捷指令</h2><h3 id="快捷指令"><a href="#快捷指令" class="headerlink" title="快捷指令"></a>快捷指令</h3><ul><li>通过 icloud 获取 <a href="https://www.icloud.com/shortcuts/4a5807a98b9a4e359815ff179c62bacb">running-page-template</a></li><li>修改下面图片中字典的值即可</li></ul><p><img src="/images/2023/10/running-page-template.jpg" alt="running-page-template"></p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><img src="/images/2023/10/new-automation.png" alt="new-automation"> <img src="/images/2023/10/select-close.png" alt="select-close"></p><p><img src="/images/2023/10/select-shortcut.png" alt="select-shortcut"> <img src="/images/2023/10/finish-automation.png" alt="finish-automation"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>可以通过关闭闹钟来同步自己的起床记录——这也是 yihong 大神写的</li><li>可以利用一个 action 触发另一个项目的 action，实现另一个 repo 的更新</li><li>…</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/yihong0618/gitblog/issues/198">yihong0618 大神</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/">https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Macos通过SSH连接显示docker容器的GUI界面（ROS1小乌龟为例）</title>
      <link href="/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/"/>
      <url>/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/</url>
      
        <content type="html"><![CDATA[<h2 id="1-软硬件设置"><a href="#1-软硬件设置" class="headerlink" title="1 软硬件设置"></a>1 软硬件设置</h2><ul><li>Macbook M1 pro</li><li>docker - ubuntu18.04</li></ul><h2 id="2-配置远程服务器（ubuntu18-04）"><a href="#2-配置远程服务器（ubuntu18-04）" class="headerlink" title="2 配置远程服务器（ubuntu18.04）"></a>2 配置远程服务器（ubuntu18.04）</h2><h3 id="2-1-安装工具包"><a href="#2-1-安装工具包" class="headerlink" title="2.1 安装工具包"></a>2.1 安装工具包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器名称 /bin/sh</span><br><span class="line">apt update</span><br><span class="line">apt install openssh-server</span><br><span class="line">apt install x11-apps</span><br><span class="line">apt install vim</span><br><span class="line">passwd   <span class="comment"># 给root账号赋予密码</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置SSH服务端"><a href="#2-2-配置SSH服务端" class="headerlink" title="2.2 配置SSH服务端"></a>2.2 配置SSH服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">## 修改以下内容，端口可以自己设置，默认是22，和启动容器的映射端口对应</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line">X11Forwarding <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h3 id="2-3-重启服务"><a href="#2-3-重启服务" class="headerlink" title="2.3 重启服务"></a>2.3 重启服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><h3 id="2-4-连接docker测试"><a href="#2-4-连接docker测试" class="headerlink" title="2.4 连接docker测试"></a>2.4 连接docker测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p docker端口 root@远程IP</span><br></pre></td></tr></table></figure><h2 id="3-本地Macos配置"><a href="#3-本地Macos配置" class="headerlink" title="3 本地Macos配置"></a>3 本地Macos配置</h2><h3 id="3-1-安装Xquartz"><a href="#3-1-安装Xquartz" class="headerlink" title="3.1 安装Xquartz"></a>3.1 安装Xquartz</h3><p><a href="https://www.xquartz.org/">Xquartz官网</a></p><h3 id="3-2-Xquartz设置"><a href="#3-2-Xquartz设置" class="headerlink" title="3.2 Xquartz设置"></a>3.2 Xquartz设置</h3><ol><li>XQuartz -&gt; 偏好设置 -&gt; 安全性 -&gt; 勾选“允许从网络客户端连接” -&gt; 退出程序；</li><li>终端键入 xhost + ip（注意两者之间的空格）重新启动 XQuartz；为远程主机添加权限 或者xhost +为所有IP添加权限</li><li>ssh -XY <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#48;&#46;&#48;&#x2e;&#48;&#46;&#48;">&#x72;&#111;&#111;&#116;&#x40;&#48;&#46;&#48;&#x2e;&#48;&#46;&#48;</a> -p 6100</li><li>netstat -an grep -F 6100 查看</li></ol><p>xquartz操作后需要重启。</p><h3 id="3-3-docker进入"><a href="#3-3-docker进入" class="headerlink" title="3.3 docker进入"></a>3.3 docker进入</h3><p>在 run 或 exec 容器时加入-e DISPLAY&#x3D;host.docker.internal:0参数，比如我这里通过对一个现有的，已经安装过 xarclock 时钟小程序的容器 toyOS 执行docker exec -ite DISPLAY&#x3D;host.docker.internal:0 toyOS &#x2F;usr&#x2F;bin&#x2F;xarclock，就会在我的本地出现一个小时钟的GUI程序；</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ite DISPLAY=host.docker.internal:0 ub18.04-orb-slam2 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="3-4-测试ros小乌龟"><a href="#3-4-测试ros小乌龟" class="headerlink" title="3.4 测试ros小乌龟"></a>3.4 测试ros小乌龟</h3><p>tmux设置三个终端</p><p>如下图所示：</p><p><img src="/images/2023/07/image-1690552905696.png" alt="file"></p><p>也可以在docker内部执行，设置环境变量指定显示端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=host.docker.internal:0  </span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/">https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> Docker </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Titanic数据集预测</title>
      <link href="/2023/07/13/dl-titanic/"/>
      <url>/2023/07/13/dl-titanic/</url>
      
        <content type="html"><![CDATA[<p>学习自@<a href="https://blog.csdn.net/csdn_xmj/article/details/122172552">双木的木</a>。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在kaggle官网上有<a href="https://www.kaggle.com/c/titanic/data">Titanic</a>有关的数据集，有以下features，现要求对Suvrived特征进行预测。</p><p><img src="/images/2023/07/image-1689229188640.png" alt="file"></p><h2 id="数据集分析"><a href="#数据集分析" class="headerlink" title="数据集分析"></a>数据集分析</h2><p>数据集被划分为训练集和测试集：</p><ul><li>training set (train.csv)</li><li>test set (test.csv)</li></ul><p>训练集应该被用来建立你的深度学习模型。对于训练集，我们为每个乘客提供结果(也称为“ground truth”)。你的模型将基于乘客的性别和阶级等“特征”。您还可以使用特征工程来创建新的特征。</p><p>测试集应该用来查看您的模型在不可见数据上的性能。对于测试集，我们不为每个乘客提供基本真相。你的工作就是预测这些结果。对于测试中的每一位乘客，使用你训练的模型来预测他们是否在泰坦尼克号沉没时幸存下来。</p><p>还包括gender_submit .csv，这是一组假设所有且只有女性乘客能够存活的预测，作为提交文件的示例。</p><p><img src="/images/2023/07/image-1689229530750.png" alt="file"></p><p>选取[“Pclass”, “Sex”, “SibSp”, “Parch”, “Fare”]五个特征进行训练。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><h4 id="TitanicDataset"><a href="#TitanicDataset" class="headerlink" title="TitanicDataset"></a>TitanicDataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TitanicDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filepath</span>):</span><br><span class="line">        features = [<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;Fare&quot;</span>]</span><br><span class="line">        xy = pd.read_csv(filepath)</span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>] <span class="comment">## [0]代表行数，[1]代表列数</span></span><br><span class="line">        <span class="comment">## dummies相当于one-hot编码</span></span><br><span class="line">        self.x_data = torch.from_numpy(np.array(pd.get_dummies(xy[features], dtype=np.float32))).<span class="built_in">float</span>()</span><br><span class="line">        <span class="comment">## np.array(data[&#x27;survived&#x27;])是对data[&#x27;survived&#x27;]创建一个矩阵</span></span><br><span class="line">        <span class="comment">## torch.from_numpy()是将括号内的矩阵形式转换为张量形式，方便torch处理</span></span><br><span class="line">        self.y_data = torch.from_numpy(np.array(xy[<span class="string">&#x27;Survived&#x27;</span>], dtype=np.float32)).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">titanic_train = TitanicDataset(<span class="string">r&#x27;./titanic/train.csv&#x27;</span>)</span><br><span class="line">train_loader = DataLoader(dataset=titanic_train, batch_size=<span class="number">16</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="构造模型"><a href="#构造模型" class="headerlink" title="构造模型"></a>构造模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">## 对继承于torch.nn的父模块类进行初始化</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        <span class="comment">## 这里包括2个线性层，每一个线性层输出都用激活函数激活</span></span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">6</span>, <span class="number">3</span>) <span class="comment">## 五个特征转化为了6维，因为get_dummies将性别这一个特征用两个维度来表示，即男性[1,0],女性[0，1]</span></span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">## 激活函数从Sigmoid这一大类激活函数中选取sigmoid这一种激活函数</span></span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self</span>):</span><br><span class="line">        val_correct, total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">                inputs, label = data</span><br><span class="line">                predicted = model.predict(inputs)</span><br><span class="line">                total += label.size(<span class="number">0</span>)</span><br><span class="line">                val_correct += (predicted == np.array(label)).<span class="built_in">sum</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Accuracy: %d&#x27;</span> %(val_correct / total * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment">## 该函数用在测试集过程，因此只有前馈，没有什么</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            x = self.sigmoid(self.linear1(x))</span><br><span class="line">            x = self.sigmoid(self.linear2(x))</span><br><span class="line">            y = []</span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> result &gt; <span class="number">0.5</span>:</span><br><span class="line">                    y.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = Model()</span><br></pre></td></tr></table></figure><h3 id="损失函数和优化器"><a href="#损失函数和优化器" class="headerlink" title="损失函数和优化器"></a>损失函数和优化器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">            inputs, label = data</span><br><span class="line">            y_pred = model(inputs)</span><br><span class="line">            y_pred = y_pred.squeeze(-<span class="number">1</span>) <span class="comment">## 将维度降至1维并输出出来</span></span><br><span class="line">            loss = criterion(y_pred, label) <span class="comment">## 将预测的值与标签进行比较，并求解出误差值</span></span><br><span class="line">            <span class="built_in">print</span>(epoch, i, loss.item())</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad() <span class="comment">## 之前的梯度进行清零，否则梯度会累加起来</span></span><br><span class="line">            loss.backward() <span class="comment">## 反向传播</span></span><br><span class="line">            optimizer.step() <span class="comment">## 更新</span></span><br></pre></td></tr></table></figure><h3 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self</span>):</span><br><span class="line">        val_correct, total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">                inputs, label = data</span><br><span class="line">                predicted = model(inputs)</span><br><span class="line">                total += label.size(<span class="number">0</span>)</span><br><span class="line">                val_correct += (predicted == label).<span class="built_in">sum</span>().item()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Accuracy: %d %%&#x27;</span> %(val_correct / total * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">model.verify()</span><br></pre></td></tr></table></figure><h3 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment">## 该函数用在测试集过程，因此只有前馈，没有什么</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            x = self.sigmoid(self.linear1(x))</span><br><span class="line">            x = self.sigmoid(self.linear2(x))</span><br><span class="line">            y = []</span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> result &gt; <span class="number">0.5</span>:</span><br><span class="line">                    y.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(<span class="string">r&#x27;./titanic/test.csv&#x27;</span>)</span><br><span class="line">features = [<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;Fare&quot;</span>]</span><br><span class="line">test = torch.from_numpy(np.array(pd.get_dummies(test_data[features]), dtype=np.float32))</span><br><span class="line"></span><br><span class="line">result = model.predict(test)</span><br><span class="line"></span><br><span class="line">submission = pd.read_csv(<span class="string">r&#x27;./titanic/gender_submission.csv&#x27;</span>)</span><br><span class="line">submission[<span class="string">&#x27;Survived&#x27;</span>] = result</span><br><span class="line">submission.to_csv(<span class="string">r&#x27;./titanic/gender_submission_result_1.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/07/13/dl-titanic/">https://blog.jujimeizuo.cn/2023/07/13/dl-titanic/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep-learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用时钟周期评测性能</title>
      <link href="/2023/04/23/rdtsc/"/>
      <url>/2023/04/23/rdtsc/</url>
      
        <content type="html"><![CDATA[<h2 id="rdtsc指令"><a href="#rdtsc指令" class="headerlink" title="rdtsc指令"></a>rdtsc指令</h2><p>rdtsc指令, 该指令返回CPU自启动以来的时钟周期数；该时钟周期数，即处理器的时间戳。</p><p>在CPU通电启动后，首先会重置EDX和EAX，在每个时钟周期上升或下降沿到来时，会自动累计周期数，并被记录到EDX和EAX寄存器中，EDX是高位，EAX是低位。</p><p>rdtsc指令就是从该寄存器中进行获取的。</p><p>周期和频率的关系公式：T（周期）&#x3D;1&#x2F;f（频率）</p><p>如CPU频率f为1GHz，则其时钟周期T&#x3D;1&#x2F;1GHz秒，意味着每隔T秒，CPU完成一个最基本的动作，并在寄存器中，对周期数加1。</p><p>故，假设当前时钟周期数为m，则可计算出CPU自启动后，累计运行时间X&#x3D;m*T.</p><p>$$CPU累计运行时间&#x3D;时钟周期数&#x2F;CPU频率$$</p><h2 id="固定CPU频率"><a href="#固定CPU频率" class="headerlink" title="固定CPU频率"></a>固定CPU频率</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cpufrequtils</span><br><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors</span><br><span class="line">sudo cpufreq-set -g performance</span><br><span class="line"></span><br><span class="line"><span class="comment">## 不能一次性设置，需要手动一个一个设置</span></span><br><span class="line">cpufreq-set -c 0 -f 2.4G</span><br><span class="line">cpufreq-set -c 1 -f 2.4G</span><br><span class="line">cpufreq-set -c 2 -f 2.4G</span><br><span class="line">cpufreq-set -c 3 -f 2.4G</span><br><span class="line">cpufreq-set -c 4 -f 2.4G</span><br><span class="line">cpufreq-set -c 5 -f 2.4G</span><br><span class="line">cpufreq-set -c 6 -f 2.4G</span><br><span class="line">cpufreq-set -c 7 -f 2.4G</span><br><span class="line">cpufreq-set -c 8 -f 2.4G</span><br><span class="line">cpufreq-set -c 9 -f 2.4G</span><br><span class="line">cpufreq-set -c 10 -f 2.4G</span><br><span class="line">cpufreq-set -c 11 -f 2.4G</span><br><span class="line">cpufreq-set -c 12 -f 2.4G</span><br><span class="line">cpufreq-set -c 13 -f 2.4G</span><br><span class="line">cpufreq-set -c 14 -f 2.4G</span><br><span class="line">cpufreq-set -c 15 -f 2.4G</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo  grep MHz</span><br></pre></td></tr></table></figure><h2 id="绑定CPU核"><a href="#绑定CPU核" class="headerlink" title="绑定CPU核"></a>绑定CPU核</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">bind_to_core</span><span class="params">(<span class="type">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return;</span></span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(tid, &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(mask), &amp;mask) != <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to set affinity (core: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定第15个CPU核。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind_to_core</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h2 id="获取时钟周期"><a href="#获取时钟周期" class="headerlink" title="获取时钟周期"></a>获取时钟周期</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">rdtsc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lo, hi;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span> (lo), <span class="string">&quot;=d&quot;</span> (hi));</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)hi &lt;&lt; <span class="number">32</span>)  lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/04/23/rdtsc/">https://blog.jujimeizuo.cn/2023/04/23/rdtsc/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> hpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法算子库 - KD-Tree</title>
      <link href="/2023/04/03/kdtree/"/>
      <url>/2023/04/03/kdtree/</url>
      
        <content type="html"><![CDATA[<h2 id="libnabo"><a href="#libnabo" class="headerlink" title="libnabo"></a>libnabo</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>libnabo 是一个用于低维空间的快速 K 最近邻库。得益于 C++ 模板，它提供了一个干净、无遗留问题、与标量类型无关的 API。它当前的 CPU 实现受到ANN的强烈启发，但具有更紧凑的数据类型。平均而言，libnabo 比ANN快 5% 到 20% 。</p><p>libnabo 依赖于Eigen，一个现代 C++ 矩阵和线性代数库。libnabo 适用于 Eigen 的版本 2 或 3。libnabo 还可以选择依赖Boost，这是一个用于 Python 绑定的 C++ 通用库。</p><h3 id="installion"><a href="#installion" class="headerlink" title="installion"></a>installion</h3><h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:ethz-asl/libnabo.git</span><br></pre></td></tr></table></figure><h4 id="prerequisites"><a href="#prerequisites" class="headerlink" title="prerequisites"></a>prerequisites</h4><ul><li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" title="Eigen">Eigen</a></li><li><a href="https://www.boost.org/users/download/">Boost</a> （Option)</li></ul><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR=<span class="built_in">pwd</span></span><br><span class="line">BUILD_DIR=<span class="variable">$&#123;SRC_DIR&#125;</span>/build</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;BUILD_DIR&#125;</span> &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;BUILD_DIR&#125;</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo <span class="variable">$&#123;SRC_DIR&#125;</span></span><br><span class="line"><span class="comment"># if Eigen or Boost are not available system-wide, run at that point:</span></span><br><span class="line"><span class="comment">#   cmake-gui .</span></span><br><span class="line"><span class="comment"># cmake-gui allows you to tell the location of Eigen or Boost</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------</span></span><br><span class="line"><span class="comment"># DEPENDENCY: nabo</span></span><br><span class="line"><span class="comment">#--------------------</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> nabo)</span><br><span class="line">  <span class="comment"># Find libnabo:</span></span><br><span class="line">  <span class="keyword">find_package</span>(libnabo REQUIRED PATHS <span class="variable">$&#123;LIBNABO_INSTALL_DIR&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;libnabo found, version $&#123;libnabo_VERSION&#125; (include=$&#123;libnabo_INCLUDE_DIRS&#125; libs=$&#123;libnabo_LIBRARIES&#125;)&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="comment"># libnabo already part of this project (e.g. as a git submodule)</span></span><br><span class="line">  <span class="comment"># (This, plus the use of cmake target properties in libnabo, will also</span></span><br><span class="line">  <span class="comment"># introduce the required include directories, flags, etc.)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># This cmake target alias will be defined by either: </span></span><br><span class="line"><span class="comment"># a) libnabo sources if built as a git submodule in the same project than this library, or</span></span><br><span class="line"><span class="comment"># b) by libnabo-targets.cmake, included by find_package(libnabo) above.</span></span><br><span class="line"><span class="keyword">set</span>(libnabo_LIBRARIES libnabo::nabo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target_link_libraries THIRD_PARTY_LIBS is ok</span></span><br><span class="line"><span class="keyword">set</span>(THIRD_PARTY_LIBS</span><br><span class="line">        <span class="variable">$&#123;libnabo_LIBRARIES&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># ####### dependencies ########</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;EIGEN3_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;NABO_INCLUDE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="flann"><a href="#flann" class="headerlink" title="flann"></a>flann</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>FLANN（近似近邻快速库）是一个用于执行快速近似近邻搜索的库。FLANN是用C++编写的，该库提供的C、MATLAB和Python接口。</p><h3 id="Installion"><a href="#Installion" class="headerlink" title="Installion"></a>Installion</h3><h4 id="download-1"><a href="#download-1" class="headerlink" title="download"></a>download</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/flann-lib/flann.git </span><br></pre></td></tr></table></figure><h4 id="install-1"><a href="#install-1" class="headerlink" title="install"></a>install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> flann</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON_BINDINGS=OFF -DBUILD_MATLAB_BINDINGS=OFF -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF -DBUILD_D</span><br><span class="line">OC=OFF ..</span><br><span class="line">make -j5</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(flann REQUIRED)</span><br><span class="line"><span class="keyword">set</span>(THIRD_PARTY_LIBS</span><br><span class="line">        <span class="variable">$&#123;libflann_LIBRARIES&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/04/03/kdtree/">https://blog.jujimeizuo.cn/2023/04/03/kdtree/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础算法算子库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决__FILE__ 宏绝对路径的问题(相对路径)</title>
      <link href="/2023/02/27/cmake-file/"/>
      <url>/2023/02/27/cmake-file/</url>
      
        <content type="html"><![CDATA[<h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><p>通过cmake编译的代码，在代码中输出FILE就代码文件的绝对路径。在大多数使用FILE这宏的，一般都是用于日志输出，首先使用绝对路径会使日志量膨胀，其次我们最终的程序执行的环境，可能与编译的环境不一样，输出绝对路径并没有多大的参考意义</p><p>例如：&#x2F;home&#x2F;dell&#x2F;workspace&#x2F;….</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>既然FILE宏是gcc定义的，默认等于gcc命令中的文件路径，我们可以通过重新定义该宏来达到我们的目的，如下方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ tests/test.cc -D__FILE__=<span class="string">&quot;\&quot;tests/test.cc\&quot;&quot;</span> -o test</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：hello __FILE__=tests/test.cc</span></span><br></pre></td></tr></table></figure><h2 id="在cmake里解决"><a href="#在cmake里解决" class="headerlink" title="在cmake里解决"></a>在cmake里解决</h2><p>如果需要在每个源文件的编译上面都带上对应的定义(-D<strong>FILE</strong>=”\”tests&#x2F;test.cc\””),那么CMakeLists.txt里面就比较混乱了。我们可以把这种定义，封装到一个cmake函数里面，当需要使用这个功能的时候，就执行一下这个函数，这样就可以优雅的解决FILE绝对路径的问题，将绝对路径变成相对路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## utils.cmake</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##重新定义当前目标的源文件的__FILE__宏</span></span><br><span class="line"><span class="keyword">function</span>(redefine_file_macro targetname)</span><br><span class="line">    <span class="comment">##获取当前目标的所有源文件</span></span><br><span class="line">    <span class="keyword">get_target_property</span>(source_files <span class="string">&quot;$&#123;targetname&#125;&quot;</span> SOURCES)</span><br><span class="line">    <span class="comment">##遍历源文件</span></span><br><span class="line">    <span class="keyword">foreach</span>(sourcefile <span class="variable">$&#123;source_files&#125;</span>)</span><br><span class="line">        <span class="comment">##获取当前源文件的编译参数</span></span><br><span class="line">        <span class="keyword">get_property</span>(defs SOURCE <span class="string">&quot;$&#123;sourcefile&#125;&quot;</span></span><br><span class="line">            PROPERTY COMPILE_DEFINITIONS)</span><br><span class="line">        <span class="comment">##获取当前文件的绝对路径</span></span><br><span class="line">        <span class="keyword">get_filename_component</span>(filepath <span class="string">&quot;$&#123;sourcefile&#125;&quot;</span> ABSOLUTE)</span><br><span class="line">        <span class="comment">##将绝对路径中的项目路径替换成空,得到源文件相对于项目路径的相对路径</span></span><br><span class="line">        <span class="keyword">string</span>(REPLACE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/ <span class="string">&quot;&quot;</span> relpath <span class="variable">$&#123;filepath&#125;</span>)</span><br><span class="line">        <span class="comment">##将我们要加的编译参数(__FILE__定义)添加到原来的编译参数里面</span></span><br><span class="line">        <span class="keyword">list</span>(APPEND defs <span class="string">&quot;__FILE__=\&quot;$&#123;relpath&#125;\&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">##重新设置源文件的编译参数</span></span><br><span class="line">        <span class="keyword">set_property</span>(</span><br><span class="line">            SOURCE <span class="string">&quot;$&#123;sourcefile&#125;&quot;</span></span><br><span class="line">            PROPERTY COMPILE_DEFINITIONS <span class="variable">$&#123;defs&#125;</span></span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>我们将上面的代码，写入到utils.cmake文件里面，然后去修改我们的CMakeLists.txt，让我们的代码支持FILE输出相对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project(server)</span><br><span class="line"></span><br><span class="line">include (utils.cmake)</span><br><span class="line"></span><br><span class="line">add_definitions(-Wno-builtin-macro-redefined)</span><br><span class="line"></span><br><span class="line">add_executable(test tests/test.cc)</span><br><span class="line">redefine_file_macro(test)</span><br></pre></td></tr></table></figure><p>redefine_file_macro(test), 为我们的输出目标添加FILE宏重定义功能 当我们冲定义了FILE宏，编译器会告警 “:0:0: warning: “FILE” redefined [-Wbuiltin-macro-redefined]”, 为了解决这个警告，我们需要在CMakeLists.txt里面加上add_definitions(-Wno-builtin-macro-redefined)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结 cmake编译的FILE虽然是绝对路径，我们可以通过冲定义FILE的方式来解决。cmake支持自定义函数，自定义宏的方式，我们利用自定义函数，将我们经常使用的特性封装到函数里面，写到一个单独的cmake文件里面，当我们需要使用的时候，只需要include xxx.cmake文件就可以了。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/02/27/cmake-file/">https://blog.jujimeizuo.cn/2023/02/27/cmake-file/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用-epoll</title>
      <link href="/2023/01/27/epoll/"/>
      <url>/2023/01/27/epoll/</url>
      
        <content type="html"><![CDATA[<h2 id="叙述"><a href="#叙述" class="headerlink" title="叙述"></a>叙述</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>epoll（eventpoll）是一种I&#x2F;O事件通知机制，是linux内核实现IO多路复用的实现。</p><p>IO多路复用指在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用时返回，然后对其进行读写操作。</p><p>epoll时select和poll的升级版，改进了工作方式会更加高效。</p><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>通知机制就是当事件发生时会主动通知，反面就是轮询机制。</p><h4 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h4><p>epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制</p><h4 id="对比select和poll"><a href="#对比select和poll" class="headerlink" title="对比select和poll"></a>对比select和poll</h4><p>select&#x2F;poll 低效的原因之一是将 “添加 &#x2F; 维护待检测任务” 和 “阻塞进程 &#x2F; 线程” 两个步骤合二为一。每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 个数相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl() 维护等待队列，再调用 epoll_wait() 阻塞进程（解耦）。通过下图的对比显而易见，epoll 的效率得到了提升。</p><p><img src="https://subingwen.cn/linux/epoll/image-20210403181746358.png"></p><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h4 id="epoll-size"><a href="#epoll-size" class="headerlink" title="epoll_size()"></a>epoll_size()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_size</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>内核会产生一个epoll 实例数据结构并返回一个文件描述符，这个特殊的描述符就是epoll实例的句柄，后面的两个接口都以它为中心（即epfd形参）。</p><ul><li>函数参数<ul><li>size：在 Linux 内核 2.6.8 版本以后，这个参数是被忽略的，只需要指定一个大于 0 的数值就可以了。</li></ul></li><li>函数返回值：<ul><li>失败：返回 - 1</li><li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的 epoll 实例了</li></ul></li></ul><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl()"></a>epoll_ctl()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理红黑树上的文件描述符（添加、修改、删除）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line"><span class="type">void</span> *ptr; <span class="comment">/* 指向用户自定义数据 */</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 注册的文件描述符 */</span></span><br><span class="line"><span class="type">uint32_t</span> u32; <span class="comment">/* 32-bit integer */</span></span><br><span class="line"><span class="type">uint64_t</span> u64; <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span> events; <span class="comment">/* 描述epoll事件 */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* 见上面的结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例</li><li>op：这是一个枚举值，控制通过该函数执行什么操作<ul><li>EPOLL_CTL_ADD：往 epoll 模型中添加新的节点</li><li>EPOLL_CTL_MOD：修改 epoll 模型中已经存在的节点</li><li>EPOLL_CTL_DEL：删除 epoll 模型中的指定的节点</li></ul></li><li>fd：文件描述符，即要添加 &#x2F; 修改 &#x2F; 删除的文件描述符</li><li>event：epoll 事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul><li>events：委托 epoll 检测的事件<ul><li>EPOLLIN：读事件，接收数据，检测读缓冲区，如果有数据该文件描述符就绪</li><li>EPOLLOUT：写事件，发送数据，检测写缓冲区，如果可写该文件描述符就绪</li><li>EPOLLERR：异常事件</li></ul></li></ul></li><li>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd 成员，用于存储待检测的文件描述符的值，在调用 epoll_wait() 函数的时候这个值会被传出。</li></ul></li><li>函数返回值：<ul><li>失败：返回 -1</li><li>成功：返回 0</li></ul></li></ul><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait()"></a>epoll_wait()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中。</p><ul><li>函数参数：<ul><li>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例</li><li>events：传出参数，这是一个结构体数组的地址，里边存储了已就绪的文件描述符的信息</li><li>maxevents：修饰第二个参数，结构体数组的容量（元素个数）</li><li>timeout：如果检测的 epoll 实例中没有已就绪的文件描述符，该函数阻塞的时长，单位 ms 毫秒<ul><li>0：函数不阻塞，不管 epoll 实例中有没有就绪的文件描述符，函数被调用后都直接返回</li><li>大于 0：如果 epoll 实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li><li>-1：函数一直阻塞，直到 epoll 实例中有已就绪的文件描述符之后才解除阻塞</li></ul></li></ul></li><li>函数返回值：<ul><li>成功：<ul><li>等于 0：函数是阻塞被强制解除了，没有检测到满足条件的文件描述符</li><li>大于 0：检测到的已就绪的文件描述符的总个数</li></ul></li><li>失败：返回 - 1</li></ul></li></ul><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll监控多个文件描述符的I&#x2F;O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通过epoll_wait等待I&#x2F;O事件，如果当前没有可用的事件则阻塞调用线程。 select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。</p><h4 id="水平触发-LT"><a href="#水平触发-LT" class="headerlink" title="水平触发(LT)"></a>水平触发(LT)</h4><p>水平模式可以简称为 LT 模式，LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行 IO 操作了。如果我们不作任何操作，内核还是会继续通知使用者。</p><ul><li>读事件：如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait () 解除阻塞<ul><li>当读事件被触发，epoll_wait () 解除阻塞，之后就可以接收数据了</li><li>如果接收数据的 buf 很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）</li><li>因为读数据是被动的，必须要通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的</li></ul></li><li>写事件：如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait () 解除阻塞<ul><li>当写事件被触发，epoll_wait () 解除阻塞，之后就可以将数据写入到写缓冲区了</li><li>写事件的触发发生在写数据之前而不是之后，被写入到写缓冲区中的数据是由内核自动发送出去的</li><li>如果写缓冲区没有被写满，写事件会一直被触发</li><li>因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的</li></ul></li></ul><h4 id="边缘触发-ET"><a href="#边缘触发-ET" class="headerlink" title="边缘触发(ET)"></a>边缘触发(ET)</h4><p>边沿模式可以简称为 ET 模式，ET（edge-triggered）是高速工作方式，只支持no-block socket。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）。如果我们对这个文件描述符做 IO 操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</p><ul><li>读事件：当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件<ul><li>如果有新数据进入到读缓冲区，读事件被触发，epoll_wait () 解除阻塞</li><li>读事件被触发，可以通过调用 read ()&#x2F;recv () 函数将缓冲区数据读出</li><li>如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次</li><li>如果数据被全部读走或者只读走一部分，此时有新数据进入，读事件被触发，并且只通知一次</li></ul></li><li>写事件：当写缓冲区状态可写，写事件只会触发一次<ul><li>如果写缓冲区被检测到可写，写事件被触发，epoll_wait () 解除阻塞</li><li>写事件被触发，就可以通过调用 write ()&#x2F;send () 函数，将数据写入到写缓冲区中</li><li>写缓冲区从不满到被写满，期间写事件只会被触发一次</li><li>写缓冲区从满到不满，状态变为可写，写事件只会被触发一次</li></ul></li></ul><p>综上所述：epoll 的边沿模式下 epoll_wait () 检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。 <strong>ET模式的设置：</strong> 边沿模式不是默认的 epoll 模式，需要额外进行设置。epoll 设置边沿模式是非常简单的，epoll 管理的红黑树示例中每个节点都是 struct epoll_event 类型，只需要将 EPOLLET 添加到结构体的 events 成员中即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN  EPOLLET;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://zhuanlan.zhihu.com/p/159135478">https://zhuanlan.zhihu.com/p/159135478</a> <a href="https://blog.csdn.net/baidu_41388533/article/details/110134366">https://blog.csdn.net/baidu_41388533&#x2F;article&#x2F;details&#x2F;110134366</a> <a href="https://subingwen.cn/linux/epoll/##2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">https://subingwen.cn/linux/epoll/##2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/27/epoll/">https://blog.jujimeizuo.cn/2023/01/27/epoll/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitbook 入门</title>
      <link href="/2023/01/18/gitbook-introduction/"/>
      <url>/2023/01/18/gitbook-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><p>高版本可能不兼容，需要版本在v10左右。 <a href="https://nodejs.org/download/release/v10.21.0/"></a><a href="https://nodejs.org/download/release/v10.21.0/">https://nodejs.org/download/release/v10.21.0/</a></p><h4 id="更换镜像"><a href="#更换镜像" class="headerlink" title="更换镜像"></a>更换镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g gitbook-cli</span><br></pre></td></tr></table></figure><p>安装完之后用<code>gitbook -V</code>查看版本，自动install gitbook。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitbook -V      查看版本号</span><br><span class="line">gitbook init    初始化</span><br><span class="line">gitbook serve   预览</span><br><span class="line">gitbook build   生成</span><br><span class="line">gitbook build --gitbook=2.6.7 生成时指定gitbook的版本, 本地没有会先下载</span><br><span class="line">gitbook uninstall 2.6.7   卸载指定版本号的gitbook</span><br><span class="line">gitbook fetch [version]      获取[版本]下载并安装&lt;版本&gt;</span><br><span class="line">gitbook --<span class="built_in">help</span>   显示帮助文档</span><br><span class="line">gitbook ls-remote  列出NPM上的可用版本：</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/18/gitbook-introduction/">https://blog.jujimeizuo.cn/2023/01/18/gitbook-introduction/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codestudio Weekend Contest 56 - Ninja And The Challenge</title>
      <link href="/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/"/>
      <url>/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给一个序列，一次操作可以使得任意元素+1&#x2F;-1，问最少多少次操作可以使得整个序列递增或递减？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>能否只构造成递增来解决？</p><blockquote><p>当然可以，如果想要构造成递减，只需要把序列逆序，然后构造成递增。</p></blockquote><p>假设我们只有 2 个数字 [10, 6]，那么我们可以将 6 向上移动 4 步或 10 向下移动 4 步；无论哪种方式，成本都是 4。同时，以同样的成本，我们还可以制作 [7, 7] 或 [8, 8] 或 [9, 9] 或 [10, 10]。</p><p>假设我们支付了 4 的成本并使其成为 [10, 6] → [6, 6]，并且由于我们已经支付了成本，以后如果我们改变主意，我们可以自由地向上移动 [6, 6]到 [7, 7], [8, 8], …, 无需额外费用，因为 [7, 7], [8, 8],[9, 9]… 都需要我们已经支付的 4 个步骤. 数字 [6, 6] 现在向上自由。</p><p>一个向上的自由数字可以自由上升直到它之前的最大数字，并作为它的最低值存储。对于每个数字，我们找到它的向上空闲数并制作向上空闲数组。保证我们总是可以使用这个更新的空闲数组来增加数组。</p><p>例如，如果向上自由数组是 [1, 7, 6, 3]，我们可以创建一个零成本的递增数组 [1, 7, 7, 7]，因为最后 6, 3 是向上自由的。</p><p>如果下一个数是5，那么我们以2为代价减少7→5，新的向上自由数组变为[1,7,6,3]→[1,5,6,3,5]，而这个数组可以成为零成本的递增序列 [1, 5, 6, 6, 6]。</p><p>总之，如果新数字大于迄今为止最大的向上自由数字，则追加它，因为序列已经在增加。但如果不是，则以差值为代价，将最大的向上自由数减少到与新数相同；这两个数字现在都向上免费了。第二大数字现在成为新的高度。</p><p>我们使用最大堆来存储这些向上的空闲数，以在 O(log(n)) 时间内找到最大的一个。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() &gt; x) &#123;</span><br><span class="line">            ans += pq.<span class="built_in">top</span>() - x;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            pq.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumMovesToSort</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.rbegin(), a.rend())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="built_in">solve</span>(a), <span class="built_in">solve</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">    std::cin.tie(nullptr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/">https://blog.jujimeizuo.cn/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模版 - 偏特化与全特化</title>
      <link href="/2023/01/11/c-template-specialization/"/>
      <url>/2023/01/11/c-template-specialization/</url>
      
        <content type="html"><![CDATA[<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数，从而实现了真正的代码可重用性。 模版可以分为两类，一个是函数模版，另外一个是类模版。</p><blockquote><p>C++的模板机制被证明是图灵完备的，即可以通过<a href="https://harttle.land/2015/09/16/effective-cpp-48.html" title="模板元编程（template meta programming）">模板元编程（template meta programming）</a>的方式在编译期做任何计算。</p></blockquote><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译。 用户提供不同的类型参数，就会实例化出不同的代码。</p><h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>类模板描述了一组相关的类或数据类型，它们只能通过类型来区分：整数值、指向（或引用）具有全局链接的变量的指针、其他的组合。 类模板尤其适用于描述通用但类型安全的数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型形式参数&gt;</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//类声明体;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;类型形式参数&gt;</span><br><span class="line">返回类型 类名 &lt;类型&gt; :: 成员函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员函数定义体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>所谓模板全特化限定死模板实现的具体类型；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">    <span class="type">double</span> data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>偏特化是指提供另一份template定义式，而其本身仍为templatized，这是针对于template参数更进一步的条件限制所设计出来的一个特化版本。 也就是如果这个模板有多个类型，那么只限定其中的一部分;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>, T2&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型形式参数&gt;      <span class="comment">//类型形式参数即此格式：&lt;typename  形式参数&gt;  或 &lt;class 形式参数&gt;</span></span><br><span class="line">返回类型  函数名 （形式参数）</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//函数定义体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全特化-1"><a href="#全特化-1" class="headerlink" title="全特化"></a>全特化</h4><p>函数模板全特化和类模板全特化本质是一样的，是对模板参数的特殊化处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> lhs, <span class="type">const</span> <span class="type">int</span> rhs)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> lhs &gt; rhs ? lhs : rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特化的歧义"><a href="#特化的歧义" class="headerlink" title="特化的歧义"></a>特化的歧义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; T d; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="type">int</span> d; &#125;</span><br></pre></td></tr></table></figure><p>此时编译器不知道f()是从f\()特化来的，编译时会有错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: no <span class="keyword">function</span> template matches <span class="keyword">function</span> template specialization <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure><p>这时我们便需要显式指定”模板实参”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">void <span class="function"><span class="title">f</span></span>()&#123; T d; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">void f&lt;int&gt;()&#123; int d; &#125;</span><br></pre></td></tr></table></figure><h4 id="偏特化-1"><a href="#偏特化-1" class="headerlink" title="偏特化"></a>偏特化</h4><p>函数模版没有偏特化。</p><p>例如下面代码会编译出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">int</span>, T2&gt;()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>但函数允许重载，声明另一个函数模板即可替代偏特化的需要：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;              <span class="comment">// 注意：这里没有&quot;模板实参&quot;</span></span><br></pre></td></tr></table></figure><p>多数情况下函数模板重载就可以完成函数偏特化的需要，一个例外便是std命名空间。 std是一个特殊的命名空间，用户可以特化其中的模板，但不允许添加模板（其实任何内容都是禁止添加的）。 因此在std中添加重载函数是不允许的，在<a href="https://harttle.land/2015/08/23/effective-cpp-25.html" title="Effective C++: Item 25">Effective C++: Item 25</a>中给出了一个更详细的案例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>函数模板只有全特化，没有偏特化；</li><li>模板、模板的特化和模板的偏特化都存在的情况下，编译器在编译阶段进行匹配，优先特殊的；</li><li>模板函数不能是虚函数；因为每个包含虚函数的类具有一个virtual table,包含该类的所有虚函数的地址，因此vtable的大小是确定的。模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定。所以，成员函数模板不能为虚函数。</li></ol><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/11/c-template-specialization/">https://blog.jujimeizuo.cn/2023/01/11/c-template-specialization/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeChef Starters 72 div2 - No sequence</title>
      <link href="/2023/01/05/codechef-starters-72-div2-no-sequence/"/>
      <url>/2023/01/05/codechef-starters-72-div2-no-sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>三个数字N，K，S，构造一个长度为N的序列B，要求如下：</p><ul><li>$B_i \in {-1,0,1}$</li><li>$\sum_{i&#x3D;1}^N B_i * K^{i-1}&#x3D;S$</li></ul><p>输出任意一种序列，如果没有输出-2。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过观察$\sum_{i&#x3D;1}^N B_i * K^{i-1}&#x3D;S $</p><p>可以得到$ S &#x3D; B1 + \sum_{i&#x3D;2}^N B_i * K^{i-1} $，即</p><p>$$ S\equiv B_1 \quad (mod \ K) $$</p><p>所以通过S可以确定B1的值，然后通过一些简单的代数可以得到</p><p>$$ \frac{S-B1}{K} &#x3D; B2+\sum_{i&#x3D;3}^N B_i * K^{i-2} $$</p><p>即</p><p>$$\frac{S-B_1}{K} \equiv B_2 \quad (mod \ K) $$</p><p>所以可以确定B2的值，以此类推可以得到所有B的值，如果中途出现越界情况，直接返-2即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2023-01-04 22:39:48</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, K;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> S;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; K &gt;&gt; S;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S % K == <span class="number">0</span>) &#123;</span><br><span class="line">            S /= K;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((S - <span class="number">1</span>) % K == <span class="number">0</span>) &#123;</span><br><span class="line">            S = (S - <span class="number">1</span>) / K;</span><br><span class="line">            B[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((S + <span class="number">1</span>) % K == <span class="number">0</span>) &#123;</span><br><span class="line">            S = (S + <span class="number">1</span>) / K;</span><br><span class="line">            B[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ok  S != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">-2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; B[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    std::cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span> (_--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/05/codechef-starters-72-div2-no-sequence/">https://blog.jujimeizuo.cn/2023/01/05/codechef-starters-72-div2-no-sequence/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB调试</title>
      <link href="/2022/12/31/linux-gdb-debug/"/>
      <url>/2022/12/31/linux-gdb-debug/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是GDB"><a href="#1-什么是GDB" class="headerlink" title="1. 什么是GDB"></a>1. 什么是GDB</h2><ul><li>GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</li><li>一般来说，GDB 主要帮助你完成下面四个方面的功能：<ol><li>启动程序，可以按照自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时程序中所发生的事</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG</li></ol></li></ul><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><p>通常，在为调试而编译时，我们会关掉编译器的优化选项（<code>-O</code>）， 并打开调试选项（<code>-g</code>）。另外，<code>-Wall</code>在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG。 例如： <code>gcc -g -Wall program.c -o program</code> <code>-g</code> 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机 器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调 试时必须保证 gdb 能找到源文件。 调试下列程序前要做准备工作，在shell中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -Wall test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#test.c</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="number">30</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        b = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">// 函数调用</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">test</span>(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;res value: %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;THE END !!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="3-GDB-命令-：-启动、退出、查看代码"><a href="#3-GDB-命令-：-启动、退出、查看代码" class="headerlink" title="3. GDB 命令 ： 启动、退出、查看代码"></a>3. GDB 命令 ： 启动、退出、查看代码</h2><h4 id="启动和退出"><a href="#启动和退出" class="headerlink" title="启动和退出"></a>启动和退出</h4><ul><li><code>gdb</code> 可执行程序</li><li><code>quit</code>或<code>q</code>退出 注意：在进行准备工作之后才可以期待调试。</li></ul><p><img src="/images/2022/12/image-1672462308255.png" alt="file"></p><p>在调试命令行输入quit就可退出调试。</p><h4 id="给程序设置参数-获取设置参数"><a href="#给程序设置参数-获取设置参数" class="headerlink" title="给程序设置参数 &#x2F; 获取设置参数"></a>给程序设置参数 &#x2F; 获取设置参数</h4><ul><li><code>set args 10 20</code></li><li><code>show args</code> 注意：有一些程序需要设置参数，例如上述的test.c程序，main函数需要指定参数。</li></ul><p><img src="/images/2022/12/image-1672462408961.png" alt="file"></p><h4 id="GDB-使用帮助"><a href="#GDB-使用帮助" class="headerlink" title="GDB 使用帮助"></a>GDB 使用帮助</h4><ul><li><code>help</code> <code>help</code> 具体命令 用来查看调试帮助或具体指令的相关信息</li></ul><h4 id="查看当前文件代码"><a href="#查看当前文件代码" class="headerlink" title="查看当前文件代码"></a>查看当前文件代码</h4><ul><li><code>list/l</code> （从默认位置显示）</li></ul><p><img src="/images/2022/12/image-1672462449889.png" alt="file"></p><ul><li><code>list/l 行号</code> （从指定的行显示）注意是把行号内容放在中间显示。</li></ul><p><img src="/images/2022/12/image-1672462538567.png" alt="file"></p><h4 id="查看非当前文件代码"><a href="#查看非当前文件代码" class="headerlink" title="查看非当前文件代码"></a>查看非当前文件代码</h4><ul><li><code>list/l 文件名 : 行号</code></li><li><code>list/l 文件名 : 函数名</code> 一个程序有好几个文件组成，当我们调试主函数所在程序时，其他文件的代码也需要查看，就可以使用上述命令。一个项目中含bubble，select.cpp，main.cpp</li></ul><p><img src="/images/2022/12/image-1672462611599.png" alt="file"> <img src="/images/2022/12/image-1672462633560.png" alt="file"></p><h4 id="设置显示的行数"><a href="#设置显示的行数" class="headerlink" title="设置显示的行数"></a>设置显示的行数</h4><ul><li><code>show list/listsize</code></li><li><code>set list/listsize 行数</code></li></ul><h2 id="4-GDB命令：断点操作"><a href="#4-GDB命令：断点操作" class="headerlink" title="4. GDB命令：断点操作"></a>4. GDB命令：断点操作</h2><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><ul><li><code>b/break 行号</code></li><li><code>b/break 函数名</code></li><li><code>b/break 文件名 : 行号</code></li><li><code>b/break 文件名 : 函数</code></li></ul><p>如下图 在第6行设置断点：</p><p><img src="/images/2022/12/image-1672462743491.png" alt="file"></p><p>其它断点设置方法类似list&#x2F;l操作。</p><h4 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h4><ul><li><code>i/info b/break</code> 查看断点信息：</li></ul><p><img src="/images/2022/12/image-1672462775358.png" alt="file"></p><p>其中num代表断点编号，Type下的breakpoint说明该点为断点，Disp为断点状态，Enb是yes代表为有效断点，adress为断点地址，What说明断点的在那个文件的第几行。</p><h4 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h4><ul><li><code>d/del/delete 断点编号</code> 如下图所示删除断点编号为1的断点。 <img src="/images/2022/12/image-1672462817833.png" alt="file"></li></ul><h4 id="设置断点无效"><a href="#设置断点无效" class="headerlink" title="设置断点无效"></a>设置断点无效</h4><ul><li><code>dis/disable 断点编号</code></li></ul><h4 id="设置断点生效"><a href="#设置断点生效" class="headerlink" title="设置断点生效"></a>设置断点生效</h4><ul><li><code>ena/enable 断点编号</code></li></ul><h4 id="设置条件断点（一般用在循环的位置）"><a href="#设置条件断点（一般用在循环的位置）" class="headerlink" title="设置条件断点（一般用在循环的位置）"></a>设置条件断点（一般用在循环的位置）</h4><ul><li><code>b/break 13 if i==3</code></li></ul><p><img src="/images/2022/12/image-1672462898795.png" alt="file"></p><h2 id="5-GDB-命令-：-调试命令"><a href="#5-GDB-命令-：-调试命令" class="headerlink" title="5. GDB 命令 ： 调试命令"></a>5. GDB 命令 ： 调试命令</h2><h4 id="运行-GDB-程序"><a href="#运行-GDB-程序" class="headerlink" title="运行 GDB 程序"></a>运行 GDB 程序</h4><ul><li><code>start</code>（程序停在第一行）</li><li><code>run</code>（遇到断点才停）</li><li>使用<code>run</code>指令和<code>c</code>(继续指令）</li></ul><h4 id="继续运行，到下一个断点停"><a href="#继续运行，到下一个断点停" class="headerlink" title="继续运行，到下一个断点停"></a>继续运行，到下一个断点停</h4><ul><li><p><code>c/continue</code></p><h4 id="向下执行一行代码（不会进入函数体）"><a href="#向下执行一行代码（不会进入函数体）" class="headerlink" title="向下执行一行代码（不会进入函数体）"></a>向下执行一行代码（不会进入函数体）</h4></li><li><p><code>n/next</code></p></li></ul><h4 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h4><ul><li><code>p/print 变量名</code>（打印变量值）</li><li><code>ptype 变量名</code>（打印变量类型）</li></ul><h4 id="向下单步调试（遇到函数进入函数体）"><a href="#向下单步调试（遇到函数进入函数体）" class="headerlink" title="向下单步调试（遇到函数进入函数体）"></a>向下单步调试（遇到函数进入函数体）</h4><ul><li><code>s/step</code></li><li><code>finish</code>（跳出函数体）</li></ul><h4 id="自动变量操作"><a href="#自动变量操作" class="headerlink" title="自动变量操作"></a>自动变量操作</h4><ul><li><code>display 变量名</code>（自动打印指定变量的值）</li><li><code>i/info display</code></li><li><code>undisplay 编号</code></li></ul><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><ul><li><code>set var 变量名 = 变量值</code> （循环中用的较多）</li><li><code>until</code>（跳出循环）</li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/31/linux-gdb-debug/">https://blog.jujimeizuo.cn/2022/12/31/linux-gdb-debug/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加git SSH Keys</title>
      <link href="/2022/12/30/add-git-ssh-keys/"/>
      <url>/2022/12/30/add-git-ssh-keys/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要添加"><a href="#为什么需要添加" class="headerlink" title="为什么需要添加"></a>为什么需要添加</h2><p>现在的github，如果想要push等操作，已经不支持密码来控制，改为ssh keys来控制，所以会存在下面这种情况.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-10-centos WebServer]<span class="comment">## git push origin master</span></span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br></pre></td></tr></table></figure><p>Permission denied (publickey) 没有权限的publickey ，出现这错误一般是以下两种原因</p><ul><li>客户端与服务端未生成 ssh key</li><li>客户端与服务端的ssh key不匹配 找到问题的原因了，解决办法也就有了，重新生成一次ssh key ，服务端也重新配置一次即可。</li></ul><h2 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加"></a>如何添加</h2><h4 id="客户端生成ssh-key"><a href="#客户端生成ssh-key" class="headerlink" title="客户端生成ssh key"></a>客户端生成ssh key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p><a href="mailto:&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#x69;&#x6c;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;">&#x79;&#x6f;&#x75;&#x72;&#101;&#x6d;&#x61;&#x69;&#x6c;&#x40;&#101;&#x78;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;</a>改为自己的邮箱即可，途中会让你输入密码啥的，不需要管，一路回车即可，会生成你的ssh key。（如果重新生成的话会覆盖之前的ssh key。）</p><p>再执行以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -s </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h4 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h4><p>打开你刚刚生成的id_rsa.pub，将里面的内容复制，进入你的github账号，在settings下，SSH and GPG keys下new SSH key，然后将id_rsa.pub里的内容复制到Key中，完成后Add SSH Key。</p><p><img src="/images/2022/12/image-1672404926598.png" alt="file"></p><h2 id="验证Key"><a href="#验证Key" class="headerlink" title="验证Key"></a>验证Key</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com </span><br></pre></td></tr></table></figure><p>提示：Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 问题就解决啦</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/30/add-git-ssh-keys/">https://blog.jujimeizuo.cn/2022/12/30/add-git-ssh-keys/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算术表达式求值</title>
      <link href="/2022/12/06/expression/"/>
      <url>/2022/12/06/expression/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>表达式求值要解决的问题一般是输入一个字符串表示的表达式，要求输出它的值。当然也有变种比如表达式中是否包含括号，指数运算，含多少变量，判断多个表达式是否等价，等等。</p><p>表达式一般需要先进行语法分析（grammer parsing）再求值，也可以边分析边求值，语法分析的作用是检查输入的字符串是否是一个合法的表达式，一般使用语法分析器（parser）解决。</p><p>表达式包含两类字符：运算数和运算符。对于长度为n的表达式，借助合适的分析方法，可以在 $O(n)$的时间复杂度内完成分析与求值。</p><h4 id="表达式树与逆波兰表达式"><a href="#表达式树与逆波兰表达式" class="headerlink" title="表达式树与逆波兰表达式"></a>表达式树与逆波兰表达式</h4><p>一种递归分析表达式的方法是，将表达式当成普通的语法规则进行分析，分析后拆分成如图所示的</p><p><img src="https://oi-wiki.org/misc/images/bet.png"></p><p>表达式树，然后在树结构上自底向上进行运算。</p><p>表达式树上进行 树的遍历 可以得到不同类型的表达式。算术表达式分为三种，分别是前缀表达式、中缀表达式、后缀表达式。中缀表达式是日常生活中最常用的表达式；后缀表达式是计算机容易理解的表达式。</p><p>前序遍历对应前缀表达式（波兰式） 中序遍历对应中缀表达式 后序遍历对应后缀表达式（逆波兰式） 逆波兰表达式（后缀表达式）是书写数学表达式的一种形式，其中运算符位于其操作数之后。例如，以下表达式：</p><p>$$a+b_c_d+(e-f)_(g_h+i)$$</p><p>可以用逆波兰表达式书写：</p><p>$$abc_d_+ef-gh_i+_+$$</p><p>因此，逆波兰表达式与表达式树一一对应。逆波兰表达式不需要括号表示，它的运算顺序是唯一确定的。</p><p>逆波兰表达式的方便之处在于很容易在线性时间内计算。举个例子：在逆波兰表达式32*1- 中，首先计算 3*2&#x3D;6（使用最后一个运算符，即栈顶运算符），然后计算6-1&#x3D;5 。可以看到：对于一个逆波兰表达式，只需要 维护一个数字栈，每次遇到一个运算符，就取出两个栈顶元素，将运算结果重新压入栈中。最后，栈中唯一一个元素就是该逆波兰表达式的运算结果。该算法拥有O(n) 的时间复杂度。</p><h4 id="只含左结合的二元运算符的含括号表达式"><a href="#只含左结合的二元运算符的含括号表达式" class="headerlink" title="只含左结合的二元运算符的含括号表达式"></a>只含左结合的二元运算符的含括号表达式</h4><p>考虑简化的问题。假设所有运算符都是二元的：所有运算符都有两个参数。并且所有运算符都是左结合的：如果运算符的优先级相等，则从左到右执行。允许使用括号。</p><p>对于这种类型的中缀表达式的计算，可以将其转化为后缀表达式再进行计算。定义两个 栈 来分别存储运算符和运算数，每当遇到一个数直接放进运算数栈。每个运算符块对应于一对括号，运算符栈只对于运算符块的内部单调。每当遇到一个操作符时，要查找运算符栈中最顶部运算符块中的元素，在运算符块的内部保持运算符按照优先级降序进行适当的弹出操作，弹出的同时求出对应的子表达式的值。</p><p>以下部分用「输出」表示输出到后缀表达式，即将该数字放在运算数栈上，或者弹出运算符和两个操作数，运算后再将结果压回运算数栈上。从左到右扫描该中缀表达式：</p><ol><li>如果遇到数字，直接输出该数字。</li><li>如果遇到左括号，那么将其放在运算符栈上。</li><li>如果遇到右括号，不断输出栈顶元素，直至遇到左括号，左括号出栈。换句话说，执行一对括号内的所有运算符。</li><li>如果遇到其他运算符，不断输出所有运算优先级大于等于当前运算符的运算符。最后，新的运算符入运算符栈。</li><li>在处理完整个字符串之后，一些运算符可能仍然在堆栈中，因此把栈中剩下的符号依次输出，表达式转换结束。</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">convert</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; level &#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;(&#x27;</span>, <span class="number">-1</span>&#125;, &#123;<span class="string">&#x27;)&#x27;</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    std::stack&lt;<span class="type">char</span>&gt; oper;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; s;</span><br><span class="line">    std::string t, tmp;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; tmp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(tmp[<span class="number">0</span>])) &#123;</span><br><span class="line">            t += tmp + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            oper.<span class="built_in">push</span>(tmp[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!oper.<span class="built_in">empty</span>() &amp;&amp; oper.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                t += std::<span class="built_in">string</span>(<span class="number">1</span>, oper.<span class="built_in">top</span>()) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                oper.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            oper.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!oper.<span class="built_in">empty</span>() &amp;&amp; level[oper.<span class="built_in">top</span>()] &gt;= level[tmp[<span class="number">0</span>]]) &#123;</span><br><span class="line">                t += std::<span class="built_in">string</span>(<span class="number">1</span>, oper.<span class="built_in">top</span>()) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                oper.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            oper.<span class="built_in">push</span>(tmp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!oper.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        t += std::<span class="built_in">string</span>(<span class="number">1</span>, oper.<span class="built_in">top</span>()) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        oper.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; s;</span><br><span class="line">    std::string t, tmp;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; tmp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(tmp[<span class="number">0</span>])) &#123;</span><br><span class="line">            num.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="number">0</span>, a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!num.<span class="built_in">empty</span>()) b = num.<span class="built_in">top</span>();</span><br><span class="line">            num.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!num.<span class="built_in">empty</span>()) a = num.<span class="built_in">top</span>();</span><br><span class="line">            num.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) num.<span class="built_in">push</span>(a + b);</span><br><span class="line">            <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) num.<span class="built_in">push</span>(a - b);</span><br><span class="line">            <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>) num.<span class="built_in">push</span>(a * b);</span><br><span class="line">            <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) num.<span class="built_in">push</span>(a / b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/06/expression/">https://blog.jujimeizuo.cn/2022/12/06/expression/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大整数相乘 - 模拟/分治/FFT/CRT/网络流/Furer</title>
      <link href="/2022/12/06/bigintegermultiply/"/>
      <url>/2022/12/06/bigintegermultiply/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有两个超过long long类型的大整数X和Y，用较低的复杂度求解X*Y。</p><h2 id="六种方法"><a href="#六种方法" class="headerlink" title="六种方法"></a>六种方法</h2><h4 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h4><p>时间复杂度：$O(n^2)$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>模拟乘法的过程，一个数的第i位和另一个数的第j位相乘，一定会累加到结果的第i+j位，结果的数组一个数组元素存2位数，最后对结果整除得到进位，mod得到余数就是i+j位的数字，最后打印出来。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(std::string s, std::string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>) s.<span class="built_in">size</span>(), m = (<span class="type">int</span>) t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m  bit; j++) &#123;</span><br><span class="line">            <span class="type">int</span> now = ans[i + j] + (s[i] - <span class="string">&#x27;0&#x27;</span>) * (t[i] - <span class="string">&#x27;0&#x27;</span>) + bit;</span><br><span class="line">            ans[i + j] = now % <span class="number">10</span>;</span><br><span class="line">            bit = now / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ans.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h4><p>时间复杂度：$O(n^{log^3}) \approx O(n^{\frac{3}{2}}) \approx O(n^{1.59})$</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>分治算法解题的一般步骤：</p><p>分解：将要解决的问题划分为若干个规模较小的同类问题 求解：当子问题划分的足够小时，用较简单的方法解决 合并：按原问题的要求，将子问题的解逐层合并构成原问题的解</p><h3 id="X和Y的位数相同"><a href="#X和Y的位数相同" class="headerlink" title="X和Y的位数相同"></a>X和Y的位数相同</h3><p><img src="/images/2022/12/20201129001414493.png" alt="X和Y的位数相同"></p><p>$$ X &#x3D; A_{10}^{\frac{n}{2}}+B \quad Y&#x3D;C_{10}^{\frac{2}{n}} + D $$</p><p>$$ XY &#x3D; (A_{10}^{\frac{n}{2}}+B)_(C*10^{\frac{n}{2}}+D) $$</p><p>$$ XY &#x3D; AC_{10}^n+(AD+BC)_{10}^{\frac{2}{n}}+BD $$</p><p>计算成本：我们必须进行4次n&#x2F;2位整数的乘法(AC，AD，BC和BD)，以及3次不超过n位的整数加法此外还要做2次移位。所有这些加法和移位共用O（n）步运算。设T（n）是2个n位整数相乘所需的运算总数，我们有：</p><p>$$ T(n) &#x3D; O(1) \quad n &#x3D; 1 $$</p><p>$$ T(n)&#x3D;4T(n&#x2F;2)+O(n) \quad n &gt; 1 $$</p><p>得：</p><p>$$T(n) &#x3D; O(n^2)$$</p><p>这种方法不见得比暴力更有效，所以需要改进一点，变换上式得：</p><p>$$ XY&#x3D;AC_{10}^n + ((A-B)_(D-C) + AC+BD)*10^{\frac{2}{n}}+BD $$</p><p>计算成本：3次n&#x2F;2位乘法，6次不超过n位加减法，2次移位，所有加法和移位共计O(n)次运算。我们有：</p><p>$$ T(n) &#x3D; O(1) \quad n &#x3D; 1 $$</p><p>$$T(n)&#x3D;3T(n&#x2F;2) + O(n) \quad n &gt; 1$$</p><p>得：</p><p>$$T(n) &#x3D; O(n^{log^3}) \approx O(n^{\frac{3}{2}}) \approx O(n^{1.59})$$</p><h3 id="X和Y的位数不同"><a href="#X和Y的位数不同" class="headerlink" title="X和Y的位数不同"></a>X和Y的位数不同</h3><p>和位数相同同理</p><p>假设 n1为B的位数，B属于低位的那一部分 n2为A的位数，A属于高位的那一部分 m1为D的位数，D属于低位的那一部分 m2为D的位数，C属于高位的那一部分</p><p>$$XY&#x3D;(A_{10}^{n_2}+B)_(C*10^{m_2}+D)+BD$$</p><p>$$XY&#x3D;AC_{10}^{n_2+m_2}+(AD_{10}^{n_2}+BC*10^{m_2})+BD$$</p><p>上式一共需要进行2次n2的乘法（AC、AD各一次）、2次m2的乘法（AC、BC各一次）和3次加法，因而该算法的时间复杂度为</p><p>$$T(m + n) &#x3D; 2T(m) + 2T(n)+O(m+n)$$</p><p>跟上面一样，对AD+BC进行分解优化得：</p><p>$$XY&#x3D;2_AC_{10}^{n_2+m_2}+(A_{10}^{n_2}-B)_(D-C_{10}^{m_2}) + 2_BD$$</p><p>修改后的时间复杂度为：</p><p>$$T(m+n) &#x3D; T(m) + T(n) + T(min(n, m)) + O(m + n)$$</p><p>由于$T(min(n,m)) &lt; T(m)+T(n) $，所以修改后的算法更好，时间复杂度为</p><p>$$T(n) &#x3D; O(n^{log^3}) \approx O(n^{\frac{3}{2}}) \approx O(n^{1.59})$$</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(std::string X, std::string Y)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">255</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(std::string, std::string, <span class="type">int</span>)&gt; multiply = [&amp;](std::string s, std::string t, <span class="type">int</span> pos) &#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>) s.<span class="built_in">size</span>(), m = (<span class="type">int</span>) t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>  m == <span class="number">0</span>) &#123;                 <span class="comment">// 位数为0时</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>) &#123;          <span class="comment">// 递归到当前数组s和t的位数全为1时</span></span><br><span class="line">            result[pos] += (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * (t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 当数组s和t的位数至少有一个不为1时</span></span><br><span class="line">            <span class="type">int</span> n1 = n / <span class="number">2</span>;                     <span class="comment">// n1为B的位数，B属于低位的那一部分</span></span><br><span class="line">            <span class="type">int</span> n2 = n - n1;                    <span class="comment">// n2为A的位数，A属于高位的那一部分</span></span><br><span class="line">            <span class="type">int</span> m1 = m / <span class="number">2</span>;                     <span class="comment">// m1为D的位数，D属于低位的那一部分</span></span><br><span class="line">            <span class="type">int</span> m2 = m - m1;                    <span class="comment">// m2为D的位数，C属于高位的那一部分</span></span><br><span class="line">            std::string A = s.<span class="built_in">substr</span>(<span class="number">0</span>, n2);    <span class="comment">// 获取s的高位部分A</span></span><br><span class="line">            std::string B = s.<span class="built_in">substr</span>(n2);       <span class="comment">// 获取s的低位部分B</span></span><br><span class="line">            std::string C = t.<span class="built_in">substr</span>(<span class="number">0</span>, m2);    <span class="comment">// 获取t的高位部分C</span></span><br><span class="line">            std::string D = t.<span class="built_in">substr</span>(m2);       <span class="comment">// 获取t的低位部分D</span></span><br><span class="line">            <span class="built_in">multiply</span>(A, C, pos + n1 + m1);      <span class="comment">// AC,在result[pos+n1+m1]的位置存储AC，也是说偏移pos+n1+m1位，pos初始化为0</span></span><br><span class="line">            <span class="built_in">multiply</span>(B, C, pos + m1);           <span class="comment">// BC,偏移pos+m1位</span></span><br><span class="line">            <span class="built_in">multiply</span>(A, D, pos + n1);           <span class="comment">// AD,偏移pos+1位</span></span><br><span class="line">            <span class="built_in">multiply</span>(B, D, pos);                <span class="comment">// BD,偏移pos位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">multiply</span>(X, Y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) X.<span class="built_in">size</span>() + (<span class="type">int</span>) Y.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> now = result[i] % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> bit1 = result[i] / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> bit2 = result[i] / <span class="number">100</span>;</span><br><span class="line">        result[i] = now;</span><br><span class="line">        result[i + <span class="number">1</span>] += bit1;</span><br><span class="line">        result[i + <span class="number">2</span>] += bit2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (result.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：FFT"><a href="#方法三：FFT" class="headerlink" title="方法三：FFT"></a>方法三：FFT</h4><p>时间复杂度：$O(nlogn)$</p><p>通过分治的思想，最终演变成FFT的雏形，FFT的思想也是分治，但是它的理论要更为深奥。 为了避免精度问题，可以改用快速数论变换FNTT。 <a href="https://blog.csdn.net/TheWayForDream/article/details/113944059">具体可以看这篇文章的推导</a></p><h4 id="方法四：中国剩余定理"><a href="#方法四：中国剩余定理" class="headerlink" title="方法四：中国剩余定理"></a>方法四：中国剩余定理</h4><p>把每个数分解到一些互素的模上，然后每个同余方程对应乘起来就行。</p><h4 id="方法五：网络流"><a href="#方法五：网络流" class="headerlink" title="方法五：网络流"></a>方法五：网络流</h4><p>补</p><h4 id="方法六-Furer’s-algorithm"><a href="#方法六-Furer’s-algorithm" class="headerlink" title="方法六: Furer’s algorithm"></a>方法六: Furer’s algorithm</h4><p>在渐进意义上FNTT还快的算法。不过好像不太实用，本文就不作介绍了。大家可以参考<a href="https://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm">维基百科Fürer’s algorithm</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/06/bigintegermultiply/">https://blog.jujimeizuo.cn/2022/12/06/bigintegermultiply/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TopCoder SRM842</title>
      <link href="/2022/12/03/topcoder-srm842/"/>
      <url>/2022/12/03/topcoder-srm842/</url>
      
        <content type="html"><![CDATA[<h2 id="A-ToniasTower"><a href="#A-ToniasTower" class="headerlink" title="A. ToniasTower"></a>A. ToniasTower</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>Tonia 有N个单位立方体。她想用它们来建造一座塔。 Tonia 的塔将由一排或多排立方体组成，每一排立在下一排上。（显然，除了站在地上的最下面一排。） 只有一个限制：除底部以外的每一行都必须严格比它所在的行短（即，立方体严格减少）。</p><p>Tonia 现在想知道：她可以用所有立方体建造的最高塔是什么？ 找到最大的 X，这样 Tonia 可以使用她的N个立方体来建造一个有 X 行立方体的塔。然后，找到一种建造这样一座塔的方法。换句话说，确定塔的 X 行中每一行的立方体数量。 返回带有 X 个元素的 a：对于塔的每一行，从上到下，Tonia 应该在该行中使用的立方体数量。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>让n一次减去，1，2，3，4，5…，最后如果剩下一个数字，则加给最后一个数。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ToniasTower</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">build</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ToniasTower::build</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        n -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">back</span>() += n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-SmallRectangles"><a href="#B-SmallRectangles" class="headerlink" title="B. SmallRectangles"></a>B. SmallRectangles</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>我们有两个 A 和 B，分别有AL和BL元素。这些描述了如何切割矩形</p><p>整个矩形的尺寸为 sum(A) 乘以 sum(B)。通过使AL -1 切割正交于长度 sum(A) 的一侧和BL -1 切割与另一侧正交， 它被切割成AL乘以BL的较小矩形。</p><p>A 的元素是段的长度，切割将长度 sum(A) 的边分成这些段。类似地，B 的元素是矩形另一边被分割成的线段的长度。因此，A 和 B 是通过将大矩形切成块而产生的较小矩形的边长。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对每一个pair插入到set中，求set到size()即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallRectangles</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">count</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; Aprefix, std::vector&lt;<span class="type">int</span>&gt; Bprefix, <span class="type">int</span> AL, <span class="type">int</span> BL, <span class="type">int</span> AM, <span class="type">int</span> BM, <span class="type">int</span> seed)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">SmallRectangles::count</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; Aprefix, std::vector&lt;<span class="type">int</span>&gt; Bprefix, <span class="type">int</span> AL, <span class="type">int</span> BL, <span class="type">int</span> AM, <span class="type">int</span> BM, <span class="type">int</span> seed)</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">long</span> <span class="type">long</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; AL; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; BL; j++) &#123;</span><br><span class="line">            <span class="type">int</span> a = std::<span class="built_in">min</span>(Aprefix[i], Bprefix[j]);</span><br><span class="line">            <span class="type">int</span> b = std::<span class="built_in">max</span>(Aprefix[i], Bprefix[j]);</span><br><span class="line">            cnt[&#123;a, b&#125;]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = cnt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-StringReduction"><a href="#C-StringReduction" class="headerlink" title="C. StringReduction"></a>C. StringReduction</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>你有一串小写英文字母： 开始。</p><p>您还获得了 X和 Y。这些描述了您可以对字符串执行的一些操作。更准确地说，对于每个有效索引 i，整数X [i] 和字符Y [i] 描述了一个这样的操作，如下所述。</p><p>您可以通过以任意顺序任意多次执行以下操作来修改字符串：</p><p>交换字符串中的任意两个连续字符。 对于任何有效索引 i：选择一组特定的X [i] 个字母Y [i ] 的连续副本。擦除其中的X [i]-1 个，保留剩下的一个。 当然，只有当当前字符串中某处存在所需的相同字母组时，才能应用擦除规则。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>用cnt存下每个字符的个数，对每个字符，尽最大努力依次减去X[i] - 1</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">StringReduction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reduce</span><span class="params">(std::string, std::vector&lt;<span class="type">int</span>&gt;, std::string)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StringReduction::reduce</span><span class="params">(std::string start, std::vector&lt;<span class="type">int</span>&gt; X, std::string Y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> &amp;c : start) &#123;</span><br><span class="line">        cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) X.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (X[i] == <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="type">int</span> digit = Y[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt[digit] &gt;= X[i]) &#123;</span><br><span class="line">            cnt[digit] -= X[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/03/topcoder-srm842/">https://blog.jujimeizuo.cn/2022/12/03/topcoder-srm842/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder ABC280</title>
      <link href="/2022/12/03/atcoder-abc280/"/>
      <url>/2022/12/03/atcoder-abc280/</url>
      
        <content type="html"><![CDATA[<h2 id="A-Pawn-on-a-Grid"><a href="#A-Pawn-on-a-Grid" class="headerlink" title="A. Pawn on a Grid"></a>A. Pawn on a Grid</h2><p>统计<code>##</code>个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2022-12-03 20:00:15</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::string s;</span><br><span class="line">        std::cin &gt;&gt; s;</span><br><span class="line">        cnt += std::<span class="built_in">count</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;##&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Inverse-Prefix-Sum"><a href="#B-Inverse-Prefix-Sum" class="headerlink" title="B. Inverse Prefix Sum"></a>B. Inverse Prefix Sum</h2><p>模拟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2022-12-03 20:01:17</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) std::cout &lt;&lt; a[i] - a[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Extra-Character"><a href="#C-Extra-Character" class="headerlink" title="C. Extra Character"></a>C. Extra Character</h2><p>找到第一个不相等字符位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2022-12-03 20:03:26</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::string s, t;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; (<span class="type">int</span>) s.<span class="built_in">size</span>() &amp;&amp; s[p] == t[p]) &#123;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Factorial-and-Multiple"><a href="#D-Factorial-and-Multiple" class="headerlink" title="D. Factorial and Multiple"></a>D. Factorial and Multiple</h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>找到最小的n是的n!是k的倍数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>n!的因子p个数为<code>n / p + n / p / p + ...</code> 质因数分解K，对于K的一个质因子p，个数为cnt，二分求出最小的x，使得x的p个数大于等于cnt。 <code>ans = std::max(ans, x)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2022-12-03 20:05:06</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> K;</span><br><span class="line">    std::cin &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> i, <span class="type">long</span> <span class="type">long</span> c) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            cnt += x / i;</span><br><span class="line">            x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= c;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">2</span>; i * i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (K % i == <span class="number">0</span>) cnt++, K /= i;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l = l, r = <span class="number">1E12</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid, i, cnt)) &#123;</span><br><span class="line">                x = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, K);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Critical-Hit"><a href="#E-Critical-Hit" class="headerlink" title="E. Critical Hit"></a>E. Critical Hit</h2><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一只怪物有n滴血，攻击一滴血的概率为p&#x2F;100 (p1),攻击两滴血的概率为1 - (100 &#x2F; p) (p2)，求打死怪物的攻击期望。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>设dp[i]表示攻击i滴血的攻击期望，则转移方程为 <code>dp[i] = dp[i - 1] * p1 + dp[i - 2] * P2 + 1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2022-12-03 21:18:42</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, p;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line"></span><br><span class="line">    Mint inv100 = <span class="built_in">power</span>(<span class="built_in">Mint</span>(<span class="number">100</span>), md - <span class="number">2</span>);</span><br><span class="line">    Mint p2 = inv100 * p, p1 = inv100 * (<span class="number">100</span> - p);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Mint&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] * p1 + dp[std::<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">2</span>)] * p2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/03/atcoder-abc280/">https://blog.jujimeizuo.cn/2022/12/03/atcoder-abc280/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 回调函数及 std::function 与 std::bind</title>
      <link href="/2022/11/20/callback/"/>
      <url>/2022/11/20/callback/</url>
      
        <content type="html"><![CDATA[<p><strong>回调函数是做为参数传递的一种函数</strong>，在早期C样式编程当中，回调函数必须依赖函数指针来实现。</p><p>而后的C++语言当中，又引入了 std::function 与 std::bind 来配合进行回调函数实现。</p><p>标准库中有大量函数应用到了回调函数，其中 std::sort 就是一个经典例子。</p><h2 id="一、-回调函数"><a href="#一、-回调函数" class="headerlink" title="一、 回调函数"></a>一、 回调函数</h2><p>回调函数的创建步骤大概为：</p><p>1，声明一个函数指针类型。</p><p>2，拟写使用回调函数的函数，将函数指针类型及变量名声明作为参数传递。</p><p>3，拟写符合函数指针类型的实现函数，将实现函数的指针作为参数传递给使用它的函数。</p><p>下面演示了一个最简单的回调函数定义及使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Calc)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalcValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> Calc &amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">CalcValue</span>(a, b, Add);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们通过语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Calc)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>来定义了回调函数的指针类型，包括返回值类型、(*类型名)函数指针、参数表。</p><p>继而又定义并且实现了回调函数的使用者函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalcValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> Calc &amp;func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再去定义并实现符合函数指针类型的实现函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要注意的是，实现函数的类型必须要和函数指针的类型声明一致，也就是返回值和参数表（个数、类型）要完全一致。</p><p>这样就完成了一个简单且最基本的回调函数。</p><p>那么，回调函数是什么情况下使用的呢？</p><p>举个最经典的例子就是 <code>std::sort</code>，当你需要给一个存储有自定义结构体的 vector 进行排序时，编译器是无法知道如何对自定义结构体进行排序的。</p><p>这时候就需要实现一个回调函数来告诉编译器如何排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DataPool</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> date = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DataPool</span>(<span class="type">int</span> v, <span class="type">int</span> d) : <span class="built_in">value</span>(v), <span class="built_in">date</span>(d) &#123;&#125;;</span><br><span class="line">&#125;DataPool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SortCallBack</span><span class="params">(<span class="type">const</span> DataPool &amp;a, <span class="type">const</span> DataPool&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value &lt; b.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;DataPool&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">DataPool</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">DataPool</span>(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">DataPool</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), SortCallBack);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就相当于自定义了 struct 的排序规则，自然编译器也可以使用 <code>std::sort</code> 对自定义 struct 进行排序操作。</p><h2 id="二、std-function-与-std-bind"><a href="#二、std-function-与-std-bind" class="headerlink" title="二、std::function 与 std::bind"></a>二、std::function 与 std::bind</h2><p>上面演示了最简单的回调函数创建及使用，然而，上面的代码却出现了一个局限性，就是：</p><p>如果需要去回调一个类成员函数，函数指针则无法指向类成员函数。</p><p>在基本C样式面向过程编程当中，这种局限性并不那么明显甚至可以说不存在。但是到了C++当中，这种弊端就显而易见了，解决方式便是使用 std::function 与 std::bind 互相配合。</p><p>它们的头文件是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>std::function</li></ul><p>std::function 是一个模板类。作用是对C++中的可调用对象进行包装，例如普通函数、成员函数、模板函数、静态函数、lambda表达式等。</p><p>它的最基本的作用是，简化调用的复杂程度，统一调用的方式。如果代码中混杂着大量普通函数、模板函数、lambda，使用 std::function 是非常有必要的。</p><p>语法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【伪代码】std::function&lt;returnType(argType, argType，...)&gt; func;</span><br><span class="line"></span><br><span class="line">【常规情况】std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func;</span><br></pre></td></tr></table></figure><p>可以看到，这个模板类当中对类型的声明方式是 &lt; 返回值类型 ( 参数类型1, 参数类型2, …) &gt;。</p><p>你几乎可以拿它包装任何可调用对象，只需简单粗暴的将可调用对象作为右值赋值给它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompareInt</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; compareFunc = CompareInt;</span><br></pre></td></tr></table></figure><p>那么如何使用它来调用类成员函数呢？这时就需要用到经常与 <code>std::function</code> 配合使用的 <code>std::bind</code>。</p><ul><li>std::bind</li></ul><p>它是一个基于模板的函数，顾明思意它的作用是绑定并返回一个 std::function 对象。</p><p>那么什么是“绑定”？它本身作为延迟计算的思想的一种实现，作为一个调用过程当中的转发者而存在，返回一个 <code>std::function</code> 对象。</p><p>它与 <code>std::function</code> 不同的是，function 是模板类，bind 是模板函数，而 bind 返回的可调用对象可以直接给 function 进行包装并保存。</p><p>为什么要进行“包装”与“转发”呢？</p><p>首先，不规范的解释是，function 的作用是包装，它可以包装类成员函数，但却无法生成类成员函数的可调用对象。而 <code>std::bind</code> 则是可以生成。</p><p>因此，function 与 bind 结合后，便成为了 C++ 中类成员函数作为回调函数的一种规范的实现方式。</p><p><code>std::bind</code> 的语法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 普通函数 --- */</span></span><br><span class="line">【伪代码】std::<span class="built_in">bind</span>(&amp;funcName, std::placeholders::_1, ...);</span><br><span class="line"></span><br><span class="line">【常规情况】std::<span class="built_in">bind</span>(&amp;Add, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 类成员函数 --- */</span></span><br><span class="line">【伪代码】std::<span class="built_in">bind</span>(&amp;className::funcName, classPtr, std::placeholders::_1, ...);</span><br><span class="line"></span><br><span class="line">【常规情况】std::<span class="built_in">bind</span>(&amp;BrainToolBox::Add, brain, std::placeholders::_1, std::placeholders::_2);</span><br></pre></td></tr></table></figure><p>当用作普通函数的绑定时，第一个参数是可调用对象(普通函数、lambda等)，而第二个参数开始对应可调用对象的参数表。</p><p><code>std::placeholders::_1</code> 代表可调用对象的第一个参数，<code>_2</code>就代表第二个参数，依此类推。</p><p>当用作类成员函数的绑定时，第一个参数仍然是作为类成员的可调用对象引用，第二个参数则是对象的指针，而第三个参数开始对应可调用对象的参数表。</p><p>同样使用 <code>std::placeholders::_*</code> 依次向后推。</p><p>所以，与 <code>std::function</code> 相结合，便可以实现对类成员函数的调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrainToolBox</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;BrainToolBox&gt; brain = std::<span class="built_in">make_shared</span>&lt;BrainToolBox&gt;();</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; addFunc = std::<span class="built_in">bind</span>(&amp;BrainToolBox::Add, brain, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line"></span><br><span class="line">　　 <span class="type">int</span> c = <span class="built_in">addFunc</span>(a, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c Value: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>std::bind</code> 的额外注解：</p><blockquote><p>1，调用指向非静态成员函数指针或指向非静态数据成员指针时，首参数必须是引用或指针（可以包含智能指针，如 std::shared_ptr 与 std::unique_ptr），指向将访问其成员的对象。 2，到 bind 的参数被复制或移动，而且决不按引用传递，除非包装于 std::ref 或 std::cref 。 3，允许同一 bind 表达式中的多重占位符（例如多个 _1 ），但结果仅若对应参数（ u1 ）是左值或不可移动右值才良好定义。</p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/11/20/callback/">https://blog.jujimeizuo.cn/2022/11/20/callback/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux统计文件夹下的文件数目</title>
      <link href="/2022/11/18/getfilenumber/"/>
      <url>/2022/11/18/getfilenumber/</url>
      
        <content type="html"><![CDATA[<p>Linux下有三个命令：<code>ls</code>、<code>grep</code>、<code>wc</code>。通过这三个命令的组合可以统计目录下文件及文件夹的个数。</p><ul><li><p>统计当前目录下文件的个数（不包括目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l  grep <span class="string">&quot;^-&quot;</span>  <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li><li><p>统计当前目录下文件的个数（包括子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lR grep <span class="string">&quot;^-&quot;</span>  <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li><li><p>查看某目录下文件夹(目录)的个数（包括子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lR  grep <span class="string">&quot;^d&quot;</span>  <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p>命令解析：</p></li><li><p><code>ls -l</code> 长列表输出该目录下文件信息(注意这里的文件是指目录、链接、设备文件等)，每一行对应一个文件或目录，<code>ls -lR</code>是列出所有文件，包括子目录。</p></li><li><p><code>grep &quot;^-&quot;</code> 过滤<code>ls</code>的输出信息，只保留一般文件，只保留目录是<code>grep &quot;^d&quot;</code>。</p></li><li><p><code>wc -l</code> 统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件，所以就是文件的个数。</p></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/11/18/getfilenumber/">https://blog.jujimeizuo.cn/2022/11/18/getfilenumber/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现简易http服务器</title>
      <link href="/2022/11/09/tinyhttpd/"/>
      <url>/2022/11/09/tinyhttpd/</url>
      
        <content type="html"><![CDATA[<h2 id="tinyhttpd工作流程"><a href="#tinyhttpd工作流程" class="headerlink" title="tinyhttpd工作流程"></a>tinyhttpd工作流程</h2><p><img src="/images/2022/11/process.png"></p><h3 id="核心函数说明"><a href="#核心函数说明" class="headerlink" title="核心函数说明"></a>核心函数说明</h3><ul><li>startup: 绑定监听套接字</li><li>accept_request 每次收到请求，创建一个线程来处理接收到的请求</li><li>serve_file 接读取文件返回给请求的http客户端</li><li>execute_cgi 执行cgi文件</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>index.html必须没有执行权限，否则看不到内容，并且会产生Program received signal SIGPIPE, Broken pipe，因为程序中如果有可执行权限会当cgi脚本处理。 所以假如html有执行权限先把它去除了，<code>chmod 600 index.html</code></p><p>color.cgi、date.cgi必须要有执行权限，<code>chmod 755 *.cgi</code></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="在项目文件目录下执行make"><a href="#在项目文件目录下执行make" class="headerlink" title="在项目文件目录下执行make"></a>在项目文件目录下执行make</h3><p><img src="/images/2022/11/make.png"></p><h3 id="在浏览器中输入-127-0-0-1-port"><a href="#在浏览器中输入-127-0-0-1-port" class="headerlink" title="在浏览器中输入 127.0.0.1:port"></a>在浏览器中输入 <code>127.0.0.1:port</code></h3><p><img src="/images/2022/11/index.png"></p><h3 id="测试color-cgi"><a href="#测试color-cgi" class="headerlink" title="测试color.cgi"></a>测试color.cgi</h3><p><img src="/images/2022/11/red.png"></p><h3 id="测试index2-html"><a href="#测试index2-html" class="headerlink" title="测试index2.html"></a>测试index2.html</h3><p><img src="/images/2022/11/index2.png"></p><h3 id="测试date-cgi"><a href="#测试date-cgi" class="headerlink" title="测试date.cgi"></a>测试date.cgi</h3><p><img src="/images/2022/11/date.png"></p><h2 id="httpd-c"><a href="#httpd-c" class="headerlink" title="httpd.c"></a>httpd.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* J. David&#x27;s webserver */</span></span><br><span class="line"><span class="comment">/* This is a simple webserver.</span></span><br><span class="line"><span class="comment"> * Created November 1999 by J. David Blackstone.</span></span><br><span class="line"><span class="comment"> * CSE 4344 (Network concepts), Prof. Zeigler</span></span><br><span class="line"><span class="comment"> * University of Texas at Arlington</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* This program compiles for Sparc Solaris 2.6.</span></span><br><span class="line"><span class="comment"> * To compile for Linux:</span></span><br><span class="line"><span class="comment"> *  1) Comment out the ##include &lt;pthread.h&gt; line.</span></span><br><span class="line"><span class="comment"> *  2) Comment out the line that defines the variable newthread.</span></span><br><span class="line"><span class="comment"> *  3) Comment out the two lines that run pthread_create().</span></span><br><span class="line"><span class="comment"> *  4) Uncomment the line that runs accept_request().</span></span><br><span class="line"><span class="comment"> *  5) Remove -lsocket from the Makefile.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> ISspace(x) isspace((int)(x))</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> SERVER_STRING <span class="string">&quot;Server: jdbhttpd/0.1.0\r\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次收到请求，创建一个线程来处理接收到的请求</span></span><br><span class="line"><span class="comment"> * 把client_sock转成地址作为参数传入pthread_create</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">accept_request</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span>, FILE *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无法执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行cig脚本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到一行数据，只要发现c为\n，就认为是一行结束，如果读到\r，在用MSG_PEEK的方式读入一个字符，如果是\n，从socket用读出</span></span><br><span class="line"><span class="comment"> * 如果是下个字符则不处理，将c置为\n，结束。如果读到的数据为0中断，或者小于0，也视为结束，c置为\n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回httpd头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有发现文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果不是CGI文件，直接读取文件返回给请求的http客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">server_file</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启tcp连接，绑定端口等操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果不是Get或者Post，就报方法没有实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Http请求，后续主要是处理这个头</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// GET / HTTP/1.1</span></span><br><span class="line"><span class="comment">// Host: 192.168.0.23:47310</span></span><br><span class="line"><span class="comment">// Connection: keep-alive</span></span><br><span class="line"><span class="comment">// Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="comment">// User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36</span></span><br><span class="line"><span class="comment">// Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*; q = 0.8</span></span><br><span class="line"><span class="comment">// Accept - Encoding: gzip, deflate, sdch</span></span><br><span class="line"><span class="comment">// Accept - Language : zh - CN, zh; q = 0.8</span></span><br><span class="line"><span class="comment">// Cookie: __guid = 179317988.1576506943281708800.1510107225903.8862; monitor_count = 5</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// POST / color1.cgi HTTP / 1.1</span></span><br><span class="line"><span class="comment">// Host: 192.168.0.23 : 47310</span></span><br><span class="line"><span class="comment">// Connection : keep - alive</span></span><br><span class="line"><span class="comment">// Content - Length : 10</span></span><br><span class="line"><span class="comment">// Cache - Control : max - age = 0</span></span><br><span class="line"><span class="comment">// Origin : http ://192.168.0.23:40786</span></span><br><span class="line"><span class="comment">// Upgrade - Insecure - Requests : 1</span></span><br><span class="line"><span class="comment">// User - Agent : Mozilla / 5.0 (Windows NT 6.1; WOW64) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 55.0.2883.87 Safari / 537.36</span></span><br><span class="line"><span class="comment">// Content - Type : application / x - www - form - urlencoded</span></span><br><span class="line"><span class="comment">// Accept : text / html, application / xhtml + xml, application / xml; q = 0.9, image / webp, */*;q=0.8</span></span><br><span class="line"><span class="comment">// Referer: http://192.168.0.23:47310/</span></span><br><span class="line"><span class="comment">// Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">// Accept-Language: zh-CN,zh;q=0.8</span></span><br><span class="line"><span class="comment">// Cookie: __guid=179317988.1576506943281708800.1510107225903.8862; monitor_count=281</span></span><br><span class="line"><span class="comment">// Form Data</span></span><br><span class="line"><span class="comment">// color=gray</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* A request has caused a call to accept() on the server port to</span></span><br><span class="line"><span class="comment"> * return.  Process the request appropriately.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket connected to the client */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">accept_request</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> client = (<span class="type">intptr_t</span>) arg;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> numchars;</span><br><span class="line">    <span class="type">char</span> method[<span class="number">255</span>];</span><br><span class="line">    <span class="type">char</span> url[<span class="number">255</span>];</span><br><span class="line">    <span class="type">char</span> path[<span class="number">512</span>];</span><br><span class="line">    <span class="type">size_t</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="type">int</span> cgi = <span class="number">0</span>;    <span class="comment">/* becomes true if server decides this is a CGI</span></span><br><span class="line"><span class="comment">                     * program */</span></span><br><span class="line">    <span class="type">char</span> *query_string = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 根据上面的Get请求，可以看到这边就是取第一行</span></span><br><span class="line">    <span class="comment">// 这边都是在处理第一条http信息</span></span><br><span class="line">    <span class="comment">// &quot;GET / HTTP/1.1\n&quot;</span></span><br><span class="line">    numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行字符串提取Get</span></span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(method) - <span class="number">1</span>)) &#123;</span><br><span class="line">        method[i] = buf[j];</span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束</span></span><br><span class="line">    method[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是Get还是Post</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) &amp;&amp; strcasecmp(method, <span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        unimplemented(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是POST，cgi置为1</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 跳过空格</span></span><br><span class="line">    <span class="keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//得到 &quot;/&quot;   注意：如果你的http的网址为http://192.168.0.23:47310/index.html</span></span><br><span class="line">     <span class="comment">//               那么你得到的第一条http信息为GET /index.html HTTP/1.1，那么</span></span><br><span class="line">     <span class="comment">//               解析得到的就是/index.html</span></span><br><span class="line">    <span class="keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="keyword">sizeof</span>(url) - <span class="number">1</span>) &amp;&amp; (j &lt; <span class="keyword">sizeof</span>(buf))) &#123;</span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Get请求</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        query_string = url;</span><br><span class="line">        <span class="keyword">while</span> ((*query_string != <span class="string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="string">&#x27;\0&#x27;</span>)) &#123;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*query_string == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">            *query_string = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径</span></span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">&quot;htdocs%s&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认地址，解析道的路径如果是/，则自动加上index.html</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="built_in">strlen</span>(path) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (stat(path, &amp;st) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 把所有http信息读出然后丢弃</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf)) &#123; <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到</span></span><br><span class="line">        not_found(client);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR) &#123;</span><br><span class="line">            <span class="built_in">strcat</span>(path, <span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果你的文件默认是有执行全县的，自动解析成cgi程序，如果有执行权限但是不能执行，会接受到报错信号</span></span><br><span class="line">        <span class="keyword">if</span> ((st.st_mode &amp; S_IXUSR) </span><br><span class="line">            (st.st_mode &amp; S_IXGRP) </span><br><span class="line">            (st.st_mode &amp; S_IXOTH)  ) &#123;</span><br><span class="line">            cgi = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cgi) &#123;</span><br><span class="line">            <span class="comment">// 接读取文件返回给请求的http客户端</span></span><br><span class="line">            server_file(client, path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行cgi文件</span></span><br><span class="line">            execute_cgi(client, path, method, query_string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行完毕关闭socket</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a request it has made has a problem.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_request</span><span class="params">(<span class="type">int</span> client)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 500 BAD REQUEST\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: test/html\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;P&gt;Your browser sent a bad request, &quot;</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;such as a POST without a Content-Length.\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Put the entire contents of a file out on a socket.  This function</span></span><br><span class="line"><span class="comment"> * is named after the UNIX &quot;cat&quot; command, because it might have been</span></span><br><span class="line"><span class="comment"> * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).</span></span><br><span class="line"><span class="comment"> * Parameters: the client socket descriptor</span></span><br><span class="line"><span class="comment"> *             FILE pointer for the file to cat */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到文件内容，发送</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cat</span><span class="params">(<span class="type">int</span> client, FILE *resource)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    <span class="comment">// 循环读</span></span><br><span class="line">    <span class="keyword">while</span> (!feof(resource)) &#123;</span><br><span class="line">        send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that a CGI script could not be executed.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket descriptor. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cannot_execute</span><span class="params">(<span class="type">int</span> client)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 500 Internal Server Error\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;P&gt;Error prohibited CGI execution.\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Print out an error message with perror() (for system errors; based</span></span><br><span class="line"><span class="comment"> * on value of errno, which indicates system call errors) and exit the</span></span><br><span class="line"><span class="comment"> * program indicating an error. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *sc)</span> &#123;</span><br><span class="line">    perror(sc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Execute a CGI script.  Will need to set environment variables as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> * Parameters: client socket descriptor</span></span><br><span class="line"><span class="comment"> *             path to the CGI script */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">execute_cgi</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *path,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *method, <span class="type">const</span> <span class="type">char</span> *query_string)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2根管道</span></span><br><span class="line">    <span class="type">int</span> cgi_output[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> cgi_input[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程pid和状态</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取的字符数</span></span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http的content_length</span></span><br><span class="line">    <span class="type">int</span> content_length = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认字符</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略大小写比较字符串</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取数据，把整个header都读掉，以为Get写死了直接读取index.html，没有必要分析余下的http信息了</span></span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf)) &#123; <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* POST */</span></span><br><span class="line">        numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf)) &#123;</span><br><span class="line">            <span class="comment">// 如果是POST请求，就需要得到Content-Length，Content-Length：这个字符串一共长15位，所以</span></span><br><span class="line">            <span class="comment">// 取出头部一句后，将第16位设置结束符，进行比较</span></span><br><span class="line">            <span class="comment">// 第16位置为结束</span></span><br><span class="line">            buf[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (strcasecmp(buf, <span class="string">&quot;Content-Length:&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 内存从第17位开始就是长度，将17位开始的所有字符串转成整数就是content-length</span></span><br><span class="line">                content_length = atoi(&amp;buf[<span class="number">16</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (content_length == <span class="number">-1</span>) &#123;</span><br><span class="line">            bad_request(client);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立output管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_output) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立input管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(cgi_input) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//       fork后管道都复制了一份，都是一样的</span></span><br><span class="line">    <span class="comment">//       子进程关闭2个无用的端口，避免浪费             </span></span><br><span class="line">    <span class="comment">//       ×&lt;-------------------------&gt;1    output</span></span><br><span class="line">    <span class="comment">//       0&lt;--------------------------&gt;×   input</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       父进程关闭2个无用的端口，避免浪费             </span></span><br><span class="line">    <span class="comment">//       0&lt;--------------------------&gt;×   output</span></span><br><span class="line">    <span class="comment">//       ×&lt;-------------------------&gt;1    input</span></span><br><span class="line">    <span class="comment">//       此时父子进程已经可以通信</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork进程，子进程用于执行CGI</span></span><br><span class="line">    <span class="comment">// 父进程用于收数据以及发送子进程处理的回复数据</span></span><br><span class="line">    <span class="keyword">if</span> ( (pid = fork()) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/*child: CGI script */</span></span><br><span class="line">        <span class="type">char</span> meth_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> query_env[<span class="number">255</span>];</span><br><span class="line">        <span class="type">char</span> length_env[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程输出重定向到output管道的1端</span></span><br><span class="line">        dup2(cgi_output[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 子进程输入重定向到input管道的0端</span></span><br><span class="line">        dup2(cgi_input[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭无用管道</span></span><br><span class="line">        close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CGI环境变量</span></span><br><span class="line">        <span class="built_in">sprintf</span>(meth_env, <span class="string">&quot;REQUEST_METHOD=%s&quot;</span>, method);</span><br><span class="line">        putenv(meth_env);</span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(query_env, <span class="string">&quot;REQUEST_STRING=%s&quot;</span>, query_string);</span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* POST */</span></span><br><span class="line">            <span class="built_in">sprintf</span>(length_env, <span class="string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);</span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换执行path</span></span><br><span class="line">        execl(path, path, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// int m = execl(path, path, NULL);</span></span><br><span class="line">        <span class="comment">// 如果path有问题，例如将html网页改成可执行的，但是执行后m为-1</span></span><br><span class="line">        <span class="comment">// 退出子进程，管道被破坏，但是父进程还在往里面写东西，触发Program received signal SIGPIPE, Broken pipe.</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* parent */</span></span><br><span class="line">        <span class="comment">// 关闭无用管道</span></span><br><span class="line">        close(cgi_output[<span class="number">1</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; content_length; i++) &#123;</span><br><span class="line">                <span class="comment">// 得到post请求数据，写到input管道中，供子进程使用</span></span><br><span class="line">                recv(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                write(cgi_input[<span class="number">1</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从output管道读到子进程处理后的信息，然后send出去</span></span><br><span class="line">        <span class="keyword">while</span> (read(cgi_output[<span class="number">0</span>], &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            send(client, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成操作后关闭管道</span></span><br><span class="line">        close(cgi_output[<span class="number">0</span>]);</span><br><span class="line">        close(cgi_input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子进程返回</span></span><br><span class="line">        waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Get a line from a socket, whether the line ends in a newline,</span></span><br><span class="line"><span class="comment"> * carriage return, or a CRLF combination.  Terminates the string read</span></span><br><span class="line"><span class="comment"> * with a null character.  If no newline indicator is found before the</span></span><br><span class="line"><span class="comment"> * end of the buffer, the string is terminated with a null.  If any of</span></span><br><span class="line"><span class="comment"> * the above three line terminators is read, the last character of the</span></span><br><span class="line"><span class="comment"> * string will be a linefeed and the string will be terminated with a</span></span><br><span class="line"><span class="comment"> * null character.</span></span><br><span class="line"><span class="comment"> * Parameters: the socket descriptor</span></span><br><span class="line"><span class="comment"> *             the buffer to save the data in</span></span><br><span class="line"><span class="comment"> *             the size of the buffer</span></span><br><span class="line"><span class="comment"> * Returns: the number of bytes stored (excluding null) */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一行数据,只要发现c为\n,就认为是一行结束，如果读到\r,再用MSG_PEEK的方式读入一个字符，如果是\n，从socket用读出</span></span><br><span class="line"><span class="comment">//如果是下个字符则不处理，将c置为\n，结束。如果读到的数据为0中断，或者小于0，也视为结束，c置为\n</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">        n = recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 偷窥一个字节，如果是\n就读走</span></span><br><span class="line">                n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">                <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></span><br><span class="line">                <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">                    recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是\n（读到下一行的字符）或者没读到，置c为\n 跳出循环,完成一行读取</span></span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Return the informational HTTP headers about a file. */</span></span><br><span class="line"><span class="comment">/* Parameters: the socket to print the headers on</span></span><br><span class="line"><span class="comment"> *             the name of the file */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入http的headers</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headers</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    (<span class="type">void</span>) filename; <span class="comment">/* could use filename to determine file type */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, SERVER_STRING);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Give a client a 404 not found status message. */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果资源没有找到得返回给客户端下面的信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">not_found</span><span class="params">(<span class="type">int</span> client)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 404 NOT FOUND\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;your request because the resource specified\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;is unavailable or nonexistent.\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Send a regular file to the client.  Use headers, and report</span></span><br><span class="line"><span class="comment"> * errors to client if they occur.</span></span><br><span class="line"><span class="comment"> * Parameters: a pointer to a file structure produced from the socket</span></span><br><span class="line"><span class="comment"> *              file descriptor</span></span><br><span class="line"><span class="comment"> *             the name of the file to serve */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是CGI文件，直接读取文件返回给请求的http客户端</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">server_file</span><span class="params">(<span class="type">int</span> client, <span class="type">const</span> <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    FILE *resource = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> numchars = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认字符</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((numchars &gt; <span class="number">0</span>) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;\n&quot;</span>, buf)) &#123; <span class="comment">/* read &amp; discard headers */</span></span><br><span class="line">        numchars = get_line(client, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    resource = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        not_found(client);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        headers(client, filename);</span><br><span class="line">        cat(client, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* This function starts the process of listening for web connections</span></span><br><span class="line"><span class="comment"> * on a specified port.  If the port is 0, then dynamically allocate a</span></span><br><span class="line"><span class="comment"> * port and modify the original port variable to reflect the actual</span></span><br><span class="line"><span class="comment"> * port.</span></span><br><span class="line"><span class="comment"> * Parameters: pointer to variable containing the port to connect on</span></span><br><span class="line"><span class="comment"> * Returns: the socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">startup</span><span class="params">(u_short *port)</span> &#123;</span><br><span class="line">    <span class="type">int</span> httpd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">name</span>;</span></span><br><span class="line"></span><br><span class="line">    httpd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (httpd == <span class="number">-1</span>) &#123;</span><br><span class="line">        error_die(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line">    name.sin_family = AF_INET;</span><br><span class="line">    name.sin_port = htons(*port);</span><br><span class="line">    name.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    <span class="keyword">if</span> (bind(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, <span class="keyword">sizeof</span>(name)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error_die(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果端口没有设置，提供个随机端口</span></span><br><span class="line">    <span class="keyword">if</span> (*port == <span class="number">0</span>) &#123; <span class="comment">/* if dynamically allocating a port */</span></span><br><span class="line">        <span class="type">socklen_t</span> namelen = <span class="keyword">sizeof</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (getsockname(httpd, (<span class="keyword">struct</span> sockaddr *)&amp;name, &amp;namelen) == <span class="number">-1</span>) &#123;</span><br><span class="line">            error_die(<span class="string">&quot;getsockname&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *port = ntohs(name.sin_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(httpd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error_die(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (httpd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/* Inform the client that the requested web method has not been</span></span><br><span class="line"><span class="comment"> * implemented.</span></span><br><span class="line"><span class="comment"> * Parameter: the client socket */</span></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果方法没有实现，就返回此信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unimplemented</span><span class="params">(<span class="type">int</span> client)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 501 Method Not Implemented\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, SERVER_STRING);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/BODY&gt;&lt;/HTML&gt;\r\n&quot;</span>);</span><br><span class="line">    send(client, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_sock = <span class="number">-1</span>;</span><br><span class="line">    u_short port = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> client_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_name</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这边要为socklen_t类型</span></span><br><span class="line">    <span class="type">socklen_t</span> client_name_len = <span class="keyword">sizeof</span>(client_name);</span><br><span class="line">    <span class="type">pthread_t</span> newthread;</span><br><span class="line"></span><br><span class="line">    server_sock = startup(&amp;port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;httpd running on port %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受请求，函数原型</span></span><br><span class="line">        <span class="comment">// ##include &lt;sys/types.h&gt;</span></span><br><span class="line">        <span class="comment">// ##include &lt;sys/socket.h&gt;</span></span><br><span class="line">        <span class="comment">// int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line">        client_sock = accept(server_sock, (<span class="keyword">struct</span> sockaddr *)&amp;client_name, &amp;client_name_len);</span><br><span class="line">        <span class="keyword">if</span> (client_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">            error_die(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* accept_request(client_sock) */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次收到请求，创建一个线程来处理接收到的请求</span></span><br><span class="line">        <span class="comment">// 把client_sock转成地址作为参数传入pthread_create</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;newthread, <span class="literal">NULL</span>, (<span class="type">void</span> *)accept_request, (<span class="type">void</span> *)(<span class="type">intptr_t</span>)client_sock) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(server_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="simpleclient-c"><a href="#simpleclient-c" class="headerlink" title="simpleclient.c"></a>simpleclient.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    address.sin_port = htons(<span class="number">9734</span>);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    result = connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;oops: client1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    read(sockfd, &amp;ch, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char from server = %c\n&quot;</span>, ch);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/11/09/tinyhttpd/">https://blog.jujimeizuo.cn/2022/11/09/tinyhttpd/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动2023秋招研发第四场笔试【后端方向】</title>
      <link href="/2022/09/18/bytedance2023fourwrittenexan/"/>
      <url>/2022/09/18/bytedance2023fourwrittenexan/</url>
      
        <content type="html"><![CDATA[<h4 id="T1-金字塔"><a href="#T1-金字塔" class="headerlink" title="T1 金字塔"></a>T1 金字塔</h4><h3 id="模拟-O-mlogm"><a href="#模拟-O-mlogm" class="headerlink" title="模拟 O(mlogm)"></a>模拟 O(mlogm)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(n);</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">flag</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        std::cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            std::cin &gt;&gt; x;</span><br><span class="line">            a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">            flag[i].<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; flag[<span class="number">0</span>].<span class="built_in">size</span>(); i++) flag[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// a[i][j] + 50 in a[i - 1]</span></span><br><span class="line">        <span class="comment">// a[i][j] + 1 in a[i - 1] a[i][j] + 99 in a[i - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> p1 = std::<span class="built_in">lower_bound</span>(a[i - <span class="number">1</span>].<span class="built_in">begin</span>(), a[i - <span class="number">1</span>].<span class="built_in">end</span>(), a[i][j]) - a[i - <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="comment">// pre one</span></span><br><span class="line">            <span class="keyword">if</span> (p1 &gt;= <span class="number">1</span> &amp;&amp; flag[i - <span class="number">1</span>][p1 - <span class="number">1</span>] &amp;&amp; a[i - <span class="number">1</span>][p1 - <span class="number">1</span>] + <span class="number">100</span> &gt; a[i][j] + <span class="number">50</span>) &#123;</span><br><span class="line">                flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// next one</span></span><br><span class="line">            <span class="keyword">if</span> (p1 &lt; a[i - <span class="number">1</span>].<span class="built_in">size</span>() &amp;&amp; flag[i - <span class="number">1</span>][p1] &amp;&amp; a[i - <span class="number">1</span>][p1] &lt; a[i][j] + <span class="number">50</span>) &#123;</span><br><span class="line">                flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1 &gt;= <span class="number">1</span> &amp;&amp; p1 &lt; a[i - <span class="number">1</span>].<span class="built_in">size</span>() &amp;&amp; flag[i - <span class="number">1</span>][p1 - <span class="number">1</span>] &amp;&amp; flag[i - <span class="number">1</span>][p1] &amp;&amp; a[i - <span class="number">1</span>][p1 - <span class="number">1</span>] + <span class="number">100</span> &gt; a[i][j] &amp;&amp; a[i - <span class="number">1</span>][p1] &lt; a[i][j] + <span class="number">100</span>) &#123;</span><br><span class="line">                flag[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="T2-最长01序列"><a href="#T2-最长01序列" class="headerlink" title="T2 最长01序列"></a>T2 最长01序列</h4><h3 id="尺取-O-n"><a href="#尺取-O-n" class="headerlink" title="尺取 O(n)"></a>尺取 O(n)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[r] != s[r - <span class="number">1</span>]) cnt++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, cnt);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="T3-修改最短子串使得整串词频相同"><a href="#T3-修改最短子串使得整串词频相同" class="headerlink" title="T3 修改最短子串使得整串词频相同"></a>T3 修改最短子串使得整串词频相同</h4><h3 id="前缀和-二分-O-nlogn"><a href="#前缀和-二分-O-nlogn" class="headerlink" title="前缀和 + 二分 O(nlogn)"></a>前缀和 + 二分 O(nlogn)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="T4-最长区间的最大值和最小值的绝对值差小于等于k，并求区间个数和起点和终点"><a href="#T4-最长区间的最大值和最小值的绝对值差小于等于k，并求区间个数和起点和终点" class="headerlink" title="T4 最长区间的最大值和最小值的绝对值差小于等于k，并求区间个数和起点和终点"></a>T4 最长区间的最大值和最小值的绝对值差小于等于k，并求区间个数和起点和终点</h4><h3 id="ST表维护区间最值，把i设为起始点并二分求出终点-O-nlognlogn"><a href="#ST表维护区间最值，把i设为起始点并二分求出终点-O-nlognlogn" class="headerlink" title="ST表维护区间最值，把i设为起始点并二分求出终点 O(nlognlogn)"></a>ST表维护区间最值，把i设为起始点并二分求出终点 O(nlognlogn)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">F</span> = std::function&lt;<span class="built_in">T</span>(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> SparseTable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;T&gt;&gt; mat;</span><br><span class="line">    F func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SparseTable</span>(<span class="type">const</span> std::vector&lt;T&gt;&amp; a, <span class="type">const</span> F&amp; f) : <span class="built_in">func</span>(f) &#123;</span><br><span class="line">        n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> max_log = <span class="number">32</span> - __builtin_clz(n);</span><br><span class="line">        mat.<span class="built_in">resize</span>(max_log);</span><br><span class="line">        mat[<span class="number">0</span>] = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; max_log; j++) &#123;</span><br><span class="line">            mat[j].<span class="built_in">resize</span>(n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j); i++) &#123;</span><br><span class="line">                mat[j][i] = <span class="built_in">func</span>(mat[j - <span class="number">1</span>][i], mat[j - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> &lt;= from &amp;&amp; from &lt;= to &amp;&amp; to &lt;= n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> lg = <span class="number">32</span> - __builtin_clz(to - from + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(mat[lg][from], mat[lg][to - (<span class="number">1</span> &lt;&lt; lg) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    std::cin &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SparseTable&lt;<span class="type">int</span>&gt; <span class="title">mx</span><span class="params">(h, [](<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j) &#123; <span class="keyword">return</span> std::max(i, j); &#125;)</span></span>;</span><br><span class="line">    <span class="function">SparseTable&lt;<span class="type">int</span>&gt; <span class="title">mn</span><span class="params">(h, [](<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j) &#123; <span class="keyword">return</span> std::min(i, j); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mx.<span class="built_in">get</span>(i, mid) - mn.<span class="built_in">get</span>(i, mid) &lt;= k) &#123;</span><br><span class="line">                j = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i - j</span></span><br><span class="line">        <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">front</span>().second - ans.<span class="built_in">front</span>().first + <span class="number">1</span> &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">clear</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans.<span class="built_in">front</span>().second - ans.<span class="built_in">front</span>().first + <span class="number">1</span> == j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/09/18/bytedance2023fourwrittenexan/">https://blog.jujimeizuo.cn/2022/09/18/bytedance2023fourwrittenexan/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shared_ptr自定义实现</title>
      <link href="/2022/07/30/shared-ptr/"/>
      <url>/2022/07/30/shared-ptr/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 智能指针中的引用计数类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefCount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefCount</span>() : <span class="built_in">count_</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">RefCount</span>(<span class="type">const</span> RefCount &amp;rhs) : <span class="built_in">count_</span>(rhs.count_) &#123;</span><br><span class="line">        (*count_)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="built_in">RefCount</span>(RefCount &amp;&amp;rhs) : <span class="built_in">count_</span>(rhs.count_) &#123;</span><br><span class="line">        rhs.count_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值</span></span><br><span class="line">    RefCount &amp;<span class="keyword">operator</span>=(<span class="type">const</span> RefCount &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">tryRelease</span>();</span><br><span class="line">        count_ = rhs.count_;</span><br><span class="line">        (*count_)++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    RefCount &amp;<span class="keyword">operator</span>=(RefCount &amp;&amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">tryRelease</span>();</span><br><span class="line">        count_ = rhs.count_;</span><br><span class="line">        rhs.count_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RefCount</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (*count_ == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> count_;</span><br><span class="line">            count_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*count_)--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">IsOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *count_ == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试减少引用计数并释放内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tryRelease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*count_ == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> count_;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (*count_)--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">size_t</span>* count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 智能指针封装类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">SmartPtr</span>() : <span class="built_in">SmartPtr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&amp; rhs) &#123;</span><br><span class="line">        ptr_ = rhs.ptr_;</span><br><span class="line">        count_ = rhs.count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(SmartPtr&amp;&amp; rhs) <span class="keyword">noexcept</span> : <span class="built_in">ptr_</span>(rhs.ptr_), <span class="built_in">count_</span>(rhs.count_) &#123;</span><br><span class="line">        rhs.count_ = rhs.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值</span></span><br><span class="line">    SmartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SmartPtr&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count_.<span class="built_in">IsOnly</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count_.<span class="built_in">tryRelease</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ptr_ = rhs.ptr_;</span><br><span class="line">        count_ = rhs.count_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    SmartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SmartPtr&amp;&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count_ = std::<span class="built_in">move</span>(rhs.count_);</span><br><span class="line">        ptr_ = rhs.ptr_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SmartPtr</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SmartPtr deconstructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (count_.<span class="built_in">IsOnly</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count_.<span class="built_in">tryRelease</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用运算符*</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员访问运算符-&gt;</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shared_Ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Shared_Ptr</span>(T* ptr = <span class="literal">nullptr</span>) : _pPtr(ptr), _pRefCount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)), _pMutex(<span class="keyword">new</span> mutex) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Shared_Ptr</span>(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp) : _pPtr(sp._pPtr), _pRefCount(sp._pRefCount), _pMutex(sp._pMutex) &#123;</span><br><span class="line">        <span class="built_in">AddRefCount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Shared_Ptr</span>() &#123;</span><br><span class="line">        <span class="built_in">Release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Shared_Ptr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != sp) &#123;</span><br><span class="line">            <span class="built_in">Release</span>();</span><br><span class="line">            _pPtr = sp._pPtr;</span><br><span class="line">            _pRefCount = sp._pRefCount;</span><br><span class="line">            _pMutex = sp._pMutex;</span><br><span class="line">            <span class="built_in">AddRefCount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *_pPtr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> _pPtr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">UseCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *_pRefCount; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _pPtr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddRefCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _pMutex -&gt; <span class="built_in">lock</span>();</span><br><span class="line">        ++(*_pRefCount);</span><br><span class="line">        _pMutex -&gt; <span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> deleteflag = <span class="literal">false</span>;</span><br><span class="line">        _pMutex -&gt; <span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (--(*_pRefCount) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pRefCount;</span><br><span class="line">            <span class="keyword">delete</span> _pPtr;</span><br><span class="line">            deleteflag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pMutex -&gt; <span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> (deleteflag == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pMutex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/07/30/shared-ptr/">https://blog.jujimeizuo.cn/2022/07/30/shared-ptr/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-python</title>
      <link href="/2022/05/17/go-python/"/>
      <url>/2022/05/17/go-python/</url>
      
        <content type="html"><![CDATA[<p><strong>视觉智慧实践课上需要写深度学习-图像检索的大作业。Python是机器&#x2F;深度学习御用开发语言，Golang是新时代后端开发语言。Python很适合算法写模型，而Golang很适合提供API服务，两位同志都红的发紫。（抄袭）</strong></p><p><strong>所以算法方面用python写的sift，qt不想写（不喜欢），最近又在学go，所以准备用gin搭建web端，不过go和python之间好像有什么联系，没错，就是go-python，所以开始吧。</strong></p><h4 id="go-python"><a href="#go-python" class="headerlink" title="go-python"></a>go-python</h4><ul><li><a href="github.com/sbinet/go-python">go-python</a>主要用在python2.x</li><li><a href="github.com/DataDog/go-python3">go-python3</a>主要用来在python3.x</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/DataDog/go-python3</span><br></pre></td></tr></table></figure><p>我的mac是python3.9版本的，所以在<code>go build</code>的时候报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## github.com/DataDog/go-python3</span><br><span class="line">../../go/pkg/mod/github.com/!data!dog/go-python3@v0.0.0-20211102160307-40adc605f1fe/dict.go:141:13: could not determine kind of name for C.PyDict_ClearFreeList</span><br></pre></td></tr></table></figure><p>意思就是python3.9的这个函数PyDict_ClearFreeList被删除了，找不到</p><p>通过查看这个<a href="https://github.com/DataDog/go-python3/issues/38">issue</a>可以发现：</p><ul><li>python的版本需要用3.7，所以需要配置python3.7虚拟环境</li><li>下好之后，需要用到pkg-config</li></ul><p>解决方案：</p><p>下载<a href="python.org/downloads/macos/">python3.7</a>，然后用anaconda或者venv创建虚拟环境。</p><p>我通过<code>brew install pkg-config</code>，然后<code>export $PKG_CONFIG_PATH=/usr/local/bin/pkg-config</code>，还是不太行。 原来需要用到python3.7里的pkg-config。</p><p>直接执行下面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bash_profile</span><br><span class="line"><span class="built_in">export</span> <span class="variable">$PKG_CONFIG_PATH</span>=/Library/Frameworks/Python.framework/Versions/3.7/lib/pkgconfig</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>最后<code>go build</code>可以顺利完成。</p><h4 id="go调用python的过程"><a href="#go调用python的过程" class="headerlink" title="go调用python的过程"></a>go调用python的过程</h4><ol><li>初始化python环境</li><li>引入模块py对象</li><li>使用该模块的变量与函数</li><li>解析结果</li><li>销毁python3运行环境</li></ol><h4 id="调用中必用到到几个函数"><a href="#调用中必用到到几个函数" class="headerlink" title="调用中必用到到几个函数"></a>调用中必用到到几个函数</h4><p><code>init func()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    python3.Py_Initialize()</span><br><span class="line">    <span class="keyword">if</span> !python3.Py_IsInitialized() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Error initializing the python interpreter&quot;</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ImportModule func(dir, name strng) *python3.PyObject</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImportModule</span></span><br><span class="line"><span class="comment">// @Description: 导入一个包</span></span><br><span class="line"><span class="comment">// @param dir</span></span><br><span class="line"><span class="comment">// @param name</span></span><br><span class="line"><span class="comment">// @return *python3.PyObject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ImportModule</span><span class="params">(dir, name <span class="type">string</span>)</span></span> *python3.PyObject &#123;</span><br><span class="line">    sysModule := python3.PyImport_ImportModule(<span class="string">&quot;sys&quot;</span>)</span><br><span class="line">    path := sysModule.GetAttrString(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    pathStr, _ := pythonRepr(path)</span><br><span class="line">    log.Println(<span class="string">&quot;before add path is &quot;</span> + pathStr)</span><br><span class="line">    python3.PyList_Insert(path, <span class="number">0</span>, python3.PyUnicode_FromString(<span class="string">&quot;&quot;</span>))</span><br><span class="line">    python3.PyList_Insert(path, <span class="number">0</span>, python3.PyUnicode_FromString(dir))</span><br><span class="line">    pathStr, _ = pythonRepr(path)</span><br><span class="line">    log.Println(<span class="string">&quot;after add path is &quot;</span> + pathStr)</span><br><span class="line">    <span class="keyword">return</span> python3.PyImport_ImportModule(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pythonRepr func(o *python3.PyObject) (string, error)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pythonRepr</span></span><br><span class="line"><span class="comment">// @Description: PyObject转换为string</span></span><br><span class="line"><span class="comment">// @param o</span></span><br><span class="line"><span class="comment">// @return string</span></span><br><span class="line"><span class="comment">// @return error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pythonRepr</span><span class="params">(o *python3.PyObject)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;object is nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    s := o.Repr()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        python3.PyErr_Clear()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;failed to call Repr object method&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> s.DecRef()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> python3.PyUnicode_AsUTF8(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/05/17/go-python/">https://blog.jujimeizuo.cn/2022/05/17/go-python/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2022/05/15/mq/"/>
      <url>/2022/05/15/mq/</url>
      
        <content type="html"><![CDATA[<h2 id="1-消息模型"><a href="#1-消息模型" class="headerlink" title="1 消息模型"></a>1 消息模型</h2><h4 id="1-1-点对点"><a href="#1-1-点对点" class="headerlink" title="1.1 点对点"></a>1.1 点对点</h4><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011250613.png"></p><h4 id="1-2-发布-订阅"><a href="#1-2-发布-订阅" class="headerlink" title="1.2 发布&#x2F;订阅"></a>1.2 发布&#x2F;订阅</h4><p>消息生产者向频道发送了一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011410374.png"></p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011747967.png"></p><h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h2><h4 id="2-1-异步处理"><a href="#2-1-异步处理" class="headerlink" title="2.1 异步处理"></a>2.1 异步处理</h4><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其他操作。消息接收者从消息队列中订阅消息之后异步处理。</p><p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p><p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p><h4 id="2-2-流量削锋"><a href="#2-2-流量削锋" class="headerlink" title="2.2 流量削锋"></a>2.2 流量削锋</h4><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中的订阅消息进行处理。</p><h4 id="2-3-应用解耦"><a href="#2-3-应用解耦" class="headerlink" title="2.3 应用解耦"></a>2.3 应用解耦</h4><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p><h2 id="3-可靠性"><a href="#3-可靠性" class="headerlink" title="3 可靠性"></a>3 可靠性</h2><h4 id="3-1-发送端的可靠性"><a href="#3-1-发送端的可靠性" class="headerlink" title="3.1 发送端的可靠性"></a>3.1 发送端的可靠性</h4><p>发送端完成操作后一定能将消息成功发送到消息队列中。</p><p>实现方法：</p><p>在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p><h4 id="3-2-接收端的可靠性"><a href="#3-2-接收端的可靠性" class="headerlink" title="3.2 接收端的可靠性"></a>3.2 接收端的可靠性</h4><p>接收端能够给从消息队列成功消费一次消息。</p><p>两种实现方法：</p><ol><li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li><li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li></ol><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/05/15/mq/">https://blog.jujimeizuo.cn/2022/05/15/mq/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go For Codeforces</title>
      <link href="/2022/05/12/go-for-codeforces/"/>
      <url>/2022/05/12/go-for-codeforces/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 用 gomod管理</span></span><br><span class="line">go get github.com/EndlessCheng/codeforces-go</span><br></pre></td></tr></table></figure><blockquote><p>用最基本的fmt.Scanln()当然可以，这里提供一种解决方法，用bufio处理，将输入输出转换成go_test。</p></blockquote><h3 id="Sol-go"><a href="#Sol-go" class="headerlink" title="Sol.go"></a>Sol.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sol</span><span class="params">(_r io.Reader, _w io.Writer)</span></span> &#123;</span><br><span class="line">    in := bufio.NewReader(_r)</span><br><span class="line">    out := bufio.NewWriter(_w)</span><br><span class="line">    <span class="keyword">defer</span> out.Flush()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; Sol(os.Stdin, os.Stdout) &#125;</span><br></pre></td></tr></table></figure><h3 id="Sol-test-go"><a href="#Sol-test-go" class="headerlink" title="Sol_test.go"></a>Sol_test.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入（inputCopy）</span><br><span class="line">输出（outputCopy）</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/EndlessCheng/codeforces-go/main/testutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSol</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// just copy from website</span></span><br><span class="line">    rawText := <span class="string">`</span></span><br><span class="line"><span class="string">inputCopy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">outputCopy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    testutil.AssertEqualCase(t, rawText, <span class="number">0</span>, Sol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/05/12/go-for-codeforces/">https://blog.jujimeizuo.cn/2022/05/12/go-for-codeforces/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统期末复习</title>
      <link href="/2022/05/11/os/"/>
      <url>/2022/05/11/os/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h4 id="1-1-基本特征"><a href="#1-1-基本特征" class="headerlink" title="1.1 基本特征"></a>1.1 基本特征</h4><h3 id="1-1-1-并发"><a href="#1-1-1-并发" class="headerlink" title="1.1.1 并发"></a>1.1.1 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线，多核处理器或者分布式计算系统。 操作系统通过引入进程和线程，使得程序能够并发运行。 操作系统通过引入进程和线程，使得程序能够并发运行。</p><h3 id="1-1-2-共享"><a href="#1-1-2-共享" class="headerlink" title="1.1.2 共享"></a>1.1.2 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h3 id="1-1-3-虚拟"><a href="#1-1-3-虚拟" class="headerlink" title="1.1.3 虚拟"></a>1.1.3 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间，地址空间的页被映射到物理内存，地址空间并不需要全部在物理内存中，当使用一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h3 id="1-1-4-异步"><a href="#1-1-4-异步" class="headerlink" title="1.1.4 异步"></a>1.1.4 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h4 id="1-2-基本功能"><a href="#1-2-基本功能" class="headerlink" title="1.2 基本功能"></a>1.2 基本功能</h4><h3 id="1-2-1-进程管理"><a href="#1-2-1-进程管理" class="headerlink" title="1.2.1 进程管理"></a>1.2.1 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="1-2-2-内存管理"><a href="#1-2-2-内存管理" class="headerlink" title="1.2.2 内存管理"></a>1.2.2 内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h3 id="1-2-3-文件管理"><a href="#1-2-3-文件管理" class="headerlink" title="1.2.3 文件管理"></a>1.2.3 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h3 id="1-2-4-设备管理"><a href="#1-2-4-设备管理" class="headerlink" title="1.2.4 设备管理"></a>1.2.4 设备管理</h3><p>完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理、虚拟设备等。</p><h4 id="1-3-系统调用"><a href="#1-3-系统调用" class="headerlink" title="1.3 系统调用"></a>1.3 系统调用</h4><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png"></p><p>Linux的系统调用主要有以下这些：</p><p>Task</p><p>Commands</p><p>进程控制</p><p>fork(); exit(); wait();</p><p>进程通信</p><p>pipe(); shmget(); mmap();</p><p>文件操作</p><p>open(); read(); write();</p><p>设备操作</p><p>ioctl(); read(); write();</p><p>信息维护</p><p>getpid(); alarm(); sleep();</p><p>安全</p><p>chmod(); umask(); chown();</p><h4 id="1-4-宏内核和微内核"><a href="#1-4-宏内核和微内核" class="headerlink" title="1.4 宏内核和微内核"></a>1.4 宏内核和微内核</h4><h3 id="1-4-1-宏内核"><a href="#1-4-1-宏内核" class="headerlink" title="1.4.1 宏内核"></a>1.4.1 宏内核</h3><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。 由于各模块共享信息，因此有很高的性能。</p><h3 id="1-4-2-微内核"><a href="#1-4-2-微内核" class="headerlink" title="1.4.2 微内核"></a>1.4.2 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"></p><h4 id="1-5-中断分类"><a href="#1-5-中断分类" class="headerlink" title="1.5 中断分类"></a>1.5 中断分类</h4><h3 id="1-5-1-外中断"><a href="#1-5-1-外中断" class="headerlink" title="1.5.1 外中断"></a>1.5.1 外中断</h3><p>由CPU执行指令以外的时间引起，如I&#x2F;O完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="1-5-2-异常"><a href="#1-5-2-异常" class="headerlink" title="1.5.2 异常"></a>1.5.2 异常</h3><p>由CPU执行指令的内部时间引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="1-5-3-陷入"><a href="#1-5-3-陷入" class="headerlink" title="1.5.3 陷入"></a>1.5.3 陷入</h3><p>在用户程序中使用系统调用。</p><h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2 进程管理"></a>2 进程管理</h2><h4 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h4><h3 id="2-1-1-进程"><a href="#2-1-1-进程" class="headerlink" title="2.1.1 进程"></a>2.1.1 进程</h3><p>进程是资源分配的基本单位。</p><p>进程控制块（Process Control Block，PCB）描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对PCB的操作。</p><h3 id="2-1-2-线程"><a href="#2-1-2-线程" class="headerlink" title="2.1.2 线程"></a>2.1.2 线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>eg：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP请求时，浏览器还可以响应用户的其它事件。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"></p><h3 id="2-1-3-区别"><a href="#2-1-3-区别" class="headerlink" title="2.1.3 区别"></a>2.1.3 区别</h3><ol><li>拥有资源</li></ol><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><ol start="2"><li>调度</li></ol><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><ol start="3"><li>系统开销</li></ol><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><ol start="4"><li>通信方面</li></ol><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。</p><h4 id="2-2-进程状态的切换"><a href="#2-2-进程状态的切换" class="headerlink" title="2.2 进程状态的切换"></a>2.2 进程状态的切换</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png"></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它都是单向转换。就绪状态的进程通过调度算法从而获得CPU时间，转为运行状态；而运行状态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转换为就绪态。</li></ul><h4 id="2-3-进程调度算法"><a href="#2-3-进程调度算法" class="headerlink" title="2.3 进程调度算法"></a>2.3 进程调度算法</h4><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h3 id="2-3-1-批处理系统"><a href="#2-3-1-批处理系统" class="headerlink" title="2.3.1 批处理系统"></a>2.3.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><h4 id="2-3-1-1-先来先服务-first-come-first-serverd-（FCFS）"><a href="#2-3-1-1-先来先服务-first-come-first-serverd-（FCFS）" class="headerlink" title="2.3.1.1 先来先服务 first-come first-serverd （FCFS）"></a>2.3.1.1 先来先服务 first-come first-serverd （FCFS）</h4><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h4 id="2-3-1-2-短作业优先-shortest-job-first-（SJF）"><a href="#2-3-1-2-短作业优先-shortest-job-first-（SJF）" class="headerlink" title="2.3.1.2 短作业优先 shortest job first （SJF）"></a>2.3.1.2 短作业优先 shortest job first （SJF）</h4><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h4 id="2-3-1-3-最短剩余时间优先-shortest-remaining-time-next-（SRTN）"><a href="#2-3-1-3-最短剩余时间优先-shortest-remaining-time-next-（SRTN）" class="headerlink" title="2.3.1.3 最短剩余时间优先 shortest remaining time next （SRTN）"></a>2.3.1.3 最短剩余时间优先 shortest remaining time next （SRTN）</h4><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。</p><h3 id="2-3-2-交互式系统"><a href="#2-3-2-交互式系统" class="headerlink" title="2.3.2 交互式系统"></a>2.3.2 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h4 id="2-3-2-1-时间片轮转"><a href="#2-3-2-1-时间片轮转" class="headerlink" title="2.3.2.1 时间片轮转"></a>2.3.2.1 时间片轮转</h4><p>将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"></p><h4 id="2-3-2-2-优先级调度"><a href="#2-3-2-2-优先级调度" class="headerlink" title="2.3.2.2 优先级调度"></a>2.3.2.2 优先级调度</h4><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h4 id="2-3-2-3-多级反馈队列"><a href="#2-3-2-3-多级反馈队列" class="headerlink" title="2.3.2.3 多级反馈队列"></a>2.3.2.3 多级反馈队列</h4><p>一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换7次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"></p><h3 id="2-3-3-实时系统"><a href="#2-3-3-实时系统" class="headerlink" title="2.3.3 实时系统"></a>2.3.3 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h4 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h4><h3 id="2-4-1-临界区"><a href="#2-4-1-临界区" class="headerlink" title="2.4.1 临界区"></a>2.4.1 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h3 id="2-4-2-同步与互斥"><a href="#2-4-2-同步与互斥" class="headerlink" title="2.4.2 同步与互斥"></a>2.4.2 同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="2-4-3-信号量"><a href="#2-4-3-信号量" class="headerlink" title="2.4.3 信号量"></a>2.4.3 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。</p><ul><li><code>down</code>：如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0；</li><li><code>up</code>：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。</li></ul><p>down和up操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为0或者1，那么就成为了<code>互斥量（Mutex）</code>，0表示临界区已经加锁，1表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-4-管程"><a href="#2-4-4-管程" class="headerlink" title="2.4.4 管程"></a>2.4.4 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>略。</p><h4 id="2-5-经典同步问题"><a href="#2-5-经典同步问题" class="headerlink" title="2.5 经典同步问题"></a>2.5 经典同步问题</h4><h3 id="2-5-1-使用信号量实现生产者-消费者问题"><a href="#2-5-1-使用信号量实现生产者-消费者问题" class="headerlink" title="2.5.1 使用信号量实现生产者-消费者问题"></a>2.5.1 使用信号量实现生产者-消费者问题</h3><p>问题描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</span><br></pre></td></tr></table></figure><p>因为缓冲区属于临界资源，因此需要使用一个互斥量<code>mutex</code>来控制缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计。</p><p>这里需要使用两个信号量：<code>empty</code>记录空缓冲区的数量，<code>full</code>记录满缓冲区的数量。</p><p>其中，<code>empty</code>信号量是在生产者进程中使用，当<code>empty</code>不为0时，生产者才可以放入物品；<code>full</code>信号量时在消费者进程中使用，当<code>full</code>信号量不为0时，消费者才可以取走物品。</p><p>注意：不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行down(mutex)再执行down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行down(empty)操作，发现empty&#x3D;0，此时生产者睡眠，消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行up(empty)操作，empty永远都为0，导致生产者永远等待下去，不会释放锁，消费者因此也会永远等待下去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-2-哲学家进餐问题"><a href="#2-5-2-哲学家进餐问题" class="headerlink" title="2.5.2 哲学家进餐问题"></a>2.5.2 哲学家进餐问题</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"></p><p>问题描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</span><br></pre></td></tr></table></figure><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其他哲学家吃完并释放自己手中的筷子，导致死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);            <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i + <span class="number">1</span>) % N);  <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i + <span class="number">1</span>) % N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有再两个邻居都没有进餐的情况下才允许进餐。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> LEFT (i - 1 + N) % N    <span class="comment">// 左邻居</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> RIGHT (i + 1) % N       <span class="comment">// 右邻居</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> HUNGRY 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> EATING 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N];                   <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;            <span class="comment">// 临界区的互斥，临界区时state数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];                 <span class="comment">// 每个哲学家的一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_two</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_two</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐</span></span><br><span class="line"><span class="comment">// 如果是的话，就up(&amp;s[i])了，使得down(&amp;s[i])能够得到通知并继续执行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-读者-写者问题"><a href="#2-5-3-读者-写者问题" class="headerlink" title="2.5.3 读者-写者问题"></a>2.5.3 读者-写者问题</h3><p>问题描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写的操作同时发生。</span><br></pre></td></tr></table></figure><p>一个整型变量<code>count</code>记录在对数据进行读操作的进程数量，一个互斥量<code>count_mutex</code>用于对<code>count</code>加锁，一个互斥量<code>data_mutex</code>用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-4-理发师问题"><a href="#2-5-4-理发师问题" class="headerlink" title="2.5.4 理发师问题"></a>2.5.4 理发师问题</h3><p>问题描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设有一个理发店只有一个理发师，一张理发时坐的椅子，若干张普通椅子顾客供等候时坐。没有顾客时，理发师就坐在理发的椅子上睡觉。顾客一到，他不是叫醒理发师，就是离开。如果理发师没有睡觉，而在为别人理发，他就会坐下来等候。如果所有的椅子都坐满了人，最后来的顾客就会离开。</span><br></pre></td></tr></table></figure><p>使用三个信号量和一个控制变量：</p><ol><li>控制变量<code>waiting</code>用来记录等候理发的顾客数，init &#x3D; 0;</li><li>信号量<code>customers</code>用来记录等候理发的顾客数，并用作阻塞理发师进程，init &#x3D; 0;</li><li>信号量<code>barbers</code>用来记录正在等候顾客的理发师数，并用作阻塞进程，init &#x3D; 0（刚开始时理发师在睡觉，所以理发师这个资源数目为0）；</li><li>信号量<code>mutex</code>用作互斥，init &#x3D; 1;</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"><span class="type">int</span> waiting = <span class="number">0</span>;</span><br><span class="line">semaphore customers = <span class="number">0</span>;</span><br><span class="line">semaphore barbers = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">barber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        down(&amp;customers); <span class="comment">// 若无顾客，理发师睡眠</span></span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        waiting--;</span><br><span class="line">        up(&amp;barbers);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(waiting == <span class="number">0</span>) &#123; <span class="comment">// 没有人就睡眠</span></span><br><span class="line">            up(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting == N) &#123; <span class="comment">// 椅子坐满了人</span></span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waiting++; <span class="comment">// 等候的人+1</span></span><br><span class="line">        up(&amp;customers); <span class="comment">// 多一个顾客</span></span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        down(&amp;barbers); <span class="comment">// 如果没有理发师，顾客就在椅子上等着</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理发师问题和生产者消费者问题在于</p><ol><li>当等候理发的凳子被坐满时候，顾客离开，即资源不满足的情况下，进程结束；当缓冲区满的时候，生产者出现等待事件，等到资源满足时往下执行，即资源不满足的情况下，进程等待。</li><li>当资源用信号量表示，资源不满足的情况下进程等待，所以理发师问题中，椅子不因该用信号量表示而因该用变量表示，再加上一个互斥信号量。</li><li>生产者消费者可以更改公共资源如缓冲区empty当前值，无论资源是否满足；而理发师问题中对于公共的资源椅子，资源条件不满足时，顾客是不能更改waiting的值。</li></ol><h4 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h4><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h3 id="2-6-1-管道"><a href="#2-6-1-管道" class="headerlink" title="2.6.1 管道"></a>2.6.1 管道</h3><p>管道是通过调用<code>pipe</code>函数创建的，fd[0]用于读，fd[1]用于写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>它具有以下限制：</p><ul><li>它支支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"></p><h3 id="2-6-2-FIFO"><a href="#2-6-2-FIFO" class="headerlink" title="2.6.2 FIFO"></a>2.6.2 FIFO</h3><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifoat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。 <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"></p><h3 id="2-6-3-消息队列"><a href="#2-6-3-消息队列" class="headerlink" title="2.6.3 消息队列"></a>2.6.3 消息队列</h3><p>相比于FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难；</li><li>避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收。</li></ul><h3 id="2-6-4-信号量"><a href="#2-6-4-信号量" class="headerlink" title="2.6.4 信号量"></a>2.6.4 信号量</h3><p>它时一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h3 id="2-6-5-共享存储"><a href="#2-6-5-共享存储" class="headerlink" title="2.6.5 共享存储"></a>2.6.5 共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSI共享内存不是使用文件，而是使用内存的匿名段。</p><h3 id="2-6-6-套结字"><a href="#2-6-6-套结字" class="headerlink" title="2.6.6 套结字"></a>2.6.6 套结字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3 死锁"></a>3 死锁</h2><h4 id="3-1-必要条件"><a href="#3-1-必要条件" class="headerlink" title="3.1 必要条件"></a>3.1 必要条件</h4><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"></p><ul><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成的一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h4 id="3-2-处理方法"><a href="#3-2-处理方法" class="headerlink" title="3.2 处理方法"></a>3.2 处理方法</h4><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h4 id="3-3-鸵鸟策略"><a href="#3-3-鸵鸟策略" class="headerlink" title="3.3 鸵鸟策略"></a>3.3 鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux和Windows，处理死锁问题的办法仅仅是忽略它。</p><h4 id="3-4-死锁检测与死锁恢复"><a href="#3-4-死锁检测与死锁恢复" class="headerlink" title="3.4 死锁检测与死锁恢复"></a>3.4 死锁检测与死锁恢复</h4><p>不试图阻止死锁，而是当检测到思索发生时，采取措施进行恢复。</p><h3 id="3-4-1-每种类型一个资源的死锁检测"><a href="#3-4-1-每种类型一个资源的死锁检测" class="headerlink" title="3.4.1 每种类型一个资源的死锁检测"></a>3.4.1 每种类型一个资源的死锁检测</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><h3 id="3-4-2-每种类型多个资源的死锁检测"><a href="#3-4-2-每种类型多个资源的死锁检测" class="headerlink" title="3.4.2 每种类型多个资源的死锁检测"></a>3.4.2 每种类型多个资源的死锁检测</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程Pi，它所请求的资源小于等于A。</li><li>如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转回1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h3 id="3-4-3-死锁恢复"><a href="#3-4-3-死锁恢复" class="headerlink" title="3.4.3 死锁恢复"></a>3.4.3 死锁恢复</h3><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h4 id="3-5-死锁预防"><a href="#3-5-死锁预防" class="headerlink" title="3.5 死锁预防"></a>3.5 死锁预防</h4><p>再程序运行之前预防发生死锁。</p><h3 id="3-5-1-破坏互斥条件"><a href="#3-5-1-破坏互斥条件" class="headerlink" title="3.5.1 破坏互斥条件"></a>3.5.1 破坏互斥条件</h3><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><h3 id="3-5-2-破坏占有和等待条件"><a href="#3-5-2-破坏占有和等待条件" class="headerlink" title="3.5.2 破坏占有和等待条件"></a>3.5.2 破坏占有和等待条件</h3><p>一般实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><h3 id="3-5-3-破坏不可抢占条件"><a href="#3-5-3-破坏不可抢占条件" class="headerlink" title="3.5.3 破坏不可抢占条件"></a>3.5.3 破坏不可抢占条件</h3><h3 id="3-5-4-破坏环路等待条件"><a href="#3-5-4-破坏环路等待条件" class="headerlink" title="3.5.4 破坏环路等待条件"></a>3.5.4 破坏环路等待条件</h3><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h4 id="3-6-死锁避免"><a href="#3-6-死锁避免" class="headerlink" title="3.6 死锁避免"></a>3.6 死锁避免</h4><p>在程序运行时避免发生死锁。</p><h3 id="3-6-1-银行家算法"><a href="#3-6-1-银行家算法" class="headerlink" title="3.6.1 银行家算法"></a>3.6.1 银行家算法</h3><h4 id="3-6-1-1-数据结构"><a href="#3-6-1-1-数据结构" class="headerlink" title="3.6.1.1 数据结构"></a>3.6.1.1 数据结构</h4><ol><li><code>Available</code> ：可利用资源向量，代表系统中所配置的该类全部可用资源的数量</li><li><code>Max</code>： 最大需求矩阵，代表进程对资源的最大需求</li><li><code>Allocation</code>：定义系统中每一类资源已分配给每一进程的资源数</li><li><code>Need</code>：表示进程还需要的各类资源数， <code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></li></ol><h4 id="3-6-1-2-算法"><a href="#3-6-1-2-算法" class="headerlink" title="3.6.1.2 算法"></a>3.6.1.2 算法</h4><p>设<code>Request</code>是进程给Pi的请求向量，若<code>Request[j] = k</code>表示进程Pi需要k个j资源，当发出请求后，会进行以下检查：</p><ol><li><code>Request[j] &lt;= Need[j]</code>，请求合理，转向2，否则认为请求不合理</li><li><code>Request[j] &lt;= Available[j]</code>，请求合理，转向3，否则表示没有足够资源，进程需等待</li><li>尝试将资源分配给进程Pi：<ul><li><code>Available[j] = Available[j] - Request[j]</code></li><li><code>Allocation[j] = Allocation[j] + Request[j]</code></li><li><code>Need[j] = Need[j] - Request[j]</code></li></ul></li><li>运行安全性算法检查，检查资源分配后系统是否处于安全状态，安全，正式分配，否则恢复资源分配，进程继续等待</li></ol><h3 id="3-6-2-安全性算法"><a href="#3-6-2-安全性算法" class="headerlink" title="3.6.2 安全性算法"></a>3.6.2 安全性算法</h3><p>设置工作向量Work表示系统可提供给进程继续运行所需的给雷资源数目（<code>Work = Availalbe</code>），设置<code>Finish</code>，表示系统是否有足够的资源分配给进程 从进程集合中找到一个满足下列条件的进程：</p><ul><li><code>Finish[i] = False</code></li><li><code>Need[i, j] &lt;= Work[j]</code></li></ul><p>找到则分配资源： <code>Work[j] = Work[j] + Allocation[i, j]</code> <code>Finish[i] = True</code></p><p>重复寻找进程的步骤</p><p>如果所有进程<code>Finish[i] = True</code>，则系统处于安全状态，否则系统处于不安全状态</p><h3 id="3-6-3-什么是安全状态与不安全状态？安全状态和不安全状态和死锁之间的关系？"><a href="#3-6-3-什么是安全状态与不安全状态？安全状态和不安全状态和死锁之间的关系？" class="headerlink" title="3.6.3 什么是安全状态与不安全状态？安全状态和不安全状态和死锁之间的关系？"></a>3.6.3 什么是安全状态与不安全状态？安全状态和不安全状态和死锁之间的关系？</h3><ul><li>系统能按某种进程顺序，若{p1, p2, …, pn}为每个进程分配所需资源，直到最大需求，是每个进程都可顺利完成，这个进程序列即为安全序列，不存在安全序列，则称系统处于不安全状态</li><li>并非所有不安全状态都将导致死锁状态，但当系统进入不安全状态后，有可能进入死锁状态，只要系统处于安全状态，则可避免进入死锁状态</li><li>（安全性检查中使用的MAX，是进程执行前提供的，实际执行过程中，进程需要的最大资源量可能小于Max，例如：进程需要错误处理的代码需要n个资源，实际运行过程中没触发错误，就不会请求资源）</li></ul><h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4 内存管理"></a>4 内存管理</h2><h4 id="4-1-虚拟内存"><a href="#4-1-虚拟内存" class="headerlink" title="4.1 虚拟内存"></a>4.1 虚拟内存</h4><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0\~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"></p><h4 id="4-2-分页系统地址映射"><a href="#4-2-分页系统地址映射" class="headerlink" title="4.2 分页系统地址映射"></a>4.2 分页系统地址映射</h4><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/05/11/os/">https://blog.jujimeizuo.cn/2022/05/11/os/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的ACM脚印</title>
      <link href="/2021/12/05/myacm/"/>
      <url>/2021/12/05/myacm/</url>
      
        <content type="html"><![CDATA[<p>感谢<a href="https://hukeqing.github.io/2020/12/21/acm/myACM/" title="胡大佬">胡大佬</a>的模板参考。</p><span id="more"></span><p>2021年12月4日，南京区域赛结束，同时结束的，还有我的两年多的ACM生涯。 接下来的寒假重心会向着找实习的方向努力，当然明年的区域赛、final以及明年的省赛等等，我都会去认真准备。</p><h2 id="这篇文章会写什么"><a href="#这篇文章会写什么" class="headerlink" title="这篇文章会写什么"></a>这篇文章会写什么</h2><ul><li><p>关于我</p><ul><li>我的ACM历程</li><li>我的ACM成绩</li></ul></li><li><p>写给新人</p><ul><li>什么是ACM</li><li>ACM能带来什么</li><li>ACM和其他竞赛有什么不同</li><li>什么样的人适合ACM，什么样的人不适合ACM</li></ul></li><li><p>写给ACMer</p><ul><li>关于训练</li><li>关于赛中</li></ul></li><li><p>完结撒花</p></li></ul><p>这篇文章更多来自我自己对ACM的观点，如果和你理解不同，请见谅。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><h4 id="我的ACM历程"><a href="#我的ACM历程" class="headerlink" title="我的ACM历程"></a>我的ACM历程</h4><h3 id="进入大学之前"><a href="#进入大学之前" class="headerlink" title="进入大学之前"></a>进入大学之前</h3><p>在2019年进入大学之前，我只是一个普普通通的高考生，学的是理科（物化生），对竞赛一无所知，可能知道数学竞赛，物理竞赛，却不知道五大学科竞赛的信息学竞赛，也就是OI。</p><p>高考填志愿的时候，在我选择计算机专业的时候，连计算机的概念是什么，你要问我为什么填计算机专业？答案只是因为高薪工作，但高薪是有高薪的理由，想必进入计算机专业的同学深有体会。</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>大一上我上了王慧燕老师的C语言高级程序设计，那是我第一次接触程序。和每届新生该开始一样一窍不通，甚至连简单的输入输出都弄不明白，英语又不好，啥都看不懂，心想完了，我是不是真的不适合这个专业？</p><p>结果新生赛给了我一个“完美”答复，“牌王新生场爆零了。”很多人看我现在有一点点成绩，可却不知当时的我是什么样子的。爆零意味这什么？学院8，90%的同学都能过写上1题，而我却1题都写不来，我的室友一个一等，一个二等，还有一个和我一样，当时的我和第三位室友比赛结束后散步，“我是不是不适合学计算机”？“我真的不适合学计算机吗？”后来秉持着和高中一样的信念，“我不信我比别人差！”，更是萌生出参加ACM这样含金量极高的竞赛。</p><p>在那之后我更加努力，胡大佬也十分鼓励我，感谢胡大佬。</p><p>当时报了ACM寒假集训，因为只要撑过七天就能进集训队，人一天一天地变少，第七天只剩下3个人，我，还有我的一个队友，也是当时新生赛的冠军-站神。之后集训队要求组队，站神在知道我新生赛爆零的情况，毅然决然地邀请我组队，我也欣然接受。当时这个决定改变了我ACM的历程，如果没有和他组队的话，可能我们寝室三个人就一个队了。还有一个人是他们班班长（简单带过~</p><p>就这样，第一届粉红毛毛兔集结了。</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>大一暑假还没开始，班长大人就决定不打ACM了，现在只剩下两个人，找了当时大三的爽哥组成第二届粉红毛毛兔。</p><p>大二前的暑假开始了，（ACMer没有暑假）整个暑假经历了牛客多校和杭电多校两个自闭式训练，因为算法什么的都还没学，并且全国985、211学校基本都来了，所以我们多校成绩非常难看（不想回忆）。但是也很感谢多校的机会，让我成长了很多。</p><p>在之后的比赛，拿下了我第一块浙江省赛铜牌，ICPC区域赛济南站铜牌，ICPC西安邀请赛铜牌，还有好几块铁牌，并且很幸运地和彤哥一起参加了EC-final，也成功地打铁，其实每场都很有机会拿牌，我觉得原因出现在题刷的不够，参赛经验不够等等。</p><p>寒假的时候我和队友也成功地把codeforces账号刷到蓝名。大一选择了数学方向，大二更是学了图论、数据结构、dp等等（字符串gou都不学）。</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>大三刚开始，因为爽哥大四了，需要找实习工作，所以就退队了，还差一位队友，找了yyds的fjh，fjh当时的acm成绩可能没有很出众，但是我能看出来“他很强”，事实来看，确实很强，因为他总能在比赛中带来惊喜。</p><p>重组队伍之后，也把队名改成了锟斤拷之烫（Runtime Error），也不知道为啥取的这个名字，队名总是出乎意料地产生了。</p><p>我们比赛基本集中在大三上学期，因为队伍里有两个要找工作，一个要考研，所以比赛能先打完就打完。</p><p>大三上总共拿了CCPC广州站银牌，ICPC沈阳站、南京站铜牌这样的几个牌，没想到的是，CCPC成绩居然能破校史记录，感谢fjh能很快地1发过了C，这样我有更多的时间去解决第四题。可惜fjh被沈阳制裁了。</p><h4 id="我的ACM成绩"><a href="#我的ACM成绩" class="headerlink" title="我的ACM成绩"></a>我的ACM成绩</h4><p>到目前为止，总共拿下了1块CCPC区域赛银牌，3块ICPC区域赛铜牌，1块ICPC邀请赛铜牌，1块浙江省赛铜牌，还有数不清的铁，寒假的重心会放在实习方向，明年还有区域赛，省赛，CCfinal等等比赛，未来在有可能拿到offer的情况下继续参加ACM竞赛。</p><p>（感谢pku给了我们第一块铜和第一块银，所以我能进北大吗？？？）</p><h2 id="写给新人"><a href="#写给新人" class="headerlink" title="写给新人"></a>写给新人</h2><h4 id="什么是ACM"><a href="#什么是ACM" class="headerlink" title="什么是ACM"></a>什么是ACM</h4><p>来自百度百科，国际大学生程序设计竞赛（英文全称：International Collegiate Programming Contest（简称<a href="https://baike.baidu.com/item/ICPC/10243">ICPC</a>））是由国际计算机协会（<a href="https://baike.baidu.com/item/ACM/64774">ACM</a>）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近40年的发展，ACM国际大学生程序设计竞赛已经发展成为全球最具影响力的大学生程序设计竞赛，赛事由<a href="https://baike.baidu.com/item/AWS/16529930">AWS</a>、<a href="https://baike.baidu.com/item/%E5%8D%8E%E4%B8%BA/298705">华为</a>和<a href="https://baike.baidu.com/item/Jetbrains/7502758">Jetbrains</a> [5] 赞助，在北京大学设有ICPC北京总部，用于组织东亚区域赛 [6] 。</p><p>简称：三个人一台电脑，需要在5小时内解决10~13题。</p><h4 id="ACM能带来什么"><a href="#ACM能带来什么" class="headerlink" title="ACM能带来什么"></a>ACM能带来什么</h4><p>物质上来说，ACM能带来无寒暑假、无周末休闲时间、面对学业上的压力还要继续坚持下去。</p><p>精神上来说，我永远喜欢过题的快感、思维的巧妙、算法的智慧。</p><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>举个例子，不打ACM的人，没有几个人会快速幂。但是对于ACMer，下面是我们能接触，并且部分都会的算法。</p><p><img src="/images/2021/11/image-1638684503449.png" alt="file"></p><p>但这些只是我们应该会的，最基本的知识。这些知识带来的财富，我写一个项目的效率远超其他人，这就是差距。ACM的知识点，只要你未来是做计算机行业的，那么它一定会在每一个角落里发挥着它的作用。</p><h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>调试是写程序必不可少的步骤，有的人可能因为编译错误而烦恼，有的人可能因为各种bug而烦恼，而我们基本不需要debug，只需要简单测试证明即可。</p><h3 id="朋友圈"><a href="#朋友圈" class="headerlink" title="朋友圈"></a>朋友圈</h3><p>我是浙江工商大学的一名学生，通过ACM，在各种群聊中，因为兴趣相投，我能认识到很多大学的好友，比如广东工业大学、青岛大学等等，而且能经常和非常nb的人交流，什么是nb的人：可能是中国顶尖的人才（当然这些人基本都是清北浙大等等）、代表中国参加全球性竞赛的“神”。并且ACM在各大知名企业都非常有名，如果你拥有一块ACM铜牌，大厂简历没问题，如果拥有一块ACM银牌，进大厂的概率大大提升，如果拥有一块ACM金牌，全国500强没问题了，如果有用进world final的门票，世界500强随便挑。而对于正常学业而言，各位也应该知道你需要读多少年的书才有胆量往这些企业中投递一份简历。</p><h3 id="和清北复交同台竞技"><a href="#和清北复交同台竞技" class="headerlink" title="和清北复交同台竞技"></a>和清北复交同台竞技</h3><p>ACM竞赛是所有队伍在相同地点使用相同设备在相同的时间内解决相同的题目。</p><p>而你的对手则是来自全国的大学，对，北大清华每年都会来，而且非常重视。</p><p>ACM从来就没有院赛、校赛、省赛等等一大堆乱七八糟的东西，虽然他们确实存在但是他们并不是被官方承认的。ACM只有区域赛，（比如Asia-East东亚地区），区域总决赛（比如EC-finial，东亚地区总决赛），和世界总决赛（WF）。无论在哪个比赛，你都可能会遇到任何一个学校的队伍。所以在这样的比赛中，你可以很清楚的知道自己的水平在全地区范围内的位置，对自己的能力有一个更好的评估，能够看到外面更加广阔的天空。而不是拘泥于那么小的一个地区，争夺那么毫无意义的第一名。</p><h4 id="ACM和其他竞赛有什么不同"><a href="#ACM和其他竞赛有什么不同" class="headerlink" title="ACM和其他竞赛有什么不同"></a>ACM和其他竞赛有什么不同</h4><p>除了ACM以外，我也打过其他竞赛，比如数学竞赛，物理竞赛，数模等等。</p><p>ACM是比赛开始，中间5小时，结束之后奖项基本确定下来（根据排名），即时性非常高，并且没有任何主观的评定奖项。</p><p>而现如今的比如说互联网+，挑战杯、包括数模（可能会好点），在我看来基本都是ppt、论文大赛，获奖完全根据评委老师打分，非常的主观。</p><p>有人说，你有没参加过，你怎么知道这里面的含金量。</p><p>那就拿我自己来举例子：</p><p>首先ACM的含金量非常高，不断训练了两年只拿到过一块银牌。</p><p>而数学建模美赛，首先我没有任何基础，也没有参加任何培训，其次疫情原因，学校不让线下集训，所以一切在线上进行，线上老师要求写几场模拟赛，我们队伍由于各有各的事情，都没有参加，但是认真分析了几份优秀论文，最终情况是什么呢？整个学校没有队伍获得O奖，只有两支队伍获得F奖，我们就是其中一只队伍。我们有参加模拟赛吗？没有。我有基础吗？没有。但是我的两个队友是有基础的。但是我们为什么能拿到这样的奖项？因为最后交上去的只有一份论文而已。面对万份论文，老师真的会每份花很多时间观看吗，那必是不可能，所以有同学想要在数模比赛获奖，我想下面几点足够了：选比较客观的题目（这样结果就不重要了），指标越多越好、公式越多越好、图要越多越好（因为图片的视觉效果非常直观），论文的基本排版、格式等等。这样的一篇论文，甚至数据都可以伪造，我想一定能获奖。</p><h4 id="什么样的人适合ACM，什么样的人不适合ACM"><a href="#什么样的人适合ACM，什么样的人不适合ACM" class="headerlink" title="什么样的人适合ACM，什么样的人不适合ACM"></a>什么样的人适合ACM，什么样的人不适合ACM</h4><p>ACM竞赛是一个需要大量的时间去投入，但是到很久之后才会有结果的产出。简称高付出低回报。这和其他竞赛不同，数学建模通常你只需要很短的时间训练就能拿出成绩，而一个ACMer，在大三之前甚至可能都没有一点点成果。但是你在大一大二的投入终将会给你在大二下至大三上的时候带来丰富的回报。</p><p>这样的回报，需要愿意投资的人耐心投资才有可能赚得盆满钵满，一旦出现懈怠都有可能颗粒无收。<strong>耐心、专注、勤奋、自觉</strong>这些是一个ACMer必须要具备的因素。</p><h2 id="写给ACMer"><a href="#写给ACMer" class="headerlink" title="写给ACMer"></a>写给ACMer</h2><h4 id="关于训练"><a href="#关于训练" class="headerlink" title="关于训练"></a>关于训练</h4><p>我们是一只稳铜队伍（毕竟在诸神之战中存活过），但是想要冲击银牌需要看场次，银牌题如果是我们熟悉的那还可以，但如果没见过的就gg。</p><p>首先是每个人负责的算法部分：</p><p>我主要负责数据结构、动态规划，会数据结构、树上问题，，了解图论、计算几何，死也不学字符串。</p><p>yl主要负责数据结构、图论，树上问题，会字符串，动态规划，死也不学字符串。</p><p>fjh主要负责图论、搜索、动态规划，模拟、会树上问题。</p><p>个人的训练计划：</p><p>大一大二上主要是学习算法，不要学习unless algorithm，大二下主要是刷题，刷各种题型，因为知识点就那么多，题目却很多，那就是套路问题了。</p><p>大三需要练的是手速、思维、补题和回忆算法，所以codeforces是必不可少的。</p><p>我很反对无效刷题，当我们刷完一道题，明白这道题的方方面面。我自己目前刷题量是1900，而我的一个队友刷题量连我的一半都没有，但是我承认他比我强太多，每次比赛都是他给思路然后carry全场，而我只是一个无情的代码机器。有的人刷题量非常高，成绩也没有特别高，面对一道见过的题目，能很快的写出来，但是遇到一道全新的题目，却没有任何办法。这也就像我们学习一样，不能死学习，要活学活用。</p><p>队伍的训练计划：</p><p>每周都会单独开一场往年区域赛训练，并且实验室周末组织一场往年区域赛，这样我们队伍会保持每周2场。</p><p>有时间都会开开cf的模拟赛等等。</p><h4 id="关于赛中"><a href="#关于赛中" class="headerlink" title="关于赛中"></a>关于赛中</h4><p>首先是看题，看到一道题目一定要先看数据范围，因为往往都能根据数据范围来算出时间复杂度，然后读完题之后大概就知道用什么算法去解决。</p><p>在前期，签到题一定要快，如果够强的话，铜牌题也应当如此，可以尝试三开，除了在最后冲刺阶段，请务必尝试多开，即使排名倒数，一道题大概40min~1h一定要解决，千万不能死在一道题上，这个错误我深有体会。</p><p>队伍里要有一个很强的代码能力的队友，要学会听懂队友说的思路，然后在短时间内完成解题。</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>ACM只是大学生的一门竞赛，虽然能在其中感受它的智慧，在以后的工作中也经常会接触到，但是他毕竟是一门竞赛，仅此而已，千万不要把它当作什么毕生追求，只要努力过，奋斗过，不管得到什么样的成绩，都要不后悔，因为竞赛的含义，有的人会成功，有的人会失败，不是所有人都能拿到自己想要的成绩，最终还是要回归自己的生活。</p><p>jujimeizuo@2021&#x2F;12&#x2F;5 14:10</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/12/05/myacm/">https://blog.jujimeizuo.cn/2021/12/05/myacm/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合redis的一个天坑</title>
      <link href="/2021/11/30/redisq/"/>
      <url>/2021/11/30/redisq/</url>
      
        <content type="html"><![CDATA[<p>若只配置下面的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则为出现：</p><p>Unsatisfied dependency expressed through field ‘redisTemplate‘；</p><p>这个不对，还必须加上 commons-pool2，修改以后是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/11/30/redisq/">https://blog.jujimeizuo.cn/2021/11/30/redisq/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM 对拍</title>
      <link href="/2021/11/30/acmduipai/"/>
      <url>/2021/11/30/acmduipai/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li>rand.cpp是随机化数据cpp</li><li>bl.cpp是暴力数据cpp</li><li>*.cpp是自己写的std</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ rand.cpp -o rand</span><br><span class="line">g++ bl.cpp -o bl</span><br><span class="line">g++ *.cpp -o std</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">g++ rand.cpp -o rand</span><br><span class="line">g++ std.cpp -o std</span><br><span class="line">g++ sol.cpp -o sol</span><br><span class="line"></span><br><span class="line">:ac</span><br><span class="line">    rand %random% &gt; <span class="keyword">in</span></span><br><span class="line">    sol &lt; <span class="keyword">in</span> &gt; out</span><br><span class="line">    std &lt; <span class="keyword">in</span> &gt; ok</span><br><span class="line">    <span class="built_in">fc</span> out ok</span><br><span class="line"><span class="keyword">if</span> not errorlevel 0 goto wa</span><br><span class="line"><span class="built_in">echo</span> ----------------OK</span><br><span class="line">goto ac</span><br><span class="line"></span><br><span class="line">:wa</span><br><span class="line"><span class="built_in">echo</span> ----------------WA------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/11/30/acmduipai/">https://blog.jujimeizuo.cn/2021/11/30/acmduipai/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适合ACM竞赛的vimrc和 MyVimConf</title>
      <link href="/2021/11/25/vimrc/"/>
      <url>/2021/11/25/vimrc/</url>
      
        <content type="html"><![CDATA[<h2 id="适合ACM竞赛的vimrc"><a href="#适合ACM竞赛的vimrc" class="headerlink" title="适合ACM竞赛的vimrc"></a>适合ACM竞赛的vimrc</h2><p>涵盖了自动缩进，自动补全花括号，输入文件重定向等</p><p>.vimrc 比较短，真正需要手打的只有 8 行，一般可以在 30 秒左右敲完</p><ul><li>F9 是运行程序（从控制台读取输入）</li><li>F5 是运行程序（将同目录下 in 文件的内容作为输入，效果等于 freopen(“in”, “r”, stdin))</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nu sts=4 ts=4 sw=4 cin</span><br><span class="line">map &lt;F5&gt; :call CR()&lt;CR&gt;</span><br><span class="line">func CR()</span><br><span class="line">    <span class="built_in">exec</span> <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="built_in">exec</span> <span class="string">&quot;!clear &amp;&amp; g++ % -std=c++11 -W -o a &amp;&amp; ./a &lt; in&quot;</span></span><br><span class="line">endfunc</span><br><span class="line">map &lt;F9&gt; :call CRr()&lt;CR&gt;</span><br><span class="line">func CRr()</span><br><span class="line">    <span class="built_in">exec</span> <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="built_in">exec</span> <span class="string">&quot;!clear &amp;&amp; g++ % -std=c++11 -W -o a &amp;&amp; ./a&quot;</span></span><br><span class="line">endfunc</span><br><span class="line">imap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;C-O&gt;O&lt;left&gt;&lt;right&gt;</span><br><span class="line">syn on</span><br></pre></td></tr></table></figure><p>在 Normal 模式下，输入 :20vsp in 可以快速分屏并打开 in 文件以进行编辑</p><h2 id="分屏技巧"><a href="#分屏技巧" class="headerlink" title="分屏技巧"></a>分屏技巧</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:sp ## 上下分屏</span><br><span class="line">:res y ## 设置当前分屏高度为y</span><br><span class="line">:vsp ## 左右分屏</span><br><span class="line">:vertical res x ## 设置当前分屏宽度为x</span><br><span class="line">Ctrl + w + hjkl ## 先按Ctrl + w，然后再按hjkl在分屏之间移动</span><br><span class="line">:e ## 刷新当前文件</span><br><span class="line">:e filename ## 在当前窗口打开名字为filename的文件</span><br></pre></td></tr></table></figure><h2 id="我自己的vimrc配置-MyVimConf"><a href="#我自己的vimrc配置-MyVimConf" class="headerlink" title="我自己的vimrc配置 MyVimConf"></a>我自己的vimrc配置 MyVimConf</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; Color</span></span><br><span class="line"><span class="string">set t_Co=256</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> background=dark</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Line Numbers</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> relativenumber</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Clipboard</span></span><br><span class="line"><span class="string">set clipboard=unnamed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Make backspace work</span><br><span class="line"><span class="built_in">set</span> backspace=2</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Maps space to colon, time saver</span></span><br><span class="line"><span class="string">nmap &lt;space&gt; :</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Indentation</span><br><span class="line"><span class="built_in">set</span> tabstop=2</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> shiftwidth=2</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="string">&quot; set ignorecase</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Allows <span class="keyword">for</span> mouse scrolling</span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Highlight Current Line</span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string">highlight NERDTreeFile ctermfg=14</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Highlight All Search Pattern</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf=<span class="string">&#x27;~/.vim/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g:ycm_confirm_extra_conf = 0</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">call plug##begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> YouCompleteme</span><br><span class="line">Plug <span class="string">&#x27;valloric/youcompleteme&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Color Schemes</span></span><br><span class="line"><span class="string">Plug &#x27;flazz/vim-colorschemes&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;joshdick/onedark.vim&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>Use 24-bit (true-color) mode <span class="keyword">in</span> Vim/Neovim when outside tmux.</span><br><span class="line"><span class="string">&quot;If you&#x27;re using tmux version 2.2 or later, you can remove the outermost <span class="variable">$TMUX</span> check and use tmux&#x27;s 24-bit color support</span></span><br><span class="line"><span class="string">&quot;</span>(see &lt; http://sunaku.github.io/tmux-24bit-color.html<span class="comment">##usage &gt; for more information.)</span></span><br><span class="line"><span class="keyword">if</span> (empty(<span class="variable">$TMUX</span>))</span><br><span class="line">  <span class="keyword">if</span> (has(<span class="string">&quot;nvim&quot;</span>))</span><br><span class="line">    <span class="string">&quot;For Neovim 0.1.3 and 0.1.4 &lt; https://github.com/neovim/neovim/pull/2198 &gt;</span></span><br><span class="line"><span class="string">    let <span class="variable">$NVIM_TUI_ENABLE_TRUE_COLOR</span>=1</span></span><br><span class="line"><span class="string">  endif</span></span><br><span class="line"><span class="string">  &quot;</span>For Neovim &gt; 0.1.5 and Vim &gt; patch 7.4.1799 &lt; https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 &gt;</span><br><span class="line">  <span class="string">&quot;Based on Vim patch 7.4.1770 (guicolors option) &lt; https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd &gt;</span></span><br><span class="line"><span class="string">  &quot;</span> &lt; https://github.com/neovim/neovim/wiki/Following-HEAD<span class="comment">##20160511 &gt;</span></span><br><span class="line">  <span class="keyword">if</span> (has(<span class="string">&quot;termguicolors&quot;</span>))</span><br><span class="line">    <span class="built_in">set</span> termguicolors</span><br><span class="line">  endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; NERDTree</span></span><br><span class="line"><span class="string">Plug &#x27;scrooloose/nerdtree&#x27;</span></span><br><span class="line"><span class="string">map &lt;silent&gt; &lt;C-e&gt; :NERDTree&lt;CR&gt;</span></span><br><span class="line"><span class="string">map &lt;silent&gt; &lt;C-w&gt; :NERDTreeFind&lt;CR&gt;</span></span><br><span class="line"><span class="string">nmap &lt;leader&gt;nt :NERDTreeFind&lt;CR&gt;</span></span><br><span class="line"><span class="string">let NERDTreeShowBookmarks=1</span></span><br><span class="line"><span class="string">let NERDTreeIgnore=[&#x27;\.py[cd]$&#x27;, &#x27;\~$&#x27;, &#x27;\.swo$&#x27;, &#x27;\.swp$&#x27;, &#x27;^\.git$&#x27;, &#x27;^\.hg$&#x27;, &#x27;^\.svn$&#x27;, &#x27;\.bzr$&#x27;]</span></span><br><span class="line"><span class="string">let NERDTreeChDirMode=0</span></span><br><span class="line"><span class="string">let NERDTreeQuitOnOpen=1</span></span><br><span class="line"><span class="string">let NERDTreeMouseMode=2</span></span><br><span class="line"><span class="string">let NERDTreeShowHidden=1</span></span><br><span class="line"><span class="string">let NERDTreeKeepTreeInNewTab=1</span></span><br><span class="line"><span class="string">let g:nerdtree_tabs_open_on_gui_startup=0</span></span><br><span class="line"><span class="string">&quot;</span> NERDTrees File highlighting</span><br><span class="line"><span class="keyword">function</span>! NERDTreeHighlightFile(extension, <span class="built_in">fg</span>, <span class="built_in">bg</span>, guifg, guibg)</span><br><span class="line"><span class="built_in">exec</span> <span class="string">&#x27;autocmd FileType nerdtree highlight &#x27;</span> . a:extension .<span class="string">&#x27; ctermbg=&#x27;</span>. a:<span class="built_in">bg</span> .<span class="string">&#x27; ctermfg=&#x27;</span>. a:<span class="built_in">fg</span> .<span class="string">&#x27; guibg=&#x27;</span>. a:guibg .<span class="string">&#x27; guifg=&#x27;</span>. a:guifg</span><br><span class="line"><span class="built_in">exec</span> <span class="string">&#x27;autocmd FileType nerdtree syn match &#x27;</span> . a:extension .<span class="string">&#x27; ##^\s\+.*&#x27;</span>. a:extension .<span class="string">&#x27;$##&#x27;</span></span><br><span class="line">endfunction</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;ini&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;md&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;##3366FF&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;yml&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;conf&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;styl&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;cyan&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;coffee&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;##ffa500&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;rb&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;##ffa500&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">au VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;Magenta&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;##ff00ff&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">autocmd VimEnter * call NERDTreeHighlightFile(<span class="string">&#x27;jade&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;##151515&#x27;</span>)</span><br><span class="line">highlight! <span class="built_in">link</span> NERDTreeFlags NERDTreeDir</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Airline</span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">let g:airline_left_sep = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_left_alt_sep = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_right_sep = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_right_alt_sep = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols = &#123;&#125;</span></span><br><span class="line"><span class="string">let g:airline_symbols.branch = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.readonly = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.linenr = &#x27;☰&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.maxlinenr = &#x27;&#x27;</span></span><br><span class="line"><span class="string">let g:airline_symbols.dirty=&#x27;⚡&#x27;</span></span><br><span class="line"><span class="string">let g:airline_theme = &#x27;onedark&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Code Formatter</span><br><span class="line"><span class="string">&quot; Plug &#x27;Chiel92/vim-autoformat&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> nnoremap &lt;Leader&gt;&lt;Leader&gt;a :Autoformat&lt;cr&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call plug##end()</span></span><br><span class="line"><span class="string">&quot;</span> Color</span><br><span class="line"><span class="built_in">set</span> t_Co=256</span><br><span class="line">syntax on</span><br><span class="line"><span class="string">&quot; set background=dark</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Line Numbers</span><br><span class="line"><span class="string">&quot; set relativenumber</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Clipboard</span><br><span class="line"><span class="built_in">set</span> clipboard=unnamed</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Make backspace work</span></span><br><span class="line"><span class="string">set backspace=2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Maps space to colon, time saver</span><br><span class="line">nmap &lt;space&gt; :</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Indentation</span></span><br><span class="line"><span class="string">set tabstop=2</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">set shiftwidth=2</span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> ignorecase</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Allows for mouse scrolling</span></span><br><span class="line"><span class="string">set mouse=a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Highlight Current Line</span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line">highlight NERDTreeFile ctermfg=14</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Highlight All Search Pattern</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let g:ycm_global_ycm_extra_conf=&#x27;~/.vim/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let g:ycm_confirm_extra_conf = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> the runtime path to include Vundle and initialize</span><br><span class="line">call plug<span class="comment">##begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; YouCompleteme</span></span><br><span class="line"><span class="string">Plug &#x27;valloric/youcompleteme&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Color Schemes</span><br><span class="line">Plug <span class="string">&#x27;flazz/vim-colorschemes&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;joshdick/onedark.vim&#x27;</span></span><br><span class="line"><span class="string">&quot;Use 24-bit (true-color) mode in Vim/Neovim when outside tmux.</span></span><br><span class="line"><span class="string">&quot;</span>If you<span class="string">&#x27;re using tmux version 2.2 or later, you can remove the outermost $TMUX check and use tmux&#x27;</span>s 24-bit color support</span><br><span class="line"><span class="string">&quot;(see &lt; http://sunaku.github.io/tmux-24bit-color.html##usage &gt; for more information.)</span></span><br><span class="line"><span class="string">if (empty(<span class="variable">$TMUX</span>))</span></span><br><span class="line"><span class="string">  if (has(&quot;</span>nvim<span class="string">&quot;))</span></span><br><span class="line"><span class="string">    &quot;</span>For Neovim 0.1.3 and 0.1.4 &lt; https://github.com/neovim/neovim/pull/2198 &gt;</span><br><span class="line">    <span class="built_in">let</span> <span class="variable">$NVIM_TUI_ENABLE_TRUE_COLOR</span>=1</span><br><span class="line">  endif</span><br><span class="line">  <span class="string">&quot;For Neovim &gt; 0.1.5 and Vim &gt; patch 7.4.1799 &lt; https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 &gt;</span></span><br><span class="line"><span class="string">  &quot;</span>Based on Vim patch 7.4.1770 (guicolors option) &lt; https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd &gt;</span><br><span class="line">  <span class="string">&quot; &lt; https://github.com/neovim/neovim/wiki/Following-HEAD##20160511 &gt;</span></span><br><span class="line"><span class="string">  if (has(&quot;</span>termguicolors<span class="string">&quot;))</span></span><br><span class="line"><span class="string">    set termguicolors</span></span><br><span class="line"><span class="string">  endif</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> NERDTree</span><br><span class="line">Plug <span class="string">&#x27;scrooloose/nerdtree&#x27;</span></span><br><span class="line">map &lt;silent&gt; &lt;C-e&gt; :NERDTree&lt;CR&gt;</span><br><span class="line">map &lt;silent&gt; &lt;C-w&gt; :NERDTreeFind&lt;CR&gt;</span><br><span class="line">nmap &lt;leader&gt;nt :NERDTreeFind&lt;CR&gt;</span><br><span class="line"><span class="built_in">let</span> NERDTreeShowBookmarks=1</span><br><span class="line"><span class="built_in">let</span> NERDTreeIgnore=[<span class="string">&#x27;\.py[cd]$&#x27;</span>, <span class="string">&#x27;\~$&#x27;</span>, <span class="string">&#x27;\.swo$&#x27;</span>, <span class="string">&#x27;\.swp$&#x27;</span>, <span class="string">&#x27;^\.git$&#x27;</span>, <span class="string">&#x27;^\.hg$&#x27;</span>, <span class="string">&#x27;^\.svn$&#x27;</span>, <span class="string">&#x27;\.bzr$&#x27;</span>]</span><br><span class="line"><span class="built_in">let</span> NERDTreeChDirMode=0</span><br><span class="line"><span class="built_in">let</span> NERDTreeQuitOnOpen=1</span><br><span class="line"><span class="built_in">let</span> NERDTreeMouseMode=2</span><br><span class="line"><span class="built_in">let</span> NERDTreeShowHidden=1</span><br><span class="line"><span class="built_in">let</span> NERDTreeKeepTreeInNewTab=1</span><br><span class="line"><span class="built_in">let</span> g:nerdtree_tabs_open_on_gui_startup=0</span><br><span class="line"><span class="string">&quot; NERDTrees File highlighting</span></span><br><span class="line"><span class="string">function! NERDTreeHighlightFile(extension, fg, bg, guifg, guibg)</span></span><br><span class="line"><span class="string">exec &#x27;autocmd FileType nerdtree highlight &#x27; . a:extension .&#x27; ctermbg=&#x27;. a:bg .&#x27; ctermfg=&#x27;. a:fg .&#x27; guibg=&#x27;. a:guibg .&#x27; guifg=&#x27;. a:guifg</span></span><br><span class="line"><span class="string">exec &#x27;autocmd FileType nerdtree syn match &#x27; . a:extension .&#x27; ##^\s\+.*&#x27;. a:extension .&#x27;<span class="variable">$#</span>#&#x27;</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;jade&#x27;, &#x27;green&#x27;, &#x27;none&#x27;, &#x27;green&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;ini&#x27;, &#x27;yellow&#x27;, &#x27;none&#x27;, &#x27;yellow&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;md&#x27;, &#x27;blue&#x27;, &#x27;none&#x27;, &#x27;##3366FF&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;yml&#x27;, &#x27;yellow&#x27;, &#x27;none&#x27;, &#x27;yellow&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;config&#x27;, &#x27;yellow&#x27;, &#x27;none&#x27;, &#x27;yellow&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;conf&#x27;, &#x27;yellow&#x27;, &#x27;none&#x27;, &#x27;yellow&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;json&#x27;, &#x27;yellow&#x27;, &#x27;none&#x27;, &#x27;yellow&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;html&#x27;, &#x27;yellow&#x27;, &#x27;none&#x27;, &#x27;yellow&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;styl&#x27;, &#x27;cyan&#x27;, &#x27;none&#x27;, &#x27;cyan&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;css&#x27;, &#x27;cyan&#x27;, &#x27;none&#x27;, &#x27;cyan&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;coffee&#x27;, &#x27;Red&#x27;, &#x27;none&#x27;, &#x27;red&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;js&#x27;, &#x27;Red&#x27;, &#x27;none&#x27;, &#x27;##ffa500&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;rb&#x27;, &#x27;Red&#x27;, &#x27;none&#x27;, &#x27;##ffa500&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">au VimEnter * call NERDTreeHighlightFile(&#x27;php&#x27;, &#x27;Magenta&#x27;, &#x27;none&#x27;, &#x27;##ff00ff&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">autocmd VimEnter * call NERDTreeHighlightFile(&#x27;jade&#x27;, &#x27;green&#x27;, &#x27;none&#x27;, &#x27;green&#x27;, &#x27;##151515&#x27;)</span></span><br><span class="line"><span class="string">highlight! link NERDTreeFlags NERDTreeDir</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Airline</span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"><span class="built_in">let</span> g:airline_left_sep = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_left_alt_sep = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_right_sep = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_right_alt_sep = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_symbols = &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> g:airline_symbols.branch = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_symbols.readonly = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_symbols.linenr = <span class="string">&#x27;☰&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_symbols.maxlinenr = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_symbols.dirty=<span class="string">&#x27;⚡&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:airline_theme = <span class="string">&#x27;onedark&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Code Formatter</span></span><br><span class="line"><span class="string">&quot;</span> Plug <span class="string">&#x27;Chiel92/vim-autoformat&#x27;</span></span><br><span class="line"><span class="string">&quot; nnoremap &lt;Leader&gt;&lt;Leader&gt;a :Autoformat&lt;cr&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> All of your Plugins must be added before the following line</span><br><span class="line">call plug<span class="comment">##end()</span></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/11/25/vimrc/">https://blog.jujimeizuo.cn/2021/11/25/vimrc/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-持久化机制</title>
      <link href="/2021/09/28/rediscjh/"/>
      <url>/2021/09/28/rediscjh/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于redis是内存数据库，所以其数据断电易失，因此需要将数据保存到磁盘中。redis有两种持久化解决方案，分别是：RDB，AOF。</p><h2 id="快照-Snapshot-RDB"><a href="#快照-Snapshot-RDB" class="headerlink" title="快照(Snapshot) &#x2F; RDB"></a>快照(Snapshot) &#x2F; RDB</h2><p>这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是redis的默认开启持久化方式,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 <strong>dump.rdb</strong>的二进制文件中。文件名可以在配置文件中进行自定义。</p><p><img src="/images/2021/09/image-1632802020120.png" alt="file"></p><h4 id="RDB持久化的大致过程"><a href="#RDB持久化的大致过程" class="headerlink" title="RDB持久化的大致过程"></a>RDB持久化的大致过程</h4><p>在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p><strong>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</strong></p><h3 id="bgsave："><a href="#bgsave：" class="headerlink" title="bgsave："></a>bgsave：</h3><p>客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。 <strong>bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ；</strong> <img src="/images/2021/09/image-1632802962900.png" alt="file"></p><h3 id="save："><a href="#save：" class="headerlink" title="save："></a>save：</h3><p>使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； <strong>由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。</strong> <img src="/images/2021/09/image-1632802954996.png" alt="file"></p><h3 id="shutdown："><a href="#shutdown：" class="headerlink" title="shutdown："></a>shutdown：</h3><p>当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p><strong>SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong></p><p>如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令</p><p><img src="/images/2021/09/image-1632802337308.png" alt="file"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</li><li>生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！</li><li>fork进程的时候，会占用一定的内容空间！！</li></ol><h4 id="RDB触发机制"><a href="#RDB触发机制" class="headerlink" title="RDB触发机制"></a>RDB触发机制</h4><ol><li>save的规则满足的情况下，会自动触发rdb规则</li><li>执行 flushall 命令，也会触发我们的rdb规则！</li><li>退出redis，也会产生 rdb 文件！</li></ol><h4 id="配置生成快照名称和位置"><a href="#配置生成快照名称和位置" class="headerlink" title="配置生成快照名称和位置"></a>配置生成快照名称和位置</h4><ol><li>修改生成快照名称 dbfilename dump.rdb</li><li>修改生成位置 dir .&#x2F;</li></ol><p><img src="/images/2021/09/image-1632802467233.png" alt="file"></p><h4 id="恢复rdb文件"><a href="#恢复rdb文件" class="headerlink" title="恢复rdb文件"></a>恢复rdb文件</h4><ol><li>只需要将rdb文件放在redis启动目录中，redis启动时自动检查dump.rdb恢复其中的数据。</li><li>查看其存在的位置</li></ol><p><img src="/images/2021/09/image-1632802829210.png" alt="file"> 如果&#x2F;var&#x2F;lib&#x2F;redis这个目录存在dump.rdb文件，则启动时自动恢复数据。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Append Only File</p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><h4 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h4><p>快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p><img src="/images/2021/09/image-1632815754859.png" alt="file"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.</p><h4 id="开启AOF持久化"><a href="#开启AOF持久化" class="headerlink" title="开启AOF持久化"></a>开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p><p><img src="/images/2021/09/image-1632815844362.png" alt="file"></p><p>appendonly no yes则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具redis-check-aof –fix</p><h4 id="日志追加频率"><a href="#日志追加频率" class="headerlink" title="日志追加频率"></a>日志追加频率</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改日志同步频率</span><br><span class="line">- 修改appendfsync everysecalwaysno 指定</span><br></pre></td></tr></table></figure><p><img src="/images/2021/09/image-1632815884193.png" alt="file"></p><h4 id="AOF文件的重写"><a href="#AOF文件的重写" class="headerlink" title="AOF文件的重写"></a>AOF文件的重写</h4><h3 id="AOF带来的问题"><a href="#AOF带来的问题" class="headerlink" title="AOF带来的问题"></a>AOF带来的问题</h3><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。</p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>用来在一定程度上减小AOF文件的体积</p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.客户端方式触发重写</span></span><br><span class="line">- 执行BGREWRITEAOF命令  不会阻塞redis的服务</span><br><span class="line"><span class="comment">## 2.服务器配置方式自动触发</span></span><br><span class="line">- 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓</span><br><span class="line">- 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大</span><br></pre></td></tr></table></figure><p><img src="/images/2021/09/image-1632816040606.png" alt="file"></p><h3 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h3><p><strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 重写流程</span></span><br><span class="line">- 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令</span><br><span class="line">- 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。</span><br><span class="line">- 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。</span><br><span class="line">- 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</span><br></pre></td></tr></table></figure><p><img src="/images/2021/09/image-1632816192423.png" alt="file"></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>没秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h2 id="如何选择哪种持久化方式"><a href="#如何选择哪种持久化方式" class="headerlink" title="如何选择哪种持久化方式"></a>如何选择哪种持久化方式</h2><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/09/28/rediscjh/">https://blog.jujimeizuo.cn/2021/09/28/rediscjh/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-事务</title>
      <link href="/2021/09/26/redisshiwu/"/>
      <url>/2021/09/26/redisshiwu/</url>
      
        <content type="html"><![CDATA[<h2 id="redis的事务操作"><a href="#redis的事务操作" class="headerlink" title="redis的事务操作"></a>redis的事务操作</h2><span id="more"></span><p><strong>redis的单条命令保证原子性，但是redis的事务不保证原子性</strong></p><p>redis的事务没有隔离级别。redis事务实际上就是一组命令的集合，这些命令在事务中会被序列化，然后按照命令的先后顺序一次性全部执行，在执行的过程中不能被打断。 即：redis的事务在执行时是一次性，顺序性和排他性的</p><h3 id="开启事务：multi"><a href="#开启事务：multi" class="headerlink" title="开启事务：multi"></a>开启事务：multi</h3><h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队:"></a>命令入队:</h3><h3 id="执行事务-exec"><a href="#执行事务-exec" class="headerlink" title="执行事务:exec"></a>执行事务:exec</h3><p><img src="/images/2021/09/image-1632644879581.png" alt="file"></p><h3 id="放弃事务：discard"><a href="#放弃事务：discard" class="headerlink" title="放弃事务：discard"></a>放弃事务：discard</h3><p><img src="/images/2021/09/image-1632644930162.png" alt="file"></p><h4 id="事务异常"><a href="#事务异常" class="headerlink" title="事务异常"></a>事务异常</h4><p><strong>在开启事务后，如果编写的命令有语法错误，则会立即报错，且整个事务队列中的所有命令都不会执行.</strong></p><p><img src="/images/2021/09/image-1632645058718.png" alt="file"></p><p><strong>如果在开启事务后，命令中没有语法错误，但是却有运行错误，即命令能够成功入队，但是不能够执行，则在事务提交后只有该命令抛错，其他命令可以正常执行。</strong></p><p><img src="/images/2021/09/image-1632645139695.png" alt="file"></p><h4 id="redis的乐观锁"><a href="#redis的乐观锁" class="headerlink" title="redis的乐观锁"></a>redis的乐观锁</h4><ul><li>乐观锁：就是它会认为所有的事务都不会失败，因此它不会给事务上锁。它只会在更新的时候判断在此期间是否有人修改过数据</li><li>悲观锁：它认为所有的事务都会执行失败，因此做任何事情它都会加锁，这样是及其影响效率的。</li></ul><h3 id="redis的乐观锁实现命令：watch"><a href="#redis的乐观锁实现命令：watch" class="headerlink" title="redis的乐观锁实现命令：watch"></a>redis的乐观锁实现命令：watch</h3><h4 id="单线程下运行："><a href="#单线程下运行：" class="headerlink" title="单线程下运行："></a>单线程下运行：</h4><p><img src="/images/2021/09/image-1632645356164.png" alt="file"></p><h4 id="多线程修改值"><a href="#多线程修改值" class="headerlink" title="多线程修改值:"></a>多线程修改值:</h4><p><img src="/images/2021/09/image-1632645487019.png" alt="file"></p><p><img src="/images/2021/09/image-1632645565809.png" alt="file"></p><p><img src="/images/2021/09/image-1632645644690.png" alt="file"></p><h4 id="如果事务执行失败，需要先解锁，再加锁，解锁命令为：unwatch"><a href="#如果事务执行失败，需要先解锁，再加锁，解锁命令为：unwatch" class="headerlink" title="如果事务执行失败，需要先解锁，再加锁，解锁命令为：unwatch"></a>如果事务执行失败，需要先解锁，再加锁，解锁命令为：unwatch</h4><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/09/26/redisshiwu/">https://blog.jujimeizuo.cn/2021/09/26/redisshiwu/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rediss-数据类型</title>
      <link href="/2021/09/24/redisleixing/"/>
      <url>/2021/09/24/redisleixing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-NoSQL"><a href="#1-NoSQL" class="headerlink" title="1. NoSQL"></a>1. NoSQL</h2><span id="more"></span><p>NoSQL(Not Only SQL )，意即不仅仅是SQL, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。</p><h4 id="1-1-单机Mysql时代"><a href="#1-1-单机Mysql时代" class="headerlink" title="1.1 单机Mysql时代"></a>1.1 单机Mysql时代</h4><p><img src="/images/2021/09/image-1632646360378.png" alt="file"></p><h4 id="1-2-Memcached-缓存-Mysql-垂直拆分（读写分离）"><a href="#1-2-Memcached-缓存-Mysql-垂直拆分（读写分离）" class="headerlink" title="1.2 Memcached(缓存) + Mysql + 垂直拆分（读写分离）"></a>1.2 Memcached(缓存) + Mysql + 垂直拆分（读写分离）</h4><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！ <img src="/images/2021/09/image-1632646410269.png" alt="file"></p><h4 id="1-3-分库分表-水平拆分-Mysql集群"><a href="#1-3-分库分表-水平拆分-Mysql集群" class="headerlink" title="1.3 分库分表 + 水平拆分 + Mysql集群"></a>1.3 分库分表 + 水平拆分 + Mysql集群</h4><p><img src="/images/2021/09/image-1632646422141.png" alt="file"></p><h4 id="1-4-如今最近的年代"><a href="#1-4-如今最近的年代" class="headerlink" title="1.4 如今最近的年代"></a>1.4 如今最近的年代</h4><p><img src="/images/2021/09/image-1632646442039.png" alt="file"></p><h2 id="2-为什么是NoSQL"><a href="#2-为什么是NoSQL" class="headerlink" title="2. 为什么是NoSQL"></a>2. 为什么是NoSQL</h2><p><strong>NoSQL &#x3D; Not Only SQL（不仅仅是SQL）</strong></p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><p>随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如商城网站中对<strong>商品数据频繁查询</strong>、<strong>对热搜商品的排行统计</strong>、<strong>订单超时问题</strong>、以及<strong>微信朋友圈（音频，视频）存储</strong>等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。</p><p><strong>了解：3V + 3高</strong></p><p>大数据时代的3V ：主要是描述问题的</p><ol><li>海量Velume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高 ： 主要是对程序的要求</p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><h2 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3. NoSQL的四大分类"></a>3. NoSQL的四大分类</h2><h4 id="3-1-键值-Key-Value-存储数据库"><a href="#3-1-键值-Key-Value-存储数据库" class="headerlink" title="3.1 键值(Key-Value)存储数据库"></a>3.1 键值(Key-Value)存储数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.说明: </span></span><br><span class="line">- 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。</span><br><span class="line"><span class="comment">## 2.特点</span></span><br><span class="line">- Key/value模型对于IT系统来说的优势在于简单、易部署。  </span><br><span class="line">- 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。</span><br><span class="line"><span class="comment">## 3.相关产品</span></span><br><span class="line">- Tokyo Cabinet/Tyrant,</span><br><span class="line">- Redis</span><br><span class="line">- SSDB</span><br><span class="line">- Voldemort </span><br><span class="line">- Oracle BDB</span><br></pre></td></tr></table></figure><h4 id="3-2-列存储数据库"><a href="#3-2-列存储数据库" class="headerlink" title="3.2 列存储数据库"></a>3.2 列存储数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.说明</span></span><br><span class="line">- 这部分数据库通常是用来应对分布式存储的海量数据。</span><br><span class="line"><span class="comment">## 2.特点</span></span><br><span class="line">- 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。</span><br><span class="line"><span class="comment">## 3.相关产品</span></span><br><span class="line">- Cassandra、HBase、Riak.</span><br></pre></td></tr></table></figure><h4 id="3-3-文档型数据库"><a href="#3-3-文档型数据库" class="headerlink" title="3.3 文档型数据库"></a>3.3 文档型数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.说明</span></span><br><span class="line">- 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高</span><br><span class="line"><span class="comment">## 2.特点</span></span><br><span class="line">- 以文档形式存储</span><br><span class="line"><span class="comment">## 3.相关产品</span></span><br><span class="line">- MongoDB、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。  </span><br></pre></td></tr></table></figure><h4 id="3-4-图形-Graph-数据库"><a href="#3-4-图形-Graph-数据库" class="headerlink" title="3.4 图形(Graph)数据库"></a>3.4 图形(Graph)数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1.说明</span></span><br><span class="line">- 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。</span><br><span class="line">- NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。</span><br><span class="line"><span class="comment">## 2.特点</span></span><br><span class="line"><span class="comment">## 3.相关产品</span></span><br><span class="line">- Neo4J、InfoGrid、 Infinite Graph、</span><br></pre></td></tr></table></figure><h2 id="4-NoSQL应用场景"><a href="#4-NoSQL应用场景" class="headerlink" title="4. NoSQL应用场景"></a>4. NoSQL应用场景</h2><ul><li>数据模型比较简单</li><li>需要灵活性更强的IT系统</li><li>对数据库性能要求较高</li><li>不需要高度的数据一致性</li></ul><h2 id="5-什么是Redis"><a href="#5-什么是Redis" class="headerlink" title="5. 什么是Redis"></a>5. 什么是Redis</h2><p><img src="/images/2021/09/image-1632473946054.png" alt="file"></p><p>Redis 开源 遵循BSD 基于内存数据存储 被用于作为 数据库 缓存 消息中间件 <strong>redis是一个内存型的数据库</strong></p><h2 id="6-Redis特点"><a href="#6-Redis特点" class="headerlink" title="6. Redis特点"></a>6. Redis特点</h2><ul><li>Redis是一个高性能key&#x2F;value内存型数据库</li><li>Redis支持丰富的数据类型</li><li>Redis支持持久化</li><li>Redis单线程,单进程</li></ul><p><strong>单线程不一定比多线程慢，在CPU中，多线程需要跳转，而单线程不需要，减少了跳转的消耗，所以在某些场景里单线程可能比多线程快。</strong></p><h2 id="7-Ridis安装"><a href="#7-Ridis安装" class="headerlink" title="7. Ridis安装"></a>7. Ridis安装</h2><p>略</p><h2 id="8-redis常用命令"><a href="#8-redis常用命令" class="headerlink" title="8. redis常用命令"></a>8. redis常用命令</h2><h4 id="8-1-set-get命令，存值，取值"><a href="#8-1-set-get命令，存值，取值" class="headerlink" title="8.1 set get命令，存值，取值"></a>8.1 set get命令，存值，取值</h4><p><img src="/images/2021/09/image-1632474345917.png" alt="file"></p><h4 id="8-2-切换数据库，redis默认有16个数据库，默认使用0号数据库，可以通过select切换"><a href="#8-2-切换数据库，redis默认有16个数据库，默认使用0号数据库，可以通过select切换" class="headerlink" title="8.2 切换数据库，redis默认有16个数据库，默认使用0号数据库，可以通过select切换"></a>8.2 切换数据库，redis默认有16个数据库，默认使用0号数据库，可以通过select切换</h4><p><img src="/images/2021/09/image-1632474418121.png" alt="file"></p><p><img src="/images/2021/09/image-1632474452155.png" alt="file"></p><h4 id="8-3-清空当前数据库：flushdb-清空所有数据库：flushall"><a href="#8-3-清空当前数据库：flushdb-清空所有数据库：flushall" class="headerlink" title="8.3 清空当前数据库：flushdb,清空所有数据库：flushall"></a>8.3 清空当前数据库：flushdb,清空所有数据库：flushall</h4><p><img src="/images/2021/09/image-1632474513302.png" alt="file"></p><h4 id="8-4-查询所有key-keys"><a href="#8-4-查询所有key-keys" class="headerlink" title="8.4 查询所有key: keys*"></a>8.4 查询所有key: keys*</h4><p><img src="/images/2021/09/image-1632474553482.png" alt="file"></p><h4 id="8-5-查询数据库的大小：dbsize"><a href="#8-5-查询数据库的大小：dbsize" class="headerlink" title="8.5 查询数据库的大小：dbsize"></a>8.5 查询数据库的大小：dbsize</h4><p><img src="/images/2021/09/image-1632474583601.png" alt="file"></p><h4 id="8-6-查看key是否存在：exists-keyName-存在返回1，否则返回0"><a href="#8-6-查看key是否存在：exists-keyName-存在返回1，否则返回0" class="headerlink" title="8.6 查看key是否存在：exists keyName,存在返回1，否则返回0"></a>8.6 查看key是否存在：exists keyName,存在返回1，否则返回0</h4><p><img src="/images/2021/09/image-1632474622298.png" alt="file"></p><h4 id="8-7-移除Key-move-keyName-1"><a href="#8-7-移除Key-move-keyName-1" class="headerlink" title="8.7 移除Key: move keyName 1"></a>8.7 移除Key: move keyName 1</h4><p><img src="/images/2021/09/image-1632474665561.png" alt="file"></p><h4 id="8-8-为key设置过期时间-expire-keyName-timeout"><a href="#8-8-为key设置过期时间-expire-keyName-timeout" class="headerlink" title="8.8 为key设置过期时间: expire keyName timeout"></a>8.8 为key设置过期时间: expire keyName timeout</h4><p><img src="/images/2021/09/image-1632474717857.png" alt="file"></p><h4 id="8-9-查看key的剩余存活时间：ttl-keyName"><a href="#8-9-查看key的剩余存活时间：ttl-keyName" class="headerlink" title="8.9 查看key的剩余存活时间：ttl keyName"></a>8.9 查看key的剩余存活时间：ttl keyName</h4><p><img src="/images/2021/09/image-1632474728589.png" alt="file"></p><h4 id="8-10-查看key的类型：type-keyName"><a href="#8-10-查看key的类型：type-keyName" class="headerlink" title="8.10 查看key的类型：type keyName"></a>8.10 查看key的类型：type keyName</h4><p><img src="/images/2021/09/image-1632474775307.png" alt="file"></p><h2 id="9-String详解"><a href="#9-String详解" class="headerlink" title="9. String详解"></a>9. String详解</h2><p><img src="/images/2021/09/image-1632643699298.png" alt="file"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">命令                         说明                      </span><br><span class="line">-------------------------  ----------------------- </span><br><span class="line"><span class="built_in">set</span>                        设置一个key/value           </span><br><span class="line">get                        根据key获得对应的value         </span><br><span class="line">mset                       一次设置多个key value         </span><br><span class="line">mget                       一次获得多个key的value         </span><br><span class="line">getset                     获得原始key的值，同时设置新值        </span><br><span class="line">strlen                     获得对应key存储value的长度       </span><br><span class="line">append                     为对应key的value追加内容        </span><br><span class="line">getrange 索引0开始             截取value的内容              </span><br><span class="line">setex                      设置一个key存活的有效期（秒）        </span><br><span class="line">psetex                     设置一个key存活的有效期（毫秒）       </span><br><span class="line">setnx                      存在不做任何操作,不存在添加          </span><br><span class="line">msetnx原子操作(只要有一个存在不做任何操作)  可以同时设置多个key,只有有一个存在都不保存 </span><br><span class="line">decr                       进行数值类型的-1操作             </span><br><span class="line">decrby                     根据提供的数据进行减法操作           </span><br><span class="line">Incr                       进行数值类型的+1操作             </span><br><span class="line">incrby                     根据提供的数据进行加法操作           </span><br><span class="line">Incrbyfloat                根据提供的数据加入浮点数            </span><br></pre></td></tr></table></figure><h4 id="9-1-strlen-求value的长度，append：追加"><a href="#9-1-strlen-求value的长度，append：追加" class="headerlink" title="9.1 strlen:求value的长度，append：追加"></a>9.1 strlen:求value的长度，append：追加</h4><p><img src="/images/2021/09/image-1632475047844.png" alt="file"></p><h4 id="9-2-自增-自减操作：incr-incrby-decr-decrby"><a href="#9-2-自增-自减操作：incr-incrby-decr-decrby" class="headerlink" title="9.2 自增,自减操作：incr incrby decr decrby"></a>9.2 自增,自减操作：incr incrby decr decrby</h4><p><img src="/images/2021/09/image-1632475096207.png" alt="file"></p><h4 id="9-3-字符串的范围操作：getrange-setrange"><a href="#9-3-字符串的范围操作：getrange-setrange" class="headerlink" title="9.3 字符串的范围操作：getrange,setrange"></a>9.3 字符串的范围操作：getrange,setrange</h4><p><img src="/images/2021/09/image-1632475184254.png" alt="file"></p><h4 id="9-4-设置过期时间：setex（如果存在Key则覆盖，不存在则创建），setnx-如果不存在就设置"><a href="#9-4-设置过期时间：setex（如果存在Key则覆盖，不存在则创建），setnx-如果不存在就设置" class="headerlink" title="9.4 设置过期时间：setex（如果存在Key则覆盖，不存在则创建），setnx(如果不存在就设置)"></a>9.4 设置过期时间：setex（如果存在Key则覆盖，不存在则创建），setnx(如果不存在就设置)</h4><p><img src="/images/2021/09/image-1632475254467.png" alt="file"></p><h4 id="9-5-批量设置和获取值：mset-mget-msetnx-操作为原子性，要么都成功，要么都失败"><a href="#9-5-批量设置和获取值：mset-mget-msetnx-操作为原子性，要么都成功，要么都失败" class="headerlink" title="9.5 批量设置和获取值：mset,mget, msetnx(操作为原子性，要么都成功，要么都失败)"></a>9.5 批量设置和获取值：mset,mget, msetnx(操作为原子性，要么都成功，要么都失败)</h4><p><img src="/images/2021/09/image-1632475380084.png" alt="file"></p><h4 id="9-6-存取对象"><a href="#9-6-存取对象" class="headerlink" title="9.6 存取对象"></a>9.6 存取对象</h4><p><img src="/images/2021/09/image-1632475484205.png" alt="file"></p><h4 id="9-7-组合操作：getset先获取再设置-如果不存在就返回nil"><a href="#9-7-组合操作：getset先获取再设置-如果不存在就返回nil" class="headerlink" title="9.7 组合操作：getset先获取再设置,如果不存在就返回nil"></a>9.7 组合操作：getset先获取再设置,如果不存在就返回nil</h4><p><img src="/images/2021/09/image-1632475553716.png" alt="file"></p><blockquote><p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储</li></ul></blockquote><h2 id="10-list详解"><a href="#10-list详解" class="headerlink" title="10. list详解"></a>10. list详解</h2><p>list的命令都是l开头,list 列表 相当于java中list 集合 特点 元素有序 且 可以重复</p><p><img src="/images/2021/09/image-1632643911652.png" alt="file"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">命令       说明                    </span><br><span class="line">-------  --------------------- </span><br><span class="line">lpush    将某个值加入到一个key列表头部      </span><br><span class="line">lpushx   同lpush,但是必须要保证这个key存在 </span><br><span class="line">rpush    将某个值加入到一个key列表末尾      </span><br><span class="line">rpushx   同rpush,但是必须要保证这个key存在 </span><br><span class="line">lpop     返回和移除列表左边的第一个元素       </span><br><span class="line">rpop     返回和移除列表右边的第一个元素       </span><br><span class="line">lrange   获取某一个下标区间内的元素         </span><br><span class="line">llen     获取列表元素个数              </span><br><span class="line">lset     设置某一个指定索引的值(索引必须存在)   </span><br><span class="line">lindex   获取某一个指定索引位置的元素        </span><br><span class="line">lrem     删除重复元素                </span><br><span class="line">ltrim    保留列表中特定区间内的元素         </span><br><span class="line">linsert  在某一个元素之前，之后插入新元素      </span><br></pre></td></tr></table></figure><h4 id="10-1-左插：lpush-左删：lpop"><a href="#10-1-左插：lpush-左删：lpop" class="headerlink" title="10.1 左插：lpush,左删：lpop"></a>10.1 左插：lpush,左删：lpop</h4><p><img src="/images/2021/09/image-1632475948773.png" alt="file"></p><h4 id="10-2-右插：rpush-右删：rpop"><a href="#10-2-右插：rpush-右删：rpop" class="headerlink" title="10.2 右插：rpush,右删：rpop"></a>10.2 右插：rpush,右删：rpop</h4><p><img src="/images/2021/09/image-1632476072915.png" alt="file"></p><h4 id="10-3-获取列表元素：lrange"><a href="#10-3-获取列表元素：lrange" class="headerlink" title="10.3 获取列表元素：lrange"></a>10.3 获取列表元素：lrange</h4><p><img src="/images/2021/09/image-1632476697115.png" alt="file"></p><h4 id="10-4-通过下标获取元素：lindex"><a href="#10-4-通过下标获取元素：lindex" class="headerlink" title="10.4 通过下标获取元素：lindex"></a>10.4 通过下标获取元素：lindex</h4><p><img src="/images/2021/09/image-1632476474867.png" alt="file"></p><h4 id="10-5-获取列表长度：llen"><a href="#10-5-获取列表长度：llen" class="headerlink" title="10.5 获取列表长度：llen"></a>10.5 获取列表长度：llen</h4><p><img src="/images/2021/09/image-1632476522194.png" alt="file"></p><h4 id="10-6-移除具体的值所在的键值对-lrem-列表-移除几个-移除的具体value"><a href="#10-6-移除具体的值所在的键值对-lrem-列表-移除几个-移除的具体value" class="headerlink" title="10.6 移除具体的值所在的键值对:lrem 列表 移除几个 移除的具体value"></a>10.6 移除具体的值所在的键值对:lrem 列表 移除几个 移除的具体value</h4><p><img src="/images/2021/09/image-1632476605108.png" alt="file"></p><h4 id="10-7-截取操作：ltrim-列表-截取的开始下标-截取的结束下标"><a href="#10-7-截取操作：ltrim-列表-截取的开始下标-截取的结束下标" class="headerlink" title="10.7 截取操作：ltrim 列表 截取的开始下标 截取的结束下标"></a>10.7 截取操作：ltrim 列表 截取的开始下标 截取的结束下标</h4><p><img src="/images/2021/09/image-1632476724171.png" alt="file"></p><h4 id="10-8-rpoplpush-移除列表中的最后一个元素并将这个元素放到一个新的列表中"><a href="#10-8-rpoplpush-移除列表中的最后一个元素并将这个元素放到一个新的列表中" class="headerlink" title="10.8 rpoplpush:移除列表中的最后一个元素并将这个元素放到一个新的列表中"></a>10.8 rpoplpush:移除列表中的最后一个元素并将这个元素放到一个新的列表中</h4><p><img src="/images/2021/09/image-1632476771483.png" alt="file"></p><h4 id="10-9-判断列表是否存在：EXISTS-list"><a href="#10-9-判断列表是否存在：EXISTS-list" class="headerlink" title="10.9 判断列表是否存在：EXISTS list"></a>10.9 判断列表是否存在：EXISTS list</h4><p><img src="/images/2021/09/image-1632476803379.png" alt="file"></p><h4 id="10-10-lset-更新列表中指定下标的元素的value-前提是该下标必须有值，否则报错"><a href="#10-10-lset-更新列表中指定下标的元素的value-前提是该下标必须有值，否则报错" class="headerlink" title="10.10 lset:更新列表中指定下标的元素的value,前提是该下标必须有值，否则报错"></a>10.10 lset:更新列表中指定下标的元素的value,前提是该下标必须有值，否则报错</h4><p><img src="/images/2021/09/image-1632476840575.png" alt="file"></p><h4 id="10-11-在列表中插入值：前插和后插：linsert"><a href="#10-11-在列表中插入值：前插和后插：linsert" class="headerlink" title="10.11 在列表中插入值：前插和后插：linsert"></a>10.11 在列表中插入值：前插和后插：linsert</h4><p><img src="/images/2021/09/image-1632476896464.png" alt="file"></p><h2 id="11-set详解"><a href="#11-set详解" class="headerlink" title="11. set详解"></a>11. set详解</h2><p>set是无序不重复集合，set命令都是s开头 <img src="/images/2021/09/image-1632643954408.png" alt="file"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">命令           说明                        </span><br><span class="line">-----------  ------------------------- </span><br><span class="line">sadd         为集合添加元素                   </span><br><span class="line">smembers     显示集合中所有元素 无序              </span><br><span class="line">scard        返回集合中元素的个数                </span><br><span class="line">spop         随机返回一个元素 并将元素在集合中删除       </span><br><span class="line">smove        从一个集合中向另一个集合移动元素 必须是同一种类型 </span><br><span class="line">srem         从集合中删除一个元素                </span><br><span class="line">sismember    判断一个集合中是否含有这个元素           </span><br><span class="line">srandmember  随机返回元素                    </span><br><span class="line">sdiff        去掉第一个集合中其它集合含有的相同元素       </span><br><span class="line">sinter       求交集                       </span><br><span class="line">sunion       求和集                       </span><br></pre></td></tr></table></figure><h4 id="11-1-添加：sadd"><a href="#11-1-添加：sadd" class="headerlink" title="11.1 添加：sadd"></a>11.1 添加：sadd</h4><p><img src="/images/2021/09/image-1632477064797.png" alt="file"></p><h4 id="11-2-查看所有-smembers"><a href="#11-2-查看所有-smembers" class="headerlink" title="11.2 查看所有: smembers"></a>11.2 查看所有: smembers</h4><p><img src="/images/2021/09/image-1632477127825.png" alt="file"></p><h4 id="11-3-查询set的元素个数：scard"><a href="#11-3-查询set的元素个数：scard" class="headerlink" title="11.3 查询set的元素个数：scard"></a>11.3 查询set的元素个数：scard</h4><p><img src="/images/2021/09/image-1632477143763.png" alt="file"></p><h4 id="11-4-判断set中是否存在某元素：sismember"><a href="#11-4-判断set中是否存在某元素：sismember" class="headerlink" title="11.4 判断set中是否存在某元素：sismember"></a>11.4 判断set中是否存在某元素：sismember</h4><p><img src="/images/2021/09/image-1632477172245.png" alt="file"></p><h4 id="11-5-移除某个元素：srem"><a href="#11-5-移除某个元素：srem" class="headerlink" title="11.5 移除某个元素：srem"></a>11.5 移除某个元素：srem</h4><p><img src="/images/2021/09/image-1632477185068.png" alt="file"></p><h4 id="11-6-随机抽取一个元素：SRANDMEMBER"><a href="#11-6-随机抽取一个元素：SRANDMEMBER" class="headerlink" title="11.6 随机抽取一个元素：SRANDMEMBER"></a>11.6 随机抽取一个元素：SRANDMEMBER</h4><p><img src="/images/2021/09/image-1632477211405.png" alt="file"></p><h4 id="11-7-随机移除一个元素：spop"><a href="#11-7-随机移除一个元素：spop" class="headerlink" title="11.7 随机移除一个元素：spop"></a>11.7 随机移除一个元素：spop</h4><p><img src="/images/2021/09/image-1632477222068.png" alt="file"></p><h4 id="11-8-将一个集合中的元素移动到另一个集合中：smove"><a href="#11-8-将一个集合中的元素移动到另一个集合中：smove" class="headerlink" title="11.8 将一个集合中的元素移动到另一个集合中：smove"></a>11.8 将一个集合中的元素移动到另一个集合中：smove</h4><p><img src="/images/2021/09/image-1632477296157.png" alt="file"></p><h4 id="11-9-集合之间求交并补集：sinter-sunite-sdiff"><a href="#11-9-集合之间求交并补集：sinter-sunite-sdiff" class="headerlink" title="11.9 集合之间求交并补集：sinter sunite sdiff"></a>11.9 集合之间求交并补集：sinter sunite sdiff</h4><p><img src="/images/2021/09/image-1632477331468.png" alt="file"></p><h3 id="差集sdiff"><a href="#差集sdiff" class="headerlink" title="差集sdiff"></a>差集sdiff</h3><p><img src="/images/2021/09/image-1632477435541.png" alt="file"></p><h3 id="交集sinter"><a href="#交集sinter" class="headerlink" title="交集sinter"></a>交集sinter</h3><p><img src="/images/2021/09/image-1632477391019.png" alt="file"></p><h3 id="并集sunion"><a href="#并集sunion" class="headerlink" title="并集sunion"></a>并集sunion</h3><p><img src="/images/2021/09/image-1632477447668.png" alt="file"></p><h2 id="12-hash详解"><a href="#12-hash详解" class="headerlink" title="12. hash详解"></a>12. hash详解</h2><p>hash的形式：key filed vlaue,相当于java中的map集合 hash命令都是h开头</p><p><img src="/images/2021/09/image-1632643989267.png" alt="file"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">命令            说明              </span><br><span class="line">------------  --------------- </span><br><span class="line">hset          设置一个key/value对  </span><br><span class="line">hget          获得一个key对应的value </span><br><span class="line">hgetall       获得所有的key/value对 </span><br><span class="line">hdel          删除某一个key/value对 </span><br><span class="line">hexists       判断一个key是否存在     </span><br><span class="line">hkeys         获得所有的key        </span><br><span class="line">hvals         获得所有的value      </span><br><span class="line">hmset         设置多个key/value   </span><br><span class="line">hmget         获得多个key的value   </span><br><span class="line">hsetnx        设置一个不存在的key的值   </span><br><span class="line">hincrby       为value进行加法运算    </span><br><span class="line">hincrbyfloat  为value加入浮点值     </span><br></pre></td></tr></table></figure><h4 id="12-1-向hash中添加值：hset"><a href="#12-1-向hash中添加值：hset" class="headerlink" title="12.1 向hash中添加值：hset"></a>12.1 向hash中添加值：hset</h4><p><img src="/images/2021/09/image-1632477692339.png" alt="file"></p><h4 id="12-2-得到hash中的指定filed的值：hget"><a href="#12-2-得到hash中的指定filed的值：hget" class="headerlink" title="12.2 得到hash中的指定filed的值：hget"></a>12.2 得到hash中的指定filed的值：hget</h4><p><img src="/images/2021/09/image-1632477703371.png" alt="file"></p><h4 id="12-3-得到hash中的所有值-hgetall"><a href="#12-3-得到hash中的所有值-hgetall" class="headerlink" title="12.3 得到hash中的所有值:hgetall"></a>12.3 得到hash中的所有值:hgetall</h4><p><img src="/images/2021/09/image-1632477745829.png" alt="file"></p><h4 id="12-4-批量添加和获取：hmset-hmget"><a href="#12-4-批量添加和获取：hmset-hmget" class="headerlink" title="12.4 批量添加和获取：hmset hmget"></a>12.4 批量添加和获取：hmset hmget</h4><p><img src="/images/2021/09/image-1632477816044.png" alt="file"></p><h4 id="12-5-删除指定的字段：hdel"><a href="#12-5-删除指定的字段：hdel" class="headerlink" title="12.5 删除指定的字段：hdel"></a>12.5 删除指定的字段：hdel</h4><p><img src="/images/2021/09/image-1632477844890.png" alt="file"></p><h4 id="12-6-获取hash的字段长度：hlen"><a href="#12-6-获取hash的字段长度：hlen" class="headerlink" title="12.6 获取hash的字段长度：hlen"></a>12.6 获取hash的字段长度：hlen</h4><p><img src="/images/2021/09/image-1632477866011.png" alt="file"></p><h4 id="12-7-判断hash中的字段是否存在：hexist"><a href="#12-7-判断hash中的字段是否存在：hexist" class="headerlink" title="12.7 判断hash中的字段是否存在：hexist"></a>12.7 判断hash中的字段是否存在：hexist</h4><p><img src="/images/2021/09/image-1632477881187.png" alt="file"></p><h4 id="12-8-获取所有的key-字段-hkeys-获取所有的value：hvals"><a href="#12-8-获取所有的key-字段-hkeys-获取所有的value：hvals" class="headerlink" title="12.8 获取所有的key(字段)hkeys,获取所有的value：hvals"></a>12.8 获取所有的key(字段)hkeys,获取所有的value：hvals</h4><p><img src="/images/2021/09/image-1632477896459.png" alt="file"></p><h4 id="12-9-指定增量：hincrby"><a href="#12-9-指定增量：hincrby" class="headerlink" title="12.9 指定增量：hincrby"></a>12.9 指定增量：hincrby</h4><p><img src="/images/2021/09/image-1632477919981.png" alt="file"></p><p><strong>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的存储，String更加适合字符串存储！</strong></p><h2 id="13-Zset详解"><a href="#13-Zset详解" class="headerlink" title="13. Zset详解"></a>13. Zset详解</h2><p>zset是有序不可重复的集合,zset命令都是z开头 <img src="/images/2021/09/image-1632644102803.png" alt="file"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">命令                      说明             </span><br><span class="line">----------------------  -------------- </span><br><span class="line">zadd                    添加一个有序集合元素     </span><br><span class="line">zcard                   返回集合的元素个数      </span><br><span class="line">zrange 升序 zrevrange 降序  返回一个范围内的元素     </span><br><span class="line">zrangebyscore           按照分数查找一个范围内的元素 </span><br><span class="line">zrank                   返回排名           </span><br><span class="line">zrevrank                倒序排名           </span><br><span class="line">zscore                  显示某一个元素的分数     </span><br><span class="line">zrem                    移除某一个元素        </span><br><span class="line">zincrby                 给某个特定元素加分      </span><br></pre></td></tr></table></figure><h4 id="13-1-添加数据：zadd"><a href="#13-1-添加数据：zadd" class="headerlink" title="13.1 添加数据：zadd"></a>13.1 添加数据：zadd</h4><p><img src="/images/2021/09/image-1632478034715.png" alt="file"></p><h4 id="13-2-获取所有值-按照索引获取：zrange"><a href="#13-2-获取所有值-按照索引获取：zrange" class="headerlink" title="13.2 获取所有值,按照索引获取：zrange"></a>13.2 获取所有值,按照索引获取：zrange</h4><p><img src="/images/2021/09/image-1632478071159.png" alt="file"></p><h4 id="13-3-获取所有值，按照score获取：zrangebyscore"><a href="#13-3-获取所有值，按照score获取：zrangebyscore" class="headerlink" title="13.3 获取所有值，按照score获取：zrangebyscore"></a>13.3 获取所有值，按照score获取：zrangebyscore</h4><p><img src="/images/2021/09/image-1632478107108.png" alt="file"></p><h4 id="13-4-移除元素：zrem"><a href="#13-4-移除元素：zrem" class="headerlink" title="13.4 移除元素：zrem"></a>13.4 移除元素：zrem</h4><p><img src="/images/2021/09/image-1632478230841.png" alt="file"></p><h4 id="13-5-得到元素的个数-zcard"><a href="#13-5-得到元素的个数-zcard" class="headerlink" title="13.5 得到元素的个数:zcard"></a>13.5 得到元素的个数:zcard</h4><p><img src="/images/2021/09/image-1632478172600.png" alt="file"></p><h4 id="13-6-获取指定区间的成员数量：zcount"><a href="#13-6-获取指定区间的成员数量：zcount" class="headerlink" title="13.6 获取指定区间的成员数量：zcount"></a>13.6 获取指定区间的成员数量：zcount</h4><p><img src="/images/2021/09/image-1632478326343.png" alt="file"></p><p><strong>ZSET 官方 可排序SET sortSet</strong></p><h2 id="14-geospatial"><a href="#14-geospatial" class="headerlink" title="14. geospatial"></a>14. geospatial</h2><h2 id="15-bitmaps"><a href="#15-bitmaps" class="headerlink" title="15. bitmaps"></a>15. bitmaps</h2><p><strong>bitmap即位存储，适用于只有两面性的内容。如：可以用bitmap存储用户是否登录，是否注册，是否打卡等等。bitmap的值只有0和1两个值。</strong></p><h4 id="15-1-存储数据：setbit"><a href="#15-1-存储数据：setbit" class="headerlink" title="15.1 存储数据：setbit"></a>15.1 存储数据：setbit</h4><p><img src="/images/2021/09/image-1632644429996.png" alt="file"></p><h4 id="15-2-获取指定下标的值：getbit"><a href="#15-2-获取指定下标的值：getbit" class="headerlink" title="15.2 获取指定下标的值：getbit"></a>15.2 获取指定下标的值：getbit</h4><p><img src="/images/2021/09/image-1632644452415.png" alt="file"></p><h4 id="15-3-统计bitmap中1的位数：bitcount"><a href="#15-3-统计bitmap中1的位数：bitcount" class="headerlink" title="15.3 统计bitmap中1的位数：bitcount"></a>15.3 统计bitmap中1的位数：bitcount</h4><p><img src="/images/2021/09/image-1632644484448.png" alt="file"></p><h2 id="16-hyperloglogs"><a href="#16-hyperloglogs" class="headerlink" title="16. hyperloglogs"></a>16. hyperloglogs</h2><p><strong>用于统计基数（即不重复的数据）,可以用于统计网页访问量</strong></p><h4 id="16-1-添加：pfadd"><a href="#16-1-添加：pfadd" class="headerlink" title="16.1 添加：pfadd"></a>16.1 添加：pfadd</h4><p><img src="/images/2021/09/image-1632644672064.png" alt="file"></p><h4 id="16-2-计数：pfcount"><a href="#16-2-计数：pfcount" class="headerlink" title="16.2 计数：pfcount"></a>16.2 计数：pfcount</h4><p><img src="/images/2021/09/image-1632644689711.png" alt="file"></p><h4 id="16-3-合并：pfmerge"><a href="#16-3-合并：pfmerge" class="headerlink" title="16.3 合并：pfmerge"></a>16.3 合并：pfmerge</h4><p><img src="/images/2021/09/image-1632644719576.png" alt="file"></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/09/24/redisleixing/">https://blog.jujimeizuo.cn/2021/09/24/redisleixing/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker精髓（容器数据卷、Dockerfile、Docker网络）</title>
      <link href="/2021/09/15/dockerimp/"/>
      <url>/2021/09/15/dockerimp/</url>
      
        <content type="html"><![CDATA[<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h4 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h4><h3 id="docker理念"><a href="#docker理念" class="headerlink" title="docker理念"></a>docker理念</h3><ul><li>将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够持久化的！</li><li>就好比，你安装一个MySQL，结果你把容器删了，就相当于删库跑路了，这TM也太扯了吧！</li><li>所以我们希望容器之间有可能可以共享数据，Docker容器产生的数据，如果不通过docker commit 生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行不通的！</li><li>为了能保存数据在Docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除 而丢失了！</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。 特点：</p><ol><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止 总结： 就是容器的持久化，以及容器间的继承和数据共享！</li></ol><h4 id="使用数据卷方式：容器中直接使用命令来添加"><a href="#使用数据卷方式：容器中直接使用命令来添加" class="headerlink" title="使用数据卷方式：容器中直接使用命令来添加"></a>使用数据卷方式：容器中直接使用命令来添加</h4><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><ol><li>命令</li><li>docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名</li><li>测试</li><li>docker run -it -v &#x2F;home&#x2F;ceshi:&#x2F;home centos &#x2F;bin&#x2F;bash ##ceshi文件夹会自己生成不需要特意去创建</li></ol><p>此时：容器内部的文件&#x2F;home，和虚拟机上&#x2F;home&#x2F;ceshi就已经相关联了，我们可以测试一下。 在虚拟机的&#x2F;home&#x2F;ceshi创建一个LH.txt，看容器内部的&#x2F;home中是否会生成这个文件</p><h3 id="测试一：查看对应路径下的文件"><a href="#测试一：查看对应路径下的文件" class="headerlink" title="测试一：查看对应路径下的文件"></a>测试一：查看对应路径下的文件</h3><ol><li>在虚拟机上</li><li>[root@slaves2 ~]## cd &#x2F;home&#x2F;ceshi&#x2F;</li><li>[root@slaves2 ceshi]## ll</li><li>总用量 0</li><li>[root@slaves2 ceshi]## touch LH.txt</li><li>查看容器内部</li><li>[root@64760dd67074 &#x2F;]## cd &#x2F;home&#x2F;</li><li>[root@64760dd67074 home]## ls</li><li>LH.txt</li></ol><h3 id="测试二：查看数据卷是否挂载成功-docker-inspect-容器id"><a href="#测试二：查看数据卷是否挂载成功-docker-inspect-容器id" class="headerlink" title="测试二：查看数据卷是否挂载成功 docker inspect 容器id"></a>测试二：查看数据卷是否挂载成功 docker inspect 容器id</h3><ol><li>查看运行的容器</li><li>docker ps</li><li>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</li><li>15132a4bcd1f centos “&#x2F;bin&#x2F;bash” About an hour ago Up About an hour brave_wilson</li><li>查看容器的详细信息</li><li>docker inspect 151</li></ol><p><img src="/images/2021/09/image-1631709001004.png" alt="file"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>容器停止运行后，数据也是一样能够同步过去的。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>你可以先将容器停止</li><li>修改虚拟机上的挂载目录</li><li>使用docker ps -a查看刚停止的容器</li><li>启动容器docker start 容器id</li><li>进入容器docker exec -it 容器id &#x2F;bin&#x2F;bash（或者docker attach 容器ID）</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用容器数据卷的好处，以后我们修改文件就直接可以在虚拟机上操作了，不需要进入容器内部了。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/09/15/dockerimp/">https://blog.jujimeizuo.cn/2021/09/15/dockerimp/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/2021/09/14/dockerml/"/>
      <url>/2021/09/14/dockerml/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><ol><li>docker version ## 显示Docker版本信息</li><li>docker info ## 显示Docker系统信息，包括镜像数、容器数、正在运行的镜像数、暂停的镜像数、停止的镜像数等</li><li>docker –help ## 显示docker指令的信息</li><li>docker 指令 –help ## 显示具体某一个docker指令的可选项docker 指令 –help ## 显示具体某一个docker指令的可选项</li></ol><p><img src="/images/2021/09/image-1631619962208.png" alt="file"></p><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><ol><li>docker images ## 显示你本地主机上（买的服务器或安装的Linux虚拟机）所有下载的镜像信息</li></ol><p><img src="/images/2021/09/image-1631620096012.png" alt="file"></p><p>执行该指令之后，信息显示如上图所示，对每个标签的解释如下：</p><ol><li>REPOSITORY ## 镜像的仓库源（也就是镜像名）</li><li>TAG ## 镜像的标签（也就是镜像的版本，如果不指定，则默认为lastest，也就是最新版）</li><li>IMAGE ID ## 镜像的ID（同一个镜像的不同版本，拥有不同的镜像ID）</li><li>CREATED ## 镜像的创建时间</li><li>SIZE ## 镜像的大小</li></ol><p>通过<strong>docker images –help</strong>可以看到该指令的一些可选项，现对几个常用的可选项做一解释：</p><p><img src="/images/2021/09/image-1631620195894.png" alt="file"></p><ol><li>-a ## 列出本地所有镜像</li><li>-q ## 只列出镜像的ID</li><li>--digests ## 显示镜像的摘要信息</li></ol><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><ol><li>docker search 某个镜像的名称 ## 搜索镜像，例如：docker search mysql</li></ol><p><img src="/images/2021/09/image-1631620344810.png" alt="file"></p><ol><li>NAME ## 镜像名</li><li>DESCRIPTION ## 镜像描述</li><li>STARS ## 收藏数（类似于GitHub上的STARS，STARS越多，表示越受欢迎，下载次数越多）</li></ol><p>如果我们只想搜索STARS不小于5000的镜像呢？我们可以采用一些过滤条件。</p><p>通过<strong>docker search –help</strong>指令来查看一些可选参数。从图中可以看出，我们可以采用<strong>-f或–filter filter</strong>指令来进行过滤。</p><p><img src="/images/2021/09/image-1631620452939.png" alt="file"></p><ol><li>以下四种方式均可</li><li>docker search –filter&#x3D;stars&#x3D;5000 mysql</li><li>docker search –filter stars&#x3D;5000 mysql</li><li>docker search -f&#x3D;stars&#x3D;5000 mysql</li><li>docker search -f stars&#x3D;5000 mysql</li></ol><p><img src="/images/2021/09/image-1631620406980.png" alt="file"></p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><ol><li>docker pull mysql ## 下载镜像（这里如果不指定TAG，默认就是lastest最新版）</li></ol><p><img src="/images/2021/09/image-1631620581235.png" alt="file"></p><ol><li>docker pull mysql:5.7 需要注意的是，这个镜像的版本一定得是DockerHub上有的版本。不然会下载</li></ol><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>首先使用<strong>docker rmi –help</strong>来看一下这个命令都有哪些可选项。如下图所示：</p><p><img src="/images/2021/09/image-1631620595815.png" alt="file"></p><p>可以看到有<strong>-f</strong>参数</p><ol><li>删除镜像</li><li>docker rmi -f 镜像id ## 删除单个镜像</li><li>docker rmi -f 镜像名:tag 镜像名:tag ## 删除多个</li><li>docker rmi -f $(docker images -qa) ## 删除全部</li></ol><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><p>有镜像才能创建容器，我们这里使用centos的镜像来测试，就是虚拟一个centos</p><h3 id="新建容器并启动（docker-run）"><a href="#新建容器并启动（docker-run）" class="headerlink" title="新建容器并启动（docker run）"></a>新建容器并启动（docker run）</h3><p><strong>docker run</strong>命令就是<strong>docker create</strong>和<strong>docker start</strong>命令的组合</p><ol><li><p>docker run [OPTIONS] 镜像名 [COMMAND][ARGS…]</p></li><li><h2 id="常用可选参数以及解释"><a href="#常用可选参数以及解释" class="headerlink" title="常用可选参数以及解释"></a>常用可选参数以及解释</h2></li><li><p>--name ## 给容器取一个名字</p></li><li><p>--rm ## 容器退出后，自动删除容器</p></li><li><p>-i ## 以交互模式运行容器，通常与-t同时使用，即-it</p></li><li><p>-t ## 分配一个虚拟的终端，在docker中启动bash就会有提示符，通常与-i通知使用，即-it</p></li><li><p>-d ## 在后台运行容器。等同于进入容器后按Ctrl+P+Q。所以可以docker attach回去。在后台运行的容器，只能通过网络和它交互。</p></li><li><p>-p ## 设置端口转发。-p:hostport:containerport</p></li></ol><p>测试如下：</p><p>使用centos进行交互模式启动容器，在容器内执行&#x2F;bin&#x2F;bash命令 <img src="/images/2021/09/image-1631620876616.png" alt="file"></p><p>由上图可以看出，地址已经变成容器内部了。</p><h3 id="列出所有运行的容器（docker-ps）"><a href="#列出所有运行的容器（docker-ps）" class="headerlink" title="列出所有运行的容器（docker ps）"></a>列出所有运行的容器（docker ps）</h3><ol><li>docker ps [OPTIONS]</li></ol><p>我们首先使用<strong>docker ps –help</strong>指令来看一下都有哪些可选参数：</p><p><img src="/images/2021/09/image-1631620901664.png" alt="file"></p><ol><li>-a ## 列出所有正在运行的容器 + 历史运行过的容器</li><li>-l ## 列出最近创建的一个容器以及该容器的信息</li><li>-n int ## 列出最近n个创建的容器以及容器的信息</li><li>-q ## 列出容器的编号</li><li>-s ## 列出容器的大小</li></ol><h3 id="容器退出（exit、Ctrl-P-Q）"><a href="#容器退出（exit、Ctrl-P-Q）" class="headerlink" title="容器退出（exit、Ctrl+P+Q）"></a>容器退出（exit、Ctrl+P+Q）</h3><ol><li>exit ## 容器停止并退出</li><li>Ctrl + P + Q ## 容器不停止退出，也就是进入后台模式，等同于docker run的参数 -d</li></ol><h3 id="删除容器（docker-rm）"><a href="#删除容器（docker-rm）" class="headerlink" title="删除容器（docker rm）"></a>删除容器（docker rm）</h3><ol><li>docker rm 容器id ## 删除指定容器</li><li>docker rm -f $(docker ps -aq) ## 删除所有容器（常用）</li><li>docker ps -aq xargs docker -rm ## 删除所有容器（不常用）</li></ol><h4 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h4><h3 id="后台启动容器-d"><a href="#后台启动容器-d" class="headerlink" title="后台启动容器 (-d)"></a>后台启动容器 (-d)</h3><ol><li>docker run -d 容器名 ## 后台启动容器</li><li>问题: 使用docker ps 查看，发现容器已经退出了！</li><li>解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命令，就会自动退出。</li><li>比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。</li></ol><h3 id="查看日志（docker-logs）"><a href="#查看日志（docker-logs）" class="headerlink" title="查看日志（docker logs）"></a>查看日志（docker logs）</h3><ol><li>docker logs 容器id</li></ol><p><strong>docker logs</strong>有以下可选参数：</p><p><img src="/images/2021/09/image-1631621011902.png" alt="file"></p><ol><li>-t ## 显示时间戳</li><li>-f ## 打印最新的日志</li><li>--tail 数字 ## 数字—显示多少条</li></ol><h3 id="查看容器中运行的进程信息（docker-top）"><a href="#查看容器中运行的进程信息（docker-top）" class="headerlink" title="查看容器中运行的进程信息（docker top）"></a>查看容器中运行的进程信息（docker top）</h3><ol><li>docker top 容器id</li></ol><p><img src="/images/2021/09/image-1631621090534.png" alt="file"></p><h3 id="查看容器-镜像的元数据（docker-inspect）"><a href="#查看容器-镜像的元数据（docker-inspect）" class="headerlink" title="查看容器 &#x2F; 镜像的元数据（docker inspect）"></a>查看容器 &#x2F; 镜像的元数据（docker inspect）</h3><ol><li>docker inspect 容器id</li></ol><p><img src="/images/2021/09/image-1631621146517.png" alt="file"></p><h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h4><p>这个命令是用已经运行的容器执行命令。需要注意的是，如果容器关闭后再次运行，那么用exec命令执行的命令是不会自己再次执行的</p><ol><li>docker exec 容器id</li></ol><p><img src="/images/2021/09/image-1631621187935.png" alt="file"></p><ol><li>-d ## 让命令在后台执行</li><li>-e ## 设置环境变量</li><li>-it ## 使用交互模式进入</li><li>-u -w ## 分别设置命令运行的用户和work directory。也就是如果要改变用户或者工作目录，就是用-u或-w</li></ol><h4 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h4><p>attach命令把一个后台运行的容器搞到前台来，这样就可以看到他们的输出，并且使用输入了。</p><ol><li>docker attach 容器id</li></ol><p>attach命令的可选参数如下： <img src="/images/2021/09/image-1631621235356.png" alt="file"></p><ol><li>--no-stdin ## 关闭输入</li><li>--sig-proxy ## 信号转发，默认开启，这样DMD进程就可以收到你的信号了</li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>exec</strong>是在容器中打开新的终端，并且可以启动新的进程</p><p><strong>attach</strong>是直接进入容器启动命令的终端，不会启动新的进程</p><h3 id="从容器内拷贝文件到主机上（docker-cp）"><a href="#从容器内拷贝文件到主机上（docker-cp）" class="headerlink" title="从容器内拷贝文件到主机上（docker cp）"></a>从容器内拷贝文件到主机上（docker cp）</h3><ol><li><p>docker cp 容器id:容器内路径 目的主机路径</p></li><li><p>例如：</p></li><li><p>docker cp f261f17bb39d:&#x2F;home&#x2F;f1 &#x2F;home</p></li></ol><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/09/14/dockerml/">https://blog.jujimeizuo.cn/2021/09/14/dockerml/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven常用依赖</title>
      <link href="/2021/09/13/maven/"/>
      <url>/2021/09/13/maven/</url>
      
        <content type="html"><![CDATA[<h4 id="maven-下载包和依赖的网站：https-mvnrepository-com-测试："><a href="#maven-下载包和依赖的网站：https-mvnrepository-com-测试：" class="headerlink" title="maven 下载包和依赖的网站：https://mvnrepository.com/测试："></a>maven 下载包和依赖的网站：<a href="https://mvnrepository.com/%E6%B5%8B%E8%AF%95">https://mvnrepository.com/测试</a>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.11</span>&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="日志："><a href="#日志：" class="headerlink" title="日志："></a>日志：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.7</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.1</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.1</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="数据库相关："><a href="#数据库相关：" class="headerlink" title="数据库相关："></a>数据库相关：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">5.1</span><span class="number">.35</span>&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;runtime&lt;/scope&gt;&lt;!--生命周期--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">0.9</span><span class="number">.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="dao框架依赖，mybatis依赖-："><a href="#dao框架依赖，mybatis依赖-：" class="headerlink" title="dao框架依赖，mybatis依赖 ："></a>dao框架依赖，mybatis依赖 ：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="mybatis与spring整合："><a href="#mybatis与spring整合：" class="headerlink" title="mybatis与spring整合："></a>mybatis与spring整合：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="标签库依赖："><a href="#标签库依赖：" class="headerlink" title="标签库依赖："></a>标签库依赖：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">2.5</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="spring相关依赖："><a href="#spring相关依赖：" class="headerlink" title="spring相关依赖："></a>spring相关依赖：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 核心依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring Dao依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Spring Web依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="Spring-test依赖"><a href="#Spring-test依赖" class="headerlink" title="Spring test依赖"></a>Spring test依赖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">4.1</span><span class="number">.7</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="maven-打jar包插件："><a href="#maven-打jar包插件：" class="headerlink" title="maven 打jar包插件："></a>maven 打jar包插件：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;source&gt;<span class="number">1.7</span>&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;<span class="number">1.7</span>&lt;/target&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h4 id="springboot依赖："><a href="#springboot依赖：" class="headerlink" title="springboot依赖："></a>springboot依赖：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 必须要引入继承springboot-parent   帮我们实现了很多jar的管理，不需要写jar版本--&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.5</span><span class="number">.2</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;!-- SpringBoot 核心组件 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt; </span><br><span class="line">&lt;!-- SpringBoot mybatis整合  --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.1</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="热部署："><a href="#热部署：" class="headerlink" title="热部署："></a>热部署：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/09/13/maven/">https://blog.jujimeizuo.cn/2021/09/13/maven/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桌面应用开发期末复习——VC++</title>
      <link href="/2021/06/25/vc/"/>
      <url>/2021/06/25/vc/</url>
      
        <content type="html"><![CDATA[<h2 id="常用句柄类型及其说明"><a href="#常用句柄类型及其说明" class="headerlink" title="常用句柄类型及其说明"></a>常用句柄类型及其说明</h2><p>句柄类型</p><p>说明</p><p>HWND</p><p>标识窗口句柄</p><p>HINSTANCE</p><p>标识当前实例句柄</p><p>HCURSOR</p><p>标识光标句柄</p><p>HFONT</p><p>标识字体句柄</p><p>HPEN</p><p>标识画笔句柄</p><p>HBRUSH</p><p>标识画刷句柄</p><p>HDC</p><p>标识设备环境句柄</p><p>HBITMAP</p><p>标识位图句柄</p><p>HICON</p><p>标识图标句柄</p><p>HMENU</p><p>标识菜单句柄</p><p>HFILE</p><p>标识文件句柄</p><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>窗口是Windows应用程序基本的操作单元，是应用程序与用户之间交互的接口环境，也是系统管理应用程序的基本单位。 应用程序的运行过程即窗口内部、窗口与窗口之间、窗口与系统之间进行数据处理与数据交换的过程。</p><h2 id="Windows应用程序常用消息"><a href="#Windows应用程序常用消息" class="headerlink" title="Windows应用程序常用消息"></a>Windows应用程序常用消息</h2><p>WM_KEYDOWN：按下一个非系统键时产生的消息。 WM_CHAR：按下一个非系统键时产生的消息。 WM_CREATE：由CreateWindow函数发出的消息。 WM_CLOSE：关闭窗口时产生此消息。 WM_DESTROY：消除窗口时由DestroyWindow函数发出此消息。 WM_QUIT：推出应用程序时由PostQuitMessage函数发出的消息。 WM_PAINT：当发生用户区移动或显示事件、用户窗口改变大小的事件、程序通过滚动条滚动窗口时，均产生一条次消息。</p><h2 id="Windows中的事件驱动程序设计"><a href="#Windows中的事件驱动程序设计" class="headerlink" title="Windows中的事件驱动程序设计"></a>Windows中的事件驱动程序设计</h2><p>Windows的应用程序是事件驱动的。事件驱动的程序不是由过程的顺序来控制，而是由事件的发生来控制。 事件驱动程序设计是围绕着信息的产生与处理而展开的。 事件驱动程序方法提供了许多便利，对于那些需要大范围用户干预的应用程序来说，更显其优越性。</p><h2 id="p44-3-3-说明其优点"><a href="#p44-3-3-说明其优点" class="headerlink" title="p44 3.3 说明其优点"></a>p44 3.3 说明其优点</h2><h2 id="Windows应用程序的组成"><a href="#Windows应用程序的组成" class="headerlink" title="Windows应用程序的组成"></a>Windows应用程序的组成</h2><p>扩展名</p><p>文件类型</p><p>备注</p><p>c或cpp</p><p>C语言源程序文件</p><p>h</p><p>头文件</p><p>头文件包含源程序文件需要的外部常量、变量、数据结构和函数定义和说明</p><p>def</p><p>模块定义文件</p><p>模块定义文件定义程序模块的属性</p><p>rc</p><p>资源描述文件</p><p>资源描述文件定义源程序使用的资源</p><p>vcproj</p><p>项目文件</p><p>各种源程序文件编译后生成项目文件，经进一步编译成为可执行文件</p><h2 id="源程序组成结构"><a href="#源程序组成结构" class="headerlink" title="源程序组成结构"></a>源程序组成结构</h2><ol><li>WinMain函数（函数说明、初始化(窗口类定义、注册窗口类、创建窗口、显示窗口)、消息循环）</li><li>窗口函数（WndProc）</li><li>数据类型（LONG、DWORD、UINT、BOOL、LOTSTR、LPCTSTR、LPSTR、LPCSTR）</li><li>数据结构（MSG、WNDCLASSEX、POINT、RECT）</li></ol><h2 id="常用显示标识及其说明"><a href="#常用显示标识及其说明" class="headerlink" title="常用显示标识及其说明"></a>常用显示标识及其说明</h2><p>标识</p><p>说明</p><p>SW_HIDE</p><p>隐藏窗口</p><p>SW_SHOW</p><p>按当前的位置和大小激活窗口</p><p>SW——SHOWNA</p><p>按当前的状态显示窗口</p><p>SW_SHOWNORMAL</p><p>显示并激活窗口</p><h2 id="图像刷新"><a href="#图像刷新" class="headerlink" title="图像刷新"></a>图像刷新</h2><p>图形刷新是绘图过程中必须考虑的问题，图形刷新包括刷新的请求、系统对刷新请求的响应以及具体的刷新方法。</p><h3 id="刷新请求"><a href="#刷新请求" class="headerlink" title="刷新请求"></a>刷新请求</h3><p>Windows应用程序大部分的用户操作都集中在用户区内，在窗口大小调整、窗口移动或其他对象覆盖时，都必须刷新窗口内用户区的内容，以恢复用户区内应有的显示形态。</p><p>Windows系统通常发送WM_PAINT消息将刷新请求传递给应用程序。当刷新时，系统在应用程序的消息队列中加入该消息，以通知窗口函数执行刷新处理。</p><h3 id="系统对刷新请求的响应"><a href="#系统对刷新请求的响应" class="headerlink" title="系统对刷新请求的响应"></a>系统对刷新请求的响应</h3><p>窗口移动后的刷新 被覆盖区域的刷新 对象穿越后的刷新</p><h3 id="刷新方法"><a href="#刷新方法" class="headerlink" title="刷新方法"></a>刷新方法</h3><p>内存中保持一个显示输出的副本，当需要重新绘制窗口时，将副本复制到相应的窗口中。适用于刷新位图等复杂图形。 记录曾经发生的事件，在窗口需要刷新时重新调用窗口执行这个事件。 重新绘制图形。常采用于简单图形，将图形绘制处理程序放在WM_PAINT响应模块中。</p><h2 id="BeginPaint与GetDC的区别"><a href="#BeginPaint与GetDC的区别" class="headerlink" title="BeginPaint与GetDC的区别"></a>BeginPaint与GetDC的区别</h2><p>项目\函数</p><p>BeginPaint函数</p><p>GetDC函数</p><p>使用环境</p><p>只用于图像刷新时获取设备环境</p><p>使用较广泛</p><p>操作区域</p><p>无效区域</p><p>特定窗口的客户区或整个窗口</p><p>释放设备环境所用函数</p><p>由EndPaint函数释放</p><p>由ReleaseDC函数释放</p><h2 id="画笔、画刷"><a href="#画笔、画刷" class="headerlink" title="画笔、画刷"></a>画笔、画刷</h2><ol><li>画笔、画刷的创建 定义：HPEN hP; 获取Windows系统定义的四种画笔：hP&#x3D;(HPEN)GetStockObject(DC_PEN)； 创建新画笔：hP&#x3D;CreatePen();</li></ol><p>定义：HBRUSH hBr; hBr &#x3D; (HBRUSH)GetStockObject(BLACK_BRUSH); CreateSolidBrush();</p><ol start="2"><li>将画笔选入设备环境 hPenOld&#x3D;SelectObject(hdc, hP)； 直到选入营外一种画笔为止，SelectObject函数的返回值中保存上一次使用的画笔句柄hPenOld。</li></ol><p>hBrOld&#x3D;SelectObject(hdc,hBr);</p><ol start="3"><li>删除画笔、画刷 DeleteObject(hP)； DeleteObject(hBr);</li></ol><p>样式</p><p>说明</p><p>PS_DASH</p><p>虚线</p><p>PS_DASHDOT</p><p>点划线</p><p>PS_DASHDOTDOT</p><p>双点划线</p><p>PS_DOT</p><p>点线</p><p>PS_INSIDEFRAME</p><p>画笔在由封闭对象框中画图（圆等）</p><p>PS_NULL</p><p>画笔不能画图</p><p>PS_SOLID</p><p>实线</p><h2 id="文本输出过程"><a href="#文本输出过程" class="headerlink" title="文本输出过程"></a>文本输出过程</h2><p>在定义了字体句柄、字体及字体颜色之后，就可以把设置的字体输出到相应的设备上。 翁嗯输出定位方式：绝对定位和相对定位。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>逻辑坐标缺点：已输出文本对后续的位置有影响，这种影响无法直接从定位坐标中体现出来。而且当窗口位置或输出字体发生变化时，文本不能随着窗口的尺寸和新的字体的变化灵活调整。</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>根据已输出内容，通过获取字体信息，然后格式化文本，确定后续文本的输出的位置，调用函数在窗口中输出文本。</p><ol><li>获取字体信息 GetTextMetrics(hdc, &amp;tm)</li><li>格式化文本 确定后续文本坐标，确定换行时文本坐标 Y &#x3D; y0 + tm.tmHeight + tmExternalLeading;</li><li>文本输出 TextOut(hdc, x, y, “”, len);</li></ol><h2 id="用户区鼠标消息"><a href="#用户区鼠标消息" class="headerlink" title="用户区鼠标消息"></a>用户区鼠标消息</h2><p>消息</p><p>含义</p><p>WM_LBUTTONDOWN &#x2F; UP</p><p>用户区单击 &#x2F; 释放鼠标左键</p><p>WM_LBUTTONDBLCLK</p><p>用户区双击鼠标左键</p><p>WM_MBUTTONDOWN &#x2F; UP</p><p>用户区单击 &#x2F; 释放鼠标中键</p><p>WM_MBUTTONDBLCLK</p><p>用户区双击鼠标中键</p><p>WM_RBUTTONDOWN &#x2F; UP</p><p>用户区单击 &#x2F; 释放鼠标右键</p><p>WM_RBUTTONDBLCLK</p><p>用户区双击鼠标右键</p><p>WM_MOUSEMOVE</p><p>鼠标在用户区内移动</p><p>WM_MOUSEWHELL</p><p>鼠标滚轮移动</p><p>WM_MOUSEACTIVATE</p><p>鼠标指针在非激活窗口的时候按下了鼠标键</p><p>WM_MOUSEHOVER</p><p>鼠标的光标在窗口的用户区盘旋时发出的消息</p><h2 id="wParam的值"><a href="#wParam的值" class="headerlink" title="wParam的值"></a>wParam的值</h2><p>消息</p><p>含义</p><p>MK_CONTROL</p><p>按下键盘Ctrl键</p><p>MK_LBUTTON</p><p>按下鼠标左键</p><p>MK_MBUTTON</p><p>按下鼠标中键</p><p>MK_RBUTTON</p><p>按下鼠标右键</p><p>MK_SHIFT</p><p>按下键盘Shift键</p><p>MK_XBUTTON1</p><p>按下Windows第一徽标键</p><p>MK_XBUTTON2</p><p>按下Windows第二徽标键</p><h2 id="鼠标应用程序实例"><a href="#鼠标应用程序实例" class="headerlink" title="鼠标应用程序实例"></a>鼠标应用程序实例</h2><p>p &#x3D; (LOWORD(lPARAM), HIWORD(lPARAM)) 当消息是鼠标消息时，获取坐标</p><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>对话框有模式对话框和非模式对话框。 模式对话框不允许用户在关闭对话框之前切换到应用程序的其他窗口，而非模式对话框然也。</p><h3 id="模式对话框的编程方法"><a href="#模式对话框的编程方法" class="headerlink" title="模式对话框的编程方法"></a>模式对话框的编程方法</h3><ol><li>定义对话框资源 STYLE DS_MODALFRAMEWS_POPUP_WS_CAPTION</li><li>调用函数DialogBox显示对话框 DialogBox();</li><li>构造对话框消息处理函数 DlgProc();</li><li>关闭对话框 EndDialog()；</li></ol><h3 id="非模式对话框的编程方法"><a href="#非模式对话框的编程方法" class="headerlink" title="非模式对话框的编程方法"></a>非模式对话框的编程方法</h3><p>非模式对话框与模式对话框的变成比较类似，但在对话框的定义、对话框的创建及消息处理上略有差别。</p><ol><li><p>定义对话框样式 STYLE WS_POPUPWS_CAPTIONWS_VISIBLE</p></li><li><p>创建对话框函数 CreateDialog();</p></li><li><p>消息循环部分的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;Msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">IsDialogMessage</span>(hdlg, &amp;Msg)) &#123;</span><br><span class="line">    <span class="built_in">TranslateMessage</span>(&amp;Msg);</span><br><span class="line">    <span class="built_in">DispatchMessage</span>(&amp;Msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭对话框的函数 DestroyWindow(HWND hdlg);</p></li></ol><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/25/vc/">https://blog.jujimeizuo.cn/2021/06/25/vc/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 桌面应用开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（八）控制单元的功能</title>
      <link href="/2021/06/20/jizu8/"/>
      <url>/2021/06/20/jizu8/</url>
      
        <content type="html"><![CDATA[<h4 id="8-1-微操作命令的分析"><a href="#8-1-微操作命令的分析" class="headerlink" title="8.1 微操作命令的分析"></a>8.1 微操作命令的分析</h4><h3 id="8-1-1-取指周期"><a href="#8-1-1-取指周期" class="headerlink" title="8.1.1 取指周期"></a>8.1.1 取指周期</h3><p><img src="/images/2021/06/2D6AC65A-597D-4AC6-92B1-DF95B1F4EF6F.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="8-1-2-间址周期"><a href="#8-1-2-间址周期" class="headerlink" title="8.1.2 间址周期"></a>8.1.2 间址周期</h3><p>间址周期完成取操作数有效地址的任务。</p><p><img src="/images/2021/06/867498D7-4CAF-47CC-86D8-F4CA93620BDB.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="8-1-3-执行周期"><a href="#8-1-3-执行周期" class="headerlink" title="8.1.3 执行周期"></a>8.1.3 执行周期</h3><p><img src="/images/2021/06/287A4FCE-31E2-4AC0-A483-643F53982B68.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/6F4D6516-67E5-4D3A-A3EC-651064F6C876.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/2CBA798F-1060-4ABF-98C8-8914A5D8F5BC.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/E33C4124-D6BA-4FAE-9C38-8730792D74A0.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="8-2-例题"><a href="#8-2-例题" class="headerlink" title="8.2 例题"></a>8.2 例题</h4><blockquote><p><img src="/images/2021/06/7BB164DB-DEA0-468E-864F-41A86D0BC2AF.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>（1）（2）（3）在上面</p><p>（4）</p><p><img src="/images/2021/06/69C9C3A7-5209-455B-A95E-C66CBCA5AF4E.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/4.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/7FE27029-750B-4D7D-A23B-2244F25BD13E.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/20/jizu8/">https://blog.jujimeizuo.cn/2021/06/20/jizu8/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（七）CPU的结构和性能</title>
      <link href="/2021/06/20/jizu7/"/>
      <url>/2021/06/20/jizu7/</url>
      
        <content type="html"><![CDATA[<h4 id="7-1-CPU的结构"><a href="#7-1-CPU的结构" class="headerlink" title="7.1 CPU的结构"></a>7.1 CPU的结构</h4><h3 id="7-1-1-CPU的功能"><a href="#7-1-1-CPU的功能" class="headerlink" title="7.1.1 CPU的功能"></a>7.1.1 CPU的功能</h3><p>（1）取指令 控制器必须具备能自动地从存储器中取出指令的功能</p><p>（2）分析指令 分析指令包括两部分内容：其一，分析此指令要完成什么操作，即控制器需发出什么操作命令；其二，分析参与这次操作的操作数地址，即操作数的有效地址。</p><p>（3）执行指令 执行指令就是根据分析指令产生的“操作命令”和“操作数地址”的要求，形成操作控制信号序列，通过对运算器、存储器以及I&#x2F;O设备的操作，执行每条指令。</p><p>CPU必须具有控制程序的顺序执行（称指令控制）、产生完成每条指令的控制命令（称操作控制）、对各种操作加以时间上的控制（称时间控制）、对数据进行算术运算和逻辑运算（称数据加工）、处理中断等功能。</p><h3 id="7-1-2-CPU结构框图"><a href="#7-1-2-CPU结构框图" class="headerlink" title="7.1.2 CPU结构框图"></a>7.1.2 CPU结构框图</h3><p><img src="/images/2021/06/image-79.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="7-1-3-CPU的寄存器"><a href="#7-1-3-CPU的寄存器" class="headerlink" title="7.1.3 CPU的寄存器"></a>7.1.3 CPU的寄存器</h3><p>CPU中的寄存器大致可分为两类：一类属于<strong>用户可见寄存器</strong>，用户可对这类寄存器编程，以及通过优化使CPU因使用这类寄存器而减少对主存的访问次数；另一类属于<strong>控制和状态寄存器</strong>，用户不可对这类寄存器编程，它们被控制部件使用，以控制CPU的操作，也可被带有特权的操作系统程序使用，从而控制程序的执行。</p><h4 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h4><p>（1）通用寄存器 通用寄存器可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。寄存器间接寻址时还可用通用寄存器存放有效地址的地址。</p><p>（2）数据寄存器 数据寄存器用于存放操作数，其位数应满足多数数据类型的数值范围。</p><p>（3）地址寄存器 地址寄存器用于存放地址，其本身可以具有通用性，也可用于特殊的寻址方式。</p><p>（4）条件码寄存器 条件码是CPU根据运算结果由硬件设置的位。将条件码放到一个或多个寄存器中，就构成了条件码寄存器。</p><h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>MAR：存储器地址寄存器，用于存放将被访问的存储单元的地址。 MDR：存储器数据寄存器，用于存放欲存入存储器中的数据或最近从存储器中读出的数据。 PC：程序计数器，存放现行指令的地址，通常具有计数功能。当遇到转移类指令时，PC的值可被修改。 IR：指令寄存器，存放当前欲执行的指令。 PSW：程序状态字寄存器，存放条件码和其他状态信息。 在具有中断系统的机器中还有中断标记寄存器。</p><h3 id="7-1-4-控制单元和中断系统"><a href="#7-1-4-控制单元和中断系统" class="headerlink" title="7.1.4 控制单元和中断系统"></a>7.1.4 控制单元和中断系统</h3><p>控制单元（CU）是提供完成计算机全部指令操作的微操作命令序列部件。微操作命令序列的形成方法有两种：一种是组合逻辑设计方法，为<strong>硬连线逻辑</strong>；另一种是微程序设计方法，为<strong>存储逻辑</strong>。</p><h4 id="7-2-指令周期"><a href="#7-2-指令周期" class="headerlink" title="7.2 指令周期"></a>7.2 指令周期</h4><h3 id="7-2-1-概念"><a href="#7-2-1-概念" class="headerlink" title="7.2.1 概念"></a>7.2.1 概念</h3><p>CPU每取出并执行一条指令所需的全部时间称为<strong>指令周期</strong>，也即CPU完成一条指令的时间。取指阶段完成取指令和分析指令的操作，又称<strong>取指周期</strong>；执行阶段完成执行指令的操作，又称<strong>执行周期</strong>。</p><h3 id="7-2-2-指令周期的数据流"><a href="#7-2-2-指令周期的数据流" class="headerlink" title="7.2.2 指令周期的数据流"></a>7.2.2 指令周期的数据流</h3><h4 id="取值周期数据流"><a href="#取值周期数据流" class="headerlink" title="取值周期数据流"></a>取值周期数据流</h4><h4 id="间址周期的数据流"><a href="#间址周期的数据流" class="headerlink" title="间址周期的数据流"></a>间址周期的数据流</h4><h4 id="执行周期的数据流"><a href="#执行周期的数据流" class="headerlink" title="执行周期的数据流"></a>执行周期的数据流</h4><h4 id="中断周期的数据流"><a href="#中断周期的数据流" class="headerlink" title="中断周期的数据流"></a>中断周期的数据流</h4><h4 id="7-3-指令流水"><a href="#7-3-指令流水" class="headerlink" title="7.3 指令流水"></a>7.3 指令流水</h4><p>（1）提高器件的性能 （2）改进系统的结构，开发系统的并行性 并行：包含同时性和并发性两方面。同时性指两个或多个事件在同一时刻发生，并发性指两个或多个事件在同一时间段发生。在同一时刻或同一时间段内完成两种或两种以上性质相同或不同的功能，只要在时间上互相重叠，就存在并行性。 并行性体现在不同等级上。通常分为4个级别：作业级或程序级、任务级或进程级、指令之间级和指令内部级。前两级为粗粒度，又称为过程级；后两级为细粒度，又称为指令级。粗粒度并行性一般用算法实现，细粒度并行性一般用硬件实现。粗粒度并行性是在多个处理机上分别运行多个进程，由多台处理机合作完成一个程序；细粒度并行性是指在处理机的操作级和指令级的并行性，其中指令的流水作业就是一项重要技术。</p><h3 id="7-3-1-指令流水原理"><a href="#7-3-1-指令流水原理" class="headerlink" title="7.3.1 指令流水原理"></a>7.3.1 指令流水原理</h3><p>把指令的处理过程分为取指令和执行指令两个阶段，在不采用流水技术的计算机里，取指令和执行指令是周而复始地出现，各条指令按顺序串行执行的。</p><h3 id="7-3-2-影响流水线性能的因素"><a href="#7-3-2-影响流水线性能的因素" class="headerlink" title="7.3.2 影响流水线性能的因素"></a>7.3.2 影响流水线性能的因素</h3><p>在流水过程中会出现三种相关，使流水线不断流实现起来很困难，即结构相关、数据相关、控制相关。 结构相关：当多条指令进入流水线后，硬件资源满足不了指令重叠执行的要求时产生的。 数据相关：指令在流水线中重叠执行时，当后继指令需要用到前面的执行结果时发生的。 控制相关：当流水线遇到分支指令和其他改变PC值的指令时引起的。</p><p>假设流水线由5段组成，它们分别是取指令（IF）、指令译码&#x2F;读寄存器（ID）、执行&#x2F;访存有效地址计算（EX）、存储器访问（MEM）、结果写回寄存器（WB）。</p><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><h3 id="7-3-3-流水线性能"><a href="#7-3-3-流水线性能" class="headerlink" title="7.3.3 流水线性能"></a>7.3.3 流水线性能</h3><p>流水线性能通常用<strong>吞吐率、加速比、效率</strong>3项指标来衡量。</p><h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>在指令级流水线中，<strong>吞吐率</strong>是指单位时间内流水线所完成指令或输出结果的数量。吞吐率又有<strong>最大吞吐率</strong>和<strong>实际吞吐率</strong>之分。</p><p><strong>最大吞吐率</strong>是指流水线在连续流动达到稳定状态后所获得的吞吐率。对于m段的指令流水线而言，若各段的时间均为Δt，则最大吞吐率为</p><p><code>T_&#123;pmax&#125;=\frac&#123;1&#125;&#123;\triangle t&#125;</code> 流水线仅在连续流动时才可达到最大吞吐率。实际吞吐率总是小于最大吞吐率。 实际吞吐率是指流水线完成n条指令的实际吞吐率。实际吞吐率为 <code>T_p=\frac&#123;T_&#123;pmax&#125;&#125;&#123;1+(m-1)/n&#125;</code></p><h4 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h4><p>流水线的加速比是指m段流水线的速度与等功能的非流水线的速度之比。加速比Sp为 <code>S_p=\frac&#123;m&#125;&#123;1+(m-1)/n&#125;</code></p><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>效率是指流水线中各功能段的利用率。通常用流水线各段处于工作时间的时空区与流水线中各段总的时空区之比来衡量流水线的效率。 <code>E=T_p\triangle t</code></p><h3 id="7-3-4-流水线种的多发技术。"><a href="#7-3-4-流水线种的多发技术。" class="headerlink" title="7.3.4 流水线种的多发技术。"></a>7.3.4 流水线种的多发技术。</h3><p>除了采用好的指令调度算法、重新组织指令执行顺序、降低相关带来的干扰以及优化编译外，还可开发流水线中的多发技术，设法在一个时钟周期内，产生更多的结果。常见的多发技术有超标量技术、超流水线技术、超长指令字技术。</p><h3 id="7-3-5-流水线结构"><a href="#7-3-5-流水线结构" class="headerlink" title="7.3.5 流水线结构"></a>7.3.5 流水线结构</h3><h4 id="指令流水线结构"><a href="#指令流水线结构" class="headerlink" title="指令流水线结构"></a>指令流水线结构</h4><p>指令流水线是将指令的整个执行过程用流水线进行分段处理，典型的指令执行过程分为“取指令——指令译码——形成地址——取操作数——执行指令——回写结果——修改指令指针”这几个阶段。 指令流水线对机器性能的改善程度取决于把处理过程分解为多少个相等的时间段数。</p><h4 id="运算流水线"><a href="#运算流水线" class="headerlink" title="运算流水线"></a>运算流水线</h4><p>流水线相邻两段在执行不同的操作，因此在相邻两段之间必须设置锁存器或寄存器，以保证在一个时钟周期内流水线的输入信号不变。这一指导思想也适用于指令流水。</p><h4 id="7-4-中断系统"><a href="#7-4-中断系统" class="headerlink" title="7.4 中断系统"></a>7.4 中断系统</h4><h3 id="7-4-1-概述"><a href="#7-4-1-概述" class="headerlink" title="7.4.1 概述"></a>7.4.1 概述</h3><h4 id="引起中断的各种因素"><a href="#引起中断的各种因素" class="headerlink" title="引起中断的各种因素"></a>引起中断的各种因素</h4><p>（1）人为设置的中断 这种中断一般称为自愿中断，因为它是程序中人为设置的，故一旦机器执行这种人为中断，便自愿停止现行程序而转入中断处理。 （2）程序性事故 如定点溢出、浮点溢出、操作码不能识别、除法中出现“非法”等，这些都属于由程序设计不周而引起的中断。 （3）硬件故障 （4）I&#x2F;O设备 I&#x2F;O设备被启动以后，一旦准备就绪，便向CPU发出中断请求。 （5）外部事件 用户通过键盘来中断现行程序属于外部事件中断。</p><p>通常将能引起中断的各个因素称为中断源。中断源可分为两大类：一类为不可屏蔽中断，这类中断CPU不能禁止，如电源掉电；另一类为可屏蔽中断，对可屏蔽中断源的请求，CPU可根据该中断源是否被屏蔽来确定是否给予响应。若未屏蔽则能响应；若已被屏蔽，则CPU不能响应。</p><h3 id="7-4-2-中断请求标记和中断判优逻辑"><a href="#7-4-2-中断请求标记和中断判优逻辑" class="headerlink" title="7.4.2 中断请求标记和中断判优逻辑"></a>7.4.2 中断请求标记和中断判优逻辑</h3><h4 id="中断请求标记"><a href="#中断请求标记" class="headerlink" title="中断请求标记"></a>中断请求标记</h4><h4 id="中断判优逻辑"><a href="#中断判优逻辑" class="headerlink" title="中断判优逻辑"></a>中断判优逻辑</h4><h3 id="7-4-3-中断服务程序入口地址的寻找"><a href="#7-4-3-中断服务程序入口地址的寻找" class="headerlink" title="7.4.3 中断服务程序入口地址的寻找"></a>7.4.3 中断服务程序入口地址的寻找</h3><p>通常有两种方法寻找入口地址：硬件向量法和软件查询法。</p><h3 id="7-4-4-中断响应"><a href="#7-4-4-中断响应" class="headerlink" title="7.4.4 中断响应"></a>7.4.4 中断响应</h3><h4 id="响应中断的条件"><a href="#响应中断的条件" class="headerlink" title="响应中断的条件"></a>响应中断的条件</h4><p>当EINT&#x3D;1，且有中断请求（即中断请求标记触发器INTR&#x3D;1）时，CPU可以响应中断。</p><h4 id="响应中断时间"><a href="#响应中断时间" class="headerlink" title="响应中断时间"></a>响应中断时间</h4><p>之所以CPU在指令的执行周期后进入中断周期，是因为CPU在执行周期的结束时刻同一向所有中断源发中断查询信号，只有此时CPU才能获知哪个中断源有请求。 可在指令执行过程中设置若干个查询断点，CPU在每个“查询断点”时刻均发中断查询信号，以便发现有中断请求便可及时响应。</p><h4 id="中断隐指令"><a href="#中断隐指令" class="headerlink" title="中断隐指令"></a>中断隐指令</h4><p>（1）保护程序断点 （2）寻找中断服务程序的入口地址 （3）关中断</p><h3 id="7-4-5-保护现场和恢复现场"><a href="#7-4-5-保护现场和恢复现场" class="headerlink" title="7.4.5 保护现场和恢复现场"></a>7.4.5 保护现场和恢复现场</h3><p>保护现场：应该包括保护程序断点和保护CPU内部各寄存器内容的现场两个方面。程序断点的现场由中断隐指令完成，各寄存器内的现场可在中断服务程序中由用户（或系统）用机器指令编程实现。</p><p>恢复现场：是指在中断返回前，必须将寄存器的内容回复到中断处理前的状态，这部分工作也由中断服务程序完成。</p><h3 id="7-4-6-中断屏蔽技术"><a href="#7-4-6-中断屏蔽技术" class="headerlink" title="7.4.6 中断屏蔽技术"></a>7.4.6 中断屏蔽技术</h3><h4 id="多重中断概念"><a href="#多重中断概念" class="headerlink" title="多重中断概念"></a>多重中断概念</h4><p>当CPU正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而CPU又响应了这个系难道请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序，这称为多重中断，又称为中断嵌套。如果的CPU对新请求不予响应，待执行完当前的服务程序后再响应，即为单重中断。</p><h4 id="实现多重中断的条件"><a href="#实现多重中断的条件" class="headerlink" title="实现多重中断的条件"></a>实现多重中断的条件</h4><p>1.提前设置“开中断”指令。 多重中断“开中断”指令的位置前于单重中断，从而保证了多重中断允许出现中断嵌套。 2.优先级别高的中断源有权中断优先级别低的中断源。 为了保证级别低的中断源不干扰级别高的中断源的中断处理过程，保证上述2的试试，可采用屏蔽技术。</p><h4 id="屏蔽技术"><a href="#屏蔽技术" class="headerlink" title="屏蔽技术"></a>屏蔽技术</h4><p>（1）屏蔽触发器与屏蔽字 （2）屏蔽技术可改变优先等级 （3）屏蔽技术的其他作用</p><h4 id="多重中断的断点保护"><a href="#多重中断的断点保护" class="headerlink" title="多重中断的断点保护"></a>多重中断的断点保护</h4><h4 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a>7.5 小结</h4><ol><li><p>CPU实质包括运算器和控制器，功能：取指令、分析指令（分析此指令要完成什么操作，分析参与这次操作的操作数地址）、执行指令</p></li><li><p>MAR（存储器地址寄存器）、MDR（存储器数据寄存器）、PC（程序计数器）、IR（指令寄存器）</p></li><li><p>CPU每取出并执行一条指令所需的全部时间称为指令周期。</p><h3 id="引起流水线性能的因素"><a href="#引起流水线性能的因素" class="headerlink" title="引起流水线性能的因素"></a>引起流水线性能的因素</h3><p>结构相关、数据相关、控制相关</p><h3 id="引起中断的各种因素-1"><a href="#引起中断的各种因素-1" class="headerlink" title="引起中断的各种因素"></a>引起中断的各种因素</h3><p>人为设置的中断、程序性事故、硬件故障、I&#x2F;O设备、外部事件</p></li></ol><h4 id="7-6-例题"><a href="#7-6-例题" class="headerlink" title="7.6 例题"></a>7.6 例题</h4><blockquote><p><img src="/images/2021/06/1.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/FD0F9CD4-2619-4F9F-95BE-3BF546880A2A.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/2.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/F1DD9958-7255-4ED5-9195-4FFC8E1FACE2.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>8.12 在5个功能段的指令流水线中，假设每段的执行时间分别为10ns，8ns，10ns，10ns和7ns。对于完成12条指令的流水线而言，其加速比为多少？该流水线的实际吞吐率为多少？</p><p>根据流水线时空图，第一条指令出结果需要5个时钟周期，当流水线满载时，每个时钟周期可以出一个结果，即执行完一条指令。完成12条指令需要16个时钟周期，故实际吞吐率为:</p><p> 12&#x2F;(10ns* 16)&#x3D;0.75*10^8条指令&#x2F;秒</p><p>对于本题五级流水线而言，处理12条指令所需的时钟周期数为T&#x3D;5+ (12-1) &#x3D;16个， 而非流水线处理12条指令需要5*12&#x3D;60个，故该流水处理器的加速比为   60&#x2F;16&#x3D;3.75。</p></blockquote><p> </p><blockquote><p>8.18 什么是中断隐指令，有哪些功能？</p><p><strong>中断隐指令</strong>：CPU响应中断后，即进入中断周期。</p><p>功能：</p><ol><li>保护程序断点</li><li>寻找中断服务程序的入口地址</li><li>关中断</li></ol></blockquote><p> </p><blockquote><p>8.19 中断系统中采用屏蔽技术有何作用？</p><ol><li>屏蔽触发器与屏蔽字</li><li>屏蔽技术可改变优先等级</li><li>屏蔽技术的其他作用</li></ol></blockquote><p> </p><blockquote><p><img src="/images/2021/06/FA7FC9E8-6EDC-4E83-9CE3-5E295976F5C8.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/722BDA51-2D08-4733-BA7B-DDC1E2BC17F8.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><blockquote><p><img src="/images/2021/06/lALPD0sXSsEKvqfNAg7NBWE_1377_526.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/A43F0FDD-6DC3-4920-BB5B-1F5F6CBCD373.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>8.26 设某机配有A、B、C三台设备，其优先顺序按A-B-C降序排列，为改变中断处理次序，它们的中断屏蔽字设置如下：</p><p>设备</p><p>屏蔽字</p><p>A</p><p>111</p><p>B</p><p>010</p><p>C</p><p>011</p><p> </p><p><img src="/images/2021/06/708FAC65-A3D6-4AC1-9F1E-77E702420951.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/455157F9-80F5-4DD7-9C48-297E3A7FBAF8.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/CD48DB4FF87D2E795DEA787F7168187D.jpg"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/F6F2BF88-5357-4DB2-823D-35F47D87F907.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-80.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/20/jizu7/">https://blog.jujimeizuo.cn/2021/06/20/jizu7/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（六）指令系统</title>
      <link href="/2021/06/20/jizu6/"/>
      <url>/2021/06/20/jizu6/</url>
      
        <content type="html"><![CDATA[<h4 id="6-1-机器指令"><a href="#6-1-机器指令" class="headerlink" title="6.1 机器指令"></a>6.1 机器指令</h4><p>每一条机器语言的语句称为机器指令，而又将全部机器指令的集合称为机器的指令系统。</p><h3 id="6-1-1-指令的一般格式"><a href="#6-1-1-指令的一般格式" class="headerlink" title="6.1.1 指令的一般格式"></a>6.1.1 指令的一般格式</h3><p>指令是由操作码和地址码两部分组成的。</p><h4 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h4><p>操作码用来指明该指令索要完成的操作，如加法、减法、传送、移位、转移等。通常，其位数反映了机器的操作种类，也即机器允许的指令条数。</p><h4 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h4><p>地址码用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。这里的“地址”可以是主存的地址，也可以是寄存器的地址，甚至可以是I&#x2F;O设备的地址。</p><h3 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h3><p><img src="/images/2021/06/image-72.png"></p><p>其中，OP为操作码；A1为第一操作数地址；A2为第二操作数地址；A3为结果地址；A4为下一条指令的地址。 如果地址字段均指示主存的地址，则完成一条四地址指令，共需访问4次存储器（取指令一次，取两个操作数两次，存放结果一次）。</p><h3 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h3><p><img src="/images/2021/06/image-73.png"></p><h3 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h3><p><img src="/images/2021/06/image-74.png"></p><h3 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h3><p><img src="/images/2021/06/image-75.png"></p><h3 id="6-1-2-指令字长"><a href="#6-1-2-指令字长" class="headerlink" title="6.1.2 指令字长"></a>6.1.2 指令字长</h3><p>指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数。 为了提高指令的运行速度和节省存储空间，通常尽可能把常用的指令（如数据传送指令、算逻运算指令等）设计成单字长或短字长格式的指令。通常指令字长取8的整数倍。</p><h4 id="6-2-操作类型"><a href="#6-2-操作类型" class="headerlink" title="6.2 操作类型"></a>6.2 操作类型</h4><h3 id="6-2-1-操作数类型"><a href="#6-2-1-操作数类型" class="headerlink" title="6.2.1 操作数类型"></a>6.2.1 操作数类型</h3><p>机器中常见的操作数类型有地址、数字、字符、逻辑数据等。</p><h3 id="6-2-2-操作类型"><a href="#6-2-2-操作类型" class="headerlink" title="6.2.2 操作类型"></a>6.2.2 操作类型</h3><h4 id="输出传送"><a href="#输出传送" class="headerlink" title="输出传送"></a>输出传送</h4><p>数据传送包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送。</p><h4 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h4><p>这类操作可实现算术运算和逻辑运算。有些机器还具有位操作功能，如位测试（测试指定位的值）、位清除（清除指定位）、位求反（对指定位求反）等。</p><h4 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h4><p>移位可分为算数移位、逻辑移位、循环移位三种。</p><h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><p>转移指令按其转移特征又可分为无条件转移、条件转移、跳转、过程调用与返回、陷阱等几种。</p><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h4 id="6-3-寻址方式"><a href="#6-3-寻址方式" class="headerlink" title="6.3 寻址方式"></a>6.3 寻址方式</h4><p>寻址方式分为指令寻址和数据寻址两大类。</p><h3 id="6-3-1-指令寻址"><a href="#6-3-1-指令寻址" class="headerlink" title="6.3.1 指令寻址"></a>6.3.1 指令寻址</h3><p>指令寻址分为顺序寻址和跳跃寻址两种。 顺序寻址可通过程序计数器PC加1，自动形成下一条指令的地址；跳跃寻址则通过转移类指令实现。</p><h3 id="6-3-2-数据寻址"><a href="#6-3-2-数据寻址" class="headerlink" title="6.3.2 数据寻址"></a>6.3.2 数据寻址</h3><p>指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的真实地址称为有效地址，记作EA，它是由寻址方式和形式地址共同来确定的。</p><p><img src="/images/2021/06/image-76.png"></p><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>立即寻址的特点是操作数本身设在指令字内，即形式地址A不是操作数的地址，而是操作数本身，又称为立即数。数据是采用补码形式存放的。</p><p><img src="/images/2021/06/image-77.png"></p><p>优点在于只要取出指令，便可立即获得操作数，这种指令在执行阶段不必再访问存储器。A的位数限制了这类指令所能表述的立即数的范围。</p><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>直接寻址的特点是指令字中的形式地址A就是操作数的真实地址EA，即EA&#x3D;A。</p><p><img src="/images/2021/06/image-78.png"></p><p>它的优点是寻找操作数比较简单，也不需要专门计算操作数的地址，在指令执行阶段对主存只访问一次。缺点在于A的位数限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数的地址。</p><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><h4 id="6-4-RISC的主要特点"><a href="#6-4-RISC的主要特点" class="headerlink" title="6.4 RISC的主要特点"></a>6.4 RISC的主要特点</h4><ol><li>选取使用频度较高的一些简单指令以及一些很有用但又不复杂的指令，让复杂指令的功能由频度高的简单指令的组合来实现。</li><li>指令长度固定，指令格式种类少，寻址方式种类少。</li><li>只有取数&#x2F;存数(LOAD&#x2F;STORE)指令访问存储器，其余指令的操作都在寄存器内完成。</li><li>CPU中有多个通用寄存器</li><li>采用流水线技术，大部分指令在一个时钟周期内完成。采用超标量和超流水线技术，可使每条指令的平均执行时长小于一个时钟周期。</li><li>控制器采用组合逻辑控制，不用微程序控制</li><li>采用优化的编译程序</li></ol><h4 id="6-5-小结"><a href="#6-5-小结" class="headerlink" title="6.5 小结"></a>6.5 小结</h4><ol><li>指令由操作码和地址码组成</li><li>指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数</li><li>半字地址是2的整数倍，字地址是4的整数倍，双字地址是8的整数倍</li><li>算数逻辑操作：加（ADD）、减（SUB）、乘（MUL）、除（DIV）、与（AND）、或（OR）、非（NOT）、异或（XOR）、增1（INC）、减1（DEC）、十进制加减乘除（AAA、AAS、AAM、AAD）、位测试（BT）、位清除（BTR）、位求反（BTC）</li><li>调用指令（CALL）一般与返回指令（RETURN）配合使用</li><li>无条件转移（JMP）</li><li>寻址方式：寻址方式是指确定本条指令的数据地址以及下一条将要执行的指令地址的方法，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。</li><li>寻址方式分为指令寻址和数据寻址两大类</li><li>指令寻址分为顺序寻址和跳跃寻址两种</li><li>数据寻址分为立即寻址（指令中）、寄存器寻址（寄存器中）、存储器寻址（存储器中）</li></ol><h4 id="6-6-例题"><a href="#6-6-例题" class="headerlink" title="6.6 例题"></a>6.6 例题</h4><blockquote><p>7.6 某指令系统字长为16位，地址码取4位，试提出一种方案，使该指令系统有8条三地址指令，16条二地址指令，100条一地址指令。</p><p><img src="/images/2021/06/lALPDgfLRY1zCzrNA-jNBSo_1322_1000.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>7.8 某机指令字长16位，每个操作数的地址码为6位，设操作码长度固定，指令分为零地址、一地址和二地址三种格式。若零地址指令有M种，一地址有N种，则二地址指令最多有几种？若操作码位数可变，则二地址指令最多允许有几种？</p><p><img src="/images/2021/06/lALPDh0cPWoVInLNA-jNByU_1829_1000.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>7.15 一相对寻址的转移指令占3个字节，第一字节是操作码，第二、三字节为相对位移量，而且数据在存储器中采用以高字节地址为字地址的存放方式。假设PC当前值为4000H。试问当结果为0，执行“JZ <em>+ 35”和“JZ</em> - 17”指令时，该指令的第二、第三字节的机器代码各为多少？</p><p><img src="/images/2021/06/lADPD4BhtfayWZzNAdDNBNo_1242_464.jpg"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>7.16某机主存容量为4M*16位，且存储字长等于指令字长，若该机指令系统可完成108种操作，操作码位数固定，且具有直接、间接、变址、基址、相对、立即等六种寻址方式，试回答以下问题。 （1）画出一地址指令格式并指出各字段作用。 （2）该指令直接寻址的最大范围。 （3）一次间接寻址和多次间接寻址的寻址范围。 （4）立即数的范围（十进制表示）。 （5）相对寻址的位移量（十进制表示）。 （6）上述六种寻址方式的指令中哪一种执行时间最短，哪一种最长，为什么？哪一种便于程序浮动，哪一种最适合处理数组问题？ （7）如何修改指令格式，使指令的寻址范围可过大到4M？ （8）位使一条转移指令能够转移到主存到任一位置，可采取什么措施？简要说明之。</p><p><img src="/images/2021/06/63C3215A-F107-4D75-A3E5-F8D9EE134218.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>7.18 某机器共能完成78种操作，若指令字长为16位，试问一地址格式的指令地址码可取几位？若想使指令寻址范围扩大到2^16，可采取什么方法？</p><p>根据78种操作，可求出操作码位数为7位，则单地址格式的指令地址码占16-7&#x3D; 9位。直接寻址范围为2^9&#x3D;512。若想使指令的寻址范围扩大到2^16，可采用以下三种寻址方法： （1）若指令字长等于存储字长均为16位，则采用间接寻址可使寻址范围扩大到2^16，因为间址时（设非多次间址）从存储单元中取出的有效地址为16位。 （2）采用变址寻址，并设变址寄存器RX为16位，则有效地址EA&#x3D;（RX）+A（形式地址），即可使寻址范围扩大到2^16。 （3）采用基址寻址，并设基址寄存器RB为16位，则有效地址EA&#x3D;（RB）+A（形式地址），即可使寻址范围扩大到2^16。</p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/8869BF19-24ED-4CE0-8CFC-3B639CD2CDD4.png"></p><p><img src="/images/2021/06/49ACB5B3-4B12-4CA0-91D7-28177AFB3DA3.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>7.20 什么是RISC？简述它的特点。</p><p>RISC技术是用20%的简单指令的组合来实现不常用的80%的那些指令功能。</p><ul><li>选取使用频度较高的一些简单指令以及一些很有用但又不复杂的指令，让复杂指令的功能由频度高的简单指令的组合来实现。</li><li>指令长度固定，指令格式种类少，寻址方式种类少。</li><li>只有取数&#x2F;存数(LOAD&#x2F;STORE)指令访问存储器，其余指令的操作都在寄存器内完成。</li><li>CPU中有多个通用寄存器</li><li>采用流水线技术，大部分指令在一个时钟周期内完成。采用超标量和超流水线技术，可使每条指令的平均执行时长小于一个时钟周期。</li><li>控制器采用组合逻辑控制，不用微程序控制</li><li>采用优化的编译程序</li></ul></blockquote><p> </p><blockquote><p>7.21 比较RISC和CISC。</p><p>与CISC机相比，RISC机的主要优点可归纳如下：</p><ul><li>充分利用VLSI芯片的面积</li><li>提高计算机的运算速度</li><li>便于设计，可降低成本，提高可靠性</li><li>有效支持高级语言程序</li></ul></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/20/jizu6/">https://blog.jujimeizuo.cn/2021/06/20/jizu6/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（九）形态学图像处理</title>
      <link href="/2021/06/20/shuzituxiang9/"/>
      <url>/2021/06/20/shuzituxiang9/</url>
      
        <content type="html"><![CDATA[<h4 id="9-1-集合论基础"><a href="#9-1-集合论基础" class="headerlink" title="9.1 集合论基础"></a>9.1 集合论基础</h4><h3 id="9-1-1-集合的概念"><a href="#9-1-1-集合的概念" class="headerlink" title="9.1.1 集合的概念"></a>9.1.1 集合的概念</h3><h3 id="9-1-2-集合间的关系和运算"><a href="#9-1-2-集合间的关系和运算" class="headerlink" title="9.1.2 集合间的关系和运算"></a>9.1.2 集合间的关系和运算</h3><p><img src="/images/2021/06/image-71.png"></p><h4 id="9-2-二值形态学的基本运算"><a href="#9-2-二值形态学的基本运算" class="headerlink" title="9.2 二值形态学的基本运算"></a>9.2 二值形态学的基本运算</h4><h3 id="9-2-1-膨胀"><a href="#9-2-1-膨胀" class="headerlink" title="9.2.1 膨胀"></a>9.2.1 膨胀</h3><p>顾名思义，膨胀就是使图像中的目标“变粗”的操作，这种特殊方式和变粗程度由一种被称为结构元的形状来控制，A被B膨胀，表示为A⊕B，集合操作表示为： <code>A\oplus B=&#123;x((\hat&#123;B&#125;)_y\cap A)\neq \text&#123;\O&#125;&#125;</code> 其中，A是图像，B是结构元，结构元通常比图像小得多。膨胀满足结合律和交换律。</p><h3 id="9-2-2-腐蚀"><a href="#9-2-2-腐蚀" class="headerlink" title="9.2.2 腐蚀"></a>9.2.2 腐蚀</h3><p>腐蚀是膨胀的反操作，是将图像中的目标进行“细化”的操作，收缩的方法和程度也由结构元控制。A被B腐蚀表示为AΘB，集合操作表示为： <code>A\ominus B=&#123;x(B)_y\subseteq A &#125;</code></p><h3 id="9-2-3-开运算"><a href="#9-2-3-开运算" class="headerlink" title="9.2.3 开运算"></a>9.2.3 开运算</h3><p>使用同一结构元素对目标图像先进行腐蚀运算，然后再进行膨胀运算称为开运算。 <code>A\circ B=(A \ominus B)\oplus B</code></p><h3 id="9-2-4-闭运算"><a href="#9-2-4-闭运算" class="headerlink" title="9.2.4 闭运算"></a>9.2.4 闭运算</h3><p>使用同一结构元素对目标图像先进行膨胀运算，然后再进行腐蚀运算称为闭运算。 <code>A\cdot B=(A \oplus B)\ominus B</code></p><h4 id="9-3-二值形态学基本运算性质"><a href="#9-3-二值形态学基本运算性质" class="headerlink" title="9.3 二值形态学基本运算性质"></a>9.3 二值形态学基本运算性质</h4><ol><li>单调性</li><li>扩展性</li><li>交换性</li><li>结合性</li><li>平移不变性</li></ol><h4 id="9-3-灰度形态学的基本运算"><a href="#9-3-灰度形态学的基本运算" class="headerlink" title="9.3 灰度形态学的基本运算"></a>9.3 灰度形态学的基本运算</h4><h3 id="9-3-1-灰度腐蚀"><a href="#9-3-1-灰度腐蚀" class="headerlink" title="9.3.1 灰度腐蚀"></a>9.3.1 灰度腐蚀</h3><p>用结构元b对灰度图像f的灰度进行腐蚀，表示为： <code>(f\ominus b)(s,t)=min&#123;f(s+x,t+y)-b(x,y)(s+x),(t+y)\in D_f;(x,y)\in D_b&#125;</code></p><h3 id="9-3-2-灰度膨胀"><a href="#9-3-2-灰度膨胀" class="headerlink" title="9.3.2 灰度膨胀"></a>9.3.2 灰度膨胀</h3><p>用结构元b对灰度图像f的灰度进行膨胀，表示为： <code>(f\oplus b)(s,t)=max&#123;f(s-x,t-y)+b(x,y)(s-t),(t-y)\in D_f;(x,y)\in D_b&#125;</code></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/20/shuzituxiang9/">https://blog.jujimeizuo.cn/2021/06/20/shuzituxiang9/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（八）图像特征提取</title>
      <link href="/2021/06/20/shuzituxiang8/"/>
      <url>/2021/06/20/shuzituxiang8/</url>
      
        <content type="html"><![CDATA[<h4 id="8-1-图像纹理的主要特征及描述与提取方法"><a href="#8-1-图像纹理的主要特征及描述与提取方法" class="headerlink" title="8.1 图像纹理的主要特征及描述与提取方法"></a>8.1 图像纹理的主要特征及描述与提取方法</h4><h3 id="8-1-1-图像纹理的主要特征"><a href="#8-1-1-图像纹理的主要特征" class="headerlink" title="8.1.1 图像纹理的主要特征"></a>8.1.1 图像纹理的主要特征</h3><ol><li>粗糙度</li><li>方向性</li><li>规则性</li></ol><h3 id="8-1-2-图像纹理特征及描述与提取方法"><a href="#8-1-2-图像纹理特征及描述与提取方法" class="headerlink" title="8.1.2 图像纹理特征及描述与提取方法"></a>8.1.2 图像纹理特征及描述与提取方法</h3><ol><li>统计分析法</li><li>结构分析法</li><li>模型分析法</li><li>频谱分析法</li></ol><h4 id="8-2-基于灰度共生矩阵的纹理特征提取方法"><a href="#8-2-基于灰度共生矩阵的纹理特征提取方法" class="headerlink" title="8.2 基于灰度共生矩阵的纹理特征提取方法"></a>8.2 基于灰度共生矩阵的纹理特征提取方法</h4><h3 id="8-2-1-概念及定义"><a href="#8-2-1-概念及定义" class="headerlink" title="8.2.1 概念及定义"></a>8.2.1 概念及定义</h3><p>灰度共生矩阵定义为像素对的联合概率分布，是一个对称矩阵，它不仅反映图像灰度在相邻的方向、相邻间隔、变化幅度的综合信息，但也反映了相同的灰度级像素之间的位置分布特征，是计算纹理特征的基础。</p><p>在图像中任意取一点(x,y)及偏离它的一点(x+a,y+b)(其中，a、b为整数，人为定义)构成点对。设该点对的灰度值为(f1,f2)，再令点(x,y)在整幅图像上移动，则会得到不同的(f1,f2)值。</p><p>设图像的最大灰度级为L，则f2与f2的组合共有L*L种。对于整幅图像，统计出每一种(f1,f2)值出现的次数，然后排列成一个方阵，再用(f1,f2)出现的总次数将他们归一化为出现的概率P(f1,f2)，由此产生的矩阵为灰度共生矩阵。θ方向上的间隔为d的灰度共生矩阵实际上是θ方向间隔为d的灰度变化量的联合概率分布。</p><h3 id="8-2-2-共生矩阵的计算"><a href="#8-2-2-共生矩阵的计算" class="headerlink" title="8.2.2 共生矩阵的计算"></a>8.2.2 共生矩阵的计算</h3><p><img src="/images/2021/06/image-65.png"> 公式(1)中d表示像素间隔，(k,l), (m,n)分别为原像素和偏移后的像素坐标，其中k,m为纵坐标，D为图像范围。 举例说明，假设原图像如图1.a所示 <img src="/images/2021/06/image-66.png"><img src="/images/2021/06/image-67.png"><img src="/images/2021/06/image-68.png"> 对1.b中蓝色字表示原像素灰度值，红字为偏移后像素灰度值。则对矩阵元素P0°,1 (0,0)表示1.a中在0°方向上（包括正和负方向）相距为1的(0,0)点对有两对，考虑正负方向的加倍效果，P0°,1 (0,0)&#x3D;4。同样由于公式(1)对距离d定义的双向性，使得灰度共生矩阵为对称矩阵。</p><p>为了减小计算量，可将d定义为沿θ正方向。则(1)式变为 <img src="/images/2021/06/image-69.png"> 由1.a得到的新的灰度共生矩阵为 <img src="/images/2021/06/image-70.png"></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/20/shuzituxiang8/">https://blog.jujimeizuo.cn/2021/06/20/shuzituxiang8/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（六）图像压缩编码</title>
      <link href="/2021/06/20/shuzituxiang6/"/>
      <url>/2021/06/20/shuzituxiang6/</url>
      
        <content type="html"><![CDATA[<h4 id="6-1-DCT变换"><a href="#6-1-DCT变换" class="headerlink" title="6.1 DCT变换"></a>6.1 DCT变换</h4><ol><li>DCT变换避免了复述运算。由于图像矩阵是实数矩阵，那么它的DCT也是实数。</li><li>DCT是正交变换，其变换矩阵是正交阵，变换核是可分离的。</li><li>DCT与IDCT具有相同的变换核，因此具有相同的变换矩阵，即正变换与逆变换公用同一个算法模块。</li><li>DCT具有更强的信息集中能力，能将最多的信息放到最少的系数上。</li></ol><h3 id="6-1-1-一维DCT变换"><a href="#6-1-1-一维DCT变换" class="headerlink" title="6.1.1 一维DCT变换"></a>6.1.1 一维DCT变换</h3><p><img src="/images/2021/06/FC7284B1-8860-46E4-AA9E-B5AB73ECB065.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/09173FD0-ADDC-47AD-A0C1-55A12999B95C.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/4B5C21E1-BED8-4025-AC63-E59CEC6FF34A.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="6-1-2-二维DCT变换"><a href="#6-1-2-二维DCT变换" class="headerlink" title="6.1.2 二维DCT变换"></a>6.1.2 二维DCT变换</h3><p><img src="/images/2021/06/32B44907-962B-4F73-B56A-426757C572A3.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="6-2-图像编码基础"><a href="#6-2-图像编码基础" class="headerlink" title="6.2 图像编码基础"></a>6.2 图像编码基础</h4><h3 id="6-2-1-图像压缩的基本概念"><a href="#6-2-1-图像压缩的基本概念" class="headerlink" title="6.2.1 图像压缩的基本概念"></a>6.2.1 图像压缩的基本概念</h3><h4 id="定义：-减少表示图像的数据量"><a href="#定义：-减少表示图像的数据量" class="headerlink" title="定义： 减少表示图像的数据量"></a>定义： 减少表示图像的数据量</h4><ol><li>在图像传输的时候，可传输较少的数据量，但不减少图像所表达的信息量</li><li>在图像存储时，可减少所需的存储空间，同时较少存储所需的时间</li></ol><h4 id="图像信息可以压缩的根据"><a href="#图像信息可以压缩的根据" class="headerlink" title="图像信息可以压缩的根据"></a>图像信息可以压缩的根据</h4><ol><li>图像信号存在大量的冗余</li><li>可以利用人的视觉特性</li></ol><p>图像信息的冗余度表现在结构和统计两个方面</p><p>图像信息结构上冗余度表现为：图像具有很强的空间（帧内）相关性和时间（帧间）相关性。</p><p><strong>编码冗余、像素间冗余、心理-视觉冗余、帧间冗余。</strong></p><p>获取图像压缩质量的好坏是通过计算其<strong>压缩比</strong>得到的，公式为：</p><p><img src="/images/2021/06/image-62.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><strong>图像熵数学公式</strong>为：</p><p><img src="/images/2021/06/image-2.gif">  <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="6-2-2-图像编码模型"><a href="#6-2-2-图像编码模型" class="headerlink" title="6.2.2 图像编码模型"></a>6.2.2 图像编码模型</h3><p><img src="/images/2021/06/image-61.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="6-3-霍夫曼码"><a href="#6-3-霍夫曼码" class="headerlink" title="6.3 霍夫曼码"></a>6.3 霍夫曼码</h4><h3 id="6-3-1-概念"><a href="#6-3-1-概念" class="headerlink" title="6.3.1 概念"></a>6.3.1 概念</h3><p>哈夫曼编码是<strong>可变字长编码</strong>(VLC)的一种。该方法<strong>完全依据字符出现概率</strong>来构造异字头的平均长度最短的码字，有时称之为<strong>最佳编码</strong>，一般就叫做Huffman编码（有时也称为霍夫曼编码）。通俗来说就是，<strong>信源符号出现频率越高，使用的码字就越少。</strong></p><h3 id="6-3-2-编码过程"><a href="#6-3-2-编码过程" class="headerlink" title="6.3.2 编码过程"></a>6.3.2 编码过程</h3><ol><li>对符号的概率进行排序，建立信源递减序列；</li><li>对每个约简的信源进行编码，从最小的信源开始，已知到原始信源。</li></ol><h3 id="6-3-3-霍夫曼编码"><a href="#6-3-3-霍夫曼编码" class="headerlink" title="6.3.3 霍夫曼编码"></a>6.3.3 霍夫曼编码</h3><p>霍夫曼码的产生不是压缩过程。为了实现成为霍夫曼码的压缩，对于产生码字的符号，不管它们的灰度级、行程长度，还是其他灰度映射操作的输出，都必须在生成码字一致的情况下被变换或映射。</p><p>霍夫曼树─即<strong>最优二叉树</strong>，带权路径长度最小的二叉树，经常应用于<strong>数据压缩</strong>。 在计算机信息处理中，“霍夫曼编码”是一种<strong>一致性编码法</strong>（又称“熵编码法”），用于数据的<strong>无损耗压缩</strong>。</p><p>霍夫曼编码的原理： 霍夫曼方法的第一步是通过对所考虑符号的概率进行排序，并将具有最小概率的符号合并为一个符号来替代下次信源化简过程中的符号，从而创建一个简化信源系列。如下图所示那样，载最左边一组虚构的信源符号集合及它们的概率根据概率值的减少从上到下排列，为了形成第一次信源简化，底部的两个概率0.06和0.04进行合并，形成一个概率值为0.1的“复合符号”，这个复合符号及其对应的概率被置于第一个信源简化的列中，以便简化后的信源概率仍然按照其值从大到小进行排列，这个过程一直重复持续到信源只有两个符号的简化信源为止。</p><p><img src="/images/2021/06/image-64.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="6-3-4-霍夫曼译码"><a href="#6-3-4-霍夫曼译码" class="headerlink" title="6.3.4 霍夫曼译码"></a>6.3.4 霍夫曼译码</h3><p>经过霍夫曼编码再译码之后，才获得有用的图像，译码器必须计算用来编码x的霍夫曼码，再反映射已编码的数据来重建x，这是一种逆过程，但是缺少了反量化的步骤（这是不可逆转的一步）。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/20/shuzituxiang6/">https://blog.jujimeizuo.cn/2021/06/20/shuzituxiang6/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（七）图像分割</title>
      <link href="/2021/06/18/shuzituxiang7/"/>
      <url>/2021/06/18/shuzituxiang7/</url>
      
        <content type="html"><![CDATA[<h4 id="7-1-图像分割概述"><a href="#7-1-图像分割概述" class="headerlink" title="7.1 图像分割概述"></a>7.1 图像分割概述</h4><h3 id="7-1-1-定义"><a href="#7-1-1-定义" class="headerlink" title="7.1.1 定义"></a>7.1.1 定义</h3><p>将数字图像划分成互不相交，有意义的，具有相同性质的区域的过程。</p><p>图像的分割一种是基于灰度的不连续变来分割（图像边缘）；</p><p>一种是基于实现制定的准则将图像分割为相似的区域。</p><p>数学定义：</p><p><img src="/images/2021/06/image-58.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><ol><li>表明分割区域要覆盖整个图像且各区域互不重叠；</li><li>表明每一个区域都具有相同的性质；</li><li>表明两个区域性质相异不能合并为一个区域。</li></ol><h3 id="7-1-2-准则"><a href="#7-1-2-准则" class="headerlink" title="7.1.2 准则"></a>7.1.2 准则</h3><p>准则：<strong>每个区域内部的特征或属性是相同或相似的</strong>。</p><p>特征可以是：像素灰度值、边缘轮廓曲线、纹理特征、形状和颜色…</p><h3 id="7-1-3-意义"><a href="#7-1-3-意义" class="headerlink" title="7.1.3 意义"></a>7.1.3 意义</h3><p>图像分割是图像处理与理解、模式识别和人工智能等多个领域中一个十分重要且又十分困难的问题，是计算机视觉技术中关键步骤，如下图所示。图像分割应用在许多方面。</p><p><strong>应用</strong>：汽车车型自动识别系统、检查癌细胞、精密零件表面缺陷检测，处理卫星拍摄的地形地貌照片等。在所有这些应用领域中，最终结果很大程度上依赖于图像分割的结果。</p><p><img src="/images/2021/06/image-57.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="7-2-基于边缘检测的图像分割"><a href="#7-2-基于边缘检测的图像分割" class="headerlink" title="7.2 基于边缘检测的图像分割"></a>7.2 基于边缘检测的图像分割</h4><p>先提取区域边界，再确定边界限定的区域；涉及到边缘检测核边缘连接两个部分。</p><p><strong>基本思想</strong>：先检测图像中的边缘点再按一定策略链接成轮廓，从而构成分割区域。</p><h3 id="7-2-1-边缘检测"><a href="#7-2-1-边缘检测" class="headerlink" title="7.2.1 边缘检测"></a>7.2.1 边缘检测</h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>边界存在于目标与背景、目标与目标、区域与区域之间，是图像最基本的特征，包含了在实际应用中用于分割的基本信息。人物体时，首先感觉到的便是边缘。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>检测灰度级或者结构具有突变的地方，这种灰度或者结构不连续性称为边缘。</p><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><p>图像中相邻的不同区域间总存在边缘，边缘处像素的灰度值不连续，这种不连续性可通过求导数来检测到，因此常用灰度的一阶或二阶微分算子进行边缘检测。直观理解如下图所示，一阶导数的峰值，二阶导数的零点值。</p><h3 id="7-2-2-Hough变换"><a href="#7-2-2-Hough变换" class="headerlink" title="7.2.2 Hough变换"></a>7.2.2 Hough变换</h3><p>原理：把直线上的点的坐标变换到过点的直线的系数域，通过利用共线和直线相交的关系，使直线的提取问题转化为计数问题</p><p><img src="/images/2021/06/image-59.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="7-3-基于阈值的图像分割"><a href="#7-3-基于阈值的图像分割" class="headerlink" title="7.3 基于阈值的图像分割"></a>7.3 基于阈值的图像分割</h4><p>确定每个像素的归属区域，从而完成分割；阈值分割法（本文介绍）、区域生长法和分裂合并法等。</p><h3 id="7-3-1-阈值分割法"><a href="#7-3-1-阈值分割法" class="headerlink" title="7.3.1 阈值分割法"></a>7.3.1 <strong>阈值分割法</strong></h3><p>基本原理：通过设定不同的特征阈值，把图像像素点分为若干类</p><ul><li>确定一个灰度阈值</li><li>将灰度值大于给定阈值的像元判归为某一个物体，赋予同一个编号</li><li>将灰度值小于给定阈值的像元统一判归为另一类物体，赋于另外一个编号。</li></ul><p><strong>适用：</strong>要分割的物体与图像的背景有较强对比度的图像。被分割的物体内部灰度值比较均一且它周围的背景灰度值也比较均一，该法效果比较理想。</p><p><strong>关键：</strong>如何找到合适的阈值。</p><p><strong>简单直方图分割法：</strong>60年代中期，Prewitt提出了直方图双峰法，即如果灰度级直方图呈明显的双峰状，则选取两峰之间的谷底所对应的灰度级作为阈值。</p><p>直方图阈值分割法可用数学表达式来描述。设图像f(i, j)，其灰度级范围为[z1, z2]，设T为阈值，是z1和z2内任一值，可得一幅二值图像，其数学表达式为:</p><p><img src="/images/2021/06/image-60.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>全局阈值的选择方法有：<strong>人工选择法，直方图技术选择法，迭代式阈值选择法，最大类间方差法</strong>。</p><h4 id="7-4-基于跟踪的图像分割"><a href="#7-4-基于跟踪的图像分割" class="headerlink" title="7.4 基于跟踪的图像分割"></a>7.4 基于跟踪的图像分割</h4><h3 id="7-4-1-轮廓跟踪法"><a href="#7-4-1-轮廓跟踪法" class="headerlink" title="7.4.1 轮廓跟踪法"></a>7.4.1 轮廓跟踪法</h3><h3 id="7-4-2-光栅跟踪法"><a href="#7-4-2-光栅跟踪法" class="headerlink" title="7.4.2 光栅跟踪法"></a>7.4.2 光栅跟踪法</h3><h4 id="7-5-基于区域的图像分割"><a href="#7-5-基于区域的图像分割" class="headerlink" title="7.5 基于区域的图像分割"></a>7.5 基于区域的图像分割</h4><h3 id="7-5-1-区域生长法"><a href="#7-5-1-区域生长法" class="headerlink" title="7.5.1 区域生长法"></a>7.5.1 区域生长法</h3><h3 id="7-5-2-分裂合并法"><a href="#7-5-2-分裂合并法" class="headerlink" title="7.5.2 分裂合并法"></a>7.5.2 分裂合并法</h3><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/18/shuzituxiang7/">https://blog.jujimeizuo.cn/2021/06/18/shuzituxiang7/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（五）计算机的运算方法</title>
      <link href="/2021/06/17/jizu5/"/>
      <url>/2021/06/17/jizu5/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-有符号数"><a href="#5-1-有符号数" class="headerlink" title="5.1 有符号数"></a>5.1 有符号数</h2><h3 id="5-1-1-原码表示法"><a href="#5-1-1-原码表示法" class="headerlink" title="5.1.1 原码表示法"></a>5.1.1 原码表示法</h3><p>原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即为真值的绝对值，故原码表示又称为带符号的绝对值表示。</p><h4 id="整数原码定义"><a href="#整数原码定义" class="headerlink" title="整数原码定义"></a><strong>整数原码定义</strong></h4><p><code>[x]_原=\left&#123;\begin&#123;matrix&#125; 0,x&amp; 2^n&gt;x&gt;0&amp; \ 2^n-x,&amp; 0\ge x&gt;-2^n &amp; \end&#123;matrix&#125;\right.</code></p><p>式中，x为真值，n为整数的位数。</p><h4 id="小数原码定义"><a href="#小数原码定义" class="headerlink" title="小数原码定义"></a><strong>小数原码定义</strong></h4><p><code>[x]_原=\left&#123;\begin&#123;matrix&#125; x,&amp; 1&gt;x \ge 0&amp; \ 1-x,&amp; 0\ge x&gt;-1 &amp; \end&#123;matrix&#125;\right.</code></p><p>当x为0时，[+0.0000]原=0.0000，[−0.0000]原=1.0000 可见原码中的“零”有两种表示形式。</p><h3 id="5-1-2-补码表示法"><a href="#5-1-2-补码表示法" class="headerlink" title="5.1.2 补码表示法"></a>5.1.2 补码表示法</h3><h4 id="补数的概念"><a href="#补数的概念" class="headerlink" title="补数的概念"></a>补数的概念</h4><p>只要确定了“模”，就可找到一个与负数灯架的整数来代替此负数，这样就可把减法运算用加法实现。</p><ol><li>一个负数可用它的正补数来代替，而这个正补数可以用模加上负数本身求得。</li><li>一个正数和一个负数互为补数时，它们绝对值之和即为模数。</li><li>正数的补数即该正数本身。</li></ol><h4 id="整数补码定义"><a href="#整数补码定义" class="headerlink" title="整数补码定义"></a>整数补码定义</h4><p><code>[x]_补=\left&#123;\begin&#123;matrix&#125; 0,x&amp; 2^n&gt;x \ge 0&amp; \ 2^&#123;n+1&#125;+x,&amp; 0&gt; x \ge -2^n (mod\;2^&#123;n+1&#125;) &amp; \end&#123;matrix&#125;\right.</code></p><h4 id="小数补码定义"><a href="#小数补码定义" class="headerlink" title="小数补码定义"></a>小数补码定义</h4><p><code>[x]_补=\left&#123;\begin&#123;matrix&#125; x&amp; 1&gt;x \ge 0&amp; \ 2+x,&amp; 0&gt;x \ge -1(mod\;2^&#123;n+1&#125;) &amp; \end&#123;matrix&#125;\right.</code></p><p>当x为0时，[+0]补=[−0]补=0.0000，即补码中的“零”只有一种表示形式。由于补码中的零只有一种表示形式，故它比原码能多表示一个“-1”。</p><p>当模数为4时，形成双符号位的补码。这种双符号位的补码又称为<strong>变形补码</strong>，它在阶码运算和溢出判断中有其特殊作用。如x&#x3D;-0.1001，对mod 22而言，</p><p>对于负数，由[x]补求[x]原和由[x]原求[x]补都可用规则<strong>除符号位外，每位求反，末尾加一</strong>。</p><p>论真值是正还是负，由[x]补求[−x]补求都是采用规则<strong>连同符号位在内，每位取反，末尾加一</strong>。</p><h3 id="5-1-3-反码表示法"><a href="#5-1-3-反码表示法" class="headerlink" title="5.1.3 反码表示法"></a>5.1.3 反码表示法</h3><p>反码同行用来作为由原码求补码或者由补码求原码的中间过渡。</p><h4 id="整数反码定义"><a href="#整数反码定义" class="headerlink" title="整数反码定义"></a>整数反码定义</h4><p><code>[x]_反=\left&#123;\begin&#123;matrix&#125; 0,x&amp; 2^n&gt;x \ge 0&amp; \ (2^&#123;n+1&#125;-1)+x,&amp; 0 \ge x &gt; -2^n (mod\;(2^&#123;n+1&#125;-1)) &amp; \end&#123;matrix&#125;\right.</code></p><h4 id="小数反码定义"><a href="#小数反码定义" class="headerlink" title="小数反码定义"></a>小数反码定义</h4><p><code>[x]_反=\left&#123;\begin&#123;matrix&#125; x&amp; 1&gt;x \ge 0&amp; \ (2-2^&#123;-n&#125;)+x,&amp; 0 \ge x &gt; -1(mod\;(2-2^&#123;-n&#125;)) &amp; \end&#123;matrix&#125;\right.</code></p><p>当x为0时，[+0.0000]反=0.0000 [−0.0000]反=(10.0000−0.0001)−0.0000&#x3D;1.1111 可见[+0]反不等于[−0]反，反码中的“零”有两种表示形式。</p><p>实际上，反码也可看作是mod(2−2−n)（对于小数）或mod（2n+1−1）（对于整数）的补码。与补码相比，仅在末尾差1，故也称小数的补码为2的补码，小数的反码为1的补码。</p><p>对于负数，由[x]反求[x]原和由[x]原求[x]反都可用规则<strong>除符号位外，每位求反</strong>。</p><blockquote><p>三种机器数的特点可归纳如下：</p><ul><li>三种机器数的最高位均为符号位。符号位和数值部分之间可用“.”(对于小数)或“,”（对于整数）隔开</li><li>当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同。</li><li>当真值为负时，原码、补码和反码的表示形式不同，但其符号位用“1”表示，而数值部分有这样的关系：<strong>补码是原码的“求反加一”，反码是原码的“每位求反”</strong>。</li></ul></blockquote><h3 id="5-1-4-移码表示法"><a href="#5-1-4-移码表示法" class="headerlink" title="5.1.4 移码表示法"></a>5.1.4 移码表示法</h3><h4 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h4><p>[x]移=2n+x(2n&gt;x≥-2n)</p><p>其实移码就是在真值上加一个常数2n。在数轴上移码所表示的范围恰好对应于真值在数轴上的范围向轴的正方向移动2n个单元，故称为移码。</p><p>当x为0时，[+0]移=[−0]移=1.0000，即移码中的“零”只有一种表示形式，故它比原码能多表示一个负数。</p><p>移码的最小真值为全0。利用移码的这一特点，当浮点数的阶码用移码表示时，就能很方便地判断阶码的大小。</p><p>同一个真值的移码和补码仅差一个符号位，若将补码的符号位由“0”改为“1”或从“1”改为“0”，即可得该真值的移码。</p><h2 id="5-2-数的定点表示和浮点表示"><a href="#5-2-数的定点表示和浮点表示" class="headerlink" title="5.2 数的定点表示和浮点表示"></a>5.2 数的定点表示和浮点表示</h2><p>共有两种方法表示小数点的存在，即定点表示和浮点表示。定点表示的数称为<strong>定点数</strong>，浮点表示的数称为<strong>浮点数</strong>。</p><h3 id="5-2-1-定点表示"><a href="#5-2-1-定点表示" class="headerlink" title="5.2.1 定点表示"></a>5.2.1 定点表示</h3><p>小数点在某一位置的数为<strong>定点数</strong>，有以下两种格式。</p><p><img src="/images/2021/06/image-40.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>当小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。采用定点数的机器称为定点机。数值部分的位数n决定了定点机中数的表示范围。若机器数采用原码，小数定点机中的数的表示范围是−(1−2−n)<del>(1−2−n)，整数定点机中数的表示范围是−(2n−1)</del>(2n−1)。 在定点机中，由于小数点的位置固定不定，故当机器处理的数不是纯小数或纯整数时，必须乘上一个<strong>比例因子</strong>，否则会产生“溢出”。</p><h3 id="5-2-2-浮点表示"><a href="#5-2-2-浮点表示" class="headerlink" title="5.2.2 浮点表示"></a>5.2.2 浮点表示</h3><p><strong>浮点数</strong>即小数点的位置可以浮动的数。</p><p>通常浮点数被表示成</p><p>N&#x3D;S×rj</p><p>式中，S为尾数，j为阶码，r是基数。在计算机中，基数可取2、4、8、16等。 为了提高数据精度以及便于浮点数的比较，在计算机中规定浮点数的尾数用纯小数形式。将尾数最高位为1的浮点数称为 <strong>规格化数</strong>。浮点数表示成规格化形式后，其精度最高。</p><h3 id="5-2-3-浮点数的表示形式"><a href="#5-2-3-浮点数的表示形式" class="headerlink" title="5.2.3 浮点数的表示形式"></a>5.2.3 浮点数的表示形式</h3><p>采用这种数据格式的机器称为<strong>浮点机</strong>。</p><p><img src="/images/2021/06/image-41.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>浮点数由阶码j和尾数S两部分组成。阶码是整数，阶符和阶码的位数m合起来反映浮点数的表示范围及小数点的实际位置；尾数是小数，其位数n反映了浮点数的精度；尾数的符号Sf代表浮点数的正负。</p><h3 id="5-2-4-浮点数的表示范围"><a href="#5-2-4-浮点数的表示范围" class="headerlink" title="5.2.4 浮点数的表示范围"></a>5.2.4 浮点数的表示范围</h3><p>设浮点数阶码的数值位取m位，尾数的数值位取n位，当浮点数为非规格化数时，它在数轴上的表示范围如下。</p><p><img src="/images/2021/06/image-42.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>最大正数为22m−1×(1−2−n)；最小正数为2(-2m−1)×2−n；最大负数为−2(-2m−1)×2−n；最小负数为−22m−1×(1−2−n)。</p><p>当浮点数阶码大于最大阶码时，称为上溢，此时机器停止运算，进行中断溢出处理；当浮点数阶码小于最小阶码时，称为下溢，此时溢出的数绝对值很小，通常将尾数各位强置为0，按机器零处理，此时机器可以继续运行。</p><p>一旦浮点数的位数确定后，合理分配阶码和尾数的位数，直接影响浮点数的表示范围和精度。对于短实数（总位数为32位），阶码取8位（含阶符1位），尾数取24位（含数符1位）；对于长实数（总位数为64位），阶码取11位（含阶符1位），尾数取53位（含数符1位）；对于临时实数（总位数为80位），阶码取15位（含阶符1位），尾数取65位（含数符1位）。</p><p>当一个浮点数尾数为0时，不论其阶码为何值；或阶码等于或小于它所能表示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为机器零。如果浮点数的阶码用移码表示，尾数用补码表示，则当阶码为它所能表示的最小数2−m且尾数为0时，其阶码（移码）全为0，尾数（补码）也全为0，这样的机器零为000…00000，全零表示有利于简化机器中判“0”电路。</p><h3 id="5-2-4-浮点数的规格化"><a href="#5-2-4-浮点数的规格化" class="headerlink" title="5.2.4 浮点数的规格化"></a>5.2.4 浮点数的规格化</h3><p>将非规格化数转换成规格化数的过程称为规格化。对于技术不同的浮点数，因其规格化数的形式不同，规格化过程也不同。</p><ol><li>当基数为2时，尾数最高位为1的数为规格化数。规格化时，尾数左移一位，阶码减1（称为左规）；尾数右移一位，阶码加1（称为右规）。</li><li>当基数为4时，尾数最高两位不全为零的数为规格化数。规格化时，尾数左移两位，阶码减1；尾数右移两位，阶码加1。</li><li>当基数为8时，尾数最高三位不全为零的数为规格化数。规格化时，尾数左移三位，阶码减1；尾数右移三位，阶码加1。</li></ol><p>一般来说，基数r越大，可表示的浮点数范围越大，而且所表示的数的个数也越多。但r越多，浮点数的精度反而下降。</p><h2 id="5-3-定点数和浮点数的比较"><a href="#5-3-定点数和浮点数的比较" class="headerlink" title="5.3 定点数和浮点数的比较"></a>5.3 定点数和浮点数的比较</h2><ul><li>当浮点机和定点机中数的位数相同时，浮点数的表示范围比定点数大得多。</li><li>当浮点数为规格化数时，其相对精度远比定点数高。</li><li>浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。</li><li>在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。</li></ul><p>浮点数在数的表示范围、数的精度、溢出处理和程序编程方面（不取比例因子）均优于定点数。到哪在运算规则、运算速度及硬件成本方面又不如定点数。</p><h2 id="5-4-IEEE-754标准"><a href="#5-4-IEEE-754标准" class="headerlink" title="5.4 IEEE 754标准"></a>5.4 IEEE 754标准</h2><p>浮点数一般采用IEEE指定的国际标准，这种标注形式如下。</p><p><img src="/images/2021/06/image-43.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>按IEEE标准，常用的浮点数有三种：</p><p><img src="/images/2021/06/image-44.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><strong>阶码用移码表示</strong>，阶码的真值都被加上一个常数（偏移量），如短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH、3FFH、3FFFH。尾数部分通常都是规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式。</p><p>1♠ffff……fff</p><p>其中 ♠表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称 <strong>隐藏位</strong>；对于临时实数不采用隐藏位方案。</p><p><img src="/images/2021/06/image-45.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h2 id="5-5-定点运算"><a href="#5-5-定点运算" class="headerlink" title="5.5 定点运算"></a>5.5 定点运算</h2><h3 id="5-5-1-移位运算"><a href="#5-5-1-移位运算" class="headerlink" title="5.5.1 移位运算"></a>5.5.1 移位运算</h3><h4 id="移位的意义"><a href="#移位的意义" class="headerlink" title="移位的意义"></a>移位的意义</h4><p>二进制表示的机器数在相对于小数点作n位左移或右移时，其实质就是该数乘以或除以2n。当某计算机没有乘除法运算线路时，可以采用移位和加法相结合，实现乘除运算。</p><p>计算机中机器数的字长往往是固定的，当机器数左移n位或右移n位时，必然会使其n位低位或n位高位出现空位。对有符号数的移位称为算数移位。</p><h4 id="算数移位的规则"><a href="#算数移位的规则" class="headerlink" title="算数移位的规则"></a>算数移位的规则</h4><p>对于正数，由于[x]原=[x]补=[x]反=真值，故移位后出现的空位均以0添之。对于负数，由于原码、补码和反码的表示形式不同，故当机器数移位时，对其空位的填补规则也不同。 <strong>不论是整数还是负数，移位后其符号位均不变。</strong></p><p><img src="/images/2021/06/image-46.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><ol><li>机器数为正时，不论是左移还是右移，添补的代码均为0.</li><li>由于负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添0即可。</li><li>由于负数的反码各位除符号位外与负数的原码正好相反，故移位后所舔代码应与原码相反，即全部添1。</li><li>负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则填补的代码应与反码相同，即添1。</li></ol><p>对于正数，三种机器数移位后符号位均不变，左移时最高数位丢1，结果出错；右移时最低数位丢1，影响精度。</p><p>对于负数，三种机器数算术移位后符号位均不变。负数的原码左移时，高位丢1，结果出错；右移时，低位丢1，影响精度。负数的补码左移时，高位丢0，结果出错；右移时，低位丢1，影响精度。负数的反码左移时，高位丢0，结果出错；右移时，低位丢0，影响精度。</p><h4 id="算数移位和逻辑移位的区别"><a href="#算数移位和逻辑移位的区别" class="headerlink" title="算数移位和逻辑移位的区别"></a>算数移位和逻辑移位的区别</h4><p>有符号数的移位称为<strong>算数移位</strong>，无符号数的移位称为<strong>逻辑移位</strong>。逻辑移位的规则是：<strong>逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。</strong>为了避免算术左移时最高数位丢1，可采用带进位（Cy）的移位。算术左移时，符号位移至Cy，最高数位就可避免移丢。</p><h3 id="5-5-2-加法与减法运算"><a href="#5-5-2-加法与减法运算" class="headerlink" title="5.5.2 加法与减法运算"></a>5.5.2 加法与减法运算</h3><h4 id="补码加法运算的基本公式"><a href="#补码加法运算的基本公式" class="headerlink" title="补码加法运算的基本公式"></a>补码加法运算的基本公式</h4><p><img src="/images/2021/06/B5835E24-2341-425E-BB10-EE866F9A69FE.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="补码减法运算的基本公式"><a href="#补码减法运算的基本公式" class="headerlink" title="补码减法运算的基本公式"></a>补码减法运算的基本公式</h4><p><img src="/images/2021/06/75AED03B-5911-4E6D-A63F-C27DC678BFDA.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><h5 id="用一位符号位判断溢出"><a href="#用一位符号位判断溢出" class="headerlink" title="用一位符号位判断溢出"></a>用一位符号位判断溢出</h5><p>只要实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出。</p><h5 id="用两位符号位判断溢出"><a href="#用两位符号位判断溢出" class="headerlink" title="用两位符号位判断溢出"></a>用两位符号位判断溢出</h5><p>2为符号位的补码，即变形补码，它是以4为模的，其定义为</p><p><code>[x]_&#123;补&#125;=\left\&#123;\begin&#123;matrix&#125; x&amp; 1&gt;x \ge 0&amp; \\ 4+x,&amp; 0&gt; x \ge -1 (mod\;4) &amp; \end&#123;matrix&#125;\right.</code></p><p>在用变形补码作加法时，2位符号位要连同数值部分一起参加运算，而且高位符号位产生的进位自动丢失，便可得正确结果，即</p><p>[x]补’+[y]补’=[x+y]补’(mod 4)</p><p>变形补码判断溢出的原则是： <strong>当2位符号位不同时，表示溢出，否则无溢出。</strong>不论是否发生溢出，高位（第1位）符号位永远代表真正的符号。</p><h4 id="补码加减运算控制流程"><a href="#补码加减运算控制流程" class="headerlink" title="补码加减运算控制流程"></a>补码加减运算控制流程</h4><p><img src="/images/2021/06/image-47.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="5-5-3-乘法运算"><a href="#5-5-3-乘法运算" class="headerlink" title="5.5.3 乘法运算"></a>5.5.3 乘法运算</h3><h4 id="笔算乘法的改进"><a href="#笔算乘法的改进" class="headerlink" title="笔算乘法的改进"></a>笔算乘法的改进</h4><p>两数相乘的过程，可视为加法和移位两种运算。</p><p>例：设A&#x3D;0.1101，B&#x3D;0.1011，求A×B。</p><p><img src="/images/2021/06/image-48.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>运算规则如下：</p><ul><li>乘法运算可用移位和加法来实现，两个4位数相乘，总共需要4次加法运算和4次移位。</li><li>由乘数的末尾值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时乘数也右移一位，由次低位作为新的末位，空出最高位放部分积的最低位。</li><li>每次作加法时，被乘数仅仅与原部分积的高位相加，其低位被移至成乘数所空出的高位位置。</li></ul><p>用一个寄存器存放被乘数，一个寄存器存放乘积的高位，另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。</p><h4 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h4><p>上述讨论结果可直接用于原码一位乘，只需加上符号位处理即可。</p><h5 id="原码一位乘运算原则"><a href="#原码一位乘运算原则" class="headerlink" title="原码一位乘运算原则"></a>原码一位乘运算原则</h5><p>以小数为例： 设  [x]原=x0.x1x2…xn [y]原=y0.y1y2…yn</p><p>则[x]原⋅[y]原=x0⊕y0.(0.x1x2…xn)(0.y1y2…yn) 式中，0.x1x2…xn为x的绝对值，记作x*；0.y1y2…yn为y的绝对值，记作y∗。</p><p>原码一位乘运算规则：</p><ul><li>乘积的符号位由两原码符号位异或运算结果决定。</li><li>乘积的数值部分由两数绝对值相乘，其通式为：x∗⋅y∗=2−1(y1x∗+(…+2−1(yn−1x∗+2−1(ynx∗+0))…))</li></ul><h5 id="例：已知x-0-1110，y-0-1101，求-x⋅y-原。"><a href="#例：已知x-0-1110，y-0-1101，求-x⋅y-原。" class="headerlink" title="例：已知x&#x3D;-0.1110，y&#x3D;-0.1101，求[x⋅y]原。"></a>例：已知x&#x3D;-0.1110，y&#x3D;-0.1101，求[x⋅y]原。</h5><p><img src="/images/2021/06/image-49.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>故[x⋅y]原=0.10110110</p><h4 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h4><p><img src="/images/2021/06/05F7859F-4788-4F3B-97E0-0D9172E88BEB.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h5 id="例：已知-x-补-1-0101，-y-补-0-1101，求-x⋅y-补。"><a href="#例：已知-x-补-1-0101，-y-补-0-1101，求-x⋅y-补。" class="headerlink" title="例：已知[x]补=1.0101，[y]补=0.1101，求[x⋅y]补。"></a>例：已知[x]补=1.0101，[y]补=0.1101，求[x⋅y]补。</h5><p><img src="/images/2021/06/image-50.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>故乘积[x⋅y]补=1.01110001。</p><h4 id="Booth算法"><a href="#Booth算法" class="headerlink" title="Booth算法"></a>Booth算法</h4><p><img src="/images/2021/06/FCB3A323-8652-4E7B-B48A-9B8D25765330.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h5 id="例：已知-x-补-0-1101，-y-补-0-1011，求-x⋅y-补。"><a href="#例：已知-x-补-0-1101，-y-补-0-1011，求-x⋅y-补。" class="headerlink" title="例：已知[x]补=0.1101，[y]补=0.1011，求[x⋅y]补。"></a>例：已知[x]补=0.1101，[y]补=0.1011，求[x⋅y]补。</h5><p><img src="/images/2021/06/image-51.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>故[x⋅y]补=0.10001111。</p><h3 id="5-5-3-除法运算"><a href="#5-5-3-除法运算" class="headerlink" title="5.5.3 除法运算"></a>5.5.3 除法运算</h3><h4 id="分析笔算除法"><a href="#分析笔算除法" class="headerlink" title="分析笔算除法"></a>分析笔算除法</h4><p>特点可归纳如下：</p><ul><li>每次上商都是由心算来比较余数（被除数）和除数的大小，确定商为“1”还是为“0”。</li><li>每做一次减法，总是保持余数不懂，低位补0，再减去右移后的除数。</li><li>上商的位置不固定。</li><li>商符单独处理。</li></ul><p>上述规则若照搬到计算机里实现有一定困难：</p><ul><li>机器不能“心算”上商，必须通过比较被除数（或余数）和除数绝对值大小来确定商值。</li><li>按照每次减法总是保持余数不懂低位补0，再减去右移后的除数这一规则，在要求加法器的位数必须为除数的两倍。</li><li>笔算求商时是从高位向低位逐位求的，而要求机器把每位商直接写到寄存器的不同位置也是不可取的。</li></ul><h4 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h4><p>小数定点除法对被除数和除数有一定的约束，即必须满足下列条件：</p><ul><li>0&lt;被除数≤除数</li></ul><p>实现除法运算时，还应避免除数为0或被除数为0。 原码除法中由于对余数的处理不同，又可分为 恢复余数法和 不恢复余数法（加减交替法）两种。</p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><p>特点是：当余数为负时，需加上除数，将其恢复成原来的余数。</p><p>例：已知x=−0.1011，y=−0.1101，求[x&#x2F;y]原。</p><p><img src="/images/2021/06/image-52.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>故商值为0.1101，商的符号位为x0⊕y0=1⊕1=0，故[x&#x2F;y]原=0.1101。</p><p>第一次上的商在商的整数位上，这对小数除法而言，可用它作溢出判断。即当该位为“1”时，表示此除法溢出，不能进行，应由程序进行处理；当该位为“0”时，说明除法合法，可以进行。 在恢复余数法中，每当余数为负时，都需恢复余数，这就延长了机器出发的时间，操作也很不规则，对线路结构不利。加减交替法可克服这些缺点。</p><h5 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h5><p>加减交替法又称为不恢复余数法，可以认为它是恢复余数法的一种改进算法。</p><p>分析原码恢复余数法得知：</p><ul><li>当余数Ri&gt;0时，可上商“1”，再对Ri左移一位后减除数，即2Ri−y∗。</li><li>当余数Ri&lt;0时，可上商“0”，然后先做Ri+y∗，即完成恢复余数的运算，再做2(Ri+y∗)−y∗，即2Ri+y∗。</li></ul><p>故原码恢复余数法可归纳为：</p><ul><li>当Ri&gt;0时，上商“1”，做2Ri−y∗的运算。</li><li>当Ri&lt;0时，上商“0”，做2Ri+y∗的运算。</li></ul><p>例：已知x=−0.1011，y=−0.1101，求[x&#x2F;y]原。</p><p><img src="/images/2021/06/image-53.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>故商值为0.1101，商的符号位为x0⊕y0=1⊕0=1，故[x&#x2F;y]原=1.1101。</p><h4 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h4><h5 id="补码加减交替法运算规则"><a href="#补码加减交替法运算规则" class="headerlink" title="补码加减交替法运算规则"></a>补码加减交替法运算规则</h5><p>补码除法的符号位和数值部分是一起参加运算的。 <strong>1.欲确定商值，必须先比较被除数和除数的大小，然后才能求得商值。</strong> 比较被除数和除数的大小</p><ul><li>当被除数与除数同号时，做减法，若得到的余数与除数同号，表示“够减”，否则表示“不够减”。</li><li>当被除数与除数异号时，做加法，若得到的余数与除数同号，表示“够减”，否则表示“不够减”。</li></ul><p><img src="/images/2021/06/image-54.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>商值的确定</p><ul><li>如果[x]补与[y]补同号，商为正，则“够减”时上商“1”，“不够减”时上商“0”。</li><li>如果[x]补与[y]补异号，商为负，则“够减”时上商“0”，“不够减”时上商“1”。</li></ul><p><strong>2.在补码除法中，商符是在求商的过程中自动形成的。</strong></p><p><strong>3.新余数[Ri+1]补的获得方法与原码加减交替法极相似</strong></p><p>例：已知x=0.1001，y=0.1101，求[x&#x2F;y]补。</p><p><img src="/images/2021/06/image-55.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>所以[x&#x2F;y]补=0.1011。</p><h2 id="5-6-浮点四则运算"><a href="#5-6-浮点四则运算" class="headerlink" title="5.6 浮点四则运算"></a>5.6 浮点四则运算</h2><p><img src="/images/2021/06/71A0406B-20D9-4D80-98BE-02E695E0FCFF.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="5-6-1-浮点加减运算"><a href="#5-6-1-浮点加减运算" class="headerlink" title="5.6.1 浮点加减运算"></a>5.6.1 浮点加减运算</h3><p>浮点数加减运算必须按以下几步进行：</p><ol><li>对阶，使两数的小数点位置对齐。</li><li>尾数求和，将对阶后的两尾数按定点加减运算规则求和（差）。</li><li>规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。</li><li>舍入，为提高精度，要考虑尾数右移时丢失的数值位。</li><li>溢出判断，即判断结果是否溢出。</li></ol><h3 id="5-6-2-浮点乘除法运算"><a href="#5-6-2-浮点乘除法运算" class="headerlink" title="5.6.2 浮点乘除法运算"></a>5.6.2 浮点乘除法运算</h3><p><img src="/images/2021/06/image-56.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="阶码运算"><a href="#阶码运算" class="headerlink" title="阶码运算"></a>阶码运算</h4><h4 id="尾数运算"><a href="#尾数运算" class="headerlink" title="尾数运算"></a>尾数运算</h4><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h2><blockquote><p><img src="/images/2021/06/481B6F94FE975A975197523BC7B72FBB.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/4DF787DD-4AC7-4C39-8B30-4F32AD558C76.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>6.5 已知[x]补，求[x]原和x。</p><p>[x1]补=1.1100;  [x2]补=1.1001;  [x3]补=0.1110;  [x4]补=1.0000;</p><p>[x5]补=1,0101;  [x6]补=1,1100;  [x7]补=0,0111;  [x8]补=1,0000</p><p>[x]补与[x]原、x的对应关系如下：</p><p>[x]补</p><p>1.1100</p><p>1.1001</p><p>0.1110</p><p>1.0000</p><p>1,0101</p><p>1,1100</p><p>0,0111</p><p>1,0000</p><p>[x]原</p><p>1.0100</p><p>1.0111</p><p>0.1110</p><p>无</p><p>1,1011</p><p>1,0100</p><p>0,0111</p><p>无</p><p>x</p><p>-0.0100</p><p>-0.0111</p><p>0.1110</p><p>-1</p><p>-1011</p><p>-100</p><p>0,0111</p><p>-10000</p></blockquote><p> </p><blockquote><p>6.11 已知机器数字长为4位（含1位符号位），写出整数定点机和小数定点机中原码、补码和反码的全部形式，并注明其对应的十进制真值。</p><p>整数定点机</p><p>小数定点机</p><p>原码</p><p>补码</p><p>反码</p><p>真值</p><p>原码</p><p>补码</p><p>反码</p><p>真值</p><p>0,000</p><p>0,000</p><p>0,000</p><p>+0</p><p>0.000</p><p>0.000</p><p>0.000</p><p>+0</p><p>0,001</p><p>0,001</p><p>0,001</p><p>1</p><p>0.001</p><p>0.001</p><p>0.001</p><p>0.125</p><p>0,010</p><p>0,010</p><p>0,010</p><p>2</p><p>0.010</p><p>0.010</p><p>0.010</p><p>0.250</p><p>0,011</p><p>0,011</p><p>0,011</p><p>3</p><p>0.011</p><p>0.011</p><p>0.011</p><p>0.375</p><p>0,100</p><p>0,100</p><p>0,100</p><p>4</p><p>0.100</p><p>0.100</p><p>0.100</p><p>0.500</p><p>0,101</p><p>0,101</p><p>0,101</p><p>5</p><p>0.101</p><p>0.101</p><p>0.101</p><p>0.625</p><p>0,110</p><p>0,110</p><p>0,110</p><p>6</p><p>0.110</p><p>0.110</p><p>0.110</p><p>0.750</p><p>0,111</p><p>0,111</p><p>0,111</p><p>7</p><p>0.111</p><p>0.111</p><p>0.111</p><p>0.875</p><p>1,000</p><p>0,000</p><p>1,111</p><p>-0</p><p>1.000</p><p>0.000</p><p>1.111</p><p>-0</p><p>1,001</p><p>1,111</p><p>1,110</p><p>-1</p><p>1.001</p><p>1.111</p><p>1.110</p><p>-0.125</p><p>1,010</p><p>1,110</p><p>1,101</p><p>-2</p><p>1.010</p><p>1.110</p><p>1.101</p><p>-0.250</p><p>1,011</p><p>1,101</p><p>1,100</p><p>-3</p><p>1.011</p><p>1.101</p><p>1.100</p><p>-0.375</p><p>1,100</p><p>1,100</p><p>1,011</p><p>-4</p><p>1.100</p><p>1.100</p><p>1.011</p><p>-0.500</p><p>1,101</p><p>1,011</p><p>1,010</p><p>-5</p><p>1.101</p><p>1.011</p><p>1.010</p><p>-0.625</p><p>1,110</p><p>1,010</p><p>1,001</p><p>-6</p><p>1.110</p><p>1.010</p><p>1.001</p><p>-0.750</p><p>1,111</p><p>1,001</p><p>1,000</p><p>-7</p><p>1.111</p><p>1.001</p><p>1.000</p><p>-0.875</p><p>无</p><p>1,000</p><p>无</p><p>-8</p><p>无</p><p>1.000</p><p>无</p><p>-1</p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/732D658E-6A92-4FD6-8132-69FEC87BE802.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/958ADDA5-10FD-4D21-A717-65D6F5012EC6.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>6.20 用原码一位乘、两位乘和补码一位乘（Booth算法）、两位乘计算x·y。</p><p>（1）x&#x3D; 0.110 111，y&#x3D; -0.101 110；</p><p>（2）x&#x3D; -0.010 111，y&#x3D; -0.010 101；</p><p>（3）x&#x3D; 19，y&#x3D; 35；</p><p>（4）x&#x3D; 0.110 11，y&#x3D; -0.111 01。</p></blockquote><p> </p><blockquote><p>6.27 </p><p><img src="/images/2021/06/ECD3F4E1-7DB6-4B56-B4B7-FAD58240D999.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>（1）</p><p>x&#x3D;2101*0.101100.      y&#x3D;2100*(-0.100100).</p><p>[x]补=00,101;00.101100.  [y]补=00,100;1.011100</p><p>1)对阶</p><p>[E]补=[Jx]补+[-Jy]补=00,101+11,100&#x3D;00,001&gt;0</p><p>应Jy向Jx对齐，则</p><p>[Jy]补=00,100+00,001&#x3D;[Jx]补</p><p>[y]补=00,101;11.101110</p><p>2)尾数运算</p><p>[Sx]补+[Sy]补=00.101100+11.101110&#x3D;00.011010&gt;0</p><p>3)规格化</p><p>左规1位，阶码减1</p><p>4)舍入：无</p><p>5)溢出：无</p><p>则x+y&#x3D;2100*0.110100&#x3D;24*(13&#x2F;16)</p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/17/jizu5/">https://blog.jujimeizuo.cn/2021/06/17/jizu5/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（五）频率域图像处理</title>
      <link href="/2021/06/17/shuzituxiang5/"/>
      <url>/2021/06/17/shuzituxiang5/</url>
      
        <content type="html"><![CDATA[<h4 id="5-1-图像变换"><a href="#5-1-图像变换" class="headerlink" title="5.1 图像变换"></a>5.1 图像变换</h4><p>将图像从空间2D平面变换到频率域，目的是更具图像在频率域中的某些性质对图像进行处理。</p><h3 id="5-1-1-傅立叶变换"><a href="#5-1-1-傅立叶变换" class="headerlink" title="5.1.1 傅立叶变换"></a>5.1.1 傅立叶变换</h3><h4 id="一维傅立叶变换"><a href="#一维傅立叶变换" class="headerlink" title="一维傅立叶变换"></a>一维傅立叶变换</h4><p><img src="/images/2021/06/039736FC-7200-4336-804D-F51D50A62E40.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="二维傅立叶变换"><a href="#二维傅立叶变换" class="headerlink" title="二维傅立叶变换"></a>二维傅立叶变换</h4><p><img src="/images/2021/06/AF0586B8-7401-4B68-A963-912543AB90D6.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="5-2-频率域图像处理"><a href="#5-2-频率域图像处理" class="headerlink" title="5.2 频率域图像处理"></a>5.2 频率域图像处理</h4><p>在频率域，图像信息表现为不同频率的组合</p><p>如果让某些频率的分量受到抑制，而其他的频率分量保持不变，则可以改变输出图像的频率分布，从而达到不同的增强目的。</p><p>频率域增强有三个步骤：</p><ol><li>将图像从图像空间转换成频率空间</li><li>在频域进行一些操作，以达到增强的目的</li><li>将增强后的图像从频率域转换成空间域</li></ol><p>频域技术的基础是<strong>卷积</strong>。</p><p><img src="/images/2021/06/EDD0C800-F83B-4316-9CC7-E41AFD0819D3.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>代表空间域的卷积相当于频率域的乘积。因此可以在频率域中直接设计滤波器，对信号进行加强。</p><p><img src="/images/2021/06/image-39.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="5-3-基于频率域的图像噪声消除——频率域低通滤波"><a href="#5-3-基于频率域的图像噪声消除——频率域低通滤波" class="headerlink" title="5.3 基于频率域的图像噪声消除——频率域低通滤波"></a>5.3 基于频率域的图像噪声消除——频率域低通滤波</h4><p><strong>频率域中的低通滤波与空间域的平滑处理类似。</strong></p><p>低通滤波器：能抑制高频成分幅度的滤波器。</p><ul><li>图像的边缘和噪声都对应傅立叶频谱的高频成分</li><li>频率域中的低通滤波可以去除或削弱噪声的影响，但同时也会模糊边缘细节，降低图像的清晰程度</li></ul><h3 id="5-3-1-理想低通滤波器"><a href="#5-3-1-理想低通滤波器" class="headerlink" title="5.3.1 理想低通滤波器"></a>5.3.1 理想低通滤波器</h3><p><img src="/images/2021/06/E88C5C16-BF58-4891-A276-59394127EFE0.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="5-3-2-巴特沃斯低通滤波器"><a href="#5-3-2-巴特沃斯低通滤波器" class="headerlink" title="5.3.2 巴特沃斯低通滤波器"></a>5.3.2 巴特沃斯低通滤波器</h3><p><img src="/images/2021/06/35906C8E-9202-4890-8979-08D4EBD3E54A.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>当H(u，v)&#x3D;0.5时，他的特性是传递函数比较光滑，连续性衰减，不陡峭，采用这个滤波器平滑抑制噪声时，图像的边缘模糊程度大大减小，没有振铃效应。</p><h3 id="5-3-3-高斯低通滤波器"><a href="#5-3-3-高斯低通滤波器" class="headerlink" title="5.3.3 高斯低通滤波器"></a>5.3.3 高斯低通滤波器</h3><h3 id="5-3-4-梯形低通滤波器"><a href="#5-3-4-梯形低通滤波器" class="headerlink" title="5.3.4 梯形低通滤波器"></a>5.3.4 梯形低通滤波器</h3><p><img src="/images/2021/06/D5CA54EB-F42C-41BF-9ACB-4299CAAE7D56.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="5-3-5-指数低通滤波器"><a href="#5-3-5-指数低通滤波器" class="headerlink" title="5.3.5 指数低通滤波器"></a>5.3.5 指数低通滤波器</h3><p><img src="/images/2021/06/E96DF0E3-DFF7-4AF6-9296-8D736B5E8CCA.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="5-4-基于频率域的图像增强——频率域高通滤波"><a href="#5-4-基于频率域的图像增强——频率域高通滤波" class="headerlink" title="5.4 基于频率域的图像增强——频率域高通滤波"></a>5.4 基于频率域的图像增强——频率域高通滤波</h4><p><strong>频率域中的高通滤波与空间域的锐化处理类似。</strong></p><p>图像的边缘对应高频分量，锐化图像就需要使用高通滤波器。</p><p>高通滤波器保留图像的高频成分，除去低频成分。</p><p>如果Hlp(u,v)是一个低通滤波器，对应的高通滤波器可以是Hhp(u,v)&#x3D;1-Hlp(u,v)</p><h3 id="5-4-1-理想高通滤波器"><a href="#5-4-1-理想高通滤波器" class="headerlink" title="5.4.1 理想高通滤波器"></a>5.4.1 理想高通滤波器</h3><p><img src="/images/2021/06/C5D9CF87-9AD0-40C3-9468-729BFB4A5106.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="5-4-2-巴特沃斯高通滤波器"><a href="#5-4-2-巴特沃斯高通滤波器" class="headerlink" title="5.4.2 巴特沃斯高通滤波器"></a>5.4.2 巴特沃斯高通滤波器</h3><p><img src="/images/2021/06/A2E9B5A3-9EB3-4DC8-8240-71BD71B43273.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="5-4-3-高斯高通滤波器"><a href="#5-4-3-高斯高通滤波器" class="headerlink" title="5.4.3 高斯高通滤波器"></a>5.4.3 高斯高通滤波器</h3><h4 id="5-5-带阻滤波和带通滤波"><a href="#5-5-带阻滤波和带通滤波" class="headerlink" title="5.5 带阻滤波和带通滤波"></a>5.5 带阻滤波和带通滤波</h4><p>带阻滤波器阻止一定频率范围内的信号，允许其他频率范围的信号通过。</p><p>带通滤波器允许一定频率范围内的信号通过，阻止其他频率范围的信号。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/17/shuzituxiang5/">https://blog.jujimeizuo.cn/2021/06/17/shuzituxiang5/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（四）空间域图像增强</title>
      <link href="/2021/06/17/shuzituxiang4/"/>
      <url>/2021/06/17/shuzituxiang4/</url>
      
        <content type="html"><![CDATA[<h4 id="4-1-图像增强概述"><a href="#4-1-图像增强概述" class="headerlink" title="4.1 图像增强概述"></a>4.1 图像增强概述</h4><p>目的：<strong>改善图像清晰度，将图像转换成一种更适合人活着机器进行分析处理的形式</strong>。</p><p>抑制没有用的信息，提高图像使用价值。</p><p><img src="/images/2021/06/image-38.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-2-基于点运算的图像增强方法"><a href="#4-2-基于点运算的图像增强方法" class="headerlink" title="4.2 基于点运算的图像增强方法"></a>4.2 基于点运算的图像增强方法</h4><p>请看上节<a href="http://121.196.156.71/blog/wordpress/index.php/2021/06/16/shuzituxiang3/">数字图像的基本运算之点运算</a></p><h4 id="4-3-基于直方图的图像增强方法"><a href="#4-3-基于直方图的图像增强方法" class="headerlink" title="4.3 基于直方图的图像增强方法"></a>4.3 基于直方图的图像增强方法</h4><p>通过图像灰度直方图均衡化处理,使得图像的灰度分布趋向均匀,图像所占有的像素灰度间距拉开,加大了图像反差，改善视觉效果,达到增强目的。</p><p>主要的两个操作：<strong>直方图均衡化、直方图规定化</strong></p><h3 id="4-3-1-直方图均衡化"><a href="#4-3-1-直方图均衡化" class="headerlink" title="4.3.1 直方图均衡化"></a>4.3.1 直方图均衡化</h3><p>主要用于增强动态范围偏小的图像的对比度；</p><p>基本思想：<strong>对图像施加一种变换，使得变换后的图像的直方图成为均匀分布的形式。</strong></p><p>p53 例4.2.1</p><h3 id="4-3-2-直方图规定化"><a href="#4-3-2-直方图规定化" class="headerlink" title="4.3.2 直方图规定化"></a>4.3.2 直方图规定化</h3><p>直方图均衡方法能显著地增强图像的对比度，但其增强效果不易控制</p><p>在实际应用中，希望可以人为地改变直方图形状，使之成为某个特定的形状</p><p>p58 例4.2.2</p><h4 id="4-4-空间滤波"><a href="#4-4-空间滤波" class="headerlink" title="4.4 空间滤波"></a>4.4 空间滤波</h4><p>利用像素本身以及邻域像素的灰度进行增强的方法一般称作滤波。</p><p>滤波一般作为一种与处理方法，即通过对某个像素邻域内的像素进行某种计算，得到该像素的一个滤波值。</p><h4 id="4-5-线性滤波：模板卷积"><a href="#4-5-线性滤波：模板卷积" class="headerlink" title="4.5 线性滤波：模板卷积"></a>4.5 线性滤波：模板卷积</h4><p><img src="/images/2021/06/6990A4A5-BAB2-49FB-93C6-3E4D1F98A51A.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-6-基于空间平滑滤波的图像增强方法"><a href="#4-6-基于空间平滑滤波的图像增强方法" class="headerlink" title="4.6 基于空间平滑滤波的图像增强方法"></a>4.6 基于空间平滑滤波的图像增强方法</h4><ol><li>以抑制噪声为主要目的的预处理算法</li><li>运算的本质是在像素邻域范围内的灰度值的（加权）平均</li><li>平滑滤波会引入边缘模糊，使图像的清晰度下降，所以研究边缘保持的平滑滤波是有意义的</li><li>平滑滤波对抑制冲激噪声和细斑纹非常有效，但对大的块状噪声和粗条纹无效</li></ol><h3 id="4-6-1-邻域平均法"><a href="#4-6-1-邻域平均法" class="headerlink" title="4.6.1 邻域平均法"></a>4.6.1 邻域平均法</h3><p><img src="/images/2021/06/138D1E5C-CA39-4C26-B8CF-D0FB7DE76D43.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-7-基于空间锐化滤波的图像增强方法"><a href="#4-7-基于空间锐化滤波的图像增强方法" class="headerlink" title="4.7 基于空间锐化滤波的图像增强方法"></a>4.7 基于空间锐化滤波的图像增强方法</h4><p>目的：<strong>使边缘和轮廓模糊的图像变得清晰</strong></p><ol><li>图像模糊往往是由于对图像的平均或积分运算引起的，对图像进行积分运算的逆运算，如微分运算可以达到锐化的目的</li><li>从频谱分析的角度，图像模糊的实质是高频分量缺失</li><li>能进行锐化处理的图像必须要有较高的信噪比，否则进行锐化处理后，信噪比会降得更低</li><li>锐化处理还经常跟边缘检测联系在一起</li></ol><h3 id="4-7-1-Roberts算子"><a href="#4-7-1-Roberts算子" class="headerlink" title="4.7.1 Roberts算子"></a>4.7.1 Roberts算子</h3><p><img src="/images/2021/06/C2DF2FB3-1559-408E-8D6B-891DD680F7B2.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-7-2-Laplace算子"><a href="#4-7-2-Laplace算子" class="headerlink" title="4.7.2 Laplace算子"></a>4.7.2 Laplace算子</h3><p><img src="/images/2021/06/9E71B9D2-5A3D-40D2-9918-683B86EBEAC2.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/60E43746-0D38-45CB-B46E-8DCACA59B376.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-7-3-Sobel算子"><a href="#4-7-3-Sobel算子" class="headerlink" title="4.7.3 Sobel算子"></a>4.7.3 Sobel算子</h3><p><img src="/images/2021/06/1EBC63D0-39B7-4851-8929-E731029ADC72.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-7-4-Prewitt算子"><a href="#4-7-4-Prewitt算子" class="headerlink" title="4.7.4 Prewitt算子"></a>4.7.4 Prewitt算子</h3><h3 id=""><a href="#" class="headerlink" title=" "></a><img src="/images/2021/06/AEED8104-AB50-4DA5-B684-3D684B01EE79.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></h3><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/17/shuzituxiang4/">https://blog.jujimeizuo.cn/2021/06/17/shuzituxiang4/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（四）输入输出系统</title>
      <link href="/2021/06/17/jizu4/"/>
      <url>/2021/06/17/jizu4/</url>
      
        <content type="html"><![CDATA[<h4 id="4-1-端口、接口的区别"><a href="#4-1-端口、接口的区别" class="headerlink" title="4.1 端口、接口的区别"></a>4.1 端口、接口的区别</h4><p>接口(Interface)和端口(Port)是两个不同的概念。端口是指接口电路中的一些寄存器，这些寄存器分别用来存放数据信息、控制信息和状态信息，相应的端口分别称为数据端口、控制端口和状态端口。若干个端口加上相应的控制逻辑才能组成接口。CPU通过输入指令，从端口读入信息，通过输出指令，可将信息写入端口中。</p><h4 id="4-2-与程序中断方式相比，DMA方式的特点"><a href="#4-2-与程序中断方式相比，DMA方式的特点" class="headerlink" title="4.2 与程序中断方式相比，DMA方式的特点"></a>4.2 与程序中断方式相比，DMA方式的特点</h4><ol><li>从<strong>数据传送</strong>看，程序中断靠<strong>程序传送</strong>，DMA方式靠硬件传送</li><li>从<strong>CPU响应时间</strong>看，程序中断方式是在一条指令执行结束时响应，而DMA方式可在命令周期内的<strong>任意</strong>存储周期结束时响应</li><li>程序中断方式有<strong>处理异常事件</strong>的能力，DMA方式没有这种能力，主要用于大批数据的传送，如磁盘存取、图像处理、高速数据采集系统等，可提高数据吞吐量</li><li>程序中断方式需要中断现行程序，故需保护现场；DMA方式不中断现行程序，无需保护现场</li><li>DMA的优先级比程序中断优先级高</li></ol><h4 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h4><ol><li>I&#x2F;O设备与主机信息传送的控制方式：<strong>程序查询方式、程序中断方式、DMA方式</strong></li><li>计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求对处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是“中断”</li><li>凡是能向CPU提出中断请求的各种因素统称为<strong>中断源</strong></li><li>CPU总是在统一的时间，即每条指令执行阶段的最后时刻，查询所有的设备是否有中断请求</li></ol><h4 id="4-4-例题"><a href="#4-4-例题" class="headerlink" title="4.4 例题"></a>4.4 例题</h4><blockquote><p>5.1 I&#x2F;O设备有哪些编址方式，各有何特点？</p><p>统一编址：采用主存单元地址完全一样的格式，I&#x2F;O设备和主存占用同一个地址空间，CPU可像访问主存一样访问I&#x2F;O设备，不需要安排专门的I&#x2F;O指令</p><p>独立编址：有完全不同于主存地址格式的地址编码，此时I&#x2F;O地址与主存地址是两个独立的空间，CPU需要通过专门的指令来访问该地址空间。</p></blockquote><p> </p><blockquote><p>5.4 试比较程序查询方式、程序中断方式和DMA方式对CPU效率的影响。</p><p>程序查询方式：需要cpu时刻咨询io，直到io准备好响应，工作效率很低。</p><p>程序中断方式：不咨询设备是否已经准备就绪，继续执行自身程序，只有当io设备准备就绪cpu发出中断请求后才予以响应。这种方式消除了踏步现象，比程序咨询方式效率更高，提高了CPU资源利用率和工作效率。</p><p>DMA方式：DMA控制器从cpu完全接管对总线的控制，数据交换不经过cpu，直接在内存和外围设备之间进行，以高速传送数据，大大减轻了cpu的数据交换工作压力，cpu工作效率更高。</p></blockquote><p> </p><blockquote><p>说明中断向量地址和入口地址的区别和联系。</p><p>中断向量地址和入口地址的区别：</p><p>向量地址是硬件电路（向量编码器）产生的中断源的内存地址编号，中断入口地址是中断服务程序首址。</p><p>中断向量地址和入口地址的联系：</p><p>中断向量地址可理解为中断服务程序入口地址指示器（入口地址的地址），通过它访存可获得中断服务程序入口地址。 (两种方法：在向量地址所指单元内放一条JMP指令；主存中设向量地址表。）</p></blockquote><p> </p><blockquote><p>什么是多重中断？实现多重中断的必要条件是什么？</p><p>多重中断是指：当CPU执行某个中断服务程序的过程中，发生了更高级、更紧迫的事件，CPU暂停现行中断服务程序的执行，转去处理该事件的中断，处理完返回现行中断服务程序继续执行的过程。</p><p>实现多重中断的必要条件是：在现行中断服务期间，中断允许触发器为1，即开中断。</p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/17/jizu4/">https://blog.jujimeizuo.cn/2021/06/17/jizu4/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（三）存储器</title>
      <link href="/2021/06/16/jizu3/"/>
      <url>/2021/06/16/jizu3/</url>
      
        <content type="html"><![CDATA[<h4 id="4-1-存储器"><a href="#4-1-存储器" class="headerlink" title="4.1 存储器"></a>4.1 存储器</h4><p><img src="/images/2021/06/image.jpeg"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-1.jpeg"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-2-存储器的分类"><a href="#4-2-存储器的分类" class="headerlink" title="4.2 存储器的分类"></a>4.2 存储器的分类</h4><p><img src="/images/2021/06/4DD85DCB-F5EF-45C4-8F91-792A83F4341A.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-2-1-存储介质"><a href="#4-2-1-存储介质" class="headerlink" title="4.2.1 存储介质"></a>4.2.1 存储介质</h3><p>半导体器件（半导体存储器）：随机存储器</p><p>磁性材料（磁表面存储器）：磁盘存储器和磁带存储器</p><h3 id="4-2-2-存储方式"><a href="#4-2-2-存储方式" class="headerlink" title="4.2.2 存储方式"></a>4.2.2 存储方式</h3><p>随机存储器RAM</p><p>只读存储器ROM</p><p>串行访问存储器</p><h3 id="4-2-3-存储作用"><a href="#4-2-3-存储作用" class="headerlink" title="4.2.3 存储作用"></a>4.2.3 存储作用</h3><p>主要分为主存储器、辅助存储器、缓存存储器</p><p><img src="/images/2021/06/image-28.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-3-存储器层次结构"><a href="#4-3-存储器层次结构" class="headerlink" title="4.3 存储器层次结构"></a>4.3 存储器层次结构</h4><p><img src="/images/2021/06/image-27.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-4-主存储器"><a href="#4-4-主存储器" class="headerlink" title="4.4 主存储器"></a>4.4 主存储器</h4><h3 id="4-4-1-主存的基本组成"><a href="#4-4-1-主存的基本组成" class="headerlink" title="4.4.1 主存的基本组成"></a>4.4.1 主存的基本组成</h3><p><img src="/images/2021/06/image-29.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-4-2-主存和CPU的联系"><a href="#4-4-2-主存和CPU的联系" class="headerlink" title="4.4.2 主存和CPU的联系"></a>4.4.2 主存和CPU的联系</h3><p><img src="/images/2021/06/image-30.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>备注：MDR、MAR在CPU里。</p><h3 id="4-4-3-主存中存储单元地址的分配"><a href="#4-4-3-主存中存储单元地址的分配" class="headerlink" title="4.4.3 主存中存储单元地址的分配"></a>4.4.3 主存中存储单元地址的分配</h3><p><img src="/images/2021/06/image-31.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-4-4-主存的技术指标"><a href="#4-4-4-主存的技术指标" class="headerlink" title="4.4.4 主存的技术指标"></a>4.4.4 主存的技术指标</h3><ol><li>存储容量：主存存放二进制代码的总位数，即存储单元个数* 存储字长</li><li>存储速度：存取时间是存储器的访问时间（读出时间、写入时间）；存取周期是连续两次独立的存储器操作（读或写）所需的最小间隔时间。通常，存储周期&gt;存取时间</li><li>存储器的带宽：位&#x2F;秒</li></ol><p> </p><h4 id="4-5-高速缓冲存储器"><a href="#4-5-高速缓冲存储器" class="headerlink" title="4.5 高速缓冲存储器"></a>4.5 高速缓冲存储器</h4><h3 id="4-5-1-问题的提出"><a href="#4-5-1-问题的提出" class="headerlink" title="4.5.1 问题的提出"></a>4.5.1 问题的提出</h3><p>避免CPU“空等”现象</p><p>CPU和主存（DRAM）的速度差异</p><p><img src="/images/2021/06/image-32.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-5-2-Cache的工作原理"><a href="#4-5-2-Cache的工作原理" class="headerlink" title="4.5.2 Cache的工作原理"></a>4.5.2 Cache的工作原理</h3><p><img src="/images/2021/06/image-36.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="4-5-3-Cache-主存地址映射"><a href="#4-5-3-Cache-主存地址映射" class="headerlink" title="4.5.3 Cache-主存地址映射"></a>4.5.3 Cache-主存地址映射</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p>某一主存块只能固定映射到某一缓存块</p><p>主存字块标记</p><p>Cache字块标记</p><p>字块内地址</p><p>——————</p><p>——————-</p><p>—————</p><p> </p><p><img src="/images/2021/06/image-33.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p>主存中的任一块可以映射到缓存中的任一块</p><p>主存字块标记</p><p>字块内地址</p><p>——————</p><p>—————</p><p><img src="/images/2021/06/image-34.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="组相连映射"><a href="#组相连映射" class="headerlink" title="组相连映射"></a>组相连映射</h4><p>某一主存块只能映射到某一缓存组中的任一块</p><p>主存字块标记</p><p>组地址</p><p>字块内地址</p><p>——————</p><p>———</p><p>—————</p><p> </p><p><img src="/images/2021/06/image-35.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h4><ol><li>在主存和CPU之间增加高速缓存的目的是<strong>解决主存和CPU速度不匹配问题</strong>。</li><li>存储器是计算机系统中的记忆设备，同来存放程序和数据。</li><li>存储器速度、容量、位价的关系：<strong>寄存器&gt;缓存&gt;主存&gt;磁盘&gt;磁带</strong>。</li><li>通常用<strong>8位二进制数表示一个字节</strong>。</li><li><strong>储存容量</strong>是指主存能存放的二进制代码的<strong>总位数</strong>。</li><li>存储速度由<strong>存储时间</strong>和<strong>存储周期</strong>来表示。</li><li>提高存储器带宽的方法：缩短存储周期、增加存储字长、增加存储体。</li><li>静态RAM是用<strong>触发器</strong>工作原理存储信息，动态RAM是靠<strong>电容存储电荷</strong>的原理来寄存信息。</li><li><strong>集中刷新</strong>是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止<strong>读&#x2F;写操作</strong>。</li></ol><p> </p><h4 id="4-7-例题"><a href="#4-7-例题" class="headerlink" title="4.7 例题"></a>4.7 例题</h4><blockquote><p>4.5 什么是存储器的带宽？若存储器的数据总线宽度为32位，存取周期位200ns，则存储器的带宽是多少？</p><p>存储器的带宽指单位时间内从存储器进出信息的最大数量。</p><p>存储器的带宽&#x3D;时钟频率*总线宽度&#x3D;1&#x2F;200ns*32位&#x3D;160M 位&#x2F;秒&#x3D;20MB&#x2F;秒</p><p>注意：字长32位，不是16位。</p></blockquote><p> </p><blockquote><p>4.6 某机字长为32位，其存储容量为64KB，按字编址其寻址范围是多少？若以主存以字节编址，试画出主存字地址和字节地址的分配情况。</p><p> 存储容量为64KB时，按字编址其寻址范围就是64K，若以主存以字节编址，其寻址范围为64K&#x2F;（32&#x2F;8）&#x3D;16K</p><p>主存字地址和字节地址的分配情况：如图</p><p> <img src="/images/2021/06/image-37.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"> </p></blockquote><p> </p><blockquote><p>4.7 一个容量为16K*32位的存储器，其地址线和数据线的总和是多少？当选用下列不同规格的存储芯片时，各需要多少片？1K*4位，2K*8位，4K*4位，16K*1位，4K*8位，8K*8位。</p><p>16K&#x3D;2^14，所以地址线有14根，数据线有32根，一共46根。</p><p>选择不同芯片时，各需要的片数为：</p><p> 1K*4位：（16K*32）&#x2F;（ 1K*4）&#x3D;16*8&#x3D;128片</p><p>2K*8位：（16K*32）&#x2F;（2K*8）&#x3D;8*4&#x3D;32片</p><p>4K*4位：（16K*32）&#x2F;（4K*4）&#x3D;4*8&#x3D;32片</p><p>16K*1位：（16K*32）&#x2F;（16K*1）&#x3D;1*32&#x3D;32片</p><p>4K*8位：（16K*32）&#x2F;（4K*8）&#x3D;4*4&#x3D;16片</p><p>8K*8位：（16K*32）&#x2F;（8K*8）&#x3D;2*4&#x3D;8片</p></blockquote><p> </p><blockquote><p>4.9 什么叫刷新？为什么要刷新？说明刷新的几种方法。</p><p>刷新指对DRAM定期进行的全部重写过程；</p><p>刷新原因：因电容泄漏而引起的DRAM所存信息的衰减需要及时补充，因此安排了定期刷新操作；</p><p>种类：</p><p>集中式：在最大刷新间隔时间内，集中安排一段时间进行刷新，存在CPU访存死时间； </p><p>分散式：在每个读&#x2F;写周期之后插入一个刷新周期，无CPU访存死时间； </p><p>异步式：是集中式和分散式的折衷。</p></blockquote><p> </p><blockquote><p>4.15 </p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/3D86EB37-F424-44F0-B368-BD1E61C7E1C3.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/lALPDg7mQdVHZPfNBD_NA-c_999_1087.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>4.18 已知接收到的汉明码（按配偶原则配置）为1100100、1100111、1100000、1100001、检查上述代码是否出错？第几位出错？</p><p>1100100:</p><p>p1 &#x3D; C1 ^ 3 ^ 5 ^ 7 &#x3D; 0; p2 &#x3D; C2 ^ 3 ^ 6 ^ 7 &#x3D; 1; p3 &#x3D; C4 ^ 5 ^ 6 ^ 7 &#x3D; 1</p><p>p3p2p1 &#x3D; 110 即第6位出错，有效信息为0110</p><p>1100111：</p><p>p1 &#x3D; C1 ^ 3 ^ 5 ^ 7 &#x3D; 1; p2 &#x3D; C2 ^ 3 ^ 6 ^ 7 &#x3D; 1; p3 &#x3D; C4 ^ 5 ^ 6 ^ 7 &#x3D; 1</p><p>p3p2p1 &#x3D; 111 即第7位出错，有效信息为0110</p><p>1100000:</p><p>p1 &#x3D; C1 ^ 3 ^ 5 ^ 7 &#x3D; 1; p2 &#x3D; C2 ^ 3 ^ 6 ^ 7 &#x3D; 1; p3 &#x3D; C4 ^ 5 ^ 6 ^ 7 &#x3D; 0</p><p>p3p2p1 &#x3D; 011 即第3位出错，有效信息为1000</p><p>1100001:</p><p>p1 &#x3D; C1 ^ 3 ^ 5 ^ 7 &#x3D; 0; p2 &#x3D; C2 ^ 3 ^ 6 ^ 7 &#x3D; 0; p3 &#x3D; C4 ^ 5 ^ 6 ^ 7 &#x3D; 1</p><p>p3p2p1 &#x3D; 100 即第4位出错，有效信息为0001</p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/16D014C8-6918-496C-AAD0-9E41425D9443.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/0F821F49-7E90-426E-AF93-0B275BB2EC2C.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/lALPDiQ3ObHyGP7NBFXNA-c_999_1109.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>4.28 设主存容量为256K字，Cache容量为2K字，块长为4，</p><p>（1）设计Cache地址格式，设计主存地址格式 （2）在直接映射方式下，设计主存地址格式 （3）在四路组相连映射方式下，设计主存地址格式 （4）在全相连映射方式下，设计主存地址格式 （5）若存储字长为32位，是存储器按字节寻址，写出上述三种映射方式下主存的地址格式。</p><p>（1）Cache容量为2K字节，块长为4，Cache共有2K&#x2F;4&#x3D;2^11&#x2F;2^2&#x3D;2^9&#x3D;512块</p><p>Cache字地址9位，字块内地址为2位</p><p>因此，Cache地址格式设计如下：</p><p>Cache字块地址（9位）字块内地址（2位）</p><p>（2）主存容量为256K字节&#x3D;2^18字节，主存地址共18位，共分256K&#x2F;4&#x3D;2^16块</p><p>主存字块标记为18-9-2&#x3D;7位</p><p>直接映射方式下主存地址格式如下：</p><p>主存字块标记（7位）Cache字块地址（9位）字块内地址（2位）</p><p>（3）根据四路组相联的条件，一组内共有4块，得Cache共分为512&#x2F;4&#x3D;2^7块</p><p>主存字块标记为18-7-2&#x3D;9位</p><p>主存地址格式设计如下：</p><p>主存字块标记（9位）组地址（7位）字块内地址（2位）</p><p>（4）在全相联映射方式下，主存字块标记为18-2&#x3D;16位，其地址格式如下：</p><p>主存字块标记（16位）字块内地址（2位）</p><p>（5）若存储字长为32位，存储器按字节寻址，则主存容量为256K*32&#x2F;8&#x3D;2^20B</p><p>Cache容量为2K*32&#x2F;8&#x3D;2^13B，块长为4*32&#x2F;8&#x3D;2^4B，字块内地址为4位。</p><p>在直接映射方式下，主存字块标记为20-9-4&#x3D;7位，主存地址格式为：</p><p>主存字块标记（7位）Cache字块地址（9位）字块内地址（4位）</p><p>在四路组相联映射方式下，主存字块标记为20-7-4&#x3D;9位，主存地址格式为：</p><p>主存字块标记（9位）组地址（7位）字块内地址（4位）</p><p>在全相联映射方式下，主存字块标记为20-4&#x3D;16位，主存地址格式为：</p><p>主存字块标记（16位）字块内地址（4位）</p></blockquote><p> </p><blockquote><p>4.29 假设CPU执行某段程序时共访问Cache命中4800次，访问主存200次，已知Cache的存取周期是30ns，主存的存取周期是150ns，求Cache的命中率以及Cache-主存系统的平均访问时间和效率，试问该系统的性能提高了多少？</p><p>命中率&#x3D;4800&#x2F;(4800+200)&#x3D;0.96</p><p>平均访问时间&#x3D;0.96*30+(1-0.96)*150&#x3D;34.8ns</p><p>效率&#x3D;30&#x2F;34.8*100%&#x3D;86.2%</p><p>性能变为原来的150&#x2F;34.8&#x3D;4.31倍，即提高了3.31倍</p></blockquote><p> </p><blockquote><p>4.31 设主存容量为1MB，采用直接映射方式的Cache容量为16KB，块长为4，每字32位。试问主存地址为ABCDEH的存储单元在Cache中的什么位置？</p><p>假设按照字节编址。</p><p>4*32&#x2F;8&#x3D;16B&#x3D;2^4B 得字块内地址为4位</p><p>16KB&#x2F;16B&#x3D;2^10 得Cache字块地址为10位</p><p>1MB&#x2F;16B&#x3D;2^16 得直接映射下主存地址为6位</p><p>ABCDEH&#x3D;1010 1011 1100 1101 1110 …</p><p>故该主存单元应映射到Cache的101010块的第1110字节，即第42块第14字节位置</p></blockquote><p> </p><blockquote><p><img src="/images/2021/06/E25F5759-9D3B-4513-8407-7A0BDFC400D5.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/lALPDiCpvA7gppnNA-fNA_I_1010_999.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>4.38 磁盘组有6片磁盘，最外两侧盘面可以记录，存储区域内径22cm，外径33cm，道密度为40道&#x2F;cm，内层密度为400位&#x2F;cm，转速3600转&#x2F;分。</p><p>（1）共有多少存储面可用？</p><p>（2）共有多少柱面？</p><p>（3）盘组总存储容量是多少？</p><p>（4）数据传输率是多少？</p><p>（1）共有6*2&#x3D;12个储存面可用</p><p>（2）有效存储区域&#x3D;（33-22）&#x2F;2&#x3D;5.5cm，柱面数&#x3D;40*5.5&#x3D;220道</p><p>（3）内层道周长&#x3D;PI*22&#x3D;69.08cm</p><p>道容量&#x3D;400位&#x2F;cm*69.08cm&#x3D;3454B</p><p>面容量&#x3D;3454B*220道&#x3D;759880B</p><p>盘组总容量&#x3D;759880B*12面&#x3D;9118560B</p><p>（4）转速&#x3D;3600转&#x2F;分&#x3D;60转&#x2F;秒</p><p>数据传输率&#x3D;3454B*60转&#x2F;秒 &#x3D; 207240B&#x2F;s</p></blockquote><p> </p><blockquote><p>4.39 某磁盘存储器转速位3000转&#x2F;分，共有4个记录盘面，每毫米5道，每道记录信息12288字节，最小磁道直径位230mm，共有275道，求：</p><p>（1）磁盘存储器的存储容量。</p><p>（2）最高位密度（最小磁道的位密度）和最低位密度。</p><p>（3）磁盘数据传输率。</p><p>（4）平均等待时间。</p><p>（1）存储容量&#x3D;275*12288*4&#x3D;13516800B</p><p>（2）最高位密度&#x3D;12288B&#x2F;（PI*230mm）&#x3D;17B&#x2F;mm</p><p>最大磁道直径&#x3D;230+2*275&#x2F;5&#x3D;230+110&#x3D;340mm</p><p>最低位密度&#x3D;12288B&#x2F;（PI*340）&#x3D;11.5B&#x2F;mm</p><p>（3）3000转&#x2F;分&#x3D;50转&#x2F;秒</p><p>磁盘数据传输率&#x3D;12288B*50转&#x2F;秒&#x3D;614400B&#x2F;s</p><p>（4）平均等待时间&#x3D;1&#x2F;（2*50转&#x2F;秒）&#x3D;10ms</p></blockquote><p> </p><blockquote><p>假设CPU执行某段程序时，共访问Cache命中20 00次，访问主存50次。已知Cache的存储周期为50ns，主存的存储周期为200ns。求Cache-主存系统的命中率、效率和平均访问时间。</p><p>（1）2000&#x2F;（2000+50）*100%&#x3D;97%</p><p>（2）设访问Cache的时间为t，访问主存时间为4t，则效率e &#x3D; t&#x2F;(0.97*t+(1-0.97)*4t)*100%&#x3D;91.7%</p><p>（3）平均访问时间&#x3D;50ns*0.97+200ns*(1-0.97)&#x3D;54.5ns</p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/16/jizu3/">https://blog.jujimeizuo.cn/2021/06/16/jizu3/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（二）系统总线</title>
      <link href="/2021/06/16/jizu2/"/>
      <url>/2021/06/16/jizu2/</url>
      
        <content type="html"><![CDATA[<h4 id="3-1-系统总线"><a href="#3-1-系统总线" class="headerlink" title="3.1 系统总线"></a>3.1 系统总线</h4><ol><li>主存总线与DMA总线<strong>不能同时</strong>对主存进行存取，</li><li>总线分类（按照连接部件不同划分）：<strong>片内总线、系统总线、通信总线</strong>。</li><li>系统总线按照传输信息不同，分<strong>数据总线【双向传输总线】、地址总线、控制总线【一般来说是单向的】</strong>。</li><li>通信总线按照传输方式不同，分<strong>串行通信【远距离传输】、并行通信【近距离传输】</strong>。</li><li>总线特性：<strong>机械特性、电气特性、功能特性、时间特性</strong>。</li><li>总线周期分为四个阶段：<strong>申请分配阶段、寻址阶段、传数阶段、结束阶段</strong>。</li><li>总线通信方式：<strong>同步通信、异步通信、半同步通信、分离式通信</strong>。</li><li>对各不相同速度的部件而言，必须按<strong>最慢速度</strong>的部件来设置公共时钟。</li><li><strong>波特率</strong>是指单位时间内传送二级制数的位数，单位用**bps(位&#x2F;秒)**，记作波特。</li><li><strong>比特率</strong>是指单位时间内传送二进制<strong>有效数据</strong>的位数，单位用<strong>bps</strong>表示。</li></ol><p> </p><h4 id="3-2-例题"><a href="#3-2-例题" class="headerlink" title="3.2 例题"></a>3.2 例题</h4><blockquote><p>3.1 什么是总线？总线传输有何特点？为了减轻总线的负载，总线上的部件都应具备什么特点？</p><p>总线是多个部件共享的传输部件。</p><p>总线传输的特点是：某一时刻只能有一路信息在总线上传输，即分时使用。</p><p>为了减轻总线负载，总线上的部件应通过三态驱动缓冲电路与总线连通。</p></blockquote><p> </p><blockquote><p>3.2 总线如何分类？什么是系统总线？系统总线又分为几类，它们各又何作用，是单向的，还是双向的，它们与机器字长、存储字长、存储单元有何关系？</p><p>按照连接部件的不同，总线可以分为片内总线、系统总线和通信总线。</p><p>系统总线是连接CPU、主存、I&#x2F;O各部件之间的信息传输线。</p><p>系统总线按照传输信息不同又分为地址线、数据线和控制线。地址线是单向的，其根数越多，寻址空间越大，即CPU能访问的存储单元的个数越多；数据线是双向的，其根数与存储字长相同，是机器字长的整数倍。</p></blockquote><p> </p><blockquote><p>3.4 为什么要设置总线判优控制？常见的集中式总线控制有几种，各有何特点，哪种方式响应时间最快，哪种方式对电路故障最敏感？</p><p>总线判优控制解决多个部件同时申请总线时的使用权分配问题。</p><p>常见的集中式总线控制有三种：</p><ol><li>链式查询：连线简单，易于扩充，对电路故障最敏感。</li><li>计数器定时查询：优先级设置较灵活，对故障不敏感，连线及控制过程较复杂。</li><li>独立请求：速度最快，但硬件器件用量大，连线多，成本较高。<img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></li></ol></blockquote><p> </p><blockquote><p>3.5 解释概念：总线宽度、总线带宽、总线复用、总线的主设备（或主模块）、总线的从设备（或从模块）、总线的传输周期、总线的通信控制。</p><p>总线宽度：通常指数据总线的总根数；</p><p>总线带宽：总线的数据传输率，指单位时间内总线上传输数据的位数；</p><p>总线复用：指同一条信号线可以分时传输不同的信号；</p><p>总线的主设备（或主模块）：指一次总线传输期间，拥有总线控制权的设备（模块）；</p><p>总线的从设备（或从模块）：指一次总线传输期间，配合主设备完成数据传输的设备（模块），他只能被动接受主设备发来的命令；</p><p>总线的传输周期：指总线完成一次完整而可靠的传输所需时间；</p><p>总线的通信控制：指总线传送过程中双方的时间配合方式。</p></blockquote><p> </p><blockquote><p>3.14 设总线的时钟频率为8MHz，一个总线周期等于一个时钟周期，如果一个总线周期中并行传输16位数据，试问总线的带宽是多少？</p><p>由题意 1s有8M个时钟周期，即总线周期，</p><p>总线带宽&#x3D;8M*16&#x2F;8B&#x3D;16MBps</p></blockquote><p> </p><blockquote><p>3.15 在一个32位的总线系统中，总线的时钟频率为66MHz，假设总线最短传输周期为4个时钟周期，试计算总线的最大数据传输率。若想提高数据传输率，可采取什么措施？</p><p>由题意 1s有66M个时钟周期，</p><p>即有66M&#x2F;4个总线最短传输周期，</p><p>数据传输率&#x3D;66M&#x2F;4*32&#x2F;8B&#x3D;66MBps</p><p>如果想要提高数据传输率，可以增加总线位数、提高时钟频率。</p></blockquote><p> </p><blockquote><p>3.16 异步串行传送系统中，字符格式为：1个起始位、8个数据位、1个校验位、2个终值位。若要求每秒传送120个字符，试求传送的波特率和比特率。</p><p>波特率&#x3D;120*(1+8+1+2)&#x3D;1440bps</p><p>比特率&#x3D;120*8&#x3D;960bps</p></blockquote><p> </p><blockquote><p>假设总线的时钟频率为100MHz，总线的传输周期为4个时钟周期，总线的宽度为32位，试求总线的数据传输率。</p><p>由题意 1s 有100M个时钟周期，</p><p>即有100M&#x2F;4&#x3D;25M个总线周期，</p><p>数据传输率&#x3D;25M*32&#x2F;8B&#x3D;100MBps</p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/16/jizu2/">https://blog.jujimeizuo.cn/2021/06/16/jizu2/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理期末复习（一）概论和计算机的发展和应用</title>
      <link href="/2021/06/16/jizu1/"/>
      <url>/2021/06/16/jizu1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><ol><li>计算机系统由<strong>硬件</strong>和<strong>软件</strong>两大部分组成。</li><li>计算机的软件分为<strong>系统软件</strong>和<strong>应用软件</strong>。</li><li>翻译程序有两种，一种是<strong>编译程序</strong>，另一种是<strong>解释程序</strong>。</li><li>冯·诺依曼计算机是以<strong>运算器</strong>为中心的，现代计算机以<strong>储存器</strong>为中心的。</li><li><strong>运算器</strong>和<strong>控制器</strong>和起来统称为<strong>中央处理器（CPU）</strong>。</li><li>现代计算机可认为由三大部件组成：<strong>CPU、I&#x2F;O设备</strong>以及<strong>主存储器</strong>。</li><li><strong>CPU</strong>和<strong>主存储器</strong>合起来称为<strong>主机。</strong></li><li><strong>ALU算术逻辑单元</strong>和<strong>CU控制单元</strong>是CPU的核心部件。</li><li>机器字长是指CPU一次能处理数据的位数，通常与CPU的<strong>寄存器位数</strong>有关。</li><li>存储器的容量包括<strong>主存容量</strong>和<strong>辅存容量</strong>。</li><li>主存容量-存储单元个数*存储字长。</li><li>现在计算机的运算速度普遍采用单位时间内执行指令的平均条数来衡量，并采用<strong>MIPS</strong>作为计量单位。CPI：执行一条指令所需的时钟周期；IPC：每个时钟周期数执行的指令数目。</li></ol><h4 id="1-2-冯·诺依曼计算机的特点"><a href="#1-2-冯·诺依曼计算机的特点" class="headerlink" title="1.2 冯·诺依曼计算机的特点"></a>1.2 冯·诺依曼计算机的特点</h4><p><img src="/images/2021/06/image-24.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><ol><li>计算机由<strong>运算器、存储器、控制器、输入设备、输出设备</strong>五大部件组成。</li><li>指令和数据以<strong>同等地位</strong>存放于<strong>存储器</strong>内，并可按<strong>地址</strong>寻访。</li><li>指令和数据均以<strong>二进制数</strong>表示。</li><li>指令由<strong>操作码</strong>和<strong>地址码</strong>组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按<strong>顺序</strong>存放。通常，指令是顺序执行的，在特定条件下，可依据运算结果或根据设定的条件改变执行顺序。</li><li>机器以<strong>运算器</strong>为中心，输入输出设备与存储器间的数据传送通过运算器完成。</li></ol><p>最重要的特点是<strong>存储程序</strong>，也就是说<strong>指令</strong>和<strong>数据</strong>都存储在<strong>存储器</strong>中，CPU运行程序时从存储器中读到每一条指令 然后运行它，这就是存储程序的基本原理(定义)。</p><blockquote><p>I&#x2F;O设备能够直接连接CPU吗？</p><p>不能，因为两者速度不匹配，需要通过接口连接。</p></blockquote><p> </p><blockquote><p>用什么部件区分M中存放的是指令还是数据？</p><p>控制器。</p><p>控制器功能：交换、检测及提供信号</p><ol><li>控制机器，控制各个部件协调一致地工作。</li><li>控制器具备数据交换功能，这是指实现CPU与控制器之间、控制器与设备之间的数据交换。</li><li>将电话比喻成人体，那么控制器就好比是人的大脑，输出各种指令，是零件灵活运行。</li><li>运算器只能完成运算，而控制器能用于控制整个CPU的工作。</li><li>通过数据总线，由CPU并行地把数据写入控制器，或从控制器中并行地读出数据。</li></ol></blockquote><h4 id="1-3-计算机系统的层次结构"><a href="#1-3-计算机系统的层次结构" class="headerlink" title="1.3 计算机系统的层次结构"></a>1.3 计算机系统的层次结构</h4><p>现代计算机系统可分为<strong>五个层次</strong>， <strong>第一级</strong>是<strong>微程序设计级</strong> <strong>第二级</strong>是<strong>一般机器级</strong> <strong>第三级</strong>是<strong>操作系统级</strong> <strong>第四级</strong>是<strong>汇编语言级</strong> <strong>第五级</strong>是<strong>高级语言级</strong></p><p><img src="/images/2021/06/image-25.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-26.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="1-4-例题"><a href="#1-4-例题" class="headerlink" title="1.4 例题"></a>1.4 例题</h4><blockquote><p>1.1 什么是计算机系统、计算机硬件和计算机软件？硬件和软件哪个重要？</p><p><img src="/images/2021/06/B7CF3F95-3833-4D90-9F8D-75E77915E57D.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>1.2 如何理解计算机系统的层次结构？</p><p><img src="/images/2021/06/0CDF6E09-9D50-408B-B0DC-E55C0D64BA33.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>1.3 说明高级语言、汇编语言和机器语言的差别及其联系。 <strong>机器语言是计算机硬件能够直接识别的语言，汇编语言是机器语言的符号表示，高级语言是面向算法的语言。高级语言编写的程序（源程序）处于最高层，必须翻译成汇编语言，再由汇编程序汇编成机器语言（目标程序）之后才能被执行。</strong></p></blockquote><p> </p><blockquote><p>1.5 冯·诺依曼计算机的特点是什么？</p><p><img src="/images/2021/06/511FC64B-7E09-4A53-99A6-5AA908D9D26E.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p></blockquote><p> </p><blockquote><p>2.1 通常，计算机的更新换代以什么为依据？</p><p><strong>主要以组成计算机基本电路的元器件为依据，如电子管、晶体管、集成电路等。</strong></p></blockquote><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/16/jizu1/">https://blog.jujimeizuo.cn/2021/06/16/jizu1/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（三）数字图像的基本运算</title>
      <link href="/2021/06/16/shuzituxiang3/"/>
      <url>/2021/06/16/shuzituxiang3/</url>
      
        <content type="html"><![CDATA[<h4 id="3-1-灰度直方图"><a href="#3-1-灰度直方图" class="headerlink" title="3.1 灰度直方图"></a>3.1 灰度直方图</h4><h3 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h3><p>灰度直方图是反映一幅图像中各灰度级像素出现的频率，反映灰度分布情况。横坐标用于表示像素的灰度级别，纵坐标用于表示该灰度出现的频数。</p><h3 id="3-1-2-特征"><a href="#3-1-2-特征" class="headerlink" title="3.1.2 特征"></a>3.1.2 特征</h3><ol><li><strong>只能反映灰度分布，丢失像素位置信息</strong></li><li><strong>一幅图像对应唯一灰度直方图，反之不一定</strong></li><li><strong>一幅图像分成多个区域，多个区域的直方图之和是原图像的直方图</strong></li></ol><h3 id="3-13-理解规则"><a href="#3-13-理解规则" class="headerlink" title="3.13 理解规则"></a>3.13 理解规则</h3><ol><li><strong>左黑右白，左暗右亮</strong></li><li><strong>横轴上各（亮度值）点对应的柱状高度就是分布在该亮度的像素个数</strong></li><li><strong>当柱状接近分布在整个横轴上，且至少有一个峰值时，图像的对比度较好</strong></li></ol><h3 id="3-1-4-应用"><a href="#3-1-4-应用" class="headerlink" title="3.1.4 应用"></a>3.1.4 应用</h3><ul><li>判断图像量化是否恰当</li><li>确定图像二值化的阈值</li></ul><p><img src="/images/2021/06/image-6.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><ul><li>物体部分灰度值比其他部分灰度值大的时候可以统计图像中物体面积</li><li>计算图像信息量（熵）</li></ul><p><img src="/images/2021/06/image-5.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="3-1-5-彩色图像转换成灰度图像"><a href="#3-1-5-彩色图像转换成灰度图像" class="headerlink" title="3.1.5 彩色图像转换成灰度图像"></a>3.1.5 彩色图像转换成灰度图像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.imread(&#x27;lenna.jpg&#x27;)</span><br><span class="line">nim = cv2.cvtColor(im,  cv2.COLOR_BGR2GRAY);</span><br></pre></td></tr></table></figure><h3 id="3-1-6-计算直方图"><a href="#3-1-6-计算直方图" class="headerlink" title="3.1.6 计算直方图"></a>3.1.6 计算直方图</h3><p>OpenCV计算直方图的函数：calcHist()</p><p>例如：打开图像 lenna.jpg，使用 cv2.calcHist()函数计算灰度图像的直方图，以屏显打印输出的形式显示具有 100-128 灰度值的像素数目；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">im = cv2.imread(&#x27;lenna.jpg&#x27;)</span><br><span class="line">nim = cv2.cvtColor(im,  cv2.COLOR_BGR2GRAY)</span><br><span class="line">jpg = cv2.calcHist([im], [0], None, [29], [100, 128])</span><br><span class="line">plt.plot(jpg)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p> </p><h4 id="3-2-归一化直方图"><a href="#3-2-归一化直方图" class="headerlink" title="3.2 归一化直方图"></a>3.2 归一化直方图</h4><p><img src="/images/2021/06/D108A660-1968-4C99-8E9F-80627540B950.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="3-3-图像的基本运算"><a href="#3-3-图像的基本运算" class="headerlink" title="3.3 图像的基本运算"></a>3.3 图像的基本运算</h4><h3 id="3-3-1-点运算"><a href="#3-3-1-点运算" class="headerlink" title="3.3.1 点运算"></a>3.3.1 点运算</h3><p><strong>点运算：</strong>是指对一幅图像中每个像素点的灰度值进行计算</p><p><img src="/images/2021/06/image-7.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><strong>点运算的效果</strong>：点运算可以改变图像数据所占据的灰度值范围，从而改善图像显示效果</p><p><strong>点运算的分类</strong>：线性点运算，非线性点运算</p><p><strong>线性点运算</strong>：灰度变换函数形式可以采用线性方程描述</p><p><img src="/images/2021/06/image-8.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><strong>非线性点运算</strong>：非线性点运算的输出灰度级与输入灰度级呈非线性关系，常见的非线性灰度变换为对数变换和次幂变换</p><p><img src="/images/2021/06/image-9.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><strong>注意：</strong></p><ul><li>点运算是否会改变图像内像素点之间的空间位置关系？</li></ul><p>不会！点运算是一种像素的逐点运算，它与相邻的像素之间没有运算关系，点运算不会改变图像内像素点之间的空间位置关系。</p><ul><li>对图像灰度的拉伸，非线性拉伸与分段线性拉伸的区别？</li></ul><p>非线性拉伸不是通过在不同灰度值区间选择不同的线性方程来实现对不同灰度值区间的扩展与压缩。而是在整个灰度值范围内采用统一的非线性变换函数。利用函数的数学性质实现对不同灰度值区间的扩展与压缩。</p><h3 id="3-3-2-代数运算"><a href="#3-3-2-代数运算" class="headerlink" title="3.3.2 代数运算"></a>3.3.2 代数运算</h3><p><strong>代数运算：</strong>将<strong>两幅或多幅</strong>图像通过对应像素之间的加、减、乘、除运算得到输出图像。</p><p><img src="/images/2021/06/image-11.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><strong>加法运算</strong>：通常用于平均值降噪的场合。</p><p><strong>减法运算（差影法）</strong>：检测同一场景两幅图像之间的变化；混合图像的分离；消除背景影响。</p><p><strong>乘法运算</strong>：图像的局部显示；改变图像的灰度级</p><p><strong>除法运算</strong>：可用于改变图像的灰度级</p><h3 id="3-3-3-逻辑运算"><a href="#3-3-3-逻辑运算" class="headerlink" title="3.3.3 逻辑运算"></a>3.3.3 逻辑运算</h3><p><strong>逻辑运算：</strong>将<strong>两幅或多幅</strong>图像通过对应像素之间的逻辑与、或、非运算得到输出图像</p><p>“与”、“或”逻辑运算可以从一幅图像中提取子图像。</p><h3 id="3-3-4-几何运算"><a href="#3-3-4-几何运算" class="headerlink" title="3.3.4 几何运算"></a>3.3.4 几何运算</h3><p>几何运算：改变图像中物体对象（像素）之间的空间关系。几何变换可以分为图像的位置变换（平移、镜像、旋转）、形状变换（放大、缩小）以及图像的复合变换等。</p><h4 id="图像的平移"><a href="#图像的平移" class="headerlink" title="图像的平移"></a>图像的平移</h4><p><img src="/images/2021/06/image-12.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-13.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="图像的镜像：水平镜像和垂直镜像"><a href="#图像的镜像：水平镜像和垂直镜像" class="headerlink" title="图像的镜像：水平镜像和垂直镜像"></a>图像的镜像：水平镜像和垂直镜像</h4><p><img src="/images/2021/06/image-15.png"> <img src="/images/2021/06/image-14.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-17.png"> <img src="/images/2021/06/image-16.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="图像的旋转"><a href="#图像的旋转" class="headerlink" title="图像的旋转"></a>图像的旋转</h4><p>以图像的中心为原点，旋转一定的角度，即将图像上的所有像素都旋转一个相同的角度。</p><p><img src="/images/2021/06/image-18.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-19.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>注意：</p><ul><li>图像旋转之后，由于数字图像的坐标值必须是整数，因此，可能引起图像部分像素点的局部改变，所以，这时图像的大小也会发生一定的改变。</li><li>为了避免图像信息的丢失，图像旋转之后必须进行平移变换（或者先平移，在旋转）。</li><li>图像旋转之后，会出现许多空洞点，我们需要对这些空洞点必须进行填充处理，进行插值处理</li></ul><h4 id="图像的缩放"><a href="#图像的缩放" class="headerlink" title="图像的缩放"></a>图像的缩放</h4><p><img src="/images/2021/06/E765E539-EB6C-4640-A729-23EFD031511C.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/ACC89F15-9E5D-49D7-9614-666131C2E8B9.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="3-3-5-灰度插值"><a href="#3-3-5-灰度插值" class="headerlink" title="3.3.5 灰度插值"></a>3.3.5 灰度插值</h3><p>在图像放大的正变换中，出现很多空格，因此，需要对放大后所多出来的一些空格填入适当的像素值。一般采用<strong>最近邻插值和线性插值法</strong>。</p><p><strong>最邻近插值</strong>：最近邻法是将<img src="/images/2021/06/image-21.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png">点最近的整数坐标<img src="/images/2021/06/image-22.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png">点的灰度值取为<img src="/images/2021/06/image-23.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png">点的灰度值。</p><p>在该点各相邻像素间灰度变化较小时，这种方法是一种简单快捷的方法，但当该点相邻像素间灰度差很大时，这种灰度估值方法会产生较大的误差。计算简单，容易产生锯齿现象。</p><p><strong>双线性插值法</strong>：是最邻近法的改进版，效果较好，但是具有低通滤波性，使高频分量受损，图像轮廓受损。会引入平滑效应，使图像产生模糊，清晰度下降。可以采用效果更好的三次内插法。</p><p><strong>三次内插法</strong>：可精确地恢复原函数，当然也就可精确得到采样点间任意点的值。此方法计算量很大，但精度高，能保持较好的图像边缘。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/16/shuzituxiang3/">https://blog.jujimeizuo.cn/2021/06/16/shuzituxiang3/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（二）数字图像处理基础</title>
      <link href="/2021/06/16/shuzituxiang2/"/>
      <url>/2021/06/16/shuzituxiang2/</url>
      
        <content type="html"><![CDATA[<h4 id="2-1-图像的数字化"><a href="#2-1-图像的数字化" class="headerlink" title="2.1 图像的数字化"></a>2.1 图像的数字化</h4><p>将一幅画面转化成计算机能处理的形式——数字图像的过程。它包括<strong>采样</strong>和<strong>量化</strong>两个过程。像素的位置和灰度就是像素的属性。</p><h4 id="2-2-图像的采样和量化"><a href="#2-2-图像的采样和量化" class="headerlink" title="2.2 图像的采样和量化"></a>2.2 图像的采样和量化</h4><h3 id="2-2-1-采样"><a href="#2-2-1-采样" class="headerlink" title="2.2.1 采样"></a>2.2.1 采样</h3><p><strong>空间坐标的离散化。</strong></p><p>将空间中连续的图像变换成离散点的操作成为采样。若横向的像素数（列数）为M ，纵向的像素数（行数）为N，则图像总像素数为M*N个像素。</p><ul><li>采样间隔越大，所得图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应；</li><li>采样间隔越小，所得图像像素数越多，空间分辨率高，图像质量好，但数据量大。</li></ul><h3 id="2-2-2-量化"><a href="#2-2-2-量化" class="headerlink" title="2.2.2 量化"></a>2.2.2 量化</h3><p><strong>灰度值的离散化。</strong></p><p>图像采样后分割成离散的像素，但是其灰度值是连续的，计算机不能处理，将像素灰度转换成离散的数值的过程称为量化。</p><ul><li>量化等级越多，图像层次越丰富，灰度分辨率高，图像质量好，但数据量大；</li><li>量化等级越少，图像层次欠丰富，灰度分辨率低，会出现假轮廓现象，图像质量变差，但数据量小；</li></ul><h4 id="2-3-像素间的关系"><a href="#2-3-像素间的关系" class="headerlink" title="2.3 像素间的关系"></a>2.3 像素间的关系</h4><h3 id="2-3-0-像素"><a href="#2-3-0-像素" class="headerlink" title="2.3.0 像素"></a>2.3.0 像素</h3><ol><li><strong>数字图像的基本组成单元</strong></li><li><strong>图像中的每个像素有一定的空间位置，可以理解成坐标</strong></li><li><strong>在每个像素，有一个值（可以是向量）表示强度</strong></li></ol><p>对于一个像素，与他关系最密切的是它的邻近像素。</p><h3 id="2-3-1-像素的相邻和邻域"><a href="#2-3-1-像素的相邻和邻域" class="headerlink" title="2.3.1 像素的相邻和邻域"></a>2.3.1 像素的相邻和邻域</h3><p>图像中像素的相邻和邻域有3种：</p><ul><li><strong>相邻像素与4邻域</strong></li></ul><p><img src="/images/2021/06/FA11FB1F-7DC2-47E1-BA19-86BB93E6A3B1.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><ul><li><strong>对角相邻像素与4对角邻域</strong></li></ul><p><img src="/images/2021/06/17D541E5-A6A8-43A7-AB40-DBBAF8EEB09C.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><ul><li><strong>8邻域</strong></li></ul><p><img src="/images/2021/06/BECBD576-3966-495F-95E4-CBFD85412B14.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="2-3-2-像素的邻接性和连通性"><a href="#2-3-2-像素的邻接性和连通性" class="headerlink" title="2.3.2 像素的邻接性和连通性"></a>2.3.2 像素的邻接性和连通性</h3><p>为了确定两个像素是否连通，必须确定他们是否相邻及它们的灰度时候满足特定的相似性准则（或者说，它们的灰度值是否相等）。</p><p>例如：当两个像素是4邻接，但是仅当它们的灰度值相同时才能说是连通的。</p><p><img src="/images/2021/06/E269A7EA-D0A1-49DA-ADA0-FA128D166E1D.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p>令V是用于定义邻接性的灰度值集合，（V是一个规则，例如V&#x3D;{A-B≤2}）如果q在p的四邻域N4(p)集中，且p和q满足V，则称p和q是4邻接，邻接性就是连通性。</p><p><strong>注意：</strong></p><ul><li><strong>4邻接必然是8邻接，反之不然；m邻接必然是8邻接，反之不然。</strong></li><li><strong>m邻接是介于4邻接和8邻接之间的。</strong></li><li><strong>m邻接是8邻接的变形，可以消除8邻接中的多路问题</strong></li></ul><h3 id="2-3-3-距离的度量"><a href="#2-3-3-距离的度量" class="headerlink" title="2.3.3 距离的度量"></a>2.3.3 距离的度量</h3><p>像素在空间的接近程度可以用像素之间的距离来度量。为测量距离需要定义距离度量函数。给定三个像素，其坐标分别为</p><p><img src="https://img-blog.csdnimg.cn/20200203155110621.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/image-2.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="2-4-图像的分类"><a href="#2-4-图像的分类" class="headerlink" title="2.4 图像的分类"></a>2.4 图像的分类</h4><p><img src="/images/2021/06/image-3.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="2-4-1-位图"><a href="#2-4-1-位图" class="headerlink" title="2.4.1 位图"></a>2.4.1 位图</h3><p>位图是静止图像的一种。位图是通过许多像素点表示一幅图像，每个像素具有颜色属性和位置属性。</p><p><img src="/images/2021/06/image-4.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/16/shuzituxiang2/">https://blog.jujimeizuo.cn/2021/06/16/shuzituxiang2/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理期末复习（一）概述</title>
      <link href="/2021/06/16/shuzituxiang1/"/>
      <url>/2021/06/16/shuzituxiang1/</url>
      
        <content type="html"><![CDATA[<h4 id="1-1数字图像处理相关概念"><a href="#1-1数字图像处理相关概念" class="headerlink" title="1.1数字图像处理相关概念"></a>1.1数字图像处理相关概念</h4><p><strong>图</strong>：物体透射或反射光的分布，是客观存在的</p><p><strong>像</strong>：人的视觉系统对图的接受在大脑中形成的印象或反映</p><p><strong>图像</strong>：是图和像的有机结合，是客观世界能量或状态以可视化形式在二维平面上的投影</p><p><strong>数字图像</strong>：物体的一个数字表示，是以数字格式存放的图像</p><p><strong>数字图像处理</strong>：又称为计算机图像处理，将<strong>图像信号</strong>转换成<strong>数字信号</strong>并利用<strong>计算机对其进行处理</strong>的过程，以提高图像的实用性，从而达到人们所要求的预期结果。</p><p><strong>数字图像处理目的</strong>：</p><ol><li>提高图像的视感质量，以达到赏心悦目的目的</li><li>提取图像中所包含的某些特征或特殊信息，便于计算机分析</li><li>对图像数据进行变换、编码和压缩，便于图像的存储和传输。</li></ol><p><strong>数字图像处理特点</strong>：</p><ol><li>处理信息量很大</li><li>数字图像处理占用的频带较宽</li><li>数字图像中各个像素相关性大</li></ol><h4 id="1-2数字图像处理系统流程图"><a href="#1-2数字图像处理系统流程图" class="headerlink" title="1.2数字图像处理系统流程图"></a>1.2数字图像处理系统流程图</h4><p><img src="/images/2021/06/image.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><img src="/images/2021/06/20200203154623189.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h4 id="1-3数字图像处理主要研究内容"><a href="#1-3数字图像处理主要研究内容" class="headerlink" title="1.3数字图像处理主要研究内容"></a>1.3数字图像处理主要研究内容</h4><p><img src="/images/2021/06/20200203154634990.png"> <img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/06/16/shuzituxiang1/">https://blog.jujimeizuo.cn/2021/06/16/shuzituxiang1/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数字图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/05/21/codeforces-round-721-div-2-e-partition-game/"/>
      <url>/2021/05/21/codeforces-round-721-div-2-e-partition-game/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1527/problem/E">https://codeforces.com/contest/1527/problem/E</a></p><p>$当时E题没有时间写，但是20分钟足够了。$</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$将一个长为n的序列，分成k段。$ $在每段中，对于每个数字来说，贡献为最后一次出现的位置减第一次出现的位置，即last(x)-first(x)$</p><p>$求分成k段后，最小的总贡献。$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$n分成k段，再看看数据范围，n\leq 35000，k\leq 100，dp[n][k]$</p><p>$dp[n][k]表示前n个数字分成k段后的最小总贡献。$ $那么转移方程就非常好写：$</p><p>$$dp[i][j]&#x3D;dp[i-1][k]+val[k+1][j]$$ $val[i][j]表示[i,j]内所有数字的贡献。$ $很容易推出k \in [i-1,j-1]$</p><p>$这样我们的复杂度为O(n^2k)，是不行的，不过O(nk)是可以的，所以我们想办法消掉一个n。$</p><p>$因为我们的dp[i][j]都是由dp[i-1][j-1]推出来的。$ $而我们的目的就是找到一个k使得dp[i-1][k]+val[k+1][j]最小，而k \in [i-1,j-1].$ $进而我们可以用线段树围绕k维护区间最小值，这样我们可以在log内找到这样的k进行转移。$</p><p>$假设我们当前要将第j个数字分类，则[1,前一个位置-1]的贡献都要改变，变多少呢？多j-(前一个位置)。$</p><p>$也就是修改：$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(from[j] != <span class="number">-1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, from[j] - <span class="number">1</span>, j - from[j]);</span><br></pre></td></tr></table></figure><p>$查询是在[i-1,j-1]找，也就是：$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j][i] = <span class="built_in">min</span>(dp[j - <span class="number">1</span>][i - <span class="number">1</span>], <span class="built_in">query</span>(<span class="number">1</span>, i - <span class="number">1</span>, j - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>$最终时间复杂度为O(nk\log n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][K];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> mn;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].mn = <span class="built_in">min</span>(t[lc].mn, t[rc].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t[u].tag) <span class="keyword">return</span> ;</span><br><span class="line">    t[lc].tag += t[u].tag;</span><br><span class="line">    t[rc].tag += t[u].tag;</span><br><span class="line">    t[lc].mn  += t[u].tag;</span><br><span class="line">    t[rc].mn  += t[u].tag;</span><br><span class="line">    t[u].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    t[u].tag = <span class="number">0</span>; t[u].mn = INF;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].mn = dp[l][k];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m, k);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        t[u].mn += val;</span><br><span class="line">        t[u].tag += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(lc, ql, qr, val);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt;  mid) <span class="built_in">modify</span>(rc, ql, qr, val);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) <span class="keyword">return</span> t[u].mn;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(lc, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr  &gt; mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(rc, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">pre</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span>, <span class="title">from</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        from[i] = pre[a[i]];</span><br><span class="line">        <span class="keyword">if</span>(from[i] != <span class="number">-1</span>) dp[i][<span class="number">1</span>] += i - from[i];</span><br><span class="line">        pre[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(from[j] != <span class="number">-1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, from[j] - <span class="number">1</span>, j - from[j]);</span><br><span class="line">            dp[j][i] = <span class="built_in">min</span>(dp[j - <span class="number">1</span>][i - <span class="number">1</span>], <span class="built_in">query</span>(<span class="number">1</span>, i - <span class="number">1</span>, j - <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// cout &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; &quot;分成&quot; &lt;&lt; i &lt;&lt; &quot;段：&quot; &lt;&lt; &quot; &quot; &lt;&lt; dp[j][i] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/21/codeforces-round-721-div-2-e-partition-game/">https://blog.jujimeizuo.cn/2021/05/21/codeforces-round-721-div-2-e-partition-game/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛50 B Random eat Cake 排列组合</title>
      <link href="/2021/05/18/nowcoder50-b-random-eat-cake/"/>
      <url>/2021/05/18/nowcoder50-b-random-eat-cake/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/11190/B">https://ac.nowcoder.com/acm/contest/11190/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2021/05/20210518183540915.png" alt="在这里插入图片描述"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$排列组合题，基本都是考虑“数”的贡献。$</p><p>$所以我们针对每个数字1，2…n出现的次数，即贡献为num_i*\frac{1}{i!}，num_i表示i出现的次数。$</p><p>$即ans&#x3D;\sum_{i&#x3D;1}^{n}num_i*\frac{1}{i!}$</p><p>$比如先考虑1，先拿出一个1，然后还剩下n-1，则我们让他们随意组合。$ $假设n-1组成4个数字，则由捆绑法可得:$</p><p>$n-1的组成4个数字的种数为C_{n-2}^{3}，然后我们的1可以插入5个位置，则*5.$</p><p>$我们可以让n-1组成1到n-1个数字，进而得出，1出现的总次数为：$</p><p>$C_{n-2}^{0}*2+C_{n-2}^{1}*3+…+C_{n-2}^{n-3}*(n-1)+C_{n-2}^{n-2}*n$</p><p>$由组合恒等式算出来，这个式子为2^{n-1}+(n-2)*2^{n-3}$</p><p>$则1的总贡献为\frac{1}{1!}*(2^{n-1}+(n-2)*2^{n-3})$</p><p>$然后计算2，3一直到n的贡献，加起来即可。注意一些边界问题，越界了都当成0.$</p><p>$分母就是n个1能有多少种组成方法:$</p><ul><li>$组成1个数，C_{n-1}^{0}$</li><li>$组成2个数，C_{n-1}^{1}$</li><li>…</li><li>$组成n个数字,C_{n-1}^{n-1}$</li></ul><p>$由二项式定理得，分母为2^{n-1}$</p><p>$总结一下ans：$</p><p>$$\frac{\sum_{i&#x3D;1}^{n}2^{n-i}+(n-i-1)*2^{n-i-2}}{2^{n-1}}$$</p><p>$预处理然后O(n)计算。$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll fac[N], inv[N], invF[N];</span><br><span class="line">ll bit[N], invbit[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll inv2 = <span class="built_in">quick_pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    invbit[<span class="number">0</span>] = bit[<span class="number">0</span>] = fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    bit[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    invbit[<span class="number">1</span>] = inv2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">        bit[i] = bit[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">        invbit[i] = invbit[i - <span class="number">1</span>] * inv2 % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + invF[i] * (bit[n - i] + (n - i - <span class="number">1</span> &gt;= <span class="number">0</span> ? n - i - <span class="number">1</span> : <span class="number">0</span>) * bit[(n - i - <span class="number">2</span> &gt;= <span class="number">0</span> ? n - i - <span class="number">2</span> : <span class="number">0</span>)] % mod) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * invbit[n - <span class="number">1</span>] % mod;</span><br><span class="line">        cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/18/nowcoder50-b-random-eat-cake/">https://blog.jujimeizuo.cn/2021/05/18/nowcoder50-b-random-eat-cake/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【牛客】树的距离 树上主席树</title>
      <link href="/2021/05/11/tree-distance-tree-chairman-tree/"/>
      <url>/2021/05/11/tree-distance-tree-chairman-tree/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/problem/14415">https://ac.nowcoder.com/acm/problem/14415</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$给一颗树，求以x为子树中，距离x大于等于k的点与x的距离和。$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$这题求的是子节点到x的距离，而我们dfs的过程中很容易得到子节点到根的距离dis。$</p><p>$所以我们转换一下，求x子节点中距离根大于等于k+dis[x]的点与x的距离和。$</p><p>$假设我们知道个数为sum\_num，这些点距离根的和为sum\_dis。$ $则ans&#x3D;sum\_dis - sum\_num * dis[x]$</p><p>$怎么求个数呢？怎么求大于等于k的点的个数呢？$</p><p>$我们可以利用主席树帮助求解，以dis[x]为叶子的主席树。$ $然后求区间内\ge k的个数即可。$</p><p>$这里有几个小细节：$</p><ul><li>$dis的大小会爆int，所以我们需要离散化进而建席树$</li><li>$dfs序建主席树，因为是树上$</li></ul><p>$最后，这题需要一定的代码能力。$</p><h2 id="Code（709MS）"><a href="#Code（709MS）" class="headerlink" title="Code（709MS）"></a>Code（709MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, val;</span><br><span class="line">&#125;t[N * <span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> root[N], cnt;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x) - v.<span class="built_in">begin</span>() + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> &amp;now, <span class="type">int</span> l, <span class="type">int</span> r, ll p, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    t[now = ++cnt] = t[pre];</span><br><span class="line">    t[now].val += val;</span><br><span class="line">    t[now].sum += v[p - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="built_in">insert</span>(t[pre].l, t[now].l, l, m, p, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(t[pre].r, t[now].r, m + <span class="number">1</span>, r, p, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> now, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> l, <span class="type">int</span> r, ll &amp;sum_num, ll &amp;sum_dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        sum_num += t[now].val - t[pre].val;</span><br><span class="line">        sum_dis += t[now].sum - t[pre].sum;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= m) <span class="built_in">query</span>(t[pre].l, t[now].l, ql, qr, l, m, sum_num, sum_dis);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; m)  <span class="built_in">query</span>(t[pre].r, t[now].r, ql, qr, m + <span class="number">1</span>, r, sum_num, sum_dis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in[N], out[N], tim;</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    in[u] = ++tim;</span><br><span class="line">    v.<span class="built_in">push_back</span>(dis[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> v = e.v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v] = dis[u] + e.w;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    out[u] = tim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> cct)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(root[in[u] - <span class="number">1</span>], root[in[u]], <span class="number">1</span>, cct, <span class="built_in">getid</span>(dis[u]), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) <span class="keyword">if</span>(e.v != fa) <span class="built_in">dfs2</span>(e.v, u, cct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p; ll d; cin &gt;&gt; p &gt;&gt; d;</span><br><span class="line">        g[i].<span class="built_in">push_back</span>(Edge&#123;p, d&#125;);</span><br><span class="line">        g[p].<span class="built_in">push_back</span>(Edge&#123;i, d&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> cct = (<span class="type">int</span>)v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, cct);</span><br><span class="line">    <span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> x; ll y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        y = dis[x] + y;</span><br><span class="line">        <span class="type">int</span> id = <span class="built_in">getid</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(id &gt; cct) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll sum_num = <span class="number">0</span>, sum_dis = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>(root[in[x] - <span class="number">1</span>], root[out[x]], id, cct, <span class="number">1</span>, cct, sum_num, sum_dis);</span><br><span class="line">        cout &lt;&lt; (ll)(sum_dis - sum_num * dis[x]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/11/tree-distance-tree-chairman-tree/">https://blog.jujimeizuo.cn/2021/05/11/tree-distance-tree-chairman-tree/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces484 E. Sign on Fence 主席树+线段树维护连续1区间+二分</title>
      <link href="/2021/05/07/codeforces484-e-sign-on-fence/"/>
      <url>/2021/05/07/codeforces484-e-sign-on-fence/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/484/problem/E">https://codeforces.com/contest/484/problem/E</a></p><p>鏖战3小时，终于…</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个序列a，m次查询，l,r,w，查询[l,r]中所有连续w个元素最小值的最大值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>查找最值，想到二分，但是要求所有[l,r]中连续w个元素区间中的最小值的最大值。</p><p>首先二分的是答案，但是h有1e9之多，二分的常数较大，所以我们可以将序列排序，然后二分下标。</p><p>假设枚举的下标为mid，则在一个区间中至少有w个元素比mid大。 则合法，ans&#x3D;mid，r&#x3D;mid+1，否则l&#x3D;mid+1。</p><p>但是我们怎么check这个区间呢？ 设比mid大的为1，反之为0，则我们要求是是否存在最长的连续1区间长度$\ge$ w。</p><p>这一部分可以用线段树处理，就是处理suml,sumr,sum等等。自行百度。</p><p>但是不可能每次check都要建立一颗线段树啊，不仅MLE还会TLE。</p><p>这时候就需要主席树这个黑科技，将序列从大到小排列后正向建立主席树，也就是创建每一个不同的版本。</p><p>而我们二分得到的mid，就可以直接在root[mid]这个版本进行处理即可。</p><p>所以总流程为：</p><ul><li>$序列从小到达排序建立主席树$</li><li>$每个版本的线段树维护最长连续1区间长度$</li><li>$对于每次询问，二分答案下标，查询时候存在query\ge w，然后处理l和r的走向。$</li><li>$输出a[ans].x$</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.id &gt; b.id : a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HJTTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> suml, sumr, sum;</span><br><span class="line">&#125;t[N * <span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> root[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    t[u].suml = t[t[u].l].suml;</span><br><span class="line">    <span class="keyword">if</span>(t[t[u].l].suml == mid - l + <span class="number">1</span>) t[u].suml += t[t[u].r].suml;</span><br><span class="line">    t[u].sumr = t[t[u].r].sumr;</span><br><span class="line">    <span class="keyword">if</span>(t[t[u].r].sumr == r - mid) t[u].sumr += t[t[u].l].sumr;</span><br><span class="line">    t[u].sum = <span class="built_in">max</span>(<span class="built_in">max</span>(t[t[u].l].sum, t[t[u].r].sum), t[t[u].l].sumr + t[t[u].r].suml);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> &amp;now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    t[now = ++cnt] = t[pre];</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[now].sum = t[now].suml = t[now].sumr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="built_in">insert</span>(t[pre].l, t[now].l, l, m, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(t[pre].r, t[now].r, m + <span class="number">1</span>, r, p);</span><br><span class="line">    <span class="built_in">push_up</span>(now, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql == l &amp;&amp; r == qr) <span class="keyword">return</span> t[u].sum;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr &lt;= m) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(t[u].l, ql, qr, l, m));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; m) ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(t[u].r, ql, qr, m + <span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(<span class="built_in">query</span>(t[u].l, ql, m, l, m), <span class="built_in">query</span>(t[u].r, m + <span class="number">1</span>, qr, m + <span class="number">1</span>, r));</span><br><span class="line">        <span class="comment">// 左儿子的右区间、右儿子的左区间---合并</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(m - ql + <span class="number">1</span>, t[t[u].l].sumr) + <span class="built_in">min</span>(qr - m, t[t[u].r].suml));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i].x, a[i].id = i;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">insert</span>(root[i - <span class="number">1</span>], root[i], <span class="number">1</span>, n, a[i].id);</span><br><span class="line">    <span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> ql, qr, w; cin &gt;&gt; ql &gt;&gt; qr &gt;&gt; w;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n, ans = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(root[mid], ql, qr, <span class="number">1</span>, n) &gt;= w) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a[ans].x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/07/codeforces484-e-sign-on-fence/">https://blog.jujimeizuo.cn/2021/05/07/codeforces484-e-sign-on-fence/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces - 560E Gerald and Giant Chess dp+排列组合</title>
      <link href="/2021/05/07/codeforces-560e-gerald-and-giant-chess/"/>
      <url>/2021/05/07/codeforces-560e-gerald-and-giant-chess/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/560/problem/E">https://codeforces.com/contest/560/problem/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n*m的棋盘，想要从(1,1)走到(n,m)，但是又k个坏点不能经过，问有多少种方案？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为n和m都有1e5，所以不能f[i][j]，但是k只有2000，所以我们考虑坏点$O(n^2)$做法。</p><p>假如我们枚举到达坏点的方案，也可以将(n,m)这一点看出第k+1个坏点，所以考虑每两个坏点之间方案。</p><p>可以推出(x1,y1)走到(x2,y2)的方案为$C_{x_2-x_1+y_2-y_1}^{x_2-x_1}$。</p><p>所以从(1,1)出发到达的坏点有$C_{x+y-2}^{x-1}$。</p><p>设两个坏点为i和j，并且不能通过j到达i，所以要把到达i的方案减掉j到i的方案，即</p><p>$$dp[i]&#x3D;dp[i]-dp[j]*\sum_{j&#x3D;1}^{i-1}C_{p[i].x-p[j].x+p[i].y-[j].y}^{p[i].x-p[j].x}$$</p><p>这样一直枚举下去，ans&#x3D;dp[k+1]，即到达最后一个坏点(n,m)的方案数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll F[N], inv[N], invF[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    F[<span class="number">0</span>] = inv[<span class="number">0</span>] = invF[<span class="number">0</span>] = F[<span class="number">1</span>] = inv[<span class="number">1</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = F[m];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pll a, pll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(k + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;pll&gt; <span class="title">p</span><span class="params">(k + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i++) cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>() + <span class="number">1</span>, p.<span class="built_in">begin</span>() + k + <span class="number">1</span>, cmp);</span><br><span class="line">    p[++k].first = n; p[k].second = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">C</span>(p[i].first + p[i].second - <span class="number">2</span>, p[i].first - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i; j++) &#123; <span class="comment">// j到i</span></span><br><span class="line">            <span class="keyword">if</span>(p[i].first &gt;= p[j].first &amp;&amp; p[i].second &gt;= p[j].second) &#123;</span><br><span class="line">                <span class="comment">// int temp = C(p[i].first - p[j].first + p[i].second - p[j].second, p[i].first - p[j].first);</span></span><br><span class="line">                dp[i] = (dp[i] - dp[j] * <span class="built_in">C</span>(p[i].first - p[j].first + p[i].second - p[j].second, p[i].first - p[j].first) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (dp[k] % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/07/codeforces-560e-gerald-and-giant-chess/">https://blog.jujimeizuo.cn/2021/05/07/codeforces-560e-gerald-and-giant-chess/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白月赛28 E-会当凌绝顶，一览众山小 线段树+二分暴力模拟</title>
      <link href="/2021/05/07/nowcoder-beginner28-e/"/>
      <url>/2021/05/07/nowcoder-beginner28-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/16081/E">https://ac.nowcoder.com/acm/contest/16081/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><ul><li>登山顺序不一定从左到右，是按照给出山峰的顺序</li><li>找到左边第一个大于当前山峰的山峰的坐标，修改它</li><li>如果右边没有大于当前山峰的，找到离当前山峰最近的最矮山峰，修改它</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先顺序是按照给出的山峰顺序，并且x坐标过大，但是点数只有2e5，所以需要离散化。</p><p>对于一个点，需要找到左边和右边两个特殊要求的山峰，这个过程可以二分。 并且是区间查询，所以需要线段树维护，维护区间最大值和最小值即可。</p><ul><li>左边：假设当前是第i座山，映射过去的位置是pos(离散化)，二分[1,pos]区间，找到最近的一个大于当前高度的山</li><li>右边：同理。假设映射的位置是pos,先求出区间[pos+1,n]的最大值判断需不需要修改。若是需要，则二分[pos+1,n]区间，找到最近的一个最小值</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, h;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> b[N], h[N], idx[N];</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> mx, mn;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].mx = <span class="built_in">max</span>(t[lc].mx, t[rc].mx);</span><br><span class="line">    t[u].mn = <span class="built_in">min</span>(t[lc].mn, t[rc].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].mx = t[u].mn = h[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[u].l == t[u].r) &#123;</span><br><span class="line">        t[u].mn = t[u].mx = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">modify</span>(lc, p, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rc, p, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) <span class="keyword">return</span> t[u].mx;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">-1e9</span> - <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) mx = <span class="built_in">max</span>(mx, <span class="built_in">query_max</span>(lc, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  mx = <span class="built_in">max</span>(mx, <span class="built_in">query_max</span>(rc, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_min</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) <span class="keyword">return</span> t[u].mn;</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) mn = <span class="built_in">min</span>(mn, <span class="built_in">query_min</span>(lc, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  mn = <span class="built_in">min</span>(mn, <span class="built_in">query_min</span>(rc, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> mn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].x &gt;&gt; a[i].h;</span><br><span class="line">        b[i] = a[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        idx[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>, a[i].x) - b;</span><br><span class="line">        h[idx[i]] = a[i].h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> pos = idx[i];</span><br><span class="line">        <span class="comment">/*------查找左边1-pos--------*/</span></span><br><span class="line">        <span class="type">int</span> lx = <span class="built_in">query_max</span>(<span class="number">1</span>, <span class="number">1</span>, pos);</span><br><span class="line">        <span class="keyword">if</span>(lx &gt; h[pos]) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>, r = pos, ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                lx = <span class="built_in">query_max</span>(<span class="number">1</span>, m, pos);</span><br><span class="line">                <span class="keyword">if</span>(lx &gt; h[pos]) ans = m, l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h[ans] = h[pos]; <span class="built_in">modify</span>(<span class="number">1</span>, ans, h[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*---------查找右边pos+1-n-----------*/</span></span><br><span class="line">        <span class="type">int</span> rx = <span class="built_in">query_max</span>(<span class="number">1</span>, pos + <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">if</span>(rx &lt;= h[pos]) &#123;</span><br><span class="line">            rx = <span class="built_in">query_min</span>(<span class="number">1</span>, pos + <span class="number">1</span>, n);</span><br><span class="line">            <span class="type">int</span> l = pos + <span class="number">1</span>, r = n, ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> nrx = <span class="built_in">query_min</span>(<span class="number">1</span>, pos + <span class="number">1</span>, m);</span><br><span class="line">                <span class="keyword">if</span>(nrx == rx) ans = m, r = m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h[ans] = h[pos]; <span class="built_in">modify</span>(<span class="number">1</span>, ans, h[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cout &lt;&lt; h[idx[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/07/nowcoder-beginner28-e/">https://blog.jujimeizuo.cn/2021/05/07/nowcoder-beginner28-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白月赛28 I-迷宫 二维dp+背包</title>
      <link href="/2021/05/06/nowcoder-beginner28-i/"/>
      <url>/2021/05/06/nowcoder-beginner28-i/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/16081/I">https://ac.nowcoder.com/acm/contest/16081/I</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个n×m的网格地图，每个点有个值$a_{ij}$ ，现在牛牛要从(1，1)走到(n，m). 他可以往右边或者往下走，每次到一个点会获得当前的点权值，并将权值和mod 1e4+7. 当牛牛从不同方式走到(n，m)的时候能获得多少种权值和？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题给的mod很关键，只有1e4，然后n和m只有100，所以能猜出来复杂度为100*100*10000，1e8只能说很标准但又很危险。</p><p>设f[i][j][k]表示走到第i行第j列加上a[i][j]之后存在k这个权值，则转移可以从上面或者左边都可以。</p><p>$$f[i][j][k]&#x3D;max(f[i-1][j][k-a[i][j]],f[i][j-1][k-a[i][j]])$$</p><p>注意mod的范围，不要RE，并且不要开ll，不要MLE，最好刚开始手动$a[i][j]\%mod$，不要WA。</p><p>复杂度为$O(n*m*mod)$。</p><h2 id="Code（384MS）"><a href="#Code（384MS）" class="headerlink" title="Code（384MS）"></a>Code（384MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e4</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">bool</span> dp[N][N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= mod) <span class="keyword">return</span> x % mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> x % mod + mod;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            a[i][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][a[<span class="number">1</span>][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = mod - <span class="number">1</span>;k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="type">int</span> temp = <span class="built_in">Mod</span>(k - a[i][j]);</span><br><span class="line">                dp[i][j][k] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>][temp], dp[i - <span class="number">1</span>][j][temp]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; mod; i++) ans += dp[n][m][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/06/nowcoder-beginner28-i/">https://blog.jujimeizuo.cn/2021/05/06/nowcoder-beginner28-i/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 14 E. Phoenix and Computers dp+排列组合</title>
      <link href="/2021/05/03/codeforces-global-round-14-e-phoenix-and-computers/"/>
      <url>/2021/05/03/codeforces-global-round-14-e-phoenix-and-computers/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1515/problem/E">https://codeforces.com/contest/1515/problem/E</a> 赛中想了一个多小时，还是处理不了一些细节。</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个电脑排在一排，你可以手动打开任意电脑，但是有个特点， 对于一个电脑，如果它左右都被打开了，那么它会自动打开。</p><p>最后问，有多少种全部开机方案？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们考虑两种方式，第一种全部都是手动打开，第二种带有自动打开。</p><ul><li><strong>全部手动打开</strong></li></ul><p>对于电脑1，如果要全部手动开启，则需要按照1，2…n的顺序打开，$C_{n-1}^0$ 对于电脑2，如果要全部手动开启，则后面必须按照3,4..n的顺序，前面必须1，$C_{n-1}^1$ 对于电脑k，如果要全部手动开启，则后面必须要按照k+1,k+2…n的顺序，前面必须是k-1,…1的顺序，所有要在n-1中选k-1个开前面，$C_{n-1}^{k-1}$</p><p>则总方案数为$C_{n-1}^0+C_{n-1}^1+…+C_{n-1}^{n-1}&#x3D;2^{n-1}$</p><p>也就是说，对于x台电脑，如果全部手动开启的话，有$2^{x-1}$种方案数，下面会用到。</p><ul><li><strong>如果有自动打开</strong></li></ul><p>自动打开只会出现现在左右都打开后才会自动打开，所以假设这么一种开机方式： 设有$x_k$台电脑自动开启。 1到$x_1-1$手动打开，$x_1+1$到$x_2-1$手动打开，…$x_k+1$到n手动打开。$(x_k+1\leq N)$ 这样，$x_k$台都满足自动打开的要求。</p><p>然后就是要怎么进行这个过程。</p><p>设f[i][j]为前i台电脑中，有j台是手动打开，第i台也是手动打开，并且第i+1台自动开启的方案数。</p><p>则我们想让第i+1台成为自动打开的电脑，则i+1后面几台电脑手动打开，设为k台。</p><p>则就是f[i][j]向f[i+1+k][j+k]的转移，怎么转移呢？</p><p>f[i+1+k][j+k]比f[i][j]多了k台手动开启。 这k台我们称为“新”打开的电脑，j台我们称为“旧”打开的电脑。 第i+1是自动打开的。 之前我们处理过，k台手动开启的方案数为$2^{k-1}$，然后我们要将k台和j台一起合并。 那么就是有j+k台中，有k台是“新”电脑，方案数为$C_{k+j}^k$。</p><p>则转移方程为$f[i+1+k][j+k]&#x3D;f[i][j]*2^{k-1}*C_{j+k}^k。$</p><p>i、j、k三层循环进行转移，$O(n^3)$是可以的。</p><p>最后预处理组合数进行转移即可。</p><h2 id="Code-436MS"><a href="#Code-436MS" class="headerlink" title="Code(436MS)"></a>Code(436MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, mod;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>;</span><br><span class="line">ll F[N], invn[N], invF[N], bit[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bit[<span class="number">1</span>] = F[<span class="number">0</span>] = F[<span class="number">1</span>] = invn[<span class="number">0</span>] = invn[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++)&#123;</span><br><span class="line">        F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        invn[i] = (mod - mod / i) * invn[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * invn[i] % mod;</span><br><span class="line">        bit[i] = bit[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = F[m];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;ll&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123; <span class="comment">// 前i台电脑</span></span><br><span class="line">        dp[i][i] = bit[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= i; j++) &#123; <span class="comment">// i台中有j台是手动打开的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k + i + <span class="number">1</span> &lt;= n; k++) &#123; <span class="comment">// i + 1是自动打开的，然后后面k台需要手动打开</span></span><br><span class="line">                dp[i + <span class="number">1</span> + k][j + k] = (dp[i + <span class="number">1</span> + k][j + k] + dp[i][j] * bit[k] % mod * <span class="built_in">C</span>(j + k, k) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ans = (ans + dp[n][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/03/codeforces-global-round-14-e-phoenix-and-computers/">https://blog.jujimeizuo.cn/2021/05/03/codeforces-global-round-14-e-phoenix-and-computers/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给你的博客网站添加一个看板娘</title>
      <link href="/2021/05/02/live2d/"/>
      <url>/2021/05/02/live2d/</url>
      
        <content type="html"><![CDATA[<p>致谢大佬：<a href="https://m1314.cn/287.html">Mario</a></p><h3 id="项目下载地址"><a href="#项目下载地址" class="headerlink" title="项目下载地址"></a>项目下载地址</h3><span id="more"></span><p><a href="https://github.com/jujimeizuo/wordpress_live2d">https://github.com/jujimeizuo/wordpress_live2d</a></p><h3 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h3><p>需要 <code>Font Awesome 4.7.0</code> 支持，请确保相关样式表已在页面中加载，例如在 <code>&lt;head&gt;</code> 中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;</span><br></pre></td></tr></table></figure><p> </p><h3 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h3><p><a href="https://github.com/jujimeizuo/wordpress_live2d">适用于Sakura主题的live2d + 少女前线API</a></p><h4 id="少女前线API版"><a href="#少女前线API版" class="headerlink" title="少女前线API版"></a>少女前线API版</h4><blockquote><ol><li>如果你是小白，或者只需要最基础的功能，请将上方 <strong>项目代码</strong> 下载下来【前面的 <code>Font Awesome</code> 的一行代码（<strong>看需求添加</strong>）】，将 <code>live2d_api</code> 目录放到你的站点根目录，新建一个 <code>live2d</code> 目录将项目的其他文件都放进去。</li><li>修改 <code>autoload.js</code> 文件中第37行的 <code>apiPath</code> 为你的 <code>https://你的域名/live2d_api/</code>, 第2行和第3行路径改为 <code>https://你的域名/live2d/</code></li><li>然后在你主题的 <code>footer.php</code> 文件 <code>&lt;/body&gt;</code> 标签之上引用即可</li></ol></blockquote><p> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://你的域名/live2d/autoload.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="效果示意图"><a href="#效果示意图" class="headerlink" title="效果示意图"></a>效果示意图</h3><p><img src="/images/2021/05/EKP694EJX@QK_4.png"><img src="/images/2021/05/VC9YM177S3GJAIBM2.png"></p><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p><code>autoload.js</code> 中的 <code>apiPath:</code> 为 live2d API 接口，默认即可，如果你有其他的也可以修改 <code>autoload.js</code> 中的 <code>cdnPath:</code> 为对象存储路径，注意跨域的问题，不使用请注释掉 Json配置（SDK 2）：<a href="https://live2d.pavostudio.com/doc/zh-cn/live2d/model-config-sdk2/">https://live2d.pavostudio.com/doc/zh-cn/live2d/model-config-sdk2/</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/05/02/live2d/">https://blog.jujimeizuo.cn/2021/05/02/live2d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> wordpress美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache2不能重启</title>
      <link href="/2021/04/25/apache2-not-start/"/>
      <url>/2021/04/25/apache2-not-start/</url>
      
        <content type="html"><![CDATA[<h4 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[....] Starting apache2 (via systemctl): apache2.serviceJob <span class="keyword">for</span> apache2.service failed because the control process exited with error code.</span><br><span class="line">See <span class="string">&quot;systemctl status apache2.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"> failed!</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>经过测试卸载并清除软件包的配置即可解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge apache2 </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 </span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/25/apache2-not-start/">https://blog.jujimeizuo.cn/2021/04/25/apache2-not-start/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 配置php</title>
      <link href="/2021/04/24/linux-config-php/"/>
      <url>/2021/04/24/linux-config-php/</url>
      
        <content type="html"><![CDATA[<h2 id="php配置"><a href="#php配置" class="headerlink" title="php配置"></a>php配置</h2><h4 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h4><p><a href="http://php.net/downloads.php-8.0.3.tar.gz">http://php.net/downloads.php-8.0.3.tar.gz</a></p><p>放在目录&#x2F;usr&#x2F;local&#x2F;src下：</p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf php-8.0.3.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/2021/04/20210424104401884.png"></p><h4 id="configure"><a href="#configure" class="headerlink" title=".&#x2F;configure"></a>.&#x2F;configure</h4><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h4 id="libxml缺失"><a href="#libxml缺失" class="headerlink" title="libxml缺失"></a>libxml缺失</h4><p><img src="/images/2021/04/20210424104732489.png"></p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxml2-dev</span><br></pre></td></tr></table></figure><h4 id="sqlite3缺失"><a href="#sqlite3缺失" class="headerlink" title="sqlite3缺失"></a>sqlite3缺失</h4><p><img src="/images/2021/04/20210424110417584.png"></p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sqlite3</span><br></pre></td></tr></table></figure><p>还是找不到？</p><p>这里是缺少dev相关配置。</p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsqlite3-dev</span><br></pre></td></tr></table></figure><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>等待一段时间</p><h4 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h4><p>等待一段时间后，完成。</p><h4 id="结束步骤"><a href="#结束步骤" class="headerlink" title="结束步骤"></a>结束步骤</h4><p>将php配置文档复制到 &#x2F;usr&#x2F;local&#x2F;lib 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> php.ini-development /usr/local/lib</span><br></pre></td></tr></table></figure><p>改名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /usr/local/lib/php.ini-development /usr/local/lib/php.ini</span><br></pre></td></tr></table></figure><h2 id="配置apache关联php"><a href="#配置apache关联php" class="headerlink" title="配置apache关联php"></a>配置apache关联php</h2><p><strong>apache版本不同，文件存放位置不同。方便起见，这里采用旧版形式，但是个人用的是新版的apache2。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure><h4 id="配置httpd-conf"><a href="#配置httpd-conf" class="headerlink" title="配置httpd.conf"></a>配置httpd.conf</h4><p>需要添加下面几句话，为了能让php文件正常编译：</p><h3 id="老版apache"><a href="#老版apache" class="headerlink" title="老版apache"></a>老版apache</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##Example:</span></span><br><span class="line"><span class="comment">##LoadMoudle foo_module modules/mod_foo.so</span></span><br><span class="line">LoadModule php5_module modules/libphp5.so</span><br><span class="line"><span class="comment">##Addtype application/x-tar .tgz</span></span><br><span class="line">AddType application/x-httpd-php .php</span><br><span class="line"><span class="comment">##</span></span><br></pre></td></tr></table></figure><p>但是LoadModule之后，sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 restart会报错。 原因：</p><p>版本不同、文件存放位置不同、代码写错等等情况。</p><h3 id="新版apache2"><a href="#新版apache2" class="headerlink" title="新版apache2"></a>新版apache2</h3><p>开启php模块：</p><p>cd到apache的模块目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2/mods-available</span><br></pre></td></tr></table></figure><p>找到php开头的文件，然后开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod php7.2</span><br></pre></td></tr></table></figure><p>会出现这样的错误：</p><p><img src="/images/2021/04/20210425155306341.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2dismod mpm_event</span><br></pre></td></tr></table></figure><p><img src="/images/2021/04/2021042515545893.png"></p><p>最后重启一下apache2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><p>如果出错的话，html的文件也会出错，但是删掉即可。但是这个问题还是要解决的。</p><h4 id="查看网站的DocumentRoot和DirectoryIndex"><a href="#查看网站的DocumentRoot和DirectoryIndex" class="headerlink" title="查看网站的DocumentRoot和DirectoryIndex"></a>查看网站的DocumentRoot和DirectoryIndex</h4><p>借鉴：<a href="https://www.cnblogs.com/omak/p/11102133.html">https://www.cnblogs.com/omak/p/11102133.html</a></p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>编写一个php文件放在网站根目录下，然后网页输入地址即可。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/24/linux-config-php/">https://blog.jujimeizuo.cn/2021/04/24/linux-config-php/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot下载文件</title>
      <link href="/2021/04/22/springboot-download-file/"/>
      <url>/2021/04/22/springboot-download-file/</url>
      
        <content type="html"><![CDATA[<h4 id="下载文件，实现在线和下载到本地"><a href="#下载文件，实现在线和下载到本地" class="headerlink" title="下载文件，实现在线和下载到本地"></a>下载文件，实现在线和下载到本地</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjgsu.sdc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zjgsu.sdc.pojo.resquest.Name;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.FileSystemResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ContentDisposition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.nashorn.internal.runtime.regexp.joni.Config.log;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;sdc.download.path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String filepath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download/&#123;file&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;FileSystemResource&gt; <span class="title function_">download</span><span class="params">(<span class="meta">@PathVariable</span> String file)</span> &#123;</span><br><span class="line"><span class="comment">//        if(file == null) &#123;</span></span><br><span class="line"><span class="comment">//            log.info(&quot;文件为空&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> filepath + file;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;下载中&quot;</span>, file);</span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">fileSystemResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(!fileSystemResource.exists())&#123;</span><br><span class="line">            log.info(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().headers(getResponseHeaders(file)).body(fileSystemResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpHeaders <span class="title function_">getResponseHeaders</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        ContentDisposition.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> ContentDisposition.builder(<span class="string">&quot;inline&quot;</span>);</span><br><span class="line">         <span class="comment">// inline表示播放，attachment为下载到本地</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(filename)) &#123;</span><br><span class="line">            builder.filename(filename, StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">        headers.setContentDisposition(builder.build());</span><br><span class="line">        headers.setContentType(<span class="keyword">new</span> <span class="title class_">MediaType</span>(<span class="string">&quot;video&quot;</span>, <span class="string">&quot;mp4&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下载二进制文件"><a href="#下载二进制文件" class="headerlink" title="下载二进制文件"></a>下载二进制文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/download/&#123;file&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> FileSystemResource <span class="title function_">download</span><span class="params">(<span class="meta">@PathVariable</span> String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(file == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;file为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> filepath + file;</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;,下载中&quot;</span>, file);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/22/springboot-download-file/">https://blog.jujimeizuo.cn/2021/04/22/springboot-download-file/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4389 付公主的背包 生成函数+多项式ln+多项式exp</title>
      <link href="/2021/04/15/luogu-p4389/"/>
      <url>/2021/04/15/luogu-p4389/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P4389">https://www.luogu.com.cn/problem/P4389</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个物品，每个物品体积为$v_i$，给定一个m，问这些物品恰好装[1,m]的方案数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果数据量小，则可以背包。 但问题是，n和m都有1e5，不可能背包的。</p><p>因为是一类计数问题，所以考虑生成函数。</p><p>设只装一个物品体积v，它可以用多大的背包，那就是v，2v，..nv。</p><p>设生成函数为$F(x)&#x3D;\sum_{i&#x3D;0}^{\infty }x^{iv}$</p><p>则，对于一个s背包，ans&#x3D;所有生成函数卷积，则复杂度为$O(n\log n)$。 对于[1,m]所有背包，复杂度为$O(mn\log n)$，也很爆炸</p><p>所以考虑生成函数的封闭形式来简化问题。</p><p>$$F(x)&#x3D;\sum_{i&#x3D;0}^{\infty }x^{iv}&#x3D;\frac{1}{1-x^{v}}$$</p><p>那我们可以把封闭形式的求卷积，再来一个多项式求逆。 复杂度为$O(2^m)$，还是爆炸，那怎么办呢？</p><p>上面两种方法，都是因为卷积，如果我们能不乘法，而改为加法，那复杂度是不是可以了？</p><p>乘法变加法，取对数，多项式取$\ln$的复杂度也是$O(n\log n)$，那对所有的F(x)取，不是也会T吗？</p><p>先来看看这个多项式取$\ln$ 是什么形式。</p><p>$设G(x)&#x3D;\ln F(x)，则$</p><p>$$G’(x)&#x3D;\frac{F’(x)}{F(x)}$$</p><p>$$G’(x)&#x3D;-\frac{-v*x^{v-1}}{1-x^{v}}$$</p><p>$$G’(x)&#x3D;\frac{v*x^{v-1}}{1-x^v}$$</p><p>$$G’(x)&#x3D;vx^{v-1}*\sum_{i&#x3D;0}^{\infty} x^{iv}$$</p><p>$$G’(x)&#x3D;v\sum_{i&#x3D;0}^{\infty} x^{iv+v-1}$$</p><p>$$G(x)&#x3D;v\sum_{i&#x3D;0}^{\infty} \frac{x^{iv+v}}{iv+v}$$</p><p>$$G(x)&#x3D;\sum_{i&#x3D;0}^{\infty}\frac{x^{v(i+1)}}{i+1}$$</p><p>$$G(x)&#x3D;\sum_{i&#x3D;1}^{\infty}\frac{x^{iv}}{i}$$</p><p>所以我们可以先对每个物品的体积计数，然后分配给对应的$x^i$。</p><p>最后多项式exp得到原来多项式，并输出。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>): <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="type">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="type">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="type">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x, -y); &#125;</span><br><span class="line">&#125; w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line">ll EXP[N], V[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>; <span class="keyword">while</span> (len &lt; (n &lt;&lt; <span class="number">1</span>)) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  (i &amp; <span class="number">1</span> ? len &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) w[i] = w[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI * i / len), <span class="built_in">sin</span>(<span class="number">2</span> * PI * i / len));</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *A, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span>(i &lt; tr[i]) <span class="built_in">swap</span>(A[i], A[tr[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, lyc = len &gt;&gt; <span class="number">1</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>, lyc &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += i) &#123;</span><br><span class="line">            Complex *l = A + j, *r = A + j + (i &gt;&gt; <span class="number">1</span>), *p = w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i &gt;&gt; <span class="number">1</span>; k++) &#123;</span><br><span class="line">                Complex tmp = *r * *p;</span><br><span class="line">                *r = *l - tmp, *l = *l + tmp;</span><br><span class="line">                ++l, ++r, p += lyc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MTT</span><span class="params">(ll *x, ll *y, ll *z, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;</span><br><span class="line">    <span class="type">static</span> Complex a[N], b[N];</span><br><span class="line">    <span class="type">static</span> Complex dfta[N], dftb[N], dftc[N], dftd[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = <span class="built_in">Complex</span>(x[i] &amp; <span class="number">32767</span>, x[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = <span class="built_in">Complex</span>(y[i] &amp; <span class="number">32767</span>, y[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a, len), <span class="built_in">FFT</span>(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = (len - i) &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="type">static</span> Complex da, db, dc, dd;</span><br><span class="line">        da = (a[i] + a[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        db = (a[i] - a[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">        dc = (b[i] + b[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        dd = (b[i] - b[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">        dfta[j] = da * dc;</span><br><span class="line">        dftb[j] = da * dd;</span><br><span class="line">        dftc[j] = db * dc;</span><br><span class="line">        dftd[j] = db * dd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = dfta[i] + dftb[i] * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = dftc[i] + dftd[i] * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a, len), <span class="built_in">FFT</span>(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ll da = (ll)(a[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        ll db = (ll)(a[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        ll dc = (ll)(b[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        ll dd = (ll)(b[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        z[i] = (da + ((ll)(db + dc) &lt;&lt; <span class="number">15</span>) + ((ll)dd &lt;&lt; <span class="number">30</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Inv</span><span class="params">(ll *f, ll *g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123; g[<span class="number">0</span>] = <span class="built_in">quick_pow</span>(f[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">Get_Inv</span>(f, g, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">getLen</span>(n);</span><br><span class="line">    <span class="type">static</span> ll c[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; i++) c[i] = i &lt; n ? f[i] : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MTT</span>(c, g, c, len); <span class="built_in">MTT</span>(c, g, c, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) g[i] = (<span class="number">2ll</span> * g[i] - c[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Der</span><span class="params">(ll *f, ll *g, <span class="type">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; len; i++) g[i - <span class="number">1</span>] = f[i] * i % mod; g[len - <span class="number">1</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Int</span><span class="params">(ll *f, ll *g, <span class="type">int</span> len)</span> </span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; len; i++) g[i] = f[i - <span class="number">1</span>] * <span class="built_in">quick_pow</span>(i, mod - <span class="number">2</span>) % mod; g[<span class="number">0</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Ln</span><span class="params">(ll *f, ll *g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> ll a[N], b[N];</span><br><span class="line">    <span class="built_in">Get_Der</span>(f, a, n);</span><br><span class="line">    <span class="built_in">Get_Inv</span>(f, b, n);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">getLen</span>(n);</span><br><span class="line">    <span class="built_in">MTT</span>(a, b, a, len);</span><br><span class="line">    <span class="built_in">Get_Int</span>(a, g, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; i++) a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Exp</span><span class="params">(ll *f, ll *g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(g[<span class="number">0</span>] = <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Get_Exp</span>(f, g, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> ll a[N];</span><br><span class="line">    <span class="built_in">Get_Ln</span>(g, a, n);</span><br><span class="line">    a[<span class="number">0</span>] = (f[<span class="number">0</span>] + <span class="number">1</span> - a[<span class="number">0</span>] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) a[i] = (f[i] - a[i] + mod) % mod;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">getLen</span>(n);</span><br><span class="line">    <span class="built_in">MTT</span>(a, g, g, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; i++) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">        V[v]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>;v &lt;= m; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(V[v]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m / v; i++) &#123;</span><br><span class="line">                EXP[i * v] = (EXP[i * v] + <span class="number">1ll</span> * V[v] * <span class="built_in">quick_pow</span>(i, mod - <span class="number">2</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Get_Exp</span>(EXP, ans, m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/15/luogu-p4389/">https://blog.jujimeizuo.cn/2021/04/15/luogu-p4389/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ Monthly 2019.11 E-数学题 莫比乌斯反演+杜教筛+拉格朗日插值</title>
      <link href="/2021/04/13/eoj-monthly-2019-11-e/"/>
      <url>/2021/04/13/eoj-monthly-2019-11-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://acm.ecnu.edu.cn/contest/231/problem/E/##report16">https://acm.ecnu.edu.cn/contest/231/problem/E/##report16</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^n\sum_{a_1&#x3D;1}^i…\sum_{a_k&#x3D;1}^i[gcd(a_1,a_2..a_k,i)&#x3D;1]$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$\sum_{i&#x3D;1}^n\sum_{a_1&#x3D;1}^i…\sum_{a_k&#x3D;1}^i[gcd(a_1,a_2..a_k,i)&#x3D;1]$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{a_1&#x3D;1}^i…\sum_{a_k&#x3D;1}^i\sum_{da_1..da_k\;di}\mu(i)$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{di}\mu(d)(\frac{i}{d})^k$$</p><p>$$\sum_{d&#x3D;1}^n\mu(d)\sum_{i&#x3D;1}^{\frac{n}{d}}i^k$$</p><p>因为n有1e9，所以杜教筛处理，$\sum_{i&#x3D;1}^n i^k$用拉格朗日插值&#x2F;伯努利数处理即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> polysum &#123;</span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> D=<span class="number">1010000</span>;<span class="comment">///可能需要用到的最高次</span></span><br><span class="line">    ll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][<span class="number">2</span>],C[D], num[D];</span><br><span class="line">    <span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span></span>&#123;ll res=<span class="number">1</span>;a%=mod;<span class="built_in">assert</span>(b&gt;=<span class="number">0</span>);<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///函数用途：给出数列的（d+1）项，其中d为最高次方项</span></span><br><span class="line">    <span class="comment">///求出数列的第n项，数组下标从0开始</span></span><br><span class="line">    <span class="function">ll <span class="title">calcn</span><span class="params">(<span class="type">int</span> d,ll *a,ll n)</span> </span>&#123; <span class="comment">/// a[0].. a[d]  a[n]</span></span><br><span class="line">        <span class="keyword">if</span> (n&lt;=d) <span class="keyword">return</span> a[n];</span><br><span class="line">        p1[<span class="number">0</span>]=p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,d+<span class="number">1</span>) &#123;</span><br><span class="line">            ll t=(n-i+mod)%mod;</span><br><span class="line">            p1[i+<span class="number">1</span>]=p1[i]*t%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,d+<span class="number">1</span>) &#123;</span><br><span class="line">            ll t=(n-d+i+mod)%mod;</span><br><span class="line">            p2[i+<span class="number">1</span>]=p2[i]*t%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,d+<span class="number">1</span>) &#123;</span><br><span class="line">            ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod;</span><br><span class="line">            <span class="keyword">if</span> ((d-i)&amp;<span class="number">1</span>) ans=(ans-t+mod)%mod;</span><br><span class="line">            <span class="keyword">else</span> ans=(ans+t)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> M)</span> </span>&#123;<span class="comment">///用到的最高次</span></span><br><span class="line">        f[<span class="number">0</span>]=f[<span class="number">1</span>]=g[<span class="number">0</span>]=g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,M+<span class="number">5</span>) f[i]=f[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        g[M+<span class="number">4</span>]=<span class="built_in">powmod</span>(f[M+<span class="number">4</span>],mod<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">per</span>(i,<span class="number">1</span>,M+<span class="number">4</span>) g[i]=g[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;<span class="comment">///费马小定理筛逆元</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///函数用途：给出数列的（m+1）项，其中m为最高次方</span></span><br><span class="line">    <span class="comment">///求出数列的前（n-1）项的和（从第0项开始）</span></span><br><span class="line">    <span class="function">ll <span class="title">polysum</span><span class="params">(ll m,ll *a,ll n)</span> </span>&#123; <span class="comment">/// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) b[i]=a[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">///前n项和，其最高次幂加1</span></span><br><span class="line">        b[m+<span class="number">1</span>]=<span class="built_in">calcn</span>(m,b,m+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,m+<span class="number">2</span>) b[i]=(b[i<span class="number">-1</span>]+b[i])%mod;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">calcn</span>(m+<span class="number">1</span>,b,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">solve</span><span class="params">(ll n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="built_in">polysum</span>(k + <span class="number">1</span>, num, n) % mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt, mu[N];</span><br><span class="line">ll n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) prime[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    polysum::<span class="built_in">init</span>(k + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= k + <span class="number">1</span>; i++) polysum::num[i] = polysum::<span class="built_in">powmod</span>((ll)i + <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(x, x / (x / l));</span><br><span class="line">        ans = ans - (r - l + <span class="number">1</span>) * <span class="built_in">S</span>(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r;l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(n, n / (n / l));</span><br><span class="line">        ans = (ans + (<span class="built_in">S</span>(r) - <span class="built_in">S</span>(l - <span class="number">1</span>)) * polysum::<span class="built_in">solve</span>(n / l, k) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/13/eoj-monthly-2019-11-e/">https://blog.jujimeizuo.cn/2021/04/13/eoj-monthly-2019-11-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jujimeizuo的一年ACM</title>
      <link href="/2021/04/12/jujimeizuo-one-year-acm/"/>
      <url>/2021/04/12/jujimeizuo-one-year-acm/</url>
      
        <content type="html"><![CDATA[<p>时间过的很快，从大一的小白，到现在的newbie，已经有一年多的时间了。这一年的时间里，几乎60%的时间里全部花在ACM上。每天起床第一个想的事情，今天要学什么算法？今天要A哪种题？每天过着既痛苦又快乐的生活。</p><h2 id="2020暑假"><a href="#2020暑假" class="headerlink" title="2020暑假"></a>2020暑假</h2><p>在2020年里，我觉得我提升实力的时间是在暑假。那个阶段，几乎每个星期都有4场比赛，每个星期都要学习新算法，补新题，不会写的就问学长（要感谢学长们对我的帮助）。所以时间很快啊，整个暑假过去了。我是数学选手，所以暑假里我学了70%和数学有关（除了计算几何）的算法，那30%的高阶算法我觉得没必要学了。因为学了也不会写。还学了点dp和一点点其他的算法。所以和实验室其他人来说，我学习的速度还是不算慢的，这时候实力应该处于中游。</p><h2 id="大二上学期"><a href="#大二上学期" class="headerlink" title="大二上学期"></a>大二上学期</h2><p>大二上学期开学了，在这个学期，我的专业课程急剧增多，但丝毫不影响我对ACM的热爱。我还是每天都会去实验室学习算法，刷题。我起早去过，晚上上完课去过，甚至通宵过。大概1个月时间，我把数学里的多项式也学了，也就是学了剩下的20%。不愧是它，真的很难。然后我们队的数据结构也没人系统地学过，我想，数学里的东西还有很多要套数据结构的，所以我把70%的数据结构也学了，剩下的30%无非是平衡树啦等等。还有树与森林部分，比如树链剖分、树的直径等等。嗯，非常不错，我已经是数学+数据结构选手了。</p><p>由于疫情原因，这个学期的所有比赛都是线上举办，没有场地的限制，参赛人数大大增加。我们很幸运的参加了所有比赛。一共四场比赛，浙江省赛、CCPC长春、ICPC上海、ICPC济南，作为一支新人队，前三个都是打铁，就济南运气好点拿了个铜。所以学校奖励每人500块，很开心买了个显示器。这四场比赛打完之后就准备期末复习，然后结束掉这个学期。</p><h2 id="大二寒假"><a href="#大二寒假" class="headerlink" title="大二寒假"></a>大二寒假</h2><p>大二寒假到了，当然我们也不能闲着。由于树是图的特例，我又粗略地学习了图论相关算法。不过学到MCMF就没有学了，吐槽一句，图论的内容真的多，我估计要一个暑假才能学完。在学习新算法的同时，打了很多线上比赛，比如牛客，codeforces等等。这个时候我的实力比之前上升一点。cf打了1700分（狗屎运），牛客打了1800分，虽然牛客的分没什么用。。。 甚至在牛客的一场比赛中，达到过Rank1，最终排名Rank4，我感受到大佬的感觉，真不错。嘟嘟嘟，寒假过去了。</p><h2 id="大二下学期"><a href="#大二下学期" class="headerlink" title="大二下学期"></a>大二下学期</h2><p>大二下学期开学了，这篇博客也就是不到期中写的。我们队每个星期都会打一场模拟赛，发现dp的题非常好，学了dp之后收益非常高，我又去重温了dp，因为我之前学过一点dp，现在疯狂的刷dp。然后我就被实验室的人嘲笑为“全能型ACMer”，虽然我不这么认为。因为学的更多的同时，才知道外面的世界到底有多大。我感觉我就就非常渺小。在这段时间我发现我到了瓶颈期了，不管写什么题，都不怎么会写，我现在非常的自闭。同时，我又发现我的队友一直在水，除了和打比赛的时间，就没怎么训练过，所以我更加的难受，以后的ACM生活到底能到什么程度。我对我的队友很失望，但是我知道，他比我聪明，但是ACM，努力&gt;智商，所以我找他聊天，做做思想工作，希望他能发现自己的缺点。</p><p>到这里，2021年4月12日15：58分，接下来我不知道该干什么，看着队友的现状，回想起1年的ACM生活，我心中有想退役的想法。但是我真的很爱ACM，不知道以后怎么办。接下来还有17号的省赛和18号的ecfinal，努力加油吧。</p><p><strong>@2021年4月12日16:00 狙击美佐</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/12/jujimeizuo-one-year-acm/">https://blog.jujimeizuo.cn/2021/04/12/jujimeizuo-one-year-acm/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年ICPC银川 Easy Problem 莫比乌斯反演+欧拉降幂+预处理</title>
      <link href="/2021/04/11/2019-icpc-yinchuan-easy-problem/"/>
      <url>/2021/04/11/2019-icpc-yinchuan-easy-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{a_1&#x3D;1}^m…\sum_{a_n&#x3D;1}^m\prod_{i&#x3D;1}^na_i^k[gcd(a_1,a_2…,a_n)&#x3D;d]$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$\sum_{a_1&#x3D;1}^{\frac{m}{d}}…\sum_{a_n&#x3D;1}^{\frac{m}{d}}\prod_{i&#x3D;1}^na_i^kd^k[gcd(a_1,a_2…,a_n)&#x3D;1]$$</p><p>$注意有一个d^k！$</p><p>$$d^k\sum_{a_1&#x3D;1}^{\frac{m}{d}}…\sum_{a_n&#x3D;1}^{\frac{m}{d}}\prod_{i&#x3D;1}^na_i^k\sum_{ta_1…ta_n}\mu(t)$$</p><p>$变换枚举顺序：$</p><p>$$d^{nk}\sum_{t&#x3D;1}^{\frac{m}{d}}\mu(t)\sum_{a_1&#x3D;1}^{\frac{m}{td}}…\sum_{a_n&#x3D;1}^{\frac{m}{td}}\prod_{i&#x3D;1}^na_i^kt^k$$</p><p>$$d^{nk}\sum_{t&#x3D;1}^{\frac{m}{d}}t^{nk}\mu(t)\sum_{a_1&#x3D;1}^{\frac{m}{td}}…\sum_{a_n&#x3D;1}^{\frac{m}{td}}\prod_{i&#x3D;1}^na_i^k$$</p><p>$这里有一个玄学:$</p><p>$$\sum_{a_1&#x3D;1}^{\frac{m}{td}}…\sum_{a_n&#x3D;1}^{\frac{m}{td}}\prod_{i&#x3D;1}^na_i^k&#x3D;(\sum_{i&#x3D;1}^{\frac{m}{td}}i^k)^n$$</p><p>$因为a可取的值再[1,\frac{m}{td}]，而后面那个你可以想成完全平方的概念，更高的数学意义就是每个数都去的所有贡献。$</p><p>$多体会体会，很黑科技。$</p><p>$最后答案为：$</p><p>$$d^{nk}\sum_{t&#x3D;1}^{\frac{m}{d}}t^{nk}\mu(t)(\sum_{i&#x3D;1}^{\frac{m}{td}}i^k)^n$$</p><p>$注意n要欧拉降幂处理。总复杂度为O(n*\logn*\logn+T*\frac{m}{d})$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">##include &quot;bits/stdc++.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line"></span><br><span class="line">const ll mod = 59964251;</span><br><span class="line">const ll phi = 59870352;</span><br><span class="line"></span><br><span class="line">bool is\_prime[N];</span><br><span class="line">int prime[N], cnt, mu[N];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    mu[1] = 1;</span><br><span class="line">    for(int i = 2;i &lt; N; i++) &#123;</span><br><span class="line">        if(!is\_prime[i]) prime[++cnt] = i, mu[i] = -1;</span><br><span class="line">        for(int j = 1;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is\_prime[i * prime[j]] = 1;</span><br><span class="line">            if(i % prime[j] == 0) &#123;</span><br><span class="line">                mu[i * prime[j]] = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    while(b) &#123;</span><br><span class="line">        if(b &amp; 1) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    init();</span><br><span class="line">    int \_; cin &gt;&gt; \_;</span><br><span class="line">    while(\_--) &#123;</span><br><span class="line">        string n; cin &gt;&gt; n;</span><br><span class="line">        ll p = 0;</span><br><span class="line">        for(int i = 0;i &lt; n.length(); i++) &#123;</span><br><span class="line">            p = p * 10 + n[i] - &#x27;0&#x27;;</span><br><span class="line">            p = p % phi + phi;</span><br><span class="line">        &#125;</span><br><span class="line">        ll m, k, d; cin &gt;&gt; m &gt;&gt; d &gt;&gt; k;</span><br><span class="line">        vector&lt;ll&gt; f(m / d + 10), F(m / d + 10);</span><br><span class="line">        for(int i = 1;i &lt;= m / d; i++) &#123;</span><br><span class="line">            f[i] = (f[i - 1] + quick\_pow(i, k)) % mod;</span><br><span class="line">            F[i] = quick\_pow(f[i], p);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = 0;</span><br><span class="line">        for(int i = 1;i &lt;= m / d; i++) &#123;</span><br><span class="line">            ans = (ans + quick\_pow(i, p * k) * mu[i] * F[m / (i * d)]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * quick\_pow(d, p * k) % mod;</span><br><span class="line">        cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/11/2019-icpc-yinchuan-easy-problem/">https://blog.jujimeizuo.cn/2021/04/11/2019-icpc-yinchuan-easy-problem/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年ICPC银川 Function！推柿子</title>
      <link href="/2021/04/11/2019-icpc-yinchuan-function/"/>
      <url>/2021/04/11/2019-icpc-yinchuan-function/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://nanti.jisuanke.com/t/42386">https://nanti.jisuanke.com/t/42386</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$设f_a(x)&#x3D;a^x，求解$</p><p>$$\sum_{a&#x3D;2}^n\left ( a\sum_{b&#x3D;a}^n\left \lfloor f_a^{-1}(b) \right \rfloor\left \lceil f_b^{-1}(a)\right \rceil \right ) mod\;998244353$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$根据f_a^{-1}(x)&#x3D;\log_a^x可知，原式等于$</p><p>$$\sum_{a&#x3D;2}^n\left ( a\sum_{b&#x3D;a}^n\left \lfloor \log_a^{b}\right \rfloor\left \lceil \log_b^a\right \rceil \right ) $$</p><p>$因为b\ge a，所以\left \lceil \log_b^a\right \rceil&#x3D;1，即$</p><p>$$\sum_{a&#x3D;2}^n\left ( a\sum_{b&#x3D;a}^n\left \lfloor \log_a^{b}\right \rfloor \right ) $$</p><p>$接下来考虑\log_a^b的贡献，我们知道\log_a^a&#x3D;1,\log_a^{a^2}&#x3D;2,\log_a^{a^k}&#x3D;k.$</p><p>$而这些有多少个呢？1有a^2-a个，2有a^3-a^2个…$</p><p>$所以对于a^2&lt;n的，遍历次幂计算贡献。$</p><p>$对于a^2&gt;n，只有1这个贡献，所以我们只要遍历\sqrt n即可，n&#x3D;1e12，very \;good!$</p><p>$不过对于a*a&#x3D;n，有a^2-a个1，和1个2，另外计算即可。$</p><p>$对于a*a&gt;n，贡献为a*(n-a+1)+(a+ 1)*(n-a)+…+n*1&#x3D;\sum_{a&#x3D;\sqrt n+1}^na*(n-a+1)$</p><p>$这一部分为：$</p><p>$$\frac{1}{2}(n+1)(\sqrt n+1+n)(n-\sqrt n)+\frac{1}{6}(n(n+1)(2n+1)-(\sqrt n-1)(\sqrt n)(2\sqrt n-1))$$</p><p>$最后整合计算即可。$</p><p>$复杂度为O(\sqrt n)。$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;a * a &lt;= n; a++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a * a == n) &#123;</span><br><span class="line">            ans = (ans + a * ((n - a + <span class="number">2</span>) % mod) % mod) % mod; <span class="comment">// a * a == n</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ll t = a;</span><br><span class="line">            ll k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(t * a &lt;= n) &#123;</span><br><span class="line">                ans = (ans + t * (a - <span class="number">1</span>) % mod * a % mod * k  % mod) % mod;</span><br><span class="line">                t = t * a;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + (n - t + <span class="number">1</span>) % mod * a % mod * k % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inv2 = quick\_pow(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    ll inv6 = quick\_pow(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 后面的a都是只有1的贡献</span></span><br><span class="line">    ans = (ans + ((n + <span class="number">1</span>) % mod) * ((n - a + <span class="number">1</span>) % mod) % mod * ((a + n) % mod) % mod * inv2 % mod) % mod;</span><br><span class="line">    ans = (ans - (n % mod) * ((n + <span class="number">1</span>) % mod) % mod * ((<span class="number">2ll</span> * n + <span class="number">1</span>) % mod) % mod * inv6 % mod + (a - <span class="number">1</span>) * a % mod * (<span class="number">2ll</span> * a - <span class="number">1</span>) % mod * inv6 % mod) % mod;</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/11/2019-icpc-yinchuan-function/">https://blog.jujimeizuo.cn/2021/04/11/2019-icpc-yinchuan-function/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛4 C-Sum 线段树+二进制拆分</title>
      <link href="/2021/04/11/nowcoder-practice4-c/"/>
      <url>/2021/04/11/nowcoder-practice4-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/16/C">https://ac.nowcoder.com/acm/contest/16/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个数$A_1…A_n，m$个操作。 操作分两种：</p><ul><li>$操作一：1\;x\;y，将A_x改成y$</li><li>$操作二：2\;l\;r，求[A_l…A_r]所有子集的\&amp;并mod\;1e9+7$</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题一看就知道树状数组或者线段树去做。 因为和位运算有关，所以考虑每个数的二进制位。</p><p>比如(3)_2&#x3D;11，则贡献为$2^0*(2^1-1)+2^1*(2^1-1)$</p><p>因为是$\&amp;$操作，所以该位上必须都是1才行，所以统计该位上有多少1即可。</p><p>比如1，2，3为1,10,11，则组合起来为22，贡献为$2^0*(2^2-1)+2^1*(2^2-1)$</p><p>如何更新和查询？线段树！</p><p>只不过更新的是一个数的二进制数组而已。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll OR[<span class="number">55</span>];</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">ll bit[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">        t[u].OR[i] = (t[lc].OR[i] + t[rc].OR[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">            t[u].OR[i] += a[l] &amp; <span class="number">1</span>;</span><br><span class="line">            a[l] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[u].l == t[u].r) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">            t[u].OR[i] = v &amp; <span class="number">1</span>;</span><br><span class="line">            v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">modify</span>(lc, p, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rc, p, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(<span class="number">33</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>; i++) ans[i] = t[u].OR[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(<span class="number">33</span>, <span class="number">0</span>)</span>, <span class="title">temp1</span><span class="params">(<span class="number">33</span>, <span class="number">0</span>)</span>, <span class="title">temp2</span><span class="params">(<span class="number">33</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) temp1 = <span class="built_in">query</span>(lc, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  temp2 = <span class="built_in">query</span>(rc, ql, qr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>; i++) ans[i] = temp1[i] + temp2[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) bit[i] = bit[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> m; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> opt; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x; ll y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            vector&lt;ll&gt; ans = <span class="built_in">query</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            ll res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">                res = (res + bit[i] % mod * (bit[ans[i]] - <span class="number">1</span> + mod) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/11/nowcoder-practice4-c/">https://blog.jujimeizuo.cn/2021/04/11/nowcoder-practice4-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛22 E-简单数据结构1 树状数组+欧拉降幂</title>
      <link href="/2021/04/10/nowcoder-practice22-e/"/>
      <url>/2021/04/10/nowcoder-practice22-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/problem/17190">https://ac.nowcoder.com/acm/problem/17190</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个数字，然后会有m次操作。 操作分两种：</p><ol><li>$1\;l\;r\;x，将l到r区间里的每个数都+x$</li><li>$2\;l\;r\;p，求a[l]^{a[l+1]^{…^{a[r]}}}\;mod\;p$</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到第一个操作，这不是差分嘛，直接树状数组搞定。 看到第二个操作，像这种递增的次方，就应该想到用欧拉降幂递归。</p><p>细节就是，注意广义欧拉降幂，是$k\%\phi(p)+p$，并且快速幂也是如此。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prime[N], cnt, phi[N];</span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) prime[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j]) phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line">ll t[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ans += t[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mod</span><span class="params">(ll ans, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ans &gt;= p ? ans % p + p : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a = <span class="built_in">Mod</span>(a, p);</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = <span class="built_in">Mod</span>(ans * a, p);</span><br><span class="line">        a = <span class="built_in">Mod</span>(a * a, p);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    ll temp = <span class="built_in">query</span>(l);</span><br><span class="line">    <span class="keyword">if</span>(l == r  p == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Mod</span>(temp, p);</span><br><span class="line">    ll ans = <span class="built_in">dfs</span>(phi[p], l + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_pow</span>(temp, ans, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">update</span>(i, x);</span><br><span class="line">        <span class="built_in">update</span>(i + <span class="number">1</span>, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> opt; cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l, r; ll x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">            <span class="built_in">update</span>(l, x);</span><br><span class="line">            <span class="built_in">update</span>(r + <span class="number">1</span>, -x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; ll p; cin &gt;&gt; l &gt;&gt; r &gt;&gt; p;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">dfs</span>(p, l, r) % p &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/10/nowcoder-practice22-e/">https://blog.jujimeizuo.cn/2021/04/10/nowcoder-practice22-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 182E - Wooden Fence 多阶段决策dp</title>
      <link href="/2021/04/09/codeforces-182e-wooden-fence/"/>
      <url>/2021/04/09/codeforces-182e-wooden-fence/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/problemset/problem/182/E">https://codeforces.com/problemset/problem/182/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n种木板，长为$a_i$，宽为$b_i$，当木板旋转时等于之前，则算一种木板，否则算不同类型。 这些木板有无数块，问，能组成多少个长为L的木板。求出方案数。</p><p>每种木板的长和宽都能作为“长”。</p><p>规则：</p><ul><li>当前选择的木板不能和前一种是同样类型</li><li>当前选择的木板，长要等于上一块的宽。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先看数据量，n&#x3D;100，L&#x3D;3000，DP！</p><p>如何选取状态？首先一定要遍历每块木板，则一个状态给遍历到第几块木板。</p><p>如果放下一块木板之后，它的总长会发生变化，而且需要上一个状态的总长。 则当前的总长需要记录，给一个状态给长度。</p><p>这块木板是横着放，还是竖着放？上一块是横还是竖？而且必须是长等于上一个宽。 所以需要一个状态记录当前块要怎么放？并且通过上一个木块怎么放来转移。</p><p>因此，我们得到dp[i][j][0&#x2F;1]，表示放入第j块之后，长度为i，并且第j快是1（宽放）｜0（长放）。</p><p>如何转移？</p><p>需要通过前一块的状态来进行转移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[j] == a[k] &amp;&amp; i &gt; a[j] &amp;&amp; dp[i - a[j]][k][<span class="number">1</span>]) </span><br><span class="line">    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - a[j]][k][<span class="number">1</span>]) % mod;</span><br><span class="line"><span class="keyword">if</span>(a[j] == b[k] &amp;&amp; i &gt; a[j] &amp;&amp; a[k] != b[k] &amp;&amp; dp[i - a[j]][k][<span class="number">0</span>]) </span><br><span class="line">    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - a[j]][k][<span class="number">0</span>]) % mod;</span><br><span class="line"><span class="keyword">if</span>(b[j] == b[k] &amp;&amp; i &gt; b[j] &amp;&amp; dp[i - b[j]][k][<span class="number">0</span>]) </span><br><span class="line">    dp[i][j][<span class="number">1</span>] = (dp[i][j][<span class="number">1</span>] + dp[i - b[j]][k][<span class="number">0</span>]) % mod;</span><br><span class="line"><span class="keyword">if</span>(b[j] == a[k] &amp;&amp; i &gt; b[j] &amp;&amp; a[k] != b[k] &amp;&amp; dp[i - b[j]][k][<span class="number">1</span>]) </span><br><span class="line">    dp[i][j][<span class="number">1</span>] = (dp[i][j][<span class="number">1</span>] + dp[i - b[j]][k][<span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure><p>这里的a[k]!&#x3D;b[k]，就是避免连续两块类型相同。</p><p>看上一块的横放还是竖放，来转移当前块是横放还是竖放。</p><p>复杂度为$O(n*n*L)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3005</span>;</span><br><span class="line">ll dp[N][N][<span class="number">2</span>]; <span class="comment">// dp[i][j][0/1] 长度为i，用到第j个board，长0，宽1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, L; cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= L; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] == i) dp[i][j][<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(b[j] == i) dp[i][j][<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= L; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123; <span class="comment">// 当前的第j个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n; k++) &#123; <span class="comment">// 之前的第k个比较</span></span><br><span class="line">                <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[j] == a[k] &amp;&amp; i &gt; a[j] &amp;&amp; dp[i - a[j]][k][<span class="number">1</span>])</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - a[j]][k][<span class="number">1</span>]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(a[j] == b[k] &amp;&amp; i &gt; a[j] &amp;&amp; a[k] != b[k] &amp;&amp; dp[i - a[j]][k][<span class="number">0</span>])</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - a[j]][k][<span class="number">0</span>]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(b[j] == b[k] &amp;&amp; i &gt; b[j] &amp;&amp; dp[i - b[j]][k][<span class="number">0</span>])</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = (dp[i][j][<span class="number">1</span>] + dp[i - b[j]][k][<span class="number">0</span>]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(b[j] == a[k] &amp;&amp; i &gt; b[j] &amp;&amp; a[k] != b[k] &amp;&amp; dp[i - b[j]][k][<span class="number">1</span>])</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = (dp[i][j][<span class="number">1</span>] + dp[i - b[j]][k][<span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ans = (ans + dp[L][i][<span class="number">0</span>]) % mod;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i]) ans = (ans + dp[L][i][<span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/09/codeforces-182e-wooden-fence/">https://blog.jujimeizuo.cn/2021/04/09/codeforces-182e-wooden-fence/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 358D - Dima and Hares DP</title>
      <link href="/2021/04/09/codeforces-358d-dima-and-hares/"/>
      <url>/2021/04/09/codeforces-358d-dima-and-hares/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/problemset/problem/358/D">http://codeforces.com/problemset/problem/358/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n匹马排列在草场上，每只马如何吃草很有讲究。</p><ul><li>如果左右的两匹马都没吃，他吃了，价值增加a[i]</li><li>如果左右的两匹马有一只吃了，他吃了，价值增加b[i]</li><li>如果左右的两匹马都吃了，他吃了，价值增加c[i]</li></ul><p>问怎么吃，才能使总价值最大。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然吃的顺序对答案有影响，也就是求出一个排列使得价值最大。</p><p>排列？3000？显然复杂度不够，我们发现每只马吃草，只有左右两匹马的作用会对该马有影响。</p><p>所以，讨论这匹马左右两边的状态。</p><p>设dp[i][0&#x2F;1]为我们的状态。 dp[i][0]表示第i匹马比第i-1匹马后吃草. dp[i][1]表示第i匹马比第i-1匹马先吃草.</p><p>根据我们的状态进行转移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + b[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + a[i - <span class="number">1</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + c[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + b[i - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>注意边界的马，不是一匹“完整”的马。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3005</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">c</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; c[i];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = -INF;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + b[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + a[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>] + c[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + b[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n + <span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/09/codeforces-358d-dima-and-hares/">https://blog.jujimeizuo.cn/2021/04/09/codeforces-358d-dima-and-hares/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装、设置密码、Spring配置</title>
      <link href="/2021/04/09/redis-install-and-spring-config/"/>
      <url>/2021/04/09/redis-install-and-spring-config/</url>
      
        <content type="html"><![CDATA[<h2 id="Window安装"><a href="#Window安装" class="headerlink" title="Window安装"></a>Window安装</h2><p>github下载：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><p>下载之后解压到位置，假如是C盘。</p><p>打开cmd窗口，cd到redis的目录下，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><p><img src="/images/2021/04/20210409105859526.png"></p><p>这表示我们已经开启了Redis服务端，请不要关闭它，另外开一个cmd窗口并cd到Redis目录下，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p><img src="/images/2021/04/20210409110023750.jpg"></p><p>恭喜你，已经安装成功，可以ping一下看看是否正确。</p><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>redis密码设置有两种方式，一种需要重启redis服务，一种不需要重启redis服务。</p><p>首先，介绍一下需要重启redis服务的设置方式 即找到redis的配置文件—redis.conf文件，然后修改里面的requirepass，这个本来是注释起来了的，将注释去掉，并将后面对应的字段设置成自己想要的密码，保存退出。重启redis服务，即可。</p><p><img src="/images/2021/04/20210409110145570.png"></p><p>我这里是设置密码成了123 然后是不需要重启redis服务的密码设置方式 这种相对简单，连接redis之后，通过命令设置，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass 123456</span><br></pre></td></tr></table></figure><p>如此，便将密码设置成了123456 设置之后，可通过以下指令查看密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure><p><img src="/images/2021/04/20210409110243120.png"></p><p>密码设置之后，当你退出再次连上redis的时候，就需要输入密码了，不然是无法操作的。这里有两种方式输入密码，一是连接的时候直接输入密码，而是连接上之后再输入密码，分别如下所示：</p><p><img src="/images/2021/04/20210409110311634.png"></p><p>检查服务是否运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; AUTH <span class="string">&quot;password&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h4 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h4><p>打开一个spring项目，打开properties文件，输入以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.host = localhost <span class="comment">// ip地址</span></span><br><span class="line">spring.redis.port = <span class="number">6379</span> <span class="comment">// redis端口</span></span><br><span class="line">spring.redis.password=password <span class="comment">// 密码</span></span><br><span class="line">spring.redis.jedis.pool.max-active=<span class="number">8</span> <span class="comment">// 开放最大数</span></span><br></pre></td></tr></table></figure><p>到现在，已经没有问题，就是如何使用Redis命令和配合项目的问题了。 具体请自行百度。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/09/redis-install-and-spring-config/">https://blog.jujimeizuo.cn/2021/04/09/redis-install-and-spring-config/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 148E Porcelain 预处理+双向dp+背包</title>
      <link href="/2021/04/08/codeforces-148e-porcelain/"/>
      <url>/2021/04/08/codeforces-148e-porcelain/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/148/problem/E">https://codeforces.com/contest/148/problem/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n层货架，每层货架都有a_i本书，每本书都有自己的价值。 拿书只能在一层的左右拿书，问拿m本书的最大价值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题难在每层拿书只能左右拿，如果不需要左右拿，那么就是个背包问题。</p><p>如果处理这个左右拿呢？</p><p>因为每层都可能拿书，所以需要处理每层拿j本书的最大价值，而且是左右拿。</p><p>设sum[i][j]表示独立的第i层拿了j本书的最大价值。 这j本可以是前j本，也可以后j本，也可以两边都有。</p><p>假设前面拿了k本，那么后面就拿了j-k本。 前k本价值，所以需要处理每层的前缀和。 转移方程为： $$sum[i][j]&#x3D;max(sum[i][j],pre[i][k]+pre[i][v]-pre[i][v-j-k])(v表示该层书总数)$$</p><p>然后就知道每一层该拿多少本书的最大价值了。</p><p>之后就是一层一层递推了（背包）.</p><p>先处理边界，也就是拿第一层书。然后推第二层、三、..</p><p>设dp[i][j]表示前i层拿了j本的最大价值。</p><p>则：$dp[1][i] &#x3D; sum[1][i]$</p><p>枚举每一层，再枚举一共拿了j本书，最后枚举拿了当前层的k本书。 状态转移方程为：</p><p>$$dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-k]+sum[i][k])$$ $ans&#x3D;max(dp[i][j],ans)$处理答案即可。</p><p>复杂度为$O(n*n*m)$，由于常数较小，所以可以过。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> sum[N][N]; <span class="comment">// 独立第i层拿了j本书第最大价值</span></span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">20005</span>]; <span class="comment">// 到了第i层拿了j本书的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a[n + <span class="number">1</span>], pre[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">        a[i].<span class="built_in">eb</span>(<span class="number">0</span>);</span><br><span class="line">        pre[i].<span class="built_in">eb</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            pre[i].<span class="built_in">eb</span>(pre[i][j - <span class="number">1</span>] + x);</span><br><span class="line">            a[i].<span class="built_in">eb</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123; <span class="comment">// 第i层</span></span><br><span class="line">        <span class="type">int</span> last = pre[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= last; j++) &#123; <span class="comment">// 拿了j本书</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= j; k++) &#123; <span class="comment">// 前k本，后j-k本</span></span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) sum[i][j] = <span class="built_in">max</span>(sum[i][j], pre[i][last] - pre[i][last - j]);</span><br><span class="line">                <span class="keyword">else</span> sum[i][j] = <span class="built_in">max</span>(sum[i][j], pre[i][k] + pre[i][last] - pre[i][last - j + k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][i] = sum[<span class="number">1</span>][i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; pre[i].<span class="built_in">size</span>() &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - k] + sum[i][k]);</span><br><span class="line">                ans = <span class="built_in">max</span>(dp[i][j], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/08/codeforces-148e-porcelain/">https://blog.jujimeizuo.cn/2021/04/08/codeforces-148e-porcelain/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 1498C Planar Reflections dp</title>
      <link href="/2021/04/08/codeforces-1498c-planar-reflections/"/>
      <url>/2021/04/08/codeforces-1498c-planar-reflections/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1498/problem/C">https://codeforces.com/contest/1498/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个粒子，衰变年龄为k，前面有n堵墙，每穿过一堵墙，都会有一个年龄-1的粒子反向前进。</p><p>当年龄为1时不反向，问有多少穿过1或者n的墙的粒子。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为n和k都是$\leq 2000$，所以可以考虑$O(nk)$的dp。 状态为dp[n][k],表示一个粒子前面还有n堵墙，衰变年龄为k的答案数。</p><p>k为1，不需要转移，dp[i][1]&#x3D;1. n为0，不需要转移，dp[0][i]&#x3D;1.</p><p>因为可以继续向前，和反向前行，所以转移方程为 $dp[i][j]&#x3D;dp[i-1][j]+dp[n-i][j-1]$</p><p>因为i会对转移先产生影响，所以要先循环第一维。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; i++) dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[n - i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/08/codeforces-1498c-planar-reflections/">https://blog.jujimeizuo.cn/2021/04/08/codeforces-1498c-planar-reflections/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 4019 Schrödinger‘s Knapsack dp</title>
      <link href="/2021/04/08/zoj-4019-schrodingers-knapsack/"/>
      <url>/2021/04/08/zoj-4019-schrodingers-knapsack/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370240">https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370240</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个背包，体积为c，有两类物品，第一类有n个，权值为k1，第二类有m个，权值为k2。每个物品都有自己的体积。</p><p>当把一个物品放进去之后，总贡献增加$k*$放入之后剩余体积。</p><p>问，最大贡献多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>体积越小，先让进去最后，所以要先排序，从小到大。</p><p>设f[i][j]表示放入第一类i个，第二类j个。则下一个是放什么呢? 可能是第一类下一个，也可能是第二类下一个。 $$f[i][j]&#x3D;max(f[i-1][j]+k1*v,f[i][j-1]+k2*v)$$</p><p>这里的v是剩余体积，也就是V-已经放入体积。</p><p>然后注意边界的选取即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll k1, k2, V; cin &gt;&gt; k1 &gt;&gt; k2 &gt;&gt; V;</span><br><span class="line">        <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;ll&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) cin &gt;&gt; b[i];</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">begin</span>() + m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (V &gt;= b[j]) f[i][j] = f[i][j - <span class="number">1</span>] + k2 * (V - b[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (V &gt;= a[i]) f[i][j] = f[i - <span class="number">1</span>][j] + k1 * (V - a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j] + k1 * (V - a[i] - b[j]), f[i][j - <span class="number">1</span>] + k2 * (V - a[i] - b[j]));</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/08/zoj-4019-schrodingers-knapsack/">https://blog.jujimeizuo.cn/2021/04/08/zoj-4019-schrodingers-knapsack/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 4011 Happy Sequence dp</title>
      <link href="/2021/04/08/zoj-4011-happy-sequence/"/>
      <url>/2021/04/08/zoj-4011-happy-sequence/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370222">https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370222</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n和一个m，表示你可以重复用[1,n]里的数字。</p><p>构造一个数列，数列中前一个数字必须是后一个数字的因子，即$a_ia_{i+1}$。</p><p>问能构造多少个这样的数列。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比如n&#x3D;8，m&#x3D;3.可以构造：</p><p>$8\;8\;8$ $8\;8\;4$ $8\;4\;4$ $4\;4\;4$ $…$</p><p>假如我们之后一个数后面可以跟多少因子，然后这个因子后面…</p><p>这就是个递推啊!</p><p>设f[i][j]表示以i结尾，长度为j的序列个数。</p><p>因为必须是因子，所以转移方程为：</p><p>$f[i][j]+&#x3D;f[k][j-1]$(k为i的因子)</p><p>所以要先预处理所有数字的因子，然后进行dp即可。$ans&#x3D;\sum_{i&#x3D;1}^nf[i][m]$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2002</span>;</span><br><span class="line"></span><br><span class="line">ll f[N][N]; <span class="comment">// 长度为j，以i结尾的个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p[1].emplace_back(1);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        p[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) p[i].<span class="built_in">emplace_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k : p[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt; N; j++) &#123;</span><br><span class="line">                f[i][j] = (f[i][j] + f[k][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + f[i][m]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/08/zoj-4011-happy-sequence/">https://blog.jujimeizuo.cn/2021/04/08/zoj-4011-happy-sequence/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 4003 Distance双指针维护区间</title>
      <link href="/2021/04/08/zoj-4003-distance/"/>
      <url>/2021/04/08/zoj-4003-distance/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370154">https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370154</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对于两个长度相同的区间a和b，如果$\suma_i-b_i^p\leq V$，则成这两个区间为good 区间. 给出两个长度相同的数列，在这两个数列中分别选择两个区间，存在多少个good区间。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为$\suma_i-b_i^p$有绝对值，所以每增加一个值，都会增加。 假设我们找到一个区间$[l1,r1]、[l2,r2]$，则$l\in [l1,r1]，l’\in [l2,r2]$都是可以的。</p><p>所以我们可以枚举区间起点，然后计算终点，最后维护区间，更新和统计答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; ll V, p;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; V &gt;&gt; p;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">x</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">y</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; x[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; y[i];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">0</span>;len &lt;= n - <span class="number">1</span>; len++) &#123; <span class="comment">// 枚举指针距离</span></span><br><span class="line">            <span class="type">int</span> l1 = <span class="number">1</span>, r1 = <span class="number">1</span>; <span class="comment">// a</span></span><br><span class="line">            <span class="type">int</span> l2 = <span class="number">1</span> + len, r2 = <span class="number">1</span> + len; <span class="comment">// b</span></span><br><span class="line">            ll cnt = <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[l1] - y[l2]), p);</span><br><span class="line">            <span class="keyword">while</span>(r2 &lt;= n) &#123; <span class="comment">// 先让b动区间</span></span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= V) &#123;</span><br><span class="line">                    ans += r1 - l1 + <span class="number">1</span>;</span><br><span class="line">                    r1++;</span><br><span class="line">                    r2++;</span><br><span class="line">                    cnt += <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[r1] - y[r2]), p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt -= <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[l1] - y[l2]), p);</span><br><span class="line">                    l1++;</span><br><span class="line">                    l2++;</span><br><span class="line">                    <span class="keyword">if</span>(l1 &gt; r1) &#123;</span><br><span class="line">                        r1++;</span><br><span class="line">                        r2++;</span><br><span class="line">                        cnt += <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[r1] - y[r2]), p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            l1 = <span class="number">1</span> + len; r1 = <span class="number">1</span> + len;</span><br><span class="line">            l2 = <span class="number">1</span>; r2 = <span class="number">1</span>;</span><br><span class="line">            cnt = <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[l1] - y[l2]), p);</span><br><span class="line">            <span class="keyword">while</span>(r1 &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt;= V) &#123;</span><br><span class="line">                    ans += r2 - l2 + <span class="number">1</span>;</span><br><span class="line">                    r1++;</span><br><span class="line">                    r2++;</span><br><span class="line">                    cnt += <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[r1] - y[r2]), p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt -= <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[l1] - y[l2]), p);</span><br><span class="line">                    l1++;</span><br><span class="line">                    l2++;</span><br><span class="line">                    <span class="keyword">if</span>(l2 &gt; r2) &#123;</span><br><span class="line">                        r1++;</span><br><span class="line">                        r2++;</span><br><span class="line">                        cnt += <span class="built_in">quick_pow</span>(<span class="built_in">abs</span>(x[r1] - y[r2]), p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/08/zoj-4003-distance/">https://blog.jujimeizuo.cn/2021/04/08/zoj-4003-distance/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 EC Finals I. Misunderstood … Missing 逆向dp</title>
      <link href="/2021/04/07/2018-ec-finals-i-misunderstood-missing/"/>
      <url>/2021/04/07/2018-ec-finals-i-misunderstood-missing/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/gym/102056/problem/I">https://codeforces.com/gym/102056/problem/I</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>刚开始，有初始值都为0的A(伤害)和D(伤害增量)。 D的含义是，每回合刚开始都可以给A增加D的伤害。 有n个回合，每个回合有3个值a,b,c。</p><p>然后三个操作：</p><ol><li>操作一：可以攻击，总伤害增加A+a。</li><li>操作二：给增量D增加b。</li><li>操作三：给伤害A增加c。</li></ol><p>问如何操作可以使总伤害值最大。n&lt;&#x3D;100。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先可以想到$3^{100}$复杂度的暴力，显然不行。</p><p>然后正向遍历？显然也不行，因为你前面的操作对后续会有影响，所以考虑逆向。</p><p>那该怎么逆向呢？如果我们知道我们攻击了几次，并且哪几次攻击，就可以算出当前的贡献。</p><p>比如n&#x3D;5，我正在第2天，如果我们第3和第5天攻击了，那么当前有三个操作：</p><ol><li>执行操作一：$ans+&#x3D;A+a[i]$</li><li>执行操作二：$ans+&#x3D;(3-2)*b[i]+(5-2)*b[i]$</li><li>执行操作三：$ans+&#x3D;2*b[i]$</li></ol><p>很显然，这些我们可以O(1)判断，所以我们要根据后面的选择来做出前面的选择，这就是逆向dp。</p><p>那我们需要知道哪些状态呢？第几轮，攻击次数（统计c[i]贡献），哪几次攻击（统计b[i]贡献）。</p><p>第几轮？最大为100，i。 攻击次数？最大为100，j。 哪几次攻击？这个很不容易想到，那就是记录攻击次数下标和，k。</p><p>那么就得到dp[i][j][k]表示第i轮，攻击了j次，并且下标和为k的最大伤害。</p><p>那么就可以进行状态转移了：</p><ol><li>$操作一：dp[i][j+1][k+i]&#x3D;max(dp[i][j+1][k+i], dp[i+1][j][k]+a[i])$</li><li>$操作二：dp[i][j][k]&#x3D;max(dp[i][j][k],dp[i+1][j][k]+(k-j*i)*b[i])$</li><li>$操作三：dp[i][j][k]&#x3D;max(dp[i][j][k],dp[i+1][j][k]+j*c[i])$</li></ol><p>所以先逆序遍历n，在遍历j，最后遍历k。</p><p>想到这里就已经很好了，可能是我们没有精力继续想了，没有优化。所以一直过不去。</p><p>我们知道n有100，所以100*100*(1+100)*100&#x2F;2会MLE，然后看到i其实可以滚动的。</p><p>所以把前面都改成$i\%2$，后面都改成$(i+1)\%2$，减小空间复杂度。</p><p>k其实也能优化，不必要1到5050，可以根据i和j得到上下限。 上限：从i开始的j-1次攻击加上最后一次为$(i+i+j-1)*(j-1)&#x2F;2+n$ 下限：从n-j+1开始的j次攻击为$(n-j+1+n)*j&#x2F;2$</p><p>最后$ans&#x3D;max(ans,dp[1][j][k])$处理答案即可。</p><p>这一题其实可以写的，可以说90%都想到了，但是ACM就是这样，不允许一点错误，AC即是王道。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">2</span>][<span class="number">101</span>][<span class="number">5051</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">c</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">        dp[n % <span class="number">2</span>][<span class="number">1</span>][n] = a[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n - i; j++) &#123;</span><br><span class="line">                <span class="type">int</span> down = (i + i + j - <span class="number">1</span>) * (j - <span class="number">1</span>) / <span class="number">2</span> + n, up = (n - j + <span class="number">1</span> + n) * j / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = down;k &lt;= up; k++) &#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j + <span class="number">1</span>][k + i] = <span class="built_in">max</span>(dp[i % <span class="number">2</span>][j + <span class="number">1</span>][k + i], dp[(i + <span class="number">1</span>) % <span class="number">2</span>][j][k] + a[i]);</span><br><span class="line">                    dp[i % <span class="number">2</span>][j][k] = <span class="built_in">max</span>(dp[i % <span class="number">2</span>][j][k], dp[(i + <span class="number">1</span>) % <span class="number">2</span>][j][k] + <span class="number">1ll</span> * j * c[i]);</span><br><span class="line">                    dp[i % <span class="number">2</span>][j][k] = <span class="built_in">max</span>(dp[i % <span class="number">2</span>][j][k], dp[(i + <span class="number">1</span>) % <span class="number">2</span>][j][k] + <span class="number">1ll</span> * (k - j * i) * b[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">5050</span>; k++) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[<span class="number">1</span>][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/07/2018-ec-finals-i-misunderstood-missing/">https://blog.jujimeizuo.cn/2021/04/07/2018-ec-finals-i-misunderstood-missing/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 3964Yet Another Game of Stones 扩展尼姆博弈</title>
      <link href="/2021/04/05/zoj-3964yet-another-game-of-stones/"/>
      <url>/2021/04/05/zoj-3964yet-another-game-of-stones/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n堆石头，每堆石头有a个数量和b性质。Alice和Bob玩游戏，每次只能在一堆中取任意多个石头。</p><ul><li>b&#x3D;0，Alice随便取。</li><li>b&#x3D;1，Alice只能取奇数个。</li><li>b&#x3D;2，Alice只能取偶数个。</li></ul><p>取最后一个win。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们知道，如果所有的石头的b都为0，那么就是简单的尼姆博弈，那么我们把b不为0的给限制出来。</p><ol><li>存在一堆b&#x3D;2，并且a为奇数，则Bob必胜。</li><li>存在两堆及以上b&#x3D;2或b&#x3D;1且a&gt;1，则Bob必胜。</li><li>如果只存在一堆b&#x3D;2，则Alice为了胜利，必须先把这堆拿完(否则Bob可以拿到奇数个然后必胜)，则转化为Bob先手的尼姆博弈。</li><li>如果只存在一堆b&#x3D;1，择Alice为了胜利，必须拿完(奇数)或者拿a-1个(偶数)，然后转化为Bob先手的尼姆博弈。</li><li>全为b&#x3D;0，简单尼姆博弈。</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>; <span class="comment">// 奇数、偶数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">c</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i];</span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; c[i];</span><br><span class="line">            <span class="keyword">if</span>(c[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i] &gt; <span class="number">1</span>) a++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i] % <span class="number">2</span>) flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">flag</span>  (a + b &gt; <span class="number">1</span>)) cout &lt;&lt; <span class="string">&quot;Bob&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!a &amp;&amp; !b) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) ans ^= v[i];</span><br><span class="line">                cout &lt;&lt; (ans ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(c[i] == <span class="number">1</span> &amp;&amp; v[i] &gt; <span class="number">1</span>) ans ^= (v[i] % <span class="number">2</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> ans ^= v[i];</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; (ans == <span class="number">0</span> ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(c[i] != <span class="number">2</span>) ans ^= v[i];</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; (ans == <span class="number">0</span> ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/05/zoj-3964yet-another-game-of-stones/">https://blog.jujimeizuo.cn/2021/04/05/zoj-3964yet-another-game-of-stones/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（昆明）(热身赛) C-Statues</title>
      <link href="/2021/04/03/icpc45-kunming-c/"/>
      <url>/2021/04/03/icpc45-kunming-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/13977/C">https://ac.nowcoder.com/acm/contest/13977/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个位置，给k个雕像，每个雕像都有一个位置和大小。想要将它放在第i个位置，需花费$x*j-i$。 将这些雕像按照大小非递减排列，求出最小花费。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为数据只有5000，所以考虑$O(n^2)$dp,第一层n，第二层k。 首先排序，根据大小从小到大排序。</p><p>设f[i][j]表示前i个位置放了j个雕像。则考虑第j个放不放的问题？</p><ul><li>放！$f[i][j] &#x3D;f[i-1][j-1]+a[j].x*abs(i-a[j].p)$</li><li>不放！$f[i][j] &#x3D; f[i-1][j]$</li></ul><p>则状态转移为： $$f[i][j]&#x3D;min(f[i-1][j],f[i-1][j-1]+a[j].x*abs(a[j].p-i))$$</p><p>因为取min，所以memset(f,INF,sizeof(f))，并且边界f[0][0]&#x3D;0。</p><p>复杂度$O(nk)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll x, p;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x == b.x) <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i++) cin &gt;&gt; a[i].p &gt;&gt; a[i].x;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; N; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= <span class="built_in">min</span>(i, k); j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1ll</span> * <span class="built_in">abs</span>(i - a[j].p) * a[j].x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/03/icpc45-kunming-c/">https://blog.jujimeizuo.cn/2021/04/03/icpc45-kunming-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot上传文件</title>
      <link href="/2021/04/02/springboot-upload/"/>
      <url>/2021/04/02/springboot-upload/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/04/02/springboot-upload/">https://blog.jujimeizuo.cn/2021/04/02/springboot-upload/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛40 F-小D的剑阵 最小割+二元关系建图</title>
      <link href="/2021/03/27/nowcoder-practice40-f/"/>
      <url>/2021/03/27/nowcoder-practice40-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/369/F">https://ac.nowcoder.com/acm/contest/369/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数据范围不大，而且存在二元限制关系，考虑网络流。</p><p>假如x和y存在二元限制关系，所以考虑x和y是否选取。</p><p>如果考虑选取呢？最小割！设与源点s在一部分的点不取，与汇点在一部分的点取。</p><p>将所有的$w$和$v_0$和$v_1$加起来，然后把最小割认为是代价，答案就是sum-最小割(最小代价)。</p><p>设$w_x,w_y,v_0,v_1,v_2$表示x的权值，y的权值，x和y都选的权值，x和y都不选的权值，x和y只选一个的权值。</p><p>为什么没有$v_2$？因为$v_2$是扣除的，不是代价，$v_2$要在我们最小割模型中会被算进去，最后会减掉。</p><p>则对于上面的模型，最小割有四种：</p><ul><li>$x和y都选，最小割为a+c&#x3D;v_1$</li><li>$x和y都不选，最小割为b+d&#x3D;w_x+w_y+v_0$</li><li>$x选，y不选，最小割为a+f+d&#x3D;w_y+v_0+v_1+v_2$</li><li>$x不选，y选，最小割为c+e+b&#x3D;w_x+v_0+v_1+v_2$</li></ul><p>然后就要构造边的容量了。</p><p>b和d分别是连向汇点的边，则为$w_x+\frac{v_0}{2}和w_y+\frac{v_0}{2}$。 a和c分别是连向源点的边，则为$\frac{v_1}{2}和\frac{v_1}{2} 剩下的e和f解出来为$$v_2+\frac{v_0+v_1}{2}$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>, INF <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    <span class="type">int</span> maxflow;</span><br><span class="line">    <span class="type">int</span> deep[N], cur[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, next;</span><br><span class="line">        <span class="type">int</span> cap;</span><br><span class="line">    &#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> head[M &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        cnt = maxflow = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">        e[cnt].v = v;</span><br><span class="line">        e[cnt].cap = cap;</span><br><span class="line">        e[cnt].next = head[u];</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line"></span><br><span class="line">        e[cnt].v = u;</span><br><span class="line">        e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">        e[cnt].next = head[v];</span><br><span class="line">        head[v] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= t; i++) &#123;</span><br><span class="line">            deep[i] = <span class="number">-1</span>, cur[i] = head[i];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s); deep[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">                <span class="type">int</span> v = e[i].v;</span><br><span class="line">                <span class="keyword">if</span>(deep[v] == <span class="number">-1</span> &amp;&amp; e[i].cap) &#123;</span><br><span class="line">                    deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deep[t] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> mx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            cur[u] = i;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap &amp;&amp; deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; (a = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(mx, e[i].cap)))) &#123;</span><br><span class="line">                e[i].cap -= a;</span><br><span class="line">                e[i ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">                <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">                maxflow += res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    mf.<span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    mf.n = n; mf.s = <span class="number">0</span>; mf.t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">m</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; w[i], ans += w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, v0, v1, v2; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v0 &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        ans += v0 + v1;</span><br><span class="line">        w[x] += v0 / <span class="number">2</span>; w[y] += v0 / <span class="number">2</span>;</span><br><span class="line">        m[x] += v1 / <span class="number">2</span>; m[y] += v1 / <span class="number">2</span>;</span><br><span class="line">        mf.<span class="built_in">add</span>(x, y, v2 + (v0 + v1) / <span class="number">2</span>);</span><br><span class="line">        mf.<span class="built_in">add</span>(y, x, v2 + (v0 + v1) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        mf.<span class="built_in">add</span>(mf.s, i, m[i]);</span><br><span class="line">        mf.<span class="built_in">add</span>(i, mf.t, w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    mf.<span class="built_in">dinic</span>();</span><br><span class="line">    cout &lt;&lt; ans - mf.maxflow &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/27/nowcoder-practice40-f/">https://blog.jujimeizuo.cn/2021/03/27/nowcoder-practice40-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51nod1588 幸运树 树形dp统计树上方案数</title>
      <link href="/2021/03/27/51nod1588/"/>
      <url>/2021/03/27/51nod1588/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.51nod.com/Challenge/Problem.html##problemId=1588">https://www.51nod.com/Challenge/Problem.html##problemId=1588</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义幸运数字只由4和7组成，比如4，7，47。</p><p>给一棵树，要我们找到三元组(i,j,k)，两两之间的路径中必须要有一条由幸运数字组成的边。</p><p>问，存在多少组这样的三元组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>幸运数字好处理，check一下。关键是怎么找出贡献。</p><p>统计树上方案数，一般先固定一个点，比如i，然后再找另外两个点j和k，算出i这个点对应的贡献。</p><p>设f[u]为以u为根节点的子树中，有几个点到u的路径中存在幸运数字。 设h[u]为以u为根节点的子树外，有几个点到u的路径中存在幸运数字。</p><p>这样，我们的j和k的选择就可以在f中选择，或者h中选择，或者f和h中选择。</p><p>即i的贡献为$f[i]*(f[i]-1)+h[i]*(h[i]-1)+f[i]*h[i]*2$</p><p>然后就是处理f和h。</p><p>dfs过程中：</p><ul><li>如果u和v的边是幸运数字，则$f[u]+&#x3D;siz[v]$</li><li>否则$f[u]+&#x3D;f[v]$</li><li>如果v和u的边是幸运数字，则$h[v]+&#x3D;siz[1]-siz[v]$</li><li>否则$h[v]+&#x3D;h[u]+f[u]-f[v]$</li></ul><p>所以要先dfs一遍预处理f和siz，然后dfs一遍处理h，最后统计方案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; g[N];</span><br><span class="line"></span><br><span class="line">ll f[N], h[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> v = e.v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(e.w) f[u] += siz[v];</span><br><span class="line">        <span class="keyword">else</span> f[u] += f[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> v = e.v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(e.w) h[v] = siz[<span class="number">1</span>] - siz[v];</span><br><span class="line">        <span class="keyword">else</span> h[v] = h[u] + f[u] - f[v];</span><br><span class="line">        <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">10</span> != <span class="number">4</span> &amp;&amp; n % <span class="number">10</span> != <span class="number">7</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        w = <span class="built_in">check</span>(w);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(Edge&#123;v, w&#125;);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(Edge&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) ans += f[i] * (f[i] - <span class="number">1</span>) + h[i] * (h[i] - <span class="number">1</span>) + f[i] * h[i] * <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/27/51nod1588/">https://blog.jujimeizuo.cn/2021/03/27/51nod1588/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 南昌ICPC网络赛 H题 The Nth Item （二阶线性数列递推+光速幂） or （矩阵快速幂+广义斐波那契循环节）</title>
      <link href="/2021/03/26/2019-icpc-nanchang-online-h/"/>
      <url>/2021/03/26/2019-icpc-nanchang-online-h/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://nanti.jisuanke.com/t/41355">https://nanti.jisuanke.com/t/41355</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$F_0&#x3D;0\;\;F_1 &#x3D;1$$</p><p>$$F_{n}&#x3D;3F_{n-1}+2F_{n-2}(n\ge 2)$$</p><p>$对每一个询问，输出F_n。$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$如果是单矩阵快速幂的话，O(8*1e7*log(10^9))T飞了。$</p><h4 id="二阶线性数列递推-快速幂优化"><a href="#二阶线性数列递推-快速幂优化" class="headerlink" title="二阶线性数列递推+快速幂优化"></a>二阶线性数列递推+快速幂优化</h4><p>$我们知道，对于二阶线性数列递推，就是假设F_n&#x3D;x^n，然后解出x^n&#x3D;ax^{n-1}+bx^{x-2}.$</p><p>$如果有二实数根，则为F(n)&#x3D;Ax_1^{n}+Bx_2^{n}$ $如果有一实数根，则为F(n)&#x3D;(A+Bn)x^n$</p><p>$设F_n&#x3D;x^n，则：$</p><p>$$x^n&#x3D;3x^{n-1}+2x^{n-2}$$</p><p>$$x^2-3x-2&#x3D;0$$</p><p>$$x1&#x3D;\frac{3+\sqrt {17}}{2}\;\;\;\;x2&#x3D;\frac{3-\sqrt{17}}{2}$$</p><p>$然后把F_0&#x3D;0\;\;F_1 &#x3D;1带入得：$</p><p>$$F_{n}&#x3D;\frac{1}{\sqrt{17}}((\frac{3+\sqrt{17}}{2})^n+(\frac{3-\sqrt{17}}{2})^n)$$</p><p>$有\sqrt {17}怎么办？用二次剩余处理出来，程序跑出来应该是\sqrt{17}\%(998244353)&#x3D;524399943.$ $注意:二次剩余处理出来的有两个值，取一个就行。$</p><p>$那么最后处理出来为$ $$F_n&#x3D;559329360*(262199973^n-736044383^n)\;\;mod\;\;998244353$$</p><p>$到这里，仍然还不行，因为复杂度为O(1e7*log_2(1e18))也会T，而这里的log是快速幂的复杂度。$ $怎么办？光速幂！$</p><p>$因为我们快速幂是根据进制选择来确定复杂度的，比如log_2就是2进制，所以我们要扩大进制优化。$</p><p>$因为n有1e18，所以我按照2^{16}进制进行求幂，在用欧拉降幂优化后，只有两个权值1和65536。$</p><p>$以262199973^n为例，262199973^n&#x3D;262199973^{n\%65536}+(262199973^2)^{(n\%65536^2)&#x2F;65536}$ $736044383^n同理。$</p><p>$这样，复杂度从log_2n变为log_{65536}^n。$</p><p>$因为会有1e7次运算，所以中间可以加上记忆化剪枝。$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll A = <span class="number">262199973</span>;</span><br><span class="line">ll B = <span class="number">736044383</span>;</span><br><span class="line">ll invsqrt17 = <span class="number">559329360</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">x1</span><span class="params">(<span class="number">2</span>)</span>,  <span class="title">x2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">   ll ans = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(b) &#123;</span><br><span class="line">       <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">       a = a * a % mod;</span><br><span class="line">       b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll v\_pow1(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    ll base = <span class="number">65536</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ans = ans * quick\_pow(x1[i], (b % (k * base)) / k) % mod;</span><br><span class="line">        k = k * base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll v\_pow2(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    ll base = <span class="number">65536</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        ans = ans * quick\_pow(x2[i], (b % (k * base)) / k) % mod;</span><br><span class="line">        k = k * base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp[n]) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = invsqrt17 * (v\_pow1(A, n) - v\_pow2(B, n)) % mod;</span><br><span class="line">    <span class="keyword">return</span> mp[n] = (ans % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll q, n; cin &gt;&gt; q &gt;&gt; n;</span><br><span class="line">    x1[<span class="number">0</span>] = A; x1[<span class="number">1</span>] = quick\_pow(A, <span class="number">65536</span>);</span><br><span class="line">    x2[<span class="number">0</span>] = B; x2[<span class="number">1</span>] = quick\_pow(B, <span class="number">65536</span>);</span><br><span class="line">    ll ans = <span class="built_in">f</span>(n % (mod - <span class="number">1</span>)), sum = <span class="built_in">f</span>(n % (mod - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; q; i++) &#123;</span><br><span class="line">        n ^= (sum * sum);</span><br><span class="line">        sum = <span class="built_in">f</span>(n % (mod - <span class="number">1</span>));</span><br><span class="line">        ans ^= sum;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵快速幂-广义斐波那契循环节"><a href="#矩阵快速幂-广义斐波那契循环节" class="headerlink" title="矩阵快速幂+广义斐波那契循环节"></a>矩阵快速幂+广义斐波那契循环节</h4><p>$对于上面二次剩余的方法，由于会有局限性，比如\sqrt {13}就没有解，而对于循环节，这是通用性。$</p><p>$对于F_n&#x3D;aF_{n-1}+bF_{n-2}，这是被称为广义斐波那契数列。$</p><p>$可以证明，F_n\;mod\;p是有循环节的。$</p><p>$设c&#x3D;a^2+4b，如果c是模p的二次剩余时，枚举所有的p-1的因子，找到最小的因子x使得：$</p><p>$$ \begin{bmatrix} a&amp; b\ 1&amp; 0 \end{bmatrix}^x&#x3D;\begin{bmatrix} 1 &amp; 0\ 0 &amp; 1 \end{bmatrix} $$</p><p>$则x为循环节。$</p><p>$如果c不是模p的二次剩余时，枚举所有的p^2-1的因子，找到最小的因子x，方法如上。$</p><p>$在这里，a^2+4b&#x3D;17是模p的二次剩余，得出循环节为\frac{p-1}{2}&#x3D;499122476。则F(N)&#x3D;F(N\;\%\;499122476)$</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/26/2019-icpc-nanchang-online-h/">https://blog.jujimeizuo.cn/2021/03/26/2019-icpc-nanchang-online-h/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2458 [SDOI2006]保安站岗 树形dp最小费用覆盖点</title>
      <link href="/2021/03/25/p2458-sdoi2006/"/>
      <url>/2021/03/25/p2458-sdoi2006/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P2458">https://www.luogu.com.cn/problem/P2458</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，在树上安置保安，一条边的两个端点至少安置一个保安，保安都有费用。 问符合情况的最小费用是多少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为一条边的两个端点必须要有一个，可以有两个，所以这是不限制父亲和儿子关系的。</p><p>如果一条边的两个端点都选，那一定不会是最小费用，所以只需要选一点即可。</p><p>对于一个点选不选，对父亲和儿子选不选都有影响，所以设f[u][0&#x2F;1&#x2F;2]。 f[u][]表示以u为根的子树。</p><ul><li>f[u][0]表示u自己选</li><li>f[u][1]表示自己不选，儿子选</li><li>f[u][2]表示自己不选，父亲选</li></ul><p>转移方程：</p><p>自己选，不妨碍其他点的选择，即</p><ul><li>$f[u][0]+&#x3D;\sum_{v\in g[u]}min(f[v][0],f[v][1],f[v][2])$</li></ul><p>父亲选，所以自己不用选了，只需要加上儿子的最小费用，即</p><ul><li>$f[u][2]+&#x3D;\sum_{v\in g[u]} min(f[v][0]+f[v][1])$</li></ul><p>儿子选，对于所有儿子，肯定不会全部都选，选择最小的儿子即可，即</p><ul><li>$f[u][1]+&#x3D;\sum_{v\in g[u]除最小}f[v][1]+f[v_{最优}][0]$</li></ul><p>对于f[u][1]，我们怎么找到最小的呢？</p><p>记录$mn&#x3D;min(mn,f[v][0]-f[v][1])$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(f[v][<span class="number">0</span>] &lt;= f[v][<span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        f[u][<span class="number">1</span>] += f[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f[u][<span class="number">1</span>] += f[v][<span class="number">1</span>];</span><br><span class="line">        mn = <span class="built_in">min</span>(mn, f[v][<span class="number">0</span>] - f[v][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) f[u][<span class="number">1</span>] += mn;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = val[u];</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mn = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">min</span>(f[v][<span class="number">0</span>], <span class="built_in">min</span>(f[v][<span class="number">1</span>], f[v][<span class="number">2</span>]));</span><br><span class="line">        f[u][<span class="number">2</span>] += <span class="built_in">min</span>(f[v][<span class="number">0</span>], f[v][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(f[v][<span class="number">0</span>] &lt;= f[v][<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            f[u][<span class="number">1</span>] += f[v][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[u][<span class="number">1</span>] += f[v][<span class="number">1</span>];</span><br><span class="line">            mn = <span class="built_in">min</span>(mn, f[v][<span class="number">0</span>] - f[v][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) f[u][<span class="number">1</span>] += mn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> id, m; cin &gt;&gt; id &gt;&gt; val[id] &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">            g[v].<span class="built_in">eb</span>(id);</span><br><span class="line">            g[id].<span class="built_in">eb</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/25/p2458-sdoi2006/">https://blog.jujimeizuo.cn/2021/03/25/p2458-sdoi2006/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018牛客国庆集训派对Day3 B-Tree 树形dp+组合计数+假换根</title>
      <link href="/2021/03/25/2018-nowcoder-guoqing-day3-b-tree/"/>
      <url>/2021/03/25/2018-nowcoder-guoqing-day3-b-tree/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/203/B">https://ac.nowcoder.com/acm/contest/203/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，对于每个节点，输出与它相连的所有子集个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>树，节点，计数-树形dp。</p><p>设f[i]为以i为根节点的字树中，包括i的子集个数，所以对于根节点，答案为f[root]。</p><p>状态转移方程：</p><p>$$f[u]&#x3D;\prod(f[v]+1)\;\;v为与u相连儿子$$</p><p>为什么+1，因为自己是子集的一部分。</p><p>上面说到，只有对于根节点，ans才为f[root]，但是不是根节点呢？</p><p>最简单的方法是，把每个点当作root，dfs一遍。但是数据范围不允许。</p><p>$但是我们看到对于以u为根节点的叶子节点，只有父亲节点那边的子集个数没有统计。</p><p>所以我们再dfs’一遍，首先是没有父亲，所以ans&#x3D;f[u]，然后利用父亲更新节点。</p><p>如果更新呢？</p><p>f[u]已经统计了所有子节点，没有统计父亲节点，所以需要乘上父亲节点那边的贡献。</p><p>贡献为$\frac{ans[fa]}{f[u]+1}$，所以$ans[u]&#x3D;(\frac{ans[fa]}{f[u]+1}+1)*f[u]$</p><p>对于$(f[u]+1) \% mod&#x3D;0$，因为0没有逆元，所以要特别统计（最大坑点）。 最简单的就是以它为根节点dfs一遍，ans&#x3D;f[u]。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">ll ans[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        f[u] = f[u] * (f[v] + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((f[u] + <span class="number">1</span>) % mod == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(u, <span class="number">-1</span>);</span><br><span class="line">            ans[u] = f[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans[u] = (ans[fa] * (<span class="built_in">quick_pow</span>(<span class="number">1</span> + f[u], mod - <span class="number">2</span>) % mod) % mod + <span class="number">1</span>) * f[u] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ans[u] = f[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">eb</span>(v);</span><br><span class="line">        g[v].<span class="built_in">eb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/25/2018-nowcoder-guoqing-day3-b-tree/">https://blog.jujimeizuo.cn/2021/03/25/2018-nowcoder-guoqing-day3-b-tree/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018 ICPC宁夏Factories 树形dp</title>
      <link href="/2021/03/25/2018-icpc-ningxia-factories/"/>
      <url>/2021/03/25/2018-icpc-ningxia-factories/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://nanti.jisuanke.com/t/A1767">https://nanti.jisuanke.com/t/A1767</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，在树中选择k个节点，要求输出最小任意两点距离和。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>树、选择节点、统计距离-树形dp。</strong> 设f[u][i]为以u为根的字树中选择i个节点的贡献。 转移方程很容易看出：</p><p>$$f[u][i+j]&#x3D;min(f[u][i+j],f[u][i]+f[v][j]+e[i].w*j*(k-j))$$</p><p>$e[i].w*j*(k-j)$是统计任意两点距离和的套路公式。</p><p>在方程中可以看出，f[u][i+j]是与f[u][i]有关的，所以不能正向转移，而要倒序转移。</p><p>但是倒序转移中会出现转移值出现被更改的问题。 所以需要一个辅助数组，这也是套路，但是不能memset，可以手写。</p><p>最后注意root不一定为1，需要记录度即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next; ll w;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line">ll f[N][<span class="number">110</span>]; <span class="comment">// 以u为根的子树中选择k个叶子节点</span></span><br><span class="line">ll temp[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> siz[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[u] == <span class="number">1</span>) &#123;</span><br><span class="line">        siz[u] = <span class="number">1</span>, f[u][<span class="number">0</span>] = f[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    siz[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i++) f[u][i] = <span class="number">2e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt;= <span class="built_in">min</span>(siz[u], k); p++) temp[p] = <span class="number">2e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt;= <span class="built_in">min</span>(siz[u], k); p++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> q = <span class="number">0</span>;q &lt;= siz[v] &amp;&amp; p + q &lt;= k; q++) &#123;</span><br><span class="line">                temp[p + q] = <span class="built_in">min</span>(temp[p + q], f[u][p] + f[v][q] + e[i].w * q * (k - q));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>;p &lt;= <span class="built_in">min</span>(siz[u], k); p++) f[u][p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="type">int</span> Case = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) d[i] = <span class="number">0</span>, siz[i] = <span class="number">0</span>, head[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v; ll w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            <span class="built_in">add</span>(u, v, w);</span><br><span class="line">            <span class="built_in">add</span>(v, u, w);</span><br><span class="line">            d[u]++; d[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case ##%d: &quot;</span>,Case++);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,e[<span class="number">1</span>].w);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[i][k]);</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/25/2018-icpc-ningxia-factories/">https://blog.jujimeizuo.cn/2021/03/25/2018-icpc-ningxia-factories/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 855C Helga Hufflepuff‘s Cup 树形dp</title>
      <link href="/2021/03/24/codeforces-855c/"/>
      <url>/2021/03/24/codeforces-855c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/problemset/problem/855/C">https://codeforces.com/problemset/problem/855/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，有m种颜色1-m，其中x种是特殊颜色，k是特殊颜色的编号。 问如何给树涂色，特殊颜色的节点不能连特殊颜色，只能连比他编号小的颜色。</p><p>问，能有多少种涂色方案？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>树、节点、计数、特殊情况–树形dp。</strong></p><p>颜色数量高达1e9，而特殊颜色数量只有10，所以我们围绕特殊颜色展开状态转移。</p><p>$因为特殊颜色的连接是有要求的，所以可以分成三类。</p><ul><li>0表示特殊颜色</li><li>1表示比特殊颜色编号小的颜色</li><li>2表示比特殊颜色编号大的颜色</li></ul><p>所以设f[u][i][j]表示以u为根节点的子树中，i个特殊颜色，当前点颜色为j的方案数。</p><p>根据特殊颜色来转移： $$f[u][i+j][0]+&#x3D;f[u][i][0]*f[v][j][1]$$</p><p>$$f[u][i+j][1]+&#x3D;f[u][i][1]*(f[v][j][0]+f[v][j][1]+f[v][j][2])$$</p><p>$$f[u][i+j][2]+&#x3D;f[u][i][2]*(f[v][j][1]+f[v][j][2])$$</p><p>因为转移的时候是+&#x3D;,所以需要一个辅助函数来帮忙存储，防止新产生的值对后续转移产生影响。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, x;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">ll dp[<span class="number">11</span>][<span class="number">3</span>], f[N][<span class="number">11</span>][<span class="number">3</span>]; <span class="comment">// [以u为根的子树][i种特殊颜色][0/1/2，特殊颜色，小于特殊颜色，大于特殊颜色]</span></span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">1</span>] = k - <span class="number">1</span>; <span class="comment">// 小于特殊颜色的有k-1种</span></span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">2</span>] = m - k; <span class="comment">// 大于特殊颜色的有m-k种</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="built_in">mem</span>(dp, <span class="number">0</span>);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="built_in">min</span>(siz[u], x); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= siz[v] &amp;&amp; i + j &lt;= x; j++) &#123;</span><br><span class="line">                dp[i + j][<span class="number">0</span>] = (dp[i + j][<span class="number">0</span>] + f[u][i][<span class="number">0</span>] * f[v][j][<span class="number">1</span>] % mod) % mod;</span><br><span class="line">                dp[i + j][<span class="number">1</span>] = (dp[i + j][<span class="number">1</span>] + f[u][i][<span class="number">1</span>] * (f[v][j][<span class="number">0</span>] + f[v][j][<span class="number">1</span>] + f[v][j][<span class="number">2</span>]) % mod) % mod;</span><br><span class="line">                dp[i + j][<span class="number">2</span>] = (dp[i + j][<span class="number">2</span>] + f[u][i][<span class="number">2</span>] * (f[v][j][<span class="number">1</span>] + f[v][j][<span class="number">2</span>]) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="built_in">min</span>(siz[u], x); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                f[u][i][j] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        g[u].<span class="built_in">eb</span>(v); g[v].<span class="built_in">eb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;x);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            ans = (ans + f[<span class="number">1</span>][i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/24/codeforces-855c/">https://blog.jujimeizuo.cn/2021/03/24/codeforces-855c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/03/24/codeforces-round-664-div-2-c/"/>
      <url>/2021/03/24/codeforces-round-664-div-2-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/problemset/problem/1395/C">https://codeforces.com/problemset/problem/1395/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2021/03/20210324143123943.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据题意看出，ans最大只有$2^9（512）$，所以我们可以枚举答案。 对于一个ans，如果所有的$a_i$都可以找到$b_j$，使得$ans(a_i\&amp;b_j)&#x3D;ans$，则最小答案为ans.</p><p>因为从0枚举到512，所以存在答案时总是最小的。</p><p>复杂度：$O(2^9*n*m)$</p><h2 id="Code-31MS"><a href="#Code-31MS" class="headerlink" title="Code(31MS)"></a>Code(31MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ans = <span class="number">0</span>;ans &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">9</span>); ans++) &#123;</span><br><span class="line">        <span class="type">bool</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> temp = a[i] &amp; b[j];</span><br><span class="line">                <span class="keyword">if</span>((ans  temp) == ans) flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span> &amp;&amp; flag) f = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f) &#123;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/24/codeforces-round-664-div-2-c/">https://blog.jujimeizuo.cn/2021/03/24/codeforces-round-664-div-2-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC南京站 Monster Hunter 树上背包</title>
      <link href="/2021/03/22/2020-icpc-nanjing-monster-hunter/"/>
      <url>/2021/03/22/2020-icpc-nanjing-monster-hunter/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一棵树，你可以去掉m个点$(m\in [0,n])$，然后计算剩余结点的贡献。 每个结点的贡献为它本身的价值加上它所有直接相连儿子的价值。 当然你需要合理安排删去的i个结点使贡献最小化。输出每个i对应的贡献值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有树、节点、贡献，得出树形dp。</p><p>设f[i][j]表示以i为根节点的子树中留下j个节点的最小贡献。 题意表示，必须杀掉父节点才能杀掉子节点，所以父节点是否存活也很关键。即： f[0][i][j]表示删掉i后留下j个节点的最小贡献。 f[1][i][j]表示保留i后留下j-1个节点的最小贡献。</p><p>$状态转移都是从子节点转移到父节点：$ $$f[0][u][j+k]&#x3D;min(f[0][u][j+k],f[0][u][j]+min(f[0][v][k],f[1][v][k]))$$ $$f[1][u][j+k]&#x3D;min(f[1][u][j+k],f[1][u][j]+min(f[0][v][k],f[1][v][k]+val[v]))$$</p><p>第二个为什么要加上val[v]，因为题意说对于一个节点的贡献，是自己加上所有儿子的权值。</p><p>上面的状态转移直接背包即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll val[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line">ll f[<span class="number">2</span>][N][N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][u][<span class="number">1</span>] = val[u];</span><br><span class="line">    f[<span class="number">0</span>][u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = siz[u];j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = siz[v];k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                f[<span class="number">0</span>][u][j + k] = <span class="built_in">min</span>(f[<span class="number">0</span>][u][j + k], f[<span class="number">0</span>][u][j] + <span class="built_in">min</span>(f[<span class="number">0</span>][v][k], f[<span class="number">1</span>][v][k]));</span><br><span class="line">                f[<span class="number">1</span>][u][j + k] = <span class="built_in">min</span>(f[<span class="number">1</span>][u][j + k], f[<span class="number">1</span>][u][j] + <span class="built_in">min</span>(f[<span class="number">0</span>][v][k], f[<span class="number">1</span>][v][k] + val[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= n; j++) &#123;</span><br><span class="line">                f[<span class="number">0</span>][i][j] = f[<span class="number">1</span>][i][j] = <span class="number">1e18</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u; cin &gt;&gt; u;</span><br><span class="line">            g[u].<span class="built_in">eb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; val[i];</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">min</span>(f[<span class="number">0</span>][<span class="number">1</span>][i], f[<span class="number">1</span>][<span class="number">1</span>][i]) &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/22/2020-icpc-nanjing-monster-hunter/">https://blog.jujimeizuo.cn/2021/03/22/2020-icpc-nanjing-monster-hunter/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1273 有线电视网 树上背包</title>
      <link href="/2021/03/22/luogu-p1273/"/>
      <url>/2021/03/22/luogu-p1273/</url>
      
        <content type="html"><![CDATA[<p>传送门:<a href="https://www.luogu.com.cn/problem/P1273">https://www.luogu.com.cn/problem/P1273</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，每条边都有收费，每个叶子节点给费用。 问从根节点出发，在不亏本的情况下能到达多少叶子节点。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设f[i][j]表示以i为根节点，能到达j个叶子节点的能赚多少钱。</p><p>树形dp都是子节点更新父节点，所以我们用子节点来进行状态转移：</p><p>假设u和v连接的一条边，则如果需要v这颗子树，则为v赚的钱-这条边的费用。 $$f[u][j]&#x3D;max(f[u][j],f[u][j-k]+f[v][k]-e[i].w)$$</p><p>和分组背包一样，倒序循环。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> d[N], siz[N], val[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next, w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = siz[u];j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= <span class="built_in">min</span>(j, siz[v]); k++) &#123;</span><br><span class="line">                f[u][j] = <span class="built_in">max</span>(f[u][j], f[u][j - k] + f[v][k] - e[i].w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[u] == <span class="number">1</span>) f[u][<span class="number">1</span>] = val[u], siz[u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">mem</span>(f, -INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="type">int</span> a, c; cin &gt;&gt; a &gt;&gt; c;</span><br><span class="line">            d[i]++; d[a]++;</span><br><span class="line">            <span class="built_in">add</span>(i, a, c);</span><br><span class="line">            <span class="built_in">add</span>(a, i, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - m + <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; val[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/22/luogu-p1273/">https://blog.jujimeizuo.cn/2021/03/22/luogu-p1273/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/03/21/codeforces-round-398-div-2-c/"/>
      <url>/2021/03/21/codeforces-round-398-div-2-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/contest/767/problem/C">https://codeforces.ml/contest/767/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，每个节点都有点权，问能否将树三等分后，每份子树的节点和相等？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为是树上操作，所以dfs，记录每个子树的节点和val。 如果val[x]&#x3D;sum&#x2F;3，说明该点为一个分割点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> head[N], cnt;</span><br><span class="line"><span class="type">int</span> root, val[N];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum3;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i].v);</span><br><span class="line">        val[u] += val[e[i].v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val[u] == sum3 &amp;&amp; u != root &amp;&amp; tot &lt;= <span class="number">1</span>) val[u] = <span class="number">0</span>, ans[++tot] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans[<span class="number">1</span>] = ans[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, w; cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        sum += w;</span><br><span class="line">        val[i] = w;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">0</span>) root = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(v, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">3</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sum3 = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">if</span>(ans[<span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; ans[<span class="number">2</span>] != <span class="number">-1</span> &amp;&amp; val[root] == sum3) &#123;</span><br><span class="line">        cout &lt;&lt; ans[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/21/codeforces-round-398-div-2-c/">https://blog.jujimeizuo.cn/2021/03/21/codeforces-round-398-div-2-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛48 B-心跳调试 概率线性DP</title>
      <link href="/2021/03/21/nowcoder-challenge48-b/"/>
      <url>/2021/03/21/nowcoder-challenge48-b/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/11161/B">https://ac.nowcoder.com/acm/contest/11161/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="http://cdn.jujimeizuo.cn/blog/2021/03/20210321153553102.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设栈顶为i，那么下一个入栈的必须是i或者i+1，所以和栈内的状态无关。</p><p>设当前为i，下一个放入i+1而不是更大的数字的概率为p，则</p><p>$$p&#x3D;f_i*p+f_{i+1}$$</p><p>则：</p><p>$$p&#x3D;\frac{w_{i+1}}{\sum_{k&#x3D;i+1}^nw_k}$$</p><p>则:</p><p>$$ans&#x3D;\prod_{i&#x3D;2}^np_i$$</p><p>复杂度O(n)dp。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">w</span><span class="params">(n + <span class="number">100</span>)</span>, <span class="title">sum</span><span class="params">(n + <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>; i--) sum[i] = sum[i + <span class="number">1</span>] + w[i];</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ans = ans * w[i] % mod * <span class="built_in">quick_pow</span>(sum[i] % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/21/nowcoder-challenge48-b/">https://blog.jujimeizuo.cn/2021/03/21/nowcoder-challenge48-b/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1272 重建道路 树上背包</title>
      <link href="/2021/03/21/luogu-p1272/"/>
      <url>/2021/03/21/luogu-p1272/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P1272">https://www.luogu.com.cn/problem/P1272</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$给一颗树，问最少删除几条边，可以使一颗子树含有p个节点？$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>树上问题，想必是树形dp。</p><p>设f[i][j]表示以i为根的子树，有j个节点最小删除边数。</p><p>状态转移： $$f[u][j] &#x3D; min(f[u][j], f[u][j-k]+f[v][k]-1)$$</p><p>为什么要减1？ f[i][j]都是包含根节点，f[u][j-k]+f[v][k]中间会多出一条u和v相连的边。</p><p>最后答案是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = f[<span class="number">1</span>][p];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i][p] &lt; ans) ans = f[i][p] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么除了根节点1，其他都要+1? 假设p&#x3D;4的话，可以看见保留以2为根节点是明智的选择。</p><p>但是dp后f[2][4]&#x3D;0，为什么呢？因为不需要删除任何边，但是1-2需要删除，所以+1。</p><hr><p>总流程：</p><ol><li>预处理f[i][1] &#x3D; a[i]，a[i]为每个点的出度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) f[i][<span class="number">1</span>] = a[i];</span><br></pre></td></tr></table></figure><ol start="2"><li>dfs(1)，返回值为sum，表示以u为子树的节点个数，然后就可以转化成背包了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">dfs</span>(v);</span><br><span class="line">        sum += temp;</span><br><span class="line">        <span class="comment">// 背包。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>状态转移。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = sum;j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt; j; k++) &#123;</span><br><span class="line">        f[u][j] = <span class="built_in">min</span>(f[u][j], f[u][i - k] + f[v][k] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N, INF));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">dfs</span>(v);</span><br><span class="line">        sum += temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = sum;j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt; j; k++) &#123;</span><br><span class="line">                f[u][j] = <span class="built_in">min</span>(f[u][j], f[u][j - k] + f[v][k] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p; cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        a[u]++;</span><br><span class="line">        g[u].<span class="built_in">eb</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) f[i][<span class="number">1</span>] = a[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = f[<span class="number">1</span>][p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][p] &lt; ans) ans = f[i][p] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/21/luogu-p1272/">https://blog.jujimeizuo.cn/2021/03/21/luogu-p1272/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6428 Problem C. Calculate 莫反+积性函数+线性筛</title>
      <link href="/2021/03/12/hdu-6428-problem-c/"/>
      <url>/2021/03/12/hdu-6428-problem-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6428">http://acm.hdu.edu.cn/showproblem.php?pid=6428</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^A\sum_{j&#x3D;1}^B\sum_{k&#x3D;1}^C\phi (gcd(i,j^2,k^3))\;\;mod\;\;2^{30}$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$首先要把\phi和gcd分开，即\phi(n)&#x3D;\sum_{dn}(\phi*\mu)(d)，证明如下：$ $$\phi(n)&#x3D;(\mu*id)(n)$$</p><p>$$\sum_{dn}\mu(d)\frac{n}{d}$$</p><p>$$\sum_{dn}\mu(d)\sum_{d’\frac{n}{d}}\phi(d’)$$</p><p>$$\sum_{dd’n}\mu(d)\phi(d’)$$</p><p>$$\sum_{dn}\sum_{d’d}\mu(d’)\phi(\frac{d}{d’})$$</p><p>$$\sum_{dn}(\phi*\mu)(d)$$</p><p>$所以原式变为：$</p><p>$$\sum_{i&#x3D;1}^A\sum_{j&#x3D;1}^B\sum_{k&#x3D;1}^C\sum_{di\;dj^2\;dk^3}(\phi*\mu)(d)$$</p><p>$$\sum_{d&#x3D;1}^{A}(\phi*\mu)(d)\sum_{i&#x3D;1\;di}^A\sum_{j&#x3D;1\;dj^2}^B\sum_{k&#x3D;1\;dk^3}^C1$$</p><p>$观察后面式子，对于一个x^k，若dx^k，先把d分解为\prod p_i^{a_i}.$ $则\prod p_i^{a_i}x^k，得\prod p_i^{\left \lceil \frac{a_i}{k} \right \rceil }x，所以设$</p><p>$$f_k(n)&#x3D;\prod p_i^{\left \lceil \frac{a_i}{k} \right \rceil }$$</p><p>$则：$</p><p>$$ans&#x3D;\sum_{d&#x3D;1}^{A}(\phi * \mu)(d)\frac{A}{f_1(d)}\frac{B}{f_2(d)}\frac{C}{f_3(d)}$$</p><p>$对于f_k(n)，类似分解n的形式。$ $分解质因子的过程中，记录质因子的指数，每次质因子+1时，若\%k&#x3D;1时，说明该向上取整了，于是f_k(n)*&#x3D;该质因子.$</p><p>$由于\phi和\mu都是积性函数，卷积之后还是积性函数，设g(d)&#x3D;(\phi*\mu)(d)，则$</p><p>$$\phi(n)&#x3D;\sum_{dn}g(d)$$</p><p>$那么可以得：$</p><p>$$\phi(p^k)&#x3D;\phi(p^{k-1})+g(p^k)$$</p><p>$$g(p^k)&#x3D;\phi(p^k)-\phi(p^{k-1})$$</p><p>$$g(p^k)&#x3D;(p-1)p^{k-1}-(p-1)p^{k-2}$$</p><p>$$g(p^k)&#x3D;(p-1)^2p^{k-2}$$</p><p>$当我们欧拉筛的过程中：$</p><p>$$g(1)&#x3D;1$$</p><p>$$g(p)&#x3D;p-2$$</p><p>$$g(p^{k})&#x3D;(p-1)^2p^{k-2}$$</p><p>$$g(p_1^{k_1}p_2^{k_2})&#x3D;g(p_1^{k_1})g(p_2^{k_2})$$</p><p>$$……$$</p><h2 id="Code-2480MS"><a href="#Code-2480MS" class="headerlink" title="Code(2480MS)"></a>Code(2480MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = (<span class="number">1ll</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> is\_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"><span class="type">int</span> f1[N], f2[N], f3[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f1[<span class="number">1</span>] = f2[<span class="number">1</span>] = f3[<span class="number">1</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f1[i] = i;</span><br><span class="line">        <span class="keyword">if</span>(!is\_prime[i]) prime[++cnt] = f2[i] = f3[i] = i, g[i] = i - <span class="number">2</span>, deg[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="type">int</span> now = i * prime[j];</span><br><span class="line">            is\_prime[now] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                deg[now] = deg[i] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> num = <span class="number">1</span>, tmp = i;</span><br><span class="line">                <span class="keyword">while</span>(num &lt;= <span class="number">3</span> &amp;&amp; tmp % prime[j] == <span class="number">0</span>) num++, tmp /= prime[j];</span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">1</span>) g[now] = g[i] * g[prime[j]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span>) g[now] = g[i / prime[j]] * (prime[j] - <span class="number">1</span>) * (prime[j] - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> g[now] = g[i] * prime[j];</span><br><span class="line">                f2[now] = f2[i] * (deg[now] % <span class="number">2</span> == <span class="number">1</span> ? prime[j] : <span class="number">1</span>);</span><br><span class="line">                f3[now] = f3[i] * (deg[now] % <span class="number">3</span> == <span class="number">1</span> ? prime[j] : <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                deg[now] = <span class="number">1</span>;</span><br><span class="line">                f2[now] = f2[i] * f2[prime[j]];</span><br><span class="line">                f3[now] = f3[i] * f3[prime[j]];</span><br><span class="line">                g[now] = g[i] * g[prime[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> \_; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;\_);</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        <span class="type">int</span> A, B, C; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;A,&amp;B,&amp;C);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>;d &lt;= A; d++) &#123;</span><br><span class="line">            ans = (ans + <span class="number">1ll</span> * g[d] * (A / f1[d]) % mod * (B / f2[d]) % mod * (C / f3[d]) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans % mod + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/12/hdu-6428-problem-c/">https://blog.jujimeizuo.cn/2021/03/12/hdu-6428-problem-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/03/12/codeforces-round-603-div-2-f/"/>
      <url>/2021/03/12/codeforces-round-603-div-2-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/contest/1263/problem/F">https://codeforces.ml/contest/1263/problem/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给两棵树，一颗在上面，另一颗在下面，两棵树的叶子节点都连接着一台机器。</p><p>问，最多删掉多少条边，每个机器都至少存在一条路径到达两个根节点1中的一个。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑dp，设dp[i]表示前i个机器通电的最大删除边数。 设val[0&#x2F;1][L][R]表示上&#x2F;下树中区间[L,R]最大删除边数。 即转移方程为： $$dp[i]&#x3D;max(dp[i],dp[j]+max(val[0][j+1][i],val[1][j+1][i]))$$</p><p>所以要怎么处理这个val呢？</p><p>在树上处理，第一想到的就是dfs！</p><p>因为叶子节点都是与机器相连的，所以n个叶子节点类似于线段的端点。 对于每个子树，都会有一个端点区间，当删除该子树时，该区间内的机器无法到达根节点。 删除该子树后，贡献为子树大小即size[i]条边。</p><p>dfs过程中不断更新val[L][R]即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> val[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="type">int</span> l[<span class="number">2</span>][N], r[<span class="number">2</span>][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">2</span>][N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u != <span class="number">1</span>) siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[opt][u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u, opt);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        l[opt][u] = <span class="built_in">min</span>(l[opt][u], l[opt][v]);</span><br><span class="line">        r[opt][u] = <span class="built_in">max</span>(r[opt][u], r[opt][v]);</span><br><span class="line">    &#125;</span><br><span class="line">    val[opt][l[opt][u]][r[opt][u]] = <span class="built_in">max</span>(val[opt][l[opt][u]][r[opt][u]], siz[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">mem</span>(l, INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        siz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt;= a; j++) &#123;</span><br><span class="line">            <span class="type">int</span> u; cin &gt;&gt; u;</span><br><span class="line">            g[i][u].<span class="built_in">eb</span>(j);</span><br><span class="line">            g[i][j].<span class="built_in">eb</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">            l[i][v] = j;</span><br><span class="line">            r[i][v] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i; j++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="built_in">max</span>(val[<span class="number">0</span>][j + <span class="number">1</span>][i], val[<span class="number">1</span>][j + <span class="number">1</span>][i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/12/codeforces-round-603-div-2-f/">https://blog.jujimeizuo.cn/2021/03/12/codeforces-round-603-div-2-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6706 杜教筛</title>
      <link href="/2021/03/09/hdu-6706/"/>
      <url>/2021/03/09/hdu-6706/</url>
      
        <content type="html"><![CDATA[<p>传送门： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6706">http://acm.hdu.edu.cn/showproblem.php?pid=6706</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^igcd(i^a-j^a,i^b-j^b)[gcd(i,j)&#x3D;1]$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$gcd(i^a-j^a,i^b-j^b)&#x3D;i^{gcd(a,b)}-j^{gcd(a,b)}$$</p><p>题目说gcd(a,b)&#x3D;1，所以那个复杂的式子直接变成i-j.</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^i(i-j)[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^ii[gcd(i,j)&#x3D;1]-\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^ij[gcd(i,j)&#x3D;1]$$</p><p>左边为与i互质的个数，右边为比i小并且互质的数字和，即为：</p><p>$$\sum_{i&#x3D;1}^ni\varphi (i)-\frac{\sum_{i&#x3D;1}^ni\varphi (i)+1}{2}$$</p><p>$$\frac{\sum_{i&#x3D;1}^ni\varphi (i)-1}{2}$$</p><p>因为n有1e9，所以需要杜教筛优化。</p><p>$$f*g(n)&#x3D;\sum_{dn}f(d)g(\frac{n}{d})&#x3D;\sum_{dn}id(d)*\varphi (d)*g(\frac{n}{d})$$</p><p>很显然，设g&#x3D;id，则：</p><p>$$f*g(n)&#x3D;\sum_{dn}\varphi (d)id(n)&#x3D;n\sum_{dn}\varphi (d)&#x3D;id(n)(\varphi *I)&#x3D;id^2(n)&#x3D;n^2$$</p><p>$$所以得：S(n)&#x3D;\sum_{i&#x3D;1}^n(f*g)i-\sum_{i&#x3D;2}^ng(i)S(\frac{n}{i})&#x3D;\frac{n(n+1)(2n+1)}{6}-\sum_{i&#x3D;2}^niS(\frac{n}{i})$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> eb emplace\_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span> </span>&#123;<span class="type">char</span> c = <span class="built_in">getchar</span>();T x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;c = <span class="built_in">getchar</span>();&#125;a = f * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is\_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line">ll sum\_i\_phi[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is\_prime[i]) prime[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is\_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        sum\_i\_phi[i] = (sum\_i\_phi[i - <span class="number">1</span>] + <span class="number">1ll</span> * i * phi[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">         a = a * a % mod;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv2;</span><br><span class="line">ll inv6;</span><br><span class="line"></span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N) <span class="keyword">return</span> sum\_i\_phi[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll ans = x * (x + <span class="number">1</span>) % mod * (<span class="number">2</span> * x + <span class="number">1</span>) % mod * inv6 % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(x, x / (x / l));</span><br><span class="line">        ans = (ans - <span class="number">1ll</span> * (r + l) % mod * (r - l + <span class="number">1</span>) % mod * inv2 % mod * <span class="built_in">S</span>(x / l)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    inv2 = quick\_pow(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    inv6 = quick\_pow(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> \_; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;\_);</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        ll n, a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">        ll ans = (<span class="built_in">S</span>(n) - <span class="number">1</span>) % mod;</span><br><span class="line">        ans = ans * inv2 % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans % mod + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT\_ACM\_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start\_clock\_for\_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end\_clock\_for\_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm\_local\_for\_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/09/hdu-6706/">https://blog.jujimeizuo.cn/2021/03/09/hdu-6706/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round</title>
      <link href="/2021/03/07/codeforces-round-705-div2-d-g/"/>
      <url>/2021/03/07/codeforces-round-705-div2-d-g/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1493/problem/D">https://codeforces.com/contest/1493/problem/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的序列，有q个操作，每次操作会将第i个数乘x，在输出gcd(所有数).</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为每次操作只对一个数操作，而不是区间修改，而且是不是求区间gcd。 即不需要用线段树求区间gcd，可以用可以动态开点维护每个质因子的min值。</p><p>$gcd&#x3D;p_1^{min(k_1,k_2…k_n)}…p_n^{min(k_1,k_2…k_n)}$</p><p>本篇题解是利用multiset维护每个质因子的min值。 因为multiset每次操作都是$\log n$，而且mtltiset内部都是有序的，可重复的，简直完美！</p><p>定义prime[i][j]表示第i个数字的质因子j的个数。 定义mt[i]表示质因子i的个数的有序序列。 所以当每个数字都有i这个因子时，即: $if(mt[i].size() &#x3D;&#x3D; n) \;*mt[i].begin()$即为质因子i的最小值贡献。</p><p>每次操作一次的时候，先对x质因子分解，然后对每个质因子操作，并维护mt[i]。</p><p>所以暴力模拟这个过程即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;i * j &lt; N; j++) &#123;</span><br><span class="line">                prime[i * j] = i;</span><br><span class="line">                is_prime[i * j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes[N];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            primes[i][prime[x]]++;</span><br><span class="line">            x /= prime[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : primes[i]) &#123;</span><br><span class="line">            mt[it.first].<span class="built_in">insert</span>(it.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mt[i].<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">            ans = ans * <span class="built_in">quick_pow</span>(i, *mt[i].<span class="built_in">begin</span>()) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="type">int</span> i, x; cin &gt;&gt; i &gt;&gt; x;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[prime[x]]++;</span><br><span class="line">            x /= prime[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(primes[i].<span class="built_in">find</span>(it.first) == primes[i].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                primes[i][it.first] = it.second;</span><br><span class="line">                mt[it.first].<span class="built_in">insert</span>(it.second);</span><br><span class="line">                <span class="keyword">if</span>(mt[it.first].<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">                    ans = ans * <span class="built_in">quick_pow</span>(it.first, *mt[it.first].<span class="built_in">begin</span>()) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> pre = primes[i][it.first];</span><br><span class="line">                <span class="type">int</span> cur = pre + it.second;</span><br><span class="line">                <span class="type">int</span> premin = *mt[it.first].<span class="built_in">begin</span>();</span><br><span class="line">                mt[it.first].<span class="built_in">erase</span>(mt[it.first].<span class="built_in">find</span>(pre));</span><br><span class="line">                mt[it.first].<span class="built_in">insert</span>(cur);</span><br><span class="line">                <span class="type">int</span> nowmin = *mt[it.first].<span class="built_in">begin</span>();</span><br><span class="line">                primes[i][it.first] = cur;</span><br><span class="line">                <span class="keyword">if</span>(mt[it.first].<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">                    ans = ans * <span class="built_in">quick_pow</span>(it.first, nowmin - premin) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/07/codeforces-round-705-div2-d-g/">https://blog.jujimeizuo.cn/2021/03/07/codeforces-round-705-div2-d-g/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年CCPC威海站 C. Rencontre 树形dp求块类任意两点距离和</title>
      <link href="/2021/03/06/2020-ccpc-weihai-c/"/>
      <url>/2021/03/06/2020-ccpc-weihai-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/gym/102798/problem/C">https://codeforces.ml/gym/102798/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，树上的点分为三种。 首先分别在三种点中随机选择一点a,b,c，然后找到一个合适的v，使得 $$f&#x3D;min(dis(a,v)+dis(b,v)+dis(c,v))$$</p><p>求出f的期望。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当a,b,c确定下来，那么v也会确定下来，因为min，所以我们围绕a,b,c展开。</p><p>数学上可以推出$min(dis(a,v)+dis(b,v)+dis(c,v))&#x3D;\frac{1}{2}(dis(a,b)+dis(b,c)+dis(c,a))$ 这样我们就不需要考虑v的存在，而怎么求dis呢？</p><p>显然dis中的点是在树上的，所以总贡献为 $$\frac{\sum_{x\in a}\sum_{y\in b}dis(x,y)}{ab}+\frac{\sum_{x\in c}\sum_{y\in b}dis(x,y)}{cb}+\frac{\sum_{x\in a}\sum_{y\in c}dis(x,y)}{ac}$$</p><p>a，b，c的个数输入的时候就知道了，那么就是求所有的dis，即树上任意两点距离和。</p><p>很多人都知道，树上任意两点之间距离就是dfs一遍树，对于一条边$ans+&#x3D;(n-siz[v])*siz[v]*w$</p><p>这里同如此，只不过是进化版，是要在三个块中选择不同点求任意距离和。 没关系，设siz[u][1&#x2F;2&#x2F;3]表示以u为根节点的子树中，1&#x2F;2&#x2F;3种类的点有多少个。</p><p>然后根据siz大小循环转移即可。</p><p>难点应该就是怎么在不同块中求贡献了。首先dfs1预处理出全部的siz，再dfs2对边求贡献。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; g[N];</span><br><span class="line">ll cnt[<span class="number">4</span>], siz[N][<span class="number">4</span>];;</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> v = e.v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            siz[u][i] += siz[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) &#123;</span><br><span class="line">        <span class="type">int</span> v = e.v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                ans += <span class="number">1.0</span> * ((siz[<span class="number">1</span>][i] - siz[v][i]) * siz[v][j] * <span class="number">1.0</span> * e.w / (cnt[i] * cnt[j]) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; ll w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(Edge&#123;v, w&#125;);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(Edge&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; cnt[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt[i]; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            siz[x][i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/06/2020-ccpc-weihai-c/">https://blog.jujimeizuo.cn/2021/03/06/2020-ccpc-weihai-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOJ 6053. 简单的函数 Min_25筛</title>
      <link href="/2021/03/05/loj-6053/"/>
      <url>/2021/03/05/loj-6053/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://loj.ac/p/6053">https://loj.ac/p/6053</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个神奇的函数f(x)，满足以下性质：</p><ul><li>$f(1)&#x3D;1$</li><li>$f(p^c)&#x3D;p \oplus c$</li><li>$f(ab)&#x3D;f(a)f(b)\;gcd(a,b)&#x3D;1的情况下$</li></ul><p>输出$\sum_{i&#x3D;1}^nf(i)\;mod\;1e9+7$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为n有1e10,所有用线性筛会T。 只能用亚线性筛，而f明显是一个积性函数，可以洲阁筛，当然，Min_25更完爆它。</p><p>那么怎么构造出一个Min_25筛呢？转移方程这么写？</p><p>观察$f(p^c)&#x3D;p \oplus c$,对于一个质数p:</p><ol><li>$if(p&#x3D;2) \;f(p)&#x3D;3$</li><li>$else\;f(p)&#x3D;p-1$</li></ol><p>所以我们要处理质数和，设$g1[j]&#x3D;\sum_{i&#x3D;2}^j1,g2[j]&#x3D;\sum_{i&#x3D;2}^ji.$ 不管第一个f(2)&#x3D;3，就统一认为f(p)&#x3D;p-1，最后如果有2的话，ans+2即可。</p><p>设prs[j]为前j个质数和，prz[j]为前j个质数个数。</p><p>g函数状态转移： $$g_1(j,n)&#x3D;g(j-1,n)-[g(j-1,\frac{n}{p_j})-prz[j-1]]$$</p><p>$$g_2(j,n)&#x3D;g(j-1,n)-pr[j]*(g[j-1,\frac{n}{p_j}]-prs[j-1])$$</p><p>S(x,y)的状态转移： $$S(x,y)&#x3D;\sum{g_t[id(x)]-sum_t[j-1]}+\sum_{kge y\;p_k^e\leq x}F(p_k^e)*S(\frac{x}{p_k^e},k+1)+F(p_k^{e+1})$$</p><p>$$S(x,y)&#x3D;\sum{g_t[id(x)]-sum_t[j-1]}+\sum_{kge y\;p_k^e\leq x}(p \oplus e)*S(\frac{x}{p_k^e},k+1)+p \oplus (e+1)$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">         a = a * a % mod;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Min_25 &#123;</span><br><span class="line">    <span class="type">int</span> is_pr[N], id1[N], id2[N], cnt;</span><br><span class="line">    ll n, m, T;</span><br><span class="line">    ll pr[N], prs[N], a[N], g1[N], g2[N];</span><br><span class="line"></span><br><span class="line">    ll inv2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc1</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x - <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc2</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % mod * (x + <span class="number">1</span>) % mod * inv2 % mod - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = m = <span class="number">0</span>;</span><br><span class="line">        inv2 = <span class="built_in">quick_pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">        T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!is_pr[i]) pr[++cnt] = i, prs[cnt] = (prs[cnt - <span class="number">1</span>] + i) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * pr[j] &lt;= T; j++) &#123;</span><br><span class="line">                is_pr[i * pr[j]] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ll l = <span class="number">1</span>;l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span>(a[m] &lt;= T) id1[a[m]] = m;</span><br><span class="line">            <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">            g1[m] = <span class="built_in">calc1</span>(a[m]);</span><br><span class="line">            g2[m] = <span class="built_in">calc2</span>(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m &amp;&amp; pr[i] * pr[i] &lt;= a[j]; j++) &#123;</span><br><span class="line">                g1[j] = (g1[j] - (g1[<span class="built_in">ID</span>(a[j] / pr[i])] - (i - <span class="number">1</span>))) % mod;</span><br><span class="line">                g2[j] = (g2[j] - pr[i] * (g2[<span class="built_in">ID</span>(a[j] / pr[i])] - prs[i - <span class="number">1</span>]) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">S</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>  x &lt; pr[y]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll ans = (g2[<span class="built_in">ID</span>(x)] - prs[y - <span class="number">1</span>] - (g1[<span class="built_in">ID</span>(x)] - (y - <span class="number">1</span>)) + (y == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">0</span>) + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = y;i &lt;= cnt &amp;&amp; pr[i] * pr[i] &lt;= x; i++) &#123;</span><br><span class="line">            ll pe = pr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> e = <span class="number">1</span>;pe * pr[i] &lt;= x; e++, pe *= pr[i]) &#123;</span><br><span class="line">                ans = (ans + (pr[i] ^ e) * <span class="built_in">S</span>(x / pe, i + <span class="number">1</span>) % mod + (pr[i] ^ e + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">Solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n = x, <span class="built_in">init</span>(), <span class="built_in">S</span>(n, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    ll ans = Min_25::<span class="built_in">Solve</span>(n);</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/05/loj-6053/">https://blog.jujimeizuo.cn/2021/03/05/loj-6053/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年ICPC 上海网络赛 E. Counting Sequences II 指数型生成函数</title>
      <link href="/2021/03/05/2019-icpc-online-shanghai-e-counting/"/>
      <url>/2021/03/05/2019-icpc-online-shanghai-e-counting/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://nanti.jisuanke.com/t/41413">https://nanti.jisuanke.com/t/41413</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>构造序列$a_1..a_n，a_i\in [1,m]$，保证偶数出现偶数次数。输出总方案数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑指数型生成函数。 我们知道对于一个数，出现次数可能为$e^x&#x3D;1+\frac{x}{1!}+\frac{2^2}{2!}+…$中的一个。</p><p>所以对于m中，设奇数有a个，偶数有b个，偶数保证出现偶数次，奇数无所谓。即：</p><p>$$f(x)&#x3D;(e^x)^a*(\frac{e^x+e^{-x}}{2})^b$$</p><p>二项式展开：</p><p>$$f(x)&#x3D;\frac{1}{2^b}*e^{ax}*\sum_{i&#x3D;0}^bC_b^ie^{xi}e^{-x(b-i)}$$</p><p>$$f(x)&#x3D;\frac{1}{2^b}*e^{(a-b)x}*\sum_{i&#x3D;0}^bC_b^ie^{2ix}$$</p><p>$$f(x)&#x3D;\frac{1}{2^b}*e^{(a-b)x}*\sum_{i&#x3D;0}^bC_b^i\sum_{j&#x3D;0}^{\infty}\frac{(2ix)^j}{j!}$$</p><p>因为序列有n个，所以取$x^n$的系数在完全排列即为ans。</p><p>$$ans&#x3D;\frac{1}{2^b}*e^{(a-b)x}*\sum_{i&#x3D;0}^bC_b^i\frac{(2i)^n}{n!}*n!$$</p><p>$$ans&#x3D;\frac{1}{2^b}*e^{(a-b)x}*\sum_{i&#x3D;0}^bC_b^i\frac{(2i)^n}{n!}*n!$$</p><ul><li>当m为偶数时，a&#x3D;b</li></ul><p>$$ans&#x3D;\frac{1}{2^b}*\sum_{i&#x3D;0}^bC_b^i(2i)^n$$</p><ul><li>当m为奇数时，a&#x3D;b+1</li></ul><p>$$ans&#x3D;\frac{1}{2^b}*\sum_{i&#x3D;0}^bC_b^i(2i+1)^n$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll F[N];</span><br><span class="line">ll invn[N];</span><br><span class="line">ll invF[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    F[<span class="number">0</span>] = F[<span class="number">1</span>] = invn[<span class="number">0</span>] = invn[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        invn[i] = mod - (mod / i) * invn[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * invn[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = F[m];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll b = m / <span class="number">2</span>;</span><br><span class="line">        ll ans = <span class="built_in">quick_pow</span>(<span class="built_in">quick_pow</span>(<span class="number">2</span>, b), mod - <span class="number">2</span>);</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= b; i++) &#123;</span><br><span class="line">            sum = (sum + <span class="built_in">C</span>(b, i) * <span class="built_in">quick_pow</span>(<span class="number">2</span> * i + (m &amp; <span class="number">1</span>), n) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * sum % mod;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/05/2019-icpc-online-shanghai-e-counting/">https://blog.jujimeizuo.cn/2021/03/05/2019-icpc-online-shanghai-e-counting/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min_25筛思想及例题集</title>
      <link href="/2021/03/05/min-25/"/>
      <url>/2021/03/05/min-25/</url>
      
        <content type="html"><![CDATA[<p>难得一批!!!</p><p>Min_25是针对积性函数f(i)求和问题，可处理范围可达到$n^{11}-n^{12}$。 所以复杂度是低于线性的。大概是$\frac{n^{\frac{3}{4}}}{\log \sqrt n}$。可以说是完爆洲阁筛甚至所有筛法。 但同时，虽然有这些优点，可理解起来相当不容易，所以很难。</p><p>粗略思路： 先将质数分为小于等于$\sqrt{n}$和大于$\sqrt{n}$两种。 再预处理所有质数函数的前缀和，利用小于等于 $\sqrt{n}$的质数进行转移，推出所有函数的和。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h4 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h4><p>问题：假设我们需要求出n以内所有质数和。</p><p>质数筛求出所有小于等于$\sqrt{n}$的质数，$p_i$表示第i个质数，一共有$p_0$个质数，ps为p的前缀和。</p><p>设函数$S(x,j)&#x3D;\sum_{i&#x3D;2}^xi*[i为质数或i的最小质因数大于p_j]$</p><p>$设Sum(n)&#x3D;\frac{n(n+1)}{2}-1.$</p><p>$显然对于任意x，S(x,0)&#x3D;Sum(x)-1，我们要求的ans&#x3D;S(x,p_0)$</p><p>考虑转移，如果$p_j^2&gt;x,S(x,j)&#x3D;S(x,j-1).$ 否则: $$S(x,j)&#x3D;S(x,j-1)-p_j*(S(\frac{x}{p_j},j-1)-ps_{j-1})$$</p><p>一直转移、递归，就可以得到$S(n,p_0).$</p><p>可以看出，这种筛法可以筛很多的积性函数，但应该不是所有积性函数都能筛吧？</p><h4 id="积性函数求和"><a href="#积性函数求和" class="headerlink" title="积性函数求和"></a>积性函数求和</h4><p>通过上面方法，可以求出很多积性函数f(x)，当x为质数时的和，现在要求： $$\sum_{i&#x3D;1}^nf(i)$$</p><p>考虑把上面的式子倒过来推，定义跟前面的一样：(可以用上面的S预处理$G(x,p_0))$ $设fs_x&#x3D;\sum_{i&#x3D;1}^xf(p_i)$</p><p>$$G(x,j)&#x3D;G(x,j+1)+\sum_{k&#x3D;1}(G(\frac{x}{p_j^k},j+1)-fs_j)*f(p_j^k)+\sum_{k&#x3D;2}f(p_j^k)$$</p><p>则ans&#x3D;G(n,0).</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>由于递归消耗的时间会过长，所以采用循环代替递归.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Min25 &#123;</span><br><span class="line">    <span class="type">int</span> prime[N], id1[N], id2[N], flag[N], ncnt, m;</span><br><span class="line"></span><br><span class="line">    ll g[N], sum[N], a[N], T, n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ncnt = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - <span class="number">1</span>] + i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= T; j++) &#123;</span><br><span class="line">                flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>; l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span> (a[m] &lt;= T) id1[a[m]] = m; <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">            g[m] = <span class="built_in">calc</span>(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; (ll)prime[i] * prime[i] &lt;= a[j]; j++)</span><br><span class="line">                g[j] = g[j] - (ll)prime[i] * (g[<span class="built_in">ID</span>(a[j] / prime[i])] - sum[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">Solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> n = x, <span class="built_in">init</span>(), g[<span class="built_in">ID</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>考虑一个递推公式g(j,n)，表示n以内筛过前j个质数的倍数的合数和。 $g(j,n)&#x3D;\sum_{i\epsilon f(i)最小质因子&gt;p_j}f(i)&#x3D;\sum_{i\epsilon f(i)最小质因子&gt;p_j}i^k$</p><p>状态转移：</p><p>$$g(j,n)&#x3D;g(j-1,n)-f(p_j)[g(j-1,\frac{n}{p_j})-\sum_{i&#x3D;1}^{j-1}f(p_i)]&#x3D;g(j-1,n)-p_j^k[g(j-1,\frac{n}{p_j})-\sum_{i&#x3D;1}^{j-1}p_i^k]$$</p><p>当$p_j^2&gt;n时，g(j,n)&#x3D;g(j-1,n)$，所以只需要计算出$\sqrt{n}$以内的素数。</p><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>预处理$id1[]，id2[]$和各种$\frac{n}{l}$的前缀和。</p><h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><p>设S(n,j)表示n以内所有最小质因子大于等于$p_j$的f(x)的和，即$S(n,j)&#x3D;\sum_{i&#x3D;1}^nF(i)[i最大质因子\ge p_j]$</p><p>状态转移：</p><p>$$S(n,j)&#x3D;\sum{g_t(id[n])-sum_t[j-1]}+\sum_{k\ge y\;p_k^{e+1}\leq n}F(p_k^e)*S(\frac{n}{p_k^e},k+1)+F(p_k^{e+1})$$</p><p>$sum_t(j-1)&#x3D;\sum_{i&#x3D;1}^{j-1}p_i^t$为前j-1个质数的t次幂之和. $\sum{g_t(id[n])-sum_t[j-1]}$为多个多项式加减运算凑成的多项式的质数和$\sum_{p\epsilon primes}F(x)[p&lt;P_j]$ 后面直接计算多项式函数$F(p_k^e),F(p_k^{e+1})$</p><p>递归完成即可。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h4 id="LOJ-6235-区间素数个数"><a href="#LOJ-6235-区间素数个数" class="headerlink" title="LOJ 6235. 区间素数个数"></a>LOJ 6235. 区间素数个数</h4><p>传送门：<a href="https://loj.ac/p/6235">https://loj.ac/p/6235</a></p><p>求解1-n之间所有素数个数</p><p>$$g(j,n)&#x3D;g(j-1,n)-f(p_j)[g(j-1,\frac{n}{p_j})-\sum_{i&#x3D;1}^{j-1}f(p_i)]&#x3D;g(j-1,n)-g(j-1,\frac{n}{p_j})-(j-1)$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Min_25 &#123;</span><br><span class="line">    <span class="type">int</span> is_pr[N], pr[N], prs[N], cnt, m;</span><br><span class="line">    ll n, T;</span><br><span class="line">    ll id1[N], id2[N], a[N], g[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = m = <span class="number">0</span>;</span><br><span class="line">        T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!is_pr[i]) pr[++cnt] = i, prs[cnt] = prs[cnt - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * pr[j] &lt;= T; j++) &#123;</span><br><span class="line">                is_pr[i * pr[j]] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ll l = <span class="number">1</span>;l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span>(a[m] &lt;= T) id1[a[m]] = m;</span><br><span class="line">            <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">            g[m] = <span class="built_in">calc</span>(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m &amp;&amp; (ll)pr[i] * pr[i] &lt;= a[j]; j++) &#123;</span><br><span class="line">                g[j] = g[j] - (g[<span class="built_in">ID</span>(a[j] / pr[i])] - prs[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">Solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> n = x, <span class="built_in">init</span>(), g[<span class="built_in">ID</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; Min_25::<span class="built_in">Solve</span>(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LOJ-6053-简单的函数"><a href="#LOJ-6053-简单的函数" class="headerlink" title="LOJ 6053. 简单的函数"></a>LOJ 6053. 简单的函数</h4><p>传送门：<a href="https://loj.ac/p/6053">https://loj.ac/p/6053</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">         a = a * a % mod;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Min_25 &#123;</span><br><span class="line">    <span class="type">int</span> is_pr[N], id1[N], id2[N], cnt;</span><br><span class="line">    ll n, m, T;</span><br><span class="line">    ll pr[N], prs[N], a[N], g1[N], g2[N];</span><br><span class="line"></span><br><span class="line">    ll inv2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">ID</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc1</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x - <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">calc2</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x % mod * (x + <span class="number">1</span>) % mod * inv2 % mod - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = m = <span class="number">0</span>;</span><br><span class="line">        inv2 = <span class="built_in">quick_pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">        T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!is_pr[i]) pr[++cnt] = i, prs[cnt] = (prs[cnt - <span class="number">1</span>] + i) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * pr[j] &lt;= T; j++) &#123;</span><br><span class="line">                is_pr[i * pr[j]] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ll l = <span class="number">1</span>;l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span>(a[m] &lt;= T) id1[a[m]] = m;</span><br><span class="line">            <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">            g1[m] = <span class="built_in">calc1</span>(a[m]);</span><br><span class="line">            g2[m] = <span class="built_in">calc2</span>(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m &amp;&amp; pr[i] * pr[i] &lt;= a[j]; j++) &#123;</span><br><span class="line">                g1[j] = (g1[j] - (g1[<span class="built_in">ID</span>(a[j] / pr[i])] - (i - <span class="number">1</span>))) % mod;</span><br><span class="line">                g2[j] = (g2[j] - pr[i] * (g2[<span class="built_in">ID</span>(a[j] / pr[i])] - prs[i - <span class="number">1</span>]) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">S</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>  x &lt; pr[y]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll ans = (g2[<span class="built_in">ID</span>(x)] - prs[y - <span class="number">1</span>] - (g1[<span class="built_in">ID</span>(x)] - (y - <span class="number">1</span>)) + (y == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">0</span>) + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = y;i &lt;= cnt &amp;&amp; pr[i] * pr[i] &lt;= x; i++) &#123;</span><br><span class="line">            ll pe = pr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> e = <span class="number">1</span>;pe * pr[i] &lt;= x; e++, pe *= pr[i]) &#123;</span><br><span class="line">                ans = (ans + (pr[i] ^ e) * <span class="built_in">S</span>(x / pe, i + <span class="number">1</span>) % mod + (pr[i] ^ e + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">Solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n = x, <span class="built_in">init</span>(), <span class="built_in">S</span>(n, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    ll ans = Min_25::<span class="built_in">Solve</span>(n);</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/05/min-25/">https://blog.jujimeizuo.cn/2021/03/05/min-25/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年ICPC南京网络赛E-K Sum 莫比乌斯反演+杜教筛+欧拉降幂</title>
      <link href="/2021/03/04/2019-icpc-online-nanjing-e/"/>
      <url>/2021/03/04/2019-icpc-online-nanjing-e/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$定义f_n(k)&#x3D;\sum_{l_1&#x3D;1}^n\sum_{l_2&#x3D;1}^n…\sum_{l_k&#x3D;1}^n[gcd(l_1,l_2,…,l_k)]^2$</p><p>$$求解\sum_{i&#x3D;2}^kf_{n(i)}$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$f_n(k)&#x3D;\sum_{l_1&#x3D;1}^n\sum_{l_2&#x3D;1}^n…\sum_{l_k&#x3D;1}^n[gcd(l_1,l_2,…,l_k)]^2$$</p><p>$$&#x3D;\sum_{t&#x3D;1}^n\sum_{l_1&#x3D;1}^n\sum_{l_2&#x3D;1}^n…\sum_{l_k&#x3D;1}^n[gcd(l_1,l_2,…,l_k)&#x3D;t]*t^2$$</p><p>$$&#x3D;\sum_{t&#x3D;1}^{n}t^2\sum_{l_1&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor }\sum_{l_2&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor }…\sum_{l_k&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor }[gcd(l_1,l_2,…,l_k)&#x3D;1]$$</p><p>$$&#x3D;\sum_{t&#x3D;1}^{n}t^2\sum_{l_1&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor }\sum_{l_2&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor }…\sum_{l_k&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor }\sum_{dl_1\;…dl_k}\mu(d)$$</p><p>$$&#x3D;\sum_{t&#x3D;1}^nt^2\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{t} \right \rfloor}\mu(d)*\left \lfloor \frac{n}{dt} \right \rfloor^k$$</p><p>$令T&#x3D;dt，则：$</p><p>$$f_n(k)&#x3D;\sum_{T&#x3D;1}^n\sum_{dT}\mu(d)\left \lfloor \frac{T}{d} \right \rfloor^2\left \lfloor \frac{n}{T} \right \rfloor^k$$</p><hr><p>$$\sum_{i&#x3D;2}^kf_n(i)&#x3D;\sum_{i&#x3D;2}^k\sum_{T&#x3D;1}^n\sum_{dT}\mu(d)\left \lfloor \frac{T}{d} \right \rfloor^2\left \lfloor \frac{n}{T} \right \rfloor^i$$</p><p>$$\sum_{T&#x3D;1}^n\sum_{dT}\mu(d)\left \lfloor \frac{T}{d} \right \rfloor^2\sum_{i&#x3D;2}^k\left \lfloor \frac{n}{T} \right \rfloor^i$$</p><p>$令h(x)&#x3D;\sum_{dx}\mu(d)\left \lfloor \frac{x}{d} \right \rfloor^2，设S(n)&#x3D;\sum_{i&#x3D;1}^nh(i)，用杜教筛求出h的前缀和。$</p><p>$根据杜教筛求前缀和公式：$</p><p>$$S(n)&#x3D;\frac{\sum_{i&#x3D;1}^n(f*g)i-\sum_{i&#x3D;2}^ng[i]S(\left \lfloor \frac{n}{i} \right \rfloor)}{g[1]}$$</p><p>$为了简便公式，设g&#x3D;I,则(h*g)i&#x3D;(I*\mu *id^2)i&#x3D;i^2$</p><p>$则$ $$S(n)&#x3D;\frac{n(n+1)(2n+1)}{6}-\sum_{i&#x3D;2}^nS(\left \lfloor \frac{n}{i} \right \rfloor)$$</p><p>$对于\sum_{i&#x3D;2}^k\left \lfloor \frac{n}{T} \right \rfloor^i，利用等比公式，p&#x3D;\left \lfloor \frac{n}{T} \right \rfloor.$</p><p>$$\sum_{i&#x3D;2}^k\left \lfloor \frac{n}{T} \right \rfloor^i&#x3D;\frac{(\frac{n}{T})^2*[1-(\frac{n}{T})^{k-1}]}{1-\frac{n}{T}}$$</p><p>$注意\frac{n}{T}&#x3D;1的情况，答案为k-1。$</p><p>$因为k很大，所以可以用欧拉降幂预先处理再作等比，再配合杜教筛求前缀和。$</p><p>$$\sum_{i&#x3D;2}^nf_n(i)&#x3D;\sum_{T&#x3D;1}^nh(i)*\frac{(\frac{n}{T})^2*[1-(\frac{n}{T})^{k-1}]}{1-\frac{n}{T}}$$</p><p>$总时间复杂度为O(T(n^{\frac{2}{3}}+\sqrt n\log n))$</p><h2 id="Code-MS"><a href="#Code-MS" class="headerlink" title="Code(MS)"></a>Code(MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line">ll h[N], s[N];</span><br><span class="line">ll inv6, k1, k2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">            h[i] = <span class="number">1ll</span> * i * i % mod - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                h[i * prime[j]] = h[i] * prime[j] % mod * prime[j] % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                h[i * prime[j]] = h[i] * h[prime[j]] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) s[i] = (s[i - <span class="number">1</span>] + h[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N) <span class="keyword">return</span> s[x];</span><br><span class="line">    <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll ans = x * (x + <span class="number">1</span>) % mod * (<span class="number">2</span> * x + <span class="number">1</span>) % mod * inv6 % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(x / (x / l), x);</span><br><span class="line">        ans = (ans - <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * <span class="built_in">S</span>(x / l) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = (ans % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Sum</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> k2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p * p % mod * (<span class="built_in">quick_pow</span>(p, k1 - <span class="number">1</span>) - <span class="number">1</span>) % mod * <span class="built_in">quick_pow</span>(p - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    inv6 = <span class="built_in">quick_pow</span>(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        k1 = k2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        string K; cin &gt;&gt; K;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; K.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            k1 = (k1 * <span class="number">10</span> + K[i] - <span class="string">&#x27;0&#x27;</span>) % (mod - <span class="number">1</span>);</span><br><span class="line">            k2 = (k2 * <span class="number">10</span> + K[i] - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        k1 += mod - <span class="number">1</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll pre = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r;l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = <span class="built_in">min</span>(n / (n / l), n);</span><br><span class="line">            now = <span class="built_in">S</span>(r);</span><br><span class="line">            ans = (ans + (now - pre + mod) % mod * <span class="built_in">Sum</span>(n / l) % mod) % mod;</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/04/2019-icpc-online-nanjing-e/">https://blog.jujimeizuo.cn/2021/03/04/2019-icpc-online-nanjing-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛32 F-Friendly Polynomial NTT+多项式求逆+组合计数</title>
      <link href="/2021/03/03/nowcoder-practice32-f/"/>
      <url>/2021/03/03/nowcoder-practice32-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/272/F">https://ac.nowcoder.com/acm/contest/272/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n，表示有1到n这些数，对于一个i，如果前i个是1到i的一个排列，则整个序列称为不合格序列。 求出所有不合格序列个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑把序列以i为界限拆成两半，设f_n为长度为n 的不合格序列个数，则：</p><ul><li>前i个是不合格序列，贡献为i!。</li><li>后n-i个不是不合格序列，贡献为$(n-i)!-f_{n-i}$</li></ul><p>则对于任意一个n来说， $$f_n&#x3D;\sum_{i&#x3D;1}^{n-1}i!*[(n-i)!-f_{n-i}]$$</p><p>$$f_n&#x3D;\sum_{i&#x3D;1}^{n-1}i!*(n-i)!-\sum_{i&#x3D;1}^{n-1}i!*f_{n-i}$$</p><p>设$g_n&#x3D;n!$，特别的，$g_0&#x3D;0!&#x3D;0$，则：</p><p>$$f&#x3D;g*g-g*f$$</p><p>$$f&#x3D;\frac{g*g}{1+g}$$</p><p>需要一个多项式求逆，多项式乘法，直接套即可。</p><p>因为我的板子都是任意模数MTT，所以直接省略NTT了，全是MTT。</p><h2 id="Code-1579MS"><a href="#Code-1579MS" class="headerlink" title="Code(1579MS)"></a>Code(1579MS)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">##include <span class="string">&quot;bits/stdc++.h&quot;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">##define endl <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">const <span class="type">ll</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">998244353</span>;</span><br><span class="line">const <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> acos(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">const <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">struct Complex &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    Complex(<span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>): x(a), y(b) &#123;&#125;</span><br><span class="line">    Complex operator + (const Complex &amp;rhs) &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex operator - (const Complex &amp;rhs) &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex operator * (const Complex &amp;rhs) &#123; <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); &#125;</span><br><span class="line">    Complex <span class="title function_">conj</span><span class="params">()</span> &#123; <span class="keyword">return</span> Complex(x, -y); &#125;</span><br><span class="line">&#125; w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line">ll f[N], g[N], invg[N], g2[N];</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">quick_pow</span><span class="params">(ll a, ll b)</span> &#123;</span><br><span class="line">    <span class="type">ll</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLen</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">while</span> (len &lt; (n &lt;&lt; <span class="number">1</span>)) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  (i &amp; <span class="number">1</span> ? len &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) w[i] = w[i] = Complex(cos(<span class="number">2</span> * PI * i / len), sin(<span class="number">2</span> * PI * i / len));</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">FFT</span><span class="params">(Complex *A, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span>(i &lt; tr[i]) swap(A[i], A[tr[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, lyc = len &gt;&gt; <span class="number">1</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>, lyc &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j += i) &#123;</span><br><span class="line">            Complex *l = A + j, *r = A + j + (i &gt;&gt; <span class="number">1</span>), *p = w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i &gt;&gt; <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="type">Complex</span> <span class="variable">tmp</span> <span class="operator">=</span> *r * *p;</span><br><span class="line">                *r = *l - tmp, *l = *l + tmp;</span><br><span class="line">                ++l, ++r, p += lyc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline <span class="keyword">void</span> <span class="title function_">MTT</span><span class="params">(ll *x, ll *y, ll *z, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  (i &amp; <span class="number">1</span> ? len &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) w[i] = w[i] = Complex(cos(<span class="number">2</span> * PI * i / len), sin(<span class="number">2</span> * PI * i / len));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;</span><br><span class="line">    <span class="keyword">static</span> Complex a[N], b[N];</span><br><span class="line">    <span class="keyword">static</span> Complex dfta[N], dftb[N], dftc[N], dftd[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) a[i] = Complex(x[i] &amp; <span class="number">32767</span>, x[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) b[i] = Complex(y[i] &amp; <span class="number">32767</span>, y[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    FFT(a, len), FFT(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (len - i) &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">static</span> Complex da, db, dc, dd;</span><br><span class="line">        da = (a[i] + a[j].conj()) * Complex(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        db = (a[i] - a[j].conj()) * Complex(<span class="number">0</span>, -<span class="number">0.5</span>);</span><br><span class="line">        dc = (b[i] + b[j].conj()) * Complex(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        dd = (b[i] - b[j].conj()) * Complex(<span class="number">0</span>, -<span class="number">0.5</span>);</span><br><span class="line">        dfta[j] = da * dc;</span><br><span class="line">        dftb[j] = da * dd;</span><br><span class="line">        dftc[j] = db * dc;</span><br><span class="line">        dftd[j] = db * dd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) a[i] = dfta[i] + dftb[i] * Complex(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) b[i] = dftc[i] + dftd[i] * Complex(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    FFT(a, len), FFT(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">da</span> <span class="operator">=</span> (ll)(a[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="type">int</span> <span class="variable">db</span> <span class="operator">=</span> (ll)(a[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dc</span> <span class="operator">=</span> (ll)(b[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dd</span> <span class="operator">=</span> (ll)(b[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        z[i] = (da + ((ll)(db + dc) &lt;&lt; <span class="number">15</span>) + ((ll)dd &lt;&lt; <span class="number">30</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Get_Inv</span><span class="params">(ll *f, ll *g, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123; g[<span class="number">0</span>] = quick_pow(f[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">    Get_Inv(f, g, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getLen(n);</span><br><span class="line">    <span class="keyword">static</span> ll c[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len; i++) c[i] = i &lt; n ? f[i] : <span class="number">0</span>;</span><br><span class="line">    MTT(c, g, c, len); MTT(c, g, c, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++) g[i] = (2ll * g[i] - c[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">1e5</span> + <span class="number">10</span>; i++) g2[i] = g[i] = g[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    Get_Inv(g, invg, <span class="number">1e5</span>);</span><br><span class="line">    g[<span class="number">0</span>] = g2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    MTT(g2, g, g2, <span class="number">1e5</span> + <span class="number">1e5</span>);</span><br><span class="line">    MTT(g2, invg, f, <span class="number">2e5</span> + <span class="number">1e5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed <span class="title function_">main</span><span class="params">()</span> &#123;(cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line">##<span class="keyword">else</span></span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/03/nowcoder-practice32-f/">https://blog.jujimeizuo.cn/2021/03/03/nowcoder-practice32-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat for mysql和IDEA连接mysql</title>
      <link href="/2021/03/02/navicat-for-mysql-and-idea-connect-mysql/"/>
      <url>/2021/03/02/navicat-for-mysql-and-idea-connect-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="Navicat-for-mysql连接mysql"><a href="#Navicat-for-mysql连接mysql" class="headerlink" title="Navicat for mysql连接mysql"></a>Navicat for mysql连接mysql</h2><p>点击连接，会显示：</p><p><img src="/images/2021/03/20210302163714633.png"></p><p>输入连接名，比如用阿里云服务器举例。 登录阿里云控制台，查看服务器ip地址。</p><p><img src="/images/2021/03/20210302163839369.png"></p><p>取前者。 然后输入你的mysql 的账号密码即可。</p><p><strong>注意！！</strong> 这个账号密码不是服务器的账号密码，是数据库的账号密码。</p><p>查看的话可以先进入服务器mysql，然后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><p>点击测试，通过测试后点击确定即可。</p><p>最后就可以查看数据库了。</p><h2 id="IDEA连接mysql"><a href="#IDEA连接mysql" class="headerlink" title="IDEA连接mysql"></a>IDEA连接mysql</h2><p>点击：</p><p><img src="/images/2021/03/20210302164422730.png"></p><p>同理上面，输入ip地址，账号密码。 注意，这里还需要输入Database。</p><p><img src="/images/2021/03/2021030216464056.png"></p><p>点击测试，通过测试后点击确定即可。</p><p>最后就可以查看数据库了。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/02/navicat-for-mysql-and-idea-connect-mysql/">https://blog.jujimeizuo.cn/2021/03/02/navicat-for-mysql-and-idea-connect-mysql/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> utils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 4006Travel along the Line 数学推导+组合</title>
      <link href="/2021/03/01/zoj-4006/"/>
      <url>/2021/03/01/zoj-4006/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370217">https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370217</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>起点在0点，有n步，每一步有$\frac{1}{4}$往左走、$\frac{1}{4}$往右走、$\frac{1}{2}$不动。 已知终点在点m，问所有方案到达m时$\frac{P}{Q}$是多少，请对1e9+7取模。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设往左走了x步，往右走了y步，z步不动，即可得： $x、-x+y&#x3D;m、x+y+z&#x3D;n$，得： $x&gt;&#x3D;0$ $y&#x3D;x+m\ge 0 \rightarrow x\ge -m$ $z&#x3D;n-x-y\ge 0 \rightarrow x\leq \frac{n-m}{2}$</p><p>所以x的范围为$[max(-m, 0),\frac{n-m}{2}]$</p><p>$对于每一个x的贡献为C_n^x(\frac{1}{4})^x*C_{n-x}^y(\frac{1}{4})^y*\frac{1}{2}^z，变量替换一下得：$ $$ans&#x3D;(\frac{1}{2})^{n+m}*\sum_{x&#x3D;max(-m,0)}^{\frac{n-m}{2}}C_n^xC_{n-x}^{x+m}(\frac{1}{4})^x$$</p><p>$算之前要判断x的范围是否错误即可。$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll f[N], inv[N], invF[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = mod - (mod / i) * inv[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = f[m];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    ll inv2 = <span class="built_in">quick_pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    ll inv4 = <span class="built_in">quick_pow</span>(<span class="number">4</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m) &gt; n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll xo = <span class="built_in">max</span>(-m, <span class="number">0ll</span>), xn = (n - m) / <span class="number">2</span>;</span><br><span class="line">        ll ans = <span class="built_in">quick_pow</span>(inv2, n + m);</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = xo;i &lt;= xn; i++) &#123;</span><br><span class="line">            res += <span class="built_in">quick_pow</span>(inv4, i) * <span class="built_in">C</span>(n, i) % mod * <span class="built_in">C</span>(n - i, m + i) % mod;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * res % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/01/zoj-4006/">https://blog.jujimeizuo.cn/2021/03/01/zoj-4006/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 13 D. Zookeeper and The Infinite Zoo 思维</title>
      <link href="/2021/03/01/codeforces-global-round-13-d/"/>
      <url>/2021/03/01/codeforces-global-round-13-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1491/problem/D">https://codeforces.com/contest/1491/problem/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给u和v，问u能不能到达v。 u能到达u+v的条件是$u\&amp;v&#x3D;v$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为u到u+v的条件是$u\&amp;v&#x3D;v$。$\&amp; $和二进制有关，所以比较u和v的二进制。</p><p>如果u&gt;v，那u绝对到不了v。 如果u&#x3D;&#x3D;v，emmm，不用动就能到达。</p><p>先给结论：计算u和v的二进制中1的个数，做一个前缀和，对于每一位必须a[i]&gt;&#x3D;b[i]能保证u到v。</p><p>$eg：对于3，(3)_2&#x3D;11，所以1，10，11，3可以到达3+1，3+2,3+3.$ $eg：对于6，(6)_2&#x3D;110，所以10，100，110，6可以到达6+2，6+4，6+6，而6到达不了111.$ $就是因为6的第一位是0，7的第一位是1，已经不能满足结论了。$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            a[i] = u &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">            b[i] = v &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">            b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u &gt; v) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(u == v) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt; b[i]) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/01/codeforces-global-round-13-d/">https://blog.jujimeizuo.cn/2021/03/01/codeforces-global-round-13-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Global Round 13 C. Pekora and Trampoline 贪心</title>
      <link href="/2021/03/01/codeforces-global-round-13-c/"/>
      <url>/2021/03/01/codeforces-global-round-13-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/contest/1491/problem/C">https://codeforces.ml/contest/1491/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个数组a，可以从任意地方开始跳。假如在第i个开始跳，那么跳到下一个的位置是I+a[i]，并且当前位置a[i]–，跳到超过n为止，这算一个操作数。问，当操作数为多少时，可以使数组全部变成1，求出最少的操作数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比赛的时候知道是贪心，但是不会贪，只能暴力模拟$n^3$，n虽然只有5000，但也会T。 而贪心的话是$n^2$，复杂度是够的。</p><p>考虑每一次都从第一个走，这无所谓，如果前面全是1，那么会直到第一个不为1的位置开始跳。</p><p>所以从前往后遍历，考虑当前第i位，有多少是要我们操作的，有多少是从之前的操作跳过来的 所以这些不对答案做贡献。</p><p>假设第i个，那么他会跳到[i+2,i+a[i]]，这些个位置都可以通过i跳到， 而第i+1个位置是必然跳到的，并且第i个位置可以从之前操作中跳过来，那么第i+1位置也是可以从之前操作跳过来。</p><p>所以需要一个数组b来记录，第i个位置有多少是从前面位置跳过来的，这些不对答案做贡献。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span> (_--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll a[n + <span class="number">10</span>], b[n + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">mem</span>(b, <span class="number">0</span>);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            ll temp = b[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; temp + <span class="number">1</span>) &#123;</span><br><span class="line">                ans += a[i] - temp - <span class="number">1</span>;</span><br><span class="line">                temp += a[i] - temp - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b[i + <span class="number">1</span>] += temp - a[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n) <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">2</span>;j &lt;= <span class="built_in">min</span>(<span class="number">1ll</span>* n, i + a[i]); j++) b[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/03/01/codeforces-global-round-13-c/">https://blog.jujimeizuo.cn/2021/03/01/codeforces-global-round-13-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛77 D-小G的LY数对 思维+Hash</title>
      <link href="/2021/02/27/nowcoder-practice77-d/"/>
      <url>/2021/02/27/nowcoder-practice77-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/11160/D">https://ac.nowcoder.com/acm/contest/11160/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>小G定义LY数对为两个数x，y在二进制的异或操作后恰好有两位是1 小G现在有两个数组a,b长度分别为n,m 现在小G想知道有多少对i,j满足 (1&lt;&#x3D;i&lt;&#x3D;n,1&lt;&#x3D;j&lt;&#x3D;m)满足a[i]和b[j]是LY数对</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果是暴力枚举a[i]的同时暴力枚举两个位置上的数，复杂度为$O(30^2n)$。 必然会T，怎么办能把其中一个30变小呢？直到复杂度在$O(1e8)$之内？</p><p>我们知道题目的意思是$x \bigoplus y&#x3D;两位2次方数相加&#x3D;(1&lt;&lt;i)\bigoplus (1&lt;&lt;j).(i!&#x3D;j)$</p><p>$转化为x\bigoplus (1&lt;&lt;i)&#x3D;y\bigoplus (1&lt;&lt;j).(i!&#x3D;j)$ $转化为x\bigoplus (1&lt;&lt;j)&#x3D;y\bigoplus (1&lt;&lt;i).(i!&#x3D;j)$</p><p>所以我们可以通过这个。 枚举i，Hash保存所有的$a_x\bigoplus (1&lt;&lt;i).$ 枚举j所有的$b_y\bigoplus (1&lt;&lt;j)$，查找是否有和它相等的数，ans+个数。</p><p>可是我们之前说过i!&#x3D;j，所以要提前减掉这个i&#x3D;&#x3D;j的情况。 i&#x3D;&#x3D;j必然x&#x3D;&#x3D;y，所以减掉x&#x3D;&#x3D;y的数量即可。</p><p>总时间复杂度为$O(30n*C)$,C是一个小于30的常数。</p><h2 id="Code（690MS）"><a href="#Code（690MS）" class="headerlink" title="Code（690MS）"></a>Code（690MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next, w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> u = x % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].v == x) &#123;</span><br><span class="line">            e[i].w++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e[cnt] = Hash&#123;x, head[u], <span class="number">1</span>&#125;;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> u = x % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].v == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(head, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i], mp[a[i]]++;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        res += mp[b[i]] * <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">30</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">Insert</span>(a[i] ^ (<span class="number">1ll</span> &lt;&lt; k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">30</span>; k++) &#123;</span><br><span class="line">            ans += <span class="built_in">get</span>(b[i] ^ (<span class="number">1ll</span> &lt;&lt; k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans - res) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/27/nowcoder-practice77-d/">https://blog.jujimeizuo.cn/2021/02/27/nowcoder-practice77-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第六场】H-动态最小生成树 线段树优化Kruskal</title>
      <link href="/2021/02/24/2021-nowcoder-hanjia-6-h/"/>
      <url>/2021/02/24/2021-nowcoder-hanjia-6-h/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9986/H">https://ac.nowcoder.com/acm/contest/9986/H</a> 这一题大部分人都是暴力Kruskal冲过去的，额，应该是全部，但这显然不是最优解。</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题意就像题目一样，动态修改和查找最小生成树。 两个操作：</p><ul><li>修改第x条边的连接点和边权</li><li>查询[l,r]所在边组成的最小生成树大小，有则输出，没有输出impossible</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到最小生成树，就知道可以用Kruskal求解。 修改还是修改，不过查询的时候就要用一次Kruskal，遇到及其恶心的数据铁T。 因为Kruskal的复杂度是和边数m有关的。</p><p>看到n只有200，m有30000，所以能不能把复杂度往n上靠？答案是可以的。</p><p>区间问题？线段树!</p><p>线段树维护什么呢？针对每一个节点，我们维护一个数组，这个数组里保存的是生成树的边的集合。</p><p>所以我们建树是build(1,1,m)，根据边建树，而不是点。</p><p>每次更新的时候都要重新组织最小生成树并保存，就是代码中的$push_up$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc t[u].l</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc t[u].r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">505</span>];</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>, z = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) f[i] = i, t[s].a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((t[u].a[x]  t[v].a[y]) &amp;&amp; z &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[t[u].a[x]].w &lt; e[t[v].a[y]].w) &#123;</span><br><span class="line">            <span class="type">int</span> U = <span class="built_in">find</span>(e[t[u].a[x]].u);</span><br><span class="line">            <span class="type">int</span> V = <span class="built_in">find</span>(e[t[u].a[x]].v);</span><br><span class="line">            <span class="keyword">if</span>(U != V) &#123;</span><br><span class="line">                f[U] = V;</span><br><span class="line">                t[s].a[z++] = t[u].a[x];</span><br><span class="line">            &#125;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> U = <span class="built_in">find</span>(e[t[v].a[y]].u);</span><br><span class="line">            <span class="type">int</span> V = <span class="built_in">find</span>(e[t[v].a[y]].v);</span><br><span class="line">            <span class="keyword">if</span>(U != V) &#123;</span><br><span class="line">                f[U] = V;</span><br><span class="line">                t[s].a[z++] = t[v].a[y];</span><br><span class="line">            &#125;</span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].a[<span class="number">1</span>] = l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    t[u].l = ++tot; t[u].r = ++tot;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u, lc, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">modify</span>(lc, l, mid, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rc, mid + <span class="number">1</span>, r, p);</span><br><span class="line">    <span class="built_in">push_up</span>(u, lc, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        <span class="built_in">push_up</span>(tot + <span class="number">2</span>, tot + <span class="number">1</span>, u);</span><br><span class="line">        <span class="built_in">memcpy</span>(t[tot + <span class="number">1</span>].a, t[tot + <span class="number">2</span>].a, <span class="number">4</span> * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">query</span>(lc, l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">query</span>(rc, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    e[<span class="number">0</span>].w = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="type">int</span> opt; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y, z, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z,&amp;w);</span><br><span class="line">            e[x].u = y; e[x].v = z; e[x].w = w;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, m, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">                t[tot + <span class="number">2</span>].a[i] = t[tot + <span class="number">1</span>].a[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, m, l, r);</span><br><span class="line">            <span class="keyword">if</span>(!t[tot + <span class="number">1</span>].a[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) ans += e[t[tot + <span class="number">1</span>].a[i]].w;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;../out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/24/2021-nowcoder-hanjia-6-h/">https://blog.jujimeizuo.cn/2021/02/24/2021-nowcoder-hanjia-6-h/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第六场】F-组合数问题 二项式定理</title>
      <link href="/2021/02/24/2021-nowcoder-hanjia-6-f/"/>
      <url>/2021/02/24/2021-nowcoder-hanjia-6-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9986/F">https://ac.nowcoder.com/acm/contest/9986/F</a> 这一题其实很难的，不过过了那么多人就离谱，估计大部分都是OEIS的吧。</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$输出C_n^0+C_n^4+C_n^8+…+C_n^n\;\;(4｜n)$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$我们知道$ $(1+1)^n&#x3D;C_n^0+C_n^1+…+C_n^n&#x3D;2^n$ $(1-1)^n&#x3D;C_n^0-C_n^1+…+C_n^n&#x3D;0$</p><p>$两式相加除2得：$ $2^{n-1}&#x3D;C_n^0+C_n^2+…+C_n^n$</p><p>$这是2的倍数，但是题目要求的是4的倍数，那该怎么办呢？$ $我们可不可以通过上面的方法凑出来呢？答案是可以的，考虑虚数i。$</p><p>$把其中一个1换成i之后，我们在二项式展开看看：$ $(1+i)^n&#x3D;C_n^0+iC_{n}^1-C_n^2-…+C_n^n$ $(1-i)^n&#x3D;C_n^0-iC_n^1-C_n^2-….+C_n^n$</p><p>$两式相加除2得$ $(1+i)^n+(1-i)^n&#x3D;C_n^0-C_n^2+C_n^4-…+C_n^n$</p><p>$而虚数我们知道，在次幂的情况下都是有循环节的，比如这里就是4个一循环.$</p><p>$所以(1+i)^4&#x3D;(1-i)^4&#x3D;-4$ $所以(1+i)^{4n}&#x3D;(-4)^{n}$</p><p>$即(-4)^{\frac{n}{4}}&#x3D;C_n^0-C_n^2+C_n^4-…+C_n^n$</p><p>$结合两式相加除2即可得：$</p><p>$2^{n-2}+\frac{1}{2}(-4)^{\frac{n}{4}}&#x3D;C_n^0+C_n^4+C_n^8+…+C_n^n$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; (((<span class="built_in">quick_pow</span>(<span class="number">2</span>, n - <span class="number">2</span>) % mod + <span class="built_in">quick_pow</span>(<span class="number">-4</span>, n / <span class="number">4</span>) * <span class="built_in">quick_pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>) % mod) % mod + mod) % mod) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/24/2021-nowcoder-hanjia-6-f/">https://blog.jujimeizuo.cn/2021/02/24/2021-nowcoder-hanjia-6-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第六场】B-系数 傻逼题</title>
      <link href="/2021/02/24/2021-nowcoder-hanjia-6-b/"/>
      <url>/2021/02/24/2021-nowcoder-hanjia-6-b/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9986/B">https://ac.nowcoder.com/acm/contest/9986/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$输出(x^2+x+1)^n的第k项\%3。$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到数据范围就知道，每次查询必须O(1)或者O(logn)，直接就想到了Lucas。</p><p>但是赛中的时候想的思路特别麻烦，想了我将近3个小时，一直以为是找规律题，赛后突发奇想，真就傻逼题。</p><p>因为是\%3，所以次幂里面可以+3x的任意倍数而保持不变，即</p><p>$$(x^2+x+1)^n&#x3D;(x^2-2x+1)^n&#x3D;(x-1)^{2n}$$</p><p>所以第k项系数为$C_{2n}^kx^k(-1)^{2n-k}$。</p><p>因为n和k都很大，所以要用Lucas优化一下。</p><p>总时间复杂度为$O(N+T\log n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll p = <span class="number">3</span>; <span class="comment">// C(n,m) % p</span></span><br><span class="line"></span><br><span class="line">ll f[N], inv[N], invF[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= p; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % p;</span><br><span class="line">        inv[i] = p - (p / i) * inv[p % i] % p;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * inv[i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = f[m];</span><br><span class="line">    ans = ans * invF[n] % p;</span><br><span class="line">    ans = ans * invF[m - n] % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n ? <span class="built_in">Lucas</span>(m / p, n / p) * <span class="built_in">C</span>(m % p, n % p) % p : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        k = <span class="built_in">min</span>(k, <span class="number">2</span> * n - k);</span><br><span class="line">        ans = <span class="built_in">Lucas</span>(<span class="number">2</span> * n, k);</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * n - k) &amp; <span class="number">1</span>) ans = -ans;</span><br><span class="line">        cout &lt;&lt; (ans % <span class="number">3</span> + <span class="number">3</span>) % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/24/2021-nowcoder-hanjia-6-b/">https://blog.jujimeizuo.cn/2021/02/24/2021-nowcoder-hanjia-6-b/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年浙江省赛 队内总结+题目分析</title>
      <link href="/2021/02/22/2019-zhejiang-competition/"/>
      <url>/2021/02/22/2019-zhejiang-competition/</url>
      
        <content type="html"><![CDATA[<p>4个小时A了8题。不得不说，模拟赛的神，现场赛的狗。 不到2小时A了5题简单题，后1个小时A了2道题，字符串和图论，最后A了一道题，数学题。</p><p>总体来看，8题是稳拿银牌的，不过考虑到现场赛降智，所以最差铜牌还是有的。 4个小时下来，前7题都很顺利，第8题有点困难，因为队内只有我一个负责数学，其他两个就等我ac，不过最后还是a掉了，估计wa了将近5、6发？</p><p>下面按照A题顺序来重温一下。</p><h2 id="Lucky-7-in-the-Pocket"><a href="#Lucky-7-in-the-Pocket" class="headerlink" title="Lucky 7 in the Pocket"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370501">Lucky 7 in the Pocket</a></h2><p>从n往上继续找第一个能被7整除不能被4整除的数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> \_; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;\_);</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; ;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Abbreviation"><a href="#Abbreviation" class="headerlink" title="Abbreviation"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370500">Abbreviation</a></h2><p>输出删掉除了第一个字符以为的a,e,i,o,u,y的字符串。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> \_; cin &gt;&gt; \_;</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        string s;cin &gt;&gt; s;</span><br><span class="line">        string t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; (<span class="type">int</span>)s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; (s[i] == <span class="string">&#x27;a&#x27;</span>  s[i] == <span class="string">&#x27;e&#x27;</span>  s[i] == <span class="string">&#x27;i&#x27;</span>  s[i] == <span class="string">&#x27;o&#x27;</span>  s[i] == <span class="string">&#x27;u&#x27;</span>  s[i] == <span class="string">&#x27;y&#x27;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            t += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fibonacci-in-the-Pocket"><a href="#Fibonacci-in-the-Pocket" class="headerlink" title="Fibonacci in the Pocket"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370503">Fibonacci in the Pocket</a></h2><p>判断$\sum_{i&#x3D;l}^rf(i)$的奇偶性。 因为斐波那契数列都是两个奇数，然后一个偶数。</p><p>所以考虑n%3的余数。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> \_; cin &gt;&gt; \_;</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.<span class="built_in">length</span>(); i++) len1 += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; b.<span class="built_in">length</span>(); i++) len2 += b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(len1 % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; (len2 % <span class="number">3</span> == <span class="number">2</span>  len2 % <span class="number">3</span> == <span class="number">0</span>)) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len1 % <span class="number">3</span> == <span class="number">1</span> &amp;&amp; (len2 % <span class="number">3</span> == <span class="number">2</span>  len2 % <span class="number">3</span> == <span class="number">0</span>)) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len1 % <span class="number">3</span> == <span class="number">2</span> &amp;&amp; len2 % <span class="number">3</span> == <span class="number">1</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Singing-Everywhere"><a href="#Singing-Everywhere" class="headerlink" title="Singing Everywhere"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370502">Singing Everywhere</a></h2><p>考虑删掉每个数之后对波峰的影响。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> \_;</span><br><span class="line">    cin &gt;&gt; \_;</span><br><span class="line">    <span class="keyword">while</span> (\_--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">2</span> &amp;&amp; (a[i - <span class="number">1</span>] &gt; a[i] &amp;&amp; a[i - <span class="number">1</span>] &gt; a[i - <span class="number">2</span>]) &amp;&amp; !(a[i - <span class="number">1</span>] &gt; a[i - <span class="number">2</span>] &amp;&amp; a[i - <span class="number">1</span>] &gt; a[i + <span class="number">1</span>]))</span><br><span class="line">                k++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">2</span> &amp;&amp; !(a[i - <span class="number">1</span>] &gt; a[i] &amp;&amp; a[i - <span class="number">1</span>] &gt; a[i - <span class="number">2</span>]) &amp;&amp; (a[i - <span class="number">1</span>] &gt; a[i - <span class="number">2</span>] &amp;&amp; a[i - <span class="number">1</span>] &gt; a[i + <span class="number">1</span>]))</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &lt;= n &amp;&amp; (a[i + <span class="number">1</span>] &gt; a[i] &amp;&amp; a[i + <span class="number">1</span>] &gt; a[i + <span class="number">2</span>]) &amp;&amp; !(a[i + <span class="number">1</span>] &gt; a[i - <span class="number">1</span>] &amp;&amp; a[i + <span class="number">1</span>] &gt; a[i + <span class="number">2</span>]))</span><br><span class="line">                k++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n &amp;&amp; !(a[i + <span class="number">1</span>] &gt; a[i] &amp;&amp; a[i + <span class="number">1</span>] &gt; a[i + <span class="number">2</span>]) &amp;&amp; (a[i + <span class="number">1</span>] &gt; a[i - <span class="number">1</span>] &amp;&amp; a[i + <span class="number">1</span>] &gt; a[i + <span class="number">2</span>]))</span><br><span class="line">                k--;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>] &amp;&amp; a[i] &gt; a[i + <span class="number">1</span>]) k++, t++;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, k);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; t - ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sequence-in-the-Pocket"><a href="#Sequence-in-the-Pocket" class="headerlink" title="Sequence in the Pocket"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370499">Sequence in the Pocket</a></h2><p>排序完数组后，比较每个数的相对位置。 要从后往前比较，这样前面不会对后面产生影响。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> \_; cin &gt;&gt; \_;</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span>, <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; v[i]; a[i] = v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == v[i + ans]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Welcome-Party"><a href="#Welcome-Party" class="headerlink" title="Welcome Party"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370504">Welcome Party</a></h2><p>队友写的。 应该拓扑排序？</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> MAXN 2500000<span class="comment">//点数</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> MAXM 20000000</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> search(i,y) for(int i = head[y];i;i=edge[i].next)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> add(u,v,c) &#123;edge[++cnt]=&#123;u,v,c,head[u]&#125;;head[u]=cnt;&#125;</span></span><br><span class="line"><span class="type">int</span> head[MAXN],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,c;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="type">int</span> used[MAXN];</span><br><span class="line"><span class="type">int</span> used2[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tot);</span><br><span class="line">    <span class="keyword">while</span>(tot--)&#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            used[i] = head[i]=used2[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a,b,<span class="number">1</span>);<span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        priority\_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; que2;</span><br><span class="line">        <span class="type">int</span> unhappy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> tt = <span class="number">1</span>;tt&lt;=n;tt++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[tt])&#123;</span><br><span class="line">                unhappy++;</span><br><span class="line">                used[tt] = <span class="literal">true</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(tt);que2.<span class="built_in">push</span>(tt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">search</span>(i,x)&#123;</span><br><span class="line">                    <span class="type">int</span> y = edge[i].v;</span><br><span class="line">                    <span class="keyword">if</span>(used[y])<span class="keyword">continue</span>;</span><br><span class="line">                    used[y] = <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x = que2.<span class="built_in">top</span>();</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">            ans.push\_back(x);</span><br><span class="line">            used2[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">search</span>(i,x)&#123;</span><br><span class="line">                <span class="type">int</span> y = edge[i].v;</span><br><span class="line">                <span class="keyword">if</span>(used2[y])<span class="keyword">continue</span>;</span><br><span class="line">                used2[y] = <span class="literal">true</span>;</span><br><span class="line">                que2.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,unhappy);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i  = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Strings-in-the-Pocket"><a href="#Strings-in-the-Pocket" class="headerlink" title="Strings in the Pocket"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370505">Strings in the Pocket</a></h2><p>队友写的。 马拉车。</p><h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"><span class="type">char</span> t[maxn];</span><br><span class="line"><span class="type">char</span> str[<span class="number">2</span>*maxn];</span><br><span class="line">ll len1,len2,p[maxn],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">//把原数组进行处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str[<span class="number">0</span>]=<span class="string">&#x27;$&#x27;</span>; <span class="comment">//字符串开头加上特殊字符</span></span><br><span class="line">    str[<span class="number">1</span>]=<span class="string">&#x27;##&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i*<span class="number">2</span>+<span class="number">2</span>]=s[i];</span><br><span class="line">        str[i*<span class="number">2</span>+<span class="number">3</span>]=<span class="string">&#x27;##&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len2=len1*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    str[len2]=<span class="string">&#x27;##&#x27;</span>;  <span class="comment">//字符串末尾也加上特殊字符（和开头不同的）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">manacher</span><span class="params">()</span>  <span class="comment">//正片开始，马拉车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll id=<span class="number">0</span>,mx=<span class="number">0</span>; <span class="comment">//id表示回文子串的中心位置，mx表示回文子串的末尾位置。</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)</span><br><span class="line">            p[i]=<span class="built_in">min</span>(p[<span class="number">2</span>*id-i],mx-i); <span class="comment">//这一步是马拉车的关键部分，后面我在重点讲解。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; str[i+p[i]]==str[i-p[i]]; p[i]++); <span class="comment">//向两边扩展，匹配。</span></span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx=p[i]+i;</span><br><span class="line">            id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len2;i++)</span><br><span class="line">        ans+=p[i]/<span class="number">2LL</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">reverse</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l,j=r;i&lt;=r;i++,j--)</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=t[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Case=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Case);</span><br><span class="line">    <span class="keyword">while</span>(Case--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,t);</span><br><span class="line">        ll l=<span class="number">-1</span>;</span><br><span class="line">        ll r=<span class="number">-1</span>;</span><br><span class="line">        ll flag=<span class="number">0</span>;</span><br><span class="line">        len1=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]!=t[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (l==<span class="number">-1</span>)</span><br><span class="line">                    l=i;</span><br><span class="line">                r=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">reverse</span>(l,r))&#123;</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (ll i = r+<span class="number">1</span>,j=l<span class="number">-1</span>; i &lt;len1,j&gt;=<span class="number">0</span>; i++,j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                        ans++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans=<span class="built_in">manacher</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Element-Swapping"><a href="#Element-Swapping" class="headerlink" title="Element Swapping"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827370496">Element Swapping</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$原序列a_{1},a_2..a_n$ $x&#x3D;\sum_{i&#x3D;1}^ni*a_i$ $y&#x3D;\sum_{i&#x3D;1}^ni*a_i^2$</p><p>$题目给的是b序列，这两个序列的差别就是b序列是a序列的基础上两个位置交换了。$</p><p>$最后问能有多少对交换了位置？$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$设Bx&#x3D;1*b_1+2*b_2+…i*b_i+…+j*b_j+…+n*b_n$ $假设i和j交换了，则$ $x&#x3D;1*b_1+…+i*b_j+…+j*b_i+…+n*b_n$ $则Bx-x&#x3D;i*b_i+j*b_j-i*b_j-j*b_i&#x3D;(j-i)*(b_j-b_i)$</p><p>$同理，设By&#x3D;…$ $则By-y&#x3D;(j-i)*(b_j^2-b_i^2)&#x3D;(j-i)*(b_j-b_i)*(b_j+b_i)$</p><p>$我们发现(Bx-x)*(b_i+b_j)&#x3D;(B_y-y)，除了i和j上的数字我们不知道以为，其他都能算出来。$</p><p>$所以(b_i+b_j)是一个定值。$</p><p>$所以有以下几种情况：$</p><ul><li>$if\;Bx-x&#x3D;0\&amp;\&amp;By-y&#x3D;0，ans&#x3D;0$</li><li>$if\;Bx-x&#x3D;0\&amp;\&amp;By-y!&#x3D;0，ans&#x3D;C_{每种数字的个数}^2$</li><li>$if\;(By-y)\%(Bx-x)!&#x3D;0 (By-y)&#x2F;(Bx-x) &lt;&#x3D;0，ans&#x3D;0$</li><li>$else$ $else就是我们最麻烦处理的了。$ $我们知道(b_j+b_i)是一个定值，所以枚举b_i，根据上面几个等式可以算出j，判断b_j&#x3D;b[j]$ $前面是算出来的，后面j是算出来的，b[j]就是题目给的序列。$</li></ul><p>$那么j怎么算呢？$</p><p>$Bx-x&#x3D;(j-i)(b_j-b_i)$</p><p>$枚举b_i，算出b_j，j&#x3D;\frac{Bx-x}{b_j-b_i}+i$ $这题细节很多，要判断b_j-b_i是否&#x3D;0？j是否&gt;i\&amp;\&amp;j&lt;&#x3D;n。$</p><p>$如果一切成立的话，ans++。$</p><p>$最后输出ans。$</p><p>$如果暴力O(n^2)铁T，而这个方法就是O(n)。$</p><h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span> (_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; ll x, y; <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>,&amp;n,&amp;x,&amp;y);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        ll Bx = <span class="number">0</span>, By = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">            mp[b[i]]++;</span><br><span class="line">            Bx += <span class="number">1ll</span> * i * b[i];</span><br><span class="line">            By += <span class="number">1ll</span> * i * b[i] * b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Bx == x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(By - y != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> i : mp) &#123;</span><br><span class="line">                    ans += <span class="number">1ll</span> * i.second * (i.second - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Bx == x  By == y) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ll tmp = (By - y) / (Bx - x);</span><br><span class="line">            <span class="keyword">if</span>((tmp * (Bx - x) == By - y) &amp;&amp; tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ll ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">                    ll aj = tmp - b[i];</span><br><span class="line">                    <span class="keyword">if</span>(aj &lt;= <span class="number">0</span>  (aj - b[i]) == <span class="number">0</span>  (Bx - x) % (b[i] - aj) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    ll j = (Bx - x) / (aj - b[i]) + i;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt;= i  j &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(b[j] == aj) ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/22/2019-zhejiang-competition/">https://blog.jujimeizuo.cn/2021/02/22/2019-zhejiang-competition/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第五场】C-比武招亲（下）欧拉降幂+多项式求逆预处理伯努利数计算等幂求和</title>
      <link href="/2021/02/22/2021-nowcoder-hanjia-5-c/"/>
      <url>/2021/02/22/2021-nowcoder-hanjia-5-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9985/C">https://ac.nowcoder.com/acm/contest/9985/C</a></p><p>这应该是我打的最好的一场了。</p><p><img src="/images/2021/03/2021022218215161.png"></p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><p>欧拉降幂、多项式求逆、伯努利数、等幂求和}</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的序列，往里面填数字，数字范围为[1,m]，可以重复填。</p><p>$m&#x3D;n^{n^{n^{..}}}$</p><p>请计算所有序列贡献和ans \% p，p一定是一个质数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到$m&#x3D;n^{n^{n^{..}}}$这个式子，很多人就知道模p之后是一个定值，根据欧拉降幂。 具体请看<a href="https://blog.csdn.net/qq_37632935/article/details/81264965">欧拉降幂</a>。</p><p>好，我们算出来m之后，到这里还是非常简单的，难点在后面。</p><p>因为n和m我们都知道，为了方便起来，我们把n和m互换一下。 n表示可以用的数字，m表示位置个数。</p><p>我们还像B题一样，计算每一个最大值的贡献值。</p><p>假设最大值为x，则剩下m-1个位置填的数不能超过x，那么这么的序列一共有 $$x^m-(x-1)^m$$ 就是存在x数字的减掉不存在x数字的个数，并且一定有x。</p><p>有人问，为什么不是$m*x^m$，因为序列中是有可重复数字的。 比如m&#x3D;3,x&#x3D;2，剩下为2和1，把x放在第一个得$2\;2\;1$，放在第二个得$2\;2\;1$。这是不对的。</p><p>但是比赛中我没有直接看出来，还是用二项式定理推出来，好菜！</p><p>根据计算出来的贡献，得到最终公式:</p><p>$$\sum_{i&#x3D;1}^ni*[i^m-(i-1)^m]\;mod\;p$$</p><p>由于n是我们欧拉降幂求出来的，最大也会有$1e9$这么多，所以O(n)肯定是不行的。</p><p>那该怎么办呢？这就是这题最难的地方了，伯努利数就诞生了。 <a href="https://oi-wiki.org/math/bernoulli/">https://oi-wiki.org/math/bernoulli/</a></p><p>因为伯努利数一大应用就是等幂求和。</p><p>根据OI-Wiki上介绍，暴力求复杂度为$O(n^2)$，不过多项式求逆可以达到$O(nlogn)$ 这里的n不是数字个数，而是幂次。所以为什么说长度为1e5，就是为$O(nlogn)$准备的。</p><p>最后等幂求和O(n)处理，最终复杂度为O(nlogn)。完全可以接受。</p><p>所以这题整个步骤就是</p><p>欧拉降幂求m，多项式求逆O(nlogn)处理伯努利数，伯努利数O(n)处理等幂求和。</p><h2 id="Code-715MS"><a href="#Code-715MS" class="headerlink" title="Code(715MS)"></a>Code(715MS)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>): <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="type">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="type">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="type">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(x, -y); &#125;</span><br><span class="line">&#125; w[N];</span><br><span class="line"></span><br><span class="line">ll mod;</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line">ll F[N], G[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *A, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span>(i &lt; tr[i]) <span class="built_in">swap</span>(A[i], A[tr[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, lyc = len &gt;&gt; <span class="number">1</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>, lyc &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += i) &#123;</span><br><span class="line">            Complex *l = A + j, *r = A + j + (i &gt;&gt; <span class="number">1</span>), *p = w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i &gt;&gt; <span class="number">1</span>; k++) &#123;</span><br><span class="line">                Complex tmp = *r * *p;</span><br><span class="line">                *r = *l - tmp, *l = *l + tmp;</span><br><span class="line">                ++l, ++r, p += lyc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MTT</span><span class="params">(ll *x, ll *y, ll *z, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>; <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  (i &amp; <span class="number">1</span> ? len &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) w[i] = w[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI * i / len), <span class="built_in">sin</span>(<span class="number">2</span> * PI * i / len));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;</span><br><span class="line">    <span class="type">static</span> Complex a[N], b[N];</span><br><span class="line">    <span class="type">static</span> Complex dfta[N], dftb[N], dftc[N], dftd[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = <span class="built_in">Complex</span>(x[i] &amp; <span class="number">32767</span>, x[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = <span class="built_in">Complex</span>(y[i] &amp; <span class="number">32767</span>, y[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a, len), <span class="built_in">FFT</span>(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = (len - i) &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="type">static</span> Complex da, db, dc, dd;</span><br><span class="line">        da = (a[i] + a[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        db = (a[i] - a[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">        dc = (b[i] + b[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        dd = (b[i] - b[j].<span class="built_in">conj</span>()) * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">        dfta[j] = da * dc;</span><br><span class="line">        dftb[j] = da * dd;</span><br><span class="line">        dftc[j] = db * dc;</span><br><span class="line">        dftd[j] = db * dd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = dfta[i] + dftb[i] * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = dftc[i] + dftd[i] * <span class="built_in">Complex</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(a, len), <span class="built_in">FFT</span>(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> da = (ll)(a[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="type">int</span> db = (ll)(a[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="type">int</span> dc = (ll)(b[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="type">int</span> dd = (ll)(b[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        z[i] = (da + ((ll)(db + dc) &lt;&lt; <span class="number">15</span>) + ((ll)dd &lt;&lt; <span class="number">30</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLen</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>; <span class="keyword">while</span> (len &lt; (n &lt;&lt; <span class="number">1</span>)) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  (i &amp; <span class="number">1</span> ? len &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) w[i] = w[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI * i / len), <span class="built_in">sin</span>(<span class="number">2</span> * PI * i / len));</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Inv</span><span class="params">(ll *f, ll *g, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123; g[<span class="number">0</span>] = <span class="built_in">quick_pow</span>(f[<span class="number">0</span>], mod - <span class="number">2</span>, mod); <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">Get_Inv</span>(f, g, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">getLen</span>(n);</span><br><span class="line">    <span class="type">static</span> ll c[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; i++) c[i] = i &lt; n ? f[i] : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MTT</span>(c, g, c, len); <span class="built_in">MTT</span>(c, g, c, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) g[i] = (<span class="number">2ll</span> * g[i] - c[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ff[N], invff[N], inv[N];</span><br><span class="line">ll B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ff[<span class="number">0</span>] = ff[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = invff[<span class="number">0</span>] = invff[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ff[i] = ff[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = mod - (mod / i) * inv[mod % i] % mod;</span><br><span class="line">        invff[i] = invff[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = ff[m];</span><br><span class="line">    ans = ans * invff[n] % mod;</span><br><span class="line">    ans = ans * invff[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_B</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= m + <span class="number">10</span>; i++) F[i] = invff[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">Get_Inv</span>(F, G, m + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= m + <span class="number">10</span>; i++) B[i] = G[i] * ff[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ph</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll res = x,a = x;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>;i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res=res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll k = <span class="built_in">ph</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_pow</span>(n, <span class="built_in">f</span>(k) + k, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    ll k = <span class="built_in">f</span>(mod);</span><br><span class="line">    ll m = n; n = k;</span><br><span class="line">    <span class="built_in">init_B</span>(m);</span><br><span class="line">    ll ans = <span class="number">0</span>, prod = n % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; ~i ; i--) &#123;</span><br><span class="line">        ans = (ans + prod * B[i] % mod * <span class="built_in">C</span>(m + <span class="number">1</span>, i) % mod) % mod;</span><br><span class="line">        prod = prod * n % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * <span class="built_in">quick_pow</span>(m + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    ans = (n * <span class="built_in">quick_pow</span>(n, m, mod) % mod - ans) % mod;</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/22/2021-nowcoder-hanjia-5-c/">https://blog.jujimeizuo.cn/2021/02/22/2021-nowcoder-hanjia-5-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第五场】B-比武招亲（上）排列组合</title>
      <link href="/2021/02/22/2021-nowcoder-hanjia-5-b/"/>
      <url>/2021/02/22/2021-nowcoder-hanjia-5-b/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9985/B">https://ac.nowcoder.com/acm/contest/9985/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2021/02/2021022217471712.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑最大值和最小值贡献。</p><p>先看最大值： 假设我们选择最大值为x，则剩下m-1个位置只能选不超过x的数字 题目表示排完序之后本质不同! 所以就是在不超过x的数字中任意重复选择m-1个并且生成不递减序列的个数。</p><p>没错，n个中选m个数(可重复)且不递减序列个数为$C_{n+m-1}^{m}$。请自行百度！</p><p>x&#x3D;n时，贡献为$n*C_{n+m-2}^{m-1}$ x&#x3D;n-1时，贡献为$(n-1)*C_{n-1+m-2}^{m-1}$ …</p><p>所以我们最大值的贡献就是</p><p>$$\sum_{i&#x3D;1}^n(n-i+1)*C_{n-i+1+m-2}^{m-1}$$</p><p>同理，最小值就是m-1个位置必须选择不小于x的数字，贡献就是</p><p>$$\sum_{i&#x3D;1}^ni*C_{n-i+1+m-2}^{m-1}$$</p><p>这两个式子是我化简过后的。难点就是不递减序列个数是多少。</p><p>两个减一减得：</p><p>$$\sum_{i&#x3D;1}^n(n-i+1)*C_{n-i+m-1}^{m-1}$$</p><h2 id="Code-44MS"><a href="#Code-44MS" class="headerlink" title="Code(44MS)"></a>Code(44MS)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll f[N], invF[N], inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = mod - (mod / i) * inv[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = f[m];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ll quick_pow(ll a, ll b) &#123;</span></span><br><span class="line"><span class="comment">//    ll ans = 1;</span></span><br><span class="line"><span class="comment">//    while(b) &#123;</span></span><br><span class="line"><span class="comment">//        if(b &amp; 1) ans = ans * a % mod;</span></span><br><span class="line"><span class="comment">//        a = a * a % mod;</span></span><br><span class="line"><span class="comment">//        b &gt;&gt;= 1;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return ans % mod;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    ll n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// C(n + m - 1, m) n个数中选m个不递减个数</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;个数：&quot; &lt;&lt; C(n - i + 1 + m - 1 - 1, m - 1) &lt;&lt; endl;</span></span><br><span class="line">        ans = (ans + (n - <span class="number">2</span> * i + <span class="number">1</span>) * <span class="built_in">C</span>(n - i + m - <span class="number">1</span>, m - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/22/2021-nowcoder-hanjia-5-b/">https://blog.jujimeizuo.cn/2021/02/22/2021-nowcoder-hanjia-5-b/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot 三层框架dao层、service层、controller层+实体model层</title>
      <link href="/2021/02/20/springboot-three-tier-architecture/"/>
      <url>/2021/02/20/springboot-three-tier-architecture/</url>
      
        <content type="html"><![CDATA[<p>首先创建一个springboot项目。</p><hr><h2 id="model层"><a href="#model层" class="headerlink" title="model层"></a>model层</h2><p>model层也叫pojo层或者entity层，个人比较喜欢pojo层。 一般数据库的一张表对应一个pojo层，并且表中所有字段都在pojo层都一一对应。</p><p>eg：一张Goods表</p><p><img src="/images/2021/02/202102201819220.png"></p><p>然后要先建一个pojo的package，代表它是实体层。 再在该package下创建一个Goods的java文件，创建的对象都是和表里字段一一对应，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    商品编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String GNo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    商品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String GName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    商品价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Double GPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的lombok的作用时为了简化代码，因为对于private这样的对象，想要调用它的时候，需要get和set两个方法，而有了lombok之后就可以不用写，直接用即可。 不过要添加依赖和注解@Data，lombok还有很多其他用法，之后可能会出一篇博客。</p><p>通过maven下载依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样数据库里的字段，我们就可以用对象来表示。</p><hr><p>但是model不属于springboot的三层框架。 主要说明是dao层、service层和controller层。 这些已经是属于后端了。</p><p>对于一个项目，安全性是非常有必要的，所以springboot很好地体现了这一点。</p><p>比如： 想要访问数据库并且操作，只能通过dao层向数据库发送sql语句，将这些结果通过接口传给service层。 想要处理数据，要先向dao层请求数据，对dao层传过来的数据进行加工处理，将这些处理好的数据通过接口传给controller层。 客户想要查询或修改数据时，要先向service层请求数据，收集service层传过来的数据，将这些数据通过接口显示给客户，一般通过html等方法给客户。 下面会一一说明。</p><hr><h2 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h2><p>dao层也叫mapper层，数据持久层，个人比较喜欢mapper层。 对数据库进行持久化操作，他的方法是针对数据库操作的，基本用到的就是增删改查。它只是个接口，只有方法名字，具体实现在mapper.xml中。</p><p>既然mapper层是直接与数据库相挂钩的，所以要先连接数据库。 可以在sqlMapConfig.xml文件或者application.properties文件里添加数据库属性等，如下所示：</p><ul><li>sqlMapConfig.xml添加属性：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 加载属性文件 --&gt;</span><br><span class="line">&lt;properties resource=<span class="string">&quot;/config/db.properties&quot;</span>&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 和spring整合后environment配置将废除 --&gt;</span><br><span class="line">&lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">    &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 使用jdbc事务管理 --&gt;</span><br><span class="line">        &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span> /&gt;</span><br><span class="line">        &lt;!-- 数据库连接池,由mybatis管理 --&gt;</span><br><span class="line">        &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure><p>在 SqlMapConfig.xml就不需要对数据库连接参数硬编码。</p><ul><li>application.properties添加属性：</li></ul><p><img src="/images/2021/02/20210220185731148.png"></p><p>方便对参数进行统一管理，其他 xml 可以应用该配置文件。</p><p>然后检查是否连上数据库，请看下图：</p><p><img src="/images/2021/02/20210220185938611.png"></p><p>然后自己配置数据库。</p><p>数据库连接上了，到了两个文件的编写，我采用mybatis框架。</p><p>如何编写mapper.xml，对数据库增删改查？</p><p><strong>在学习MyBatis框架的过程中，发现在idea里面没法创建Mapper.xml映射文件，创建出的xml文件没有Mapper.xml文件的基本格式，下面说明如何在idea中创建Mapper.xml映射文件模板。</strong></p><p>File → Settings… → Editor → File and Code Templates</p><p><img src="/images/2021/02/20210220190615764.jpg"></p><p><img src="/images/2021/02/20210220190739783.png"></p><p>点击”+”号，并输入文件的名称和文件的类型，编辑好模板后点击Apply即可创建成功}</p><p><img src="/images/2021/02/20210220190846808.png"></p><p><img src="/images/2021/02/20210220190913559.png"></p><p><strong>mapper.xml文件模版</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span><br><span class="line"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>创建GoodsMapper.xml文件。</p><p><img src="/images/2021/02/20210220191221241.png"></p><p>编写内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;mapper.GoodsMapper&quot;</span>&gt;</span><br><span class="line">    &lt;!--增加商品--&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;insertGoods&quot;</span> parameterType=<span class="string">&quot;mapper.GoodsMapper&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">Goods</span><span class="params">(GNo, GName, GPrice)</span> values(##&#123;GNo&#125;,##&#123;GName&#125;,##&#123;GPrice&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--删除商品--&gt;</span><br><span class="line">    &lt;delete id=<span class="string">&quot;deleteGoods&quot;</span> parameterType=<span class="string">&quot;java.String&quot;</span>&gt;</span><br><span class="line">        delete from Goods where id=##&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--修改商品--&gt;</span><br><span class="line">    &lt;update id=<span class="string">&quot;uodateGoods&quot;</span> parameterType=<span class="string">&quot;mapper.GoodsMapper&quot;</span>&gt;</span><br><span class="line">        update Goods set GNo=##&#123;GNo&#125;, GName=##&#123;GName&#125;, GPrice=##&#123;GPrice&#125; where id=##&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查找商品--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findGoods&quot;</span> parameterType=<span class="string">&quot;java.String&quot;</span> resultType=<span class="string">&quot;mapper.GoodsMapper&quot;</span>&gt;</span><br><span class="line">        select *from Goods where id=##&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>创建GoodsMapper的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pojo.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoodsMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *增加商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> goods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throw</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> GNo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throw</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteGoods</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改商品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> goods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throw</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据GNo查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throw</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Goods <span class="title function_">findByGNo</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要编写接口对实现类了，只要这两个文件的映射关系对应好就ok，这不在本文的讲述范围内。</p><hr><h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><p>service层叫业务逻辑层，存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类，提供controller层调用的方法。</p><p>创建两个文件，一个存放接口类，一个存放接口实现类。</p><p>GoodsService接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pojo.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteGoods</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateGood</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findByGNo</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GoodsServiceImpl接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mapper.GoodsMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> pojo.Goods;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsMapper goodsMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsMapper.insertGoods(goods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteGoods</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsMapper.deleteGoods(GNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateGood</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsMapper.updateGoods(goods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findByGNo</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsMapper.findByGNo(GNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>就这样，service层与mapper层建立起了联系，service层可以调用mapper层的方法。</strong></p><hr><h2 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h2><p>controller层叫控制器层，负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。</p><p>同样，也需要两个文件，接口类和接口实现类。</p><p>GoodsControllerI接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Controller.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pojo.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GoodsController</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteGoods</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateGood</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findByGNo</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GoodsControllerImpl接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Controller.Goods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> pojo.Goods;</span><br><span class="line"><span class="keyword">import</span> service.Goods.GoodsService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsControllerImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">insertGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsService.insertGoods(goods);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteGoods</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsService.deleteGoods(GNo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateGoods</span><span class="params">(Goods goods)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        goodsService.updateGood(goods);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findByGNo</span><span class="params">(String GNo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Goods</span>();</span><br><span class="line">        goods = goodsService.findByGNo(GNo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，客户可以通过请求的方式，将数据从前端传给Controller层，然后一层一层传下去，在一层一层地传上来，实现了后端开发。</p><p>是不是发现和前端没什么关系？ 是的，springboot还有一个优点就是实现了前后端分离，从而工作人员分配任务的时候更加具有条理性。而三层的架构可以让程序员很快地知道bug出现在哪里，哪一层，哪一文件，很快的修改bug。</p><p><strong>呜呼，总而言之，springboot作为web开发的一个主流框架，正式因为这些优秀点让它脱颖而出。</strong></p><p><strong>这一篇写得好累。</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/20/springboot-three-tier-architecture/">https://blog.jujimeizuo.cn/2021/02/20/springboot-three-tier-architecture/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第四场】B题 武辰延的字符串 二分+哈希</title>
      <link href="/2021/02/19/2021-nowcoder-hanjia-4-b/"/>
      <url>/2021/02/19/2021-nowcoder-hanjia-4-b/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9984/B">https://ac.nowcoder.com/acm/contest/9984/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给字符串s和t，问有多少种s的两个前缀相连是t的前缀的个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先这题暴力n^2肯定会T的。 正确解法是先找s的前缀s1和t的前半部分配对，再找s的最长前缀s2和t的后半部分配对，贡献为s2的长度。</p><p>如何配对? 区间字符串哈希!</p><p><strong>关于字符串哈希，就是将一个区间的字符段用一个整数表示，在没有哈希冲突的情况下，这个整数就代表独一无二的字符段。</strong></p><p>如何找最长前缀？ 二分！</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ull mod = <span class="number">131</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ull p[N];</span><br><span class="line">ull sums[N], sumt[N];</span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"><span class="type">int</span> lens, lent;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">hashs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sums[r] - sums[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">hasht</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; lent) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sumt[r] - sumt[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; (t + <span class="number">1</span>);</span><br><span class="line">    lens = <span class="built_in">strlen</span>(s + <span class="number">1</span>), lent = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="built_in">max</span>(lens, lent); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= lens) sums[i] = sums[i - <span class="number">1</span>] * mod + s[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= lent) sumt[i] = sumt[i - <span class="number">1</span>] * mod + t[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ull ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= lent - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != t[i]) <span class="keyword">break</span>; <span class="comment">// 先匹配第一个s1</span></span><br><span class="line">        <span class="keyword">if</span>(t[i + <span class="number">1</span>] != s[<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = lens, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123; <span class="comment">// 二分找出最长前缀</span></span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hashs</span>(<span class="number">1</span>, mid) == <span class="built_in">hasht</span>(i + <span class="number">1</span>, i + mid)) &#123;</span><br><span class="line">                res = mid; l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/19/2021-nowcoder-hanjia-4-b/">https://blog.jujimeizuo.cn/2021/02/19/2021-nowcoder-hanjia-4-b/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/02/19/codeforces-round-703-div2-d/"/>
      <url>/2021/02/19/codeforces-round-703-div2-d/</url>
      
        <content type="html"><![CDATA[<p>@(Codeforces Round ##703 Div2 D. Max Median 二分答案) 传送门：<a href="https://codeforces.com/contest/1486/problem/D">https://codeforces.com/contest/1486/problem/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的数组，在里面找若干个长度$\ge k$的区间，问这些区间中最大的中位数是多少。 中位数，请输出最大值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>依靠我们小学二年级的知识，将一个序列排序后，中位数为中间的数字。 奇数则为$\frac{(n+1)}{2}$，偶数为$\frac{n}{2}$处。 所以不管奇偶，都会有一半$(\ge)$中位数，一半$(&lt;)$中位数。即$(\ge)$中位数$&gt;(&lt;)$中位数的数。</p><p>$eg:1\;2\;3 \;4。$ $3个(\ge)2，1个(&lt;)2$，则$2$一定是中位数，$2个(\ge)3，2个(&lt;)3$，则$3$不是中位数。</p><p>所以我们可以O(n)判断一个数字是不是中位数。</p><p>首先要获取这个中位数，也就是答案，那么就二分获取答案！</p><p>我们二分获取x之后，判断该数字是不是可以为中位数，如果是l&#x3D;mid，否则r&#x3D;mid-1。</p><p>对于怎么O(n)判断，用一个前缀和数字存取与x大小有关的。 $if(a[i]&gt;&#x3D;x) \;sum[i] &#x3D; sum[i-1]+1$ $else\;sum[i]&#x3D;sum[i-1]-1$</p><p>当处理完前缀和之后，从第k个开始检查，有没有在一个区间里起点到终点，$(\ge x)$的数是否大于$(&lt;x)$。 存在，直接返回true，否则返回false。</p><h2 id="Code（78MS）"><a href="#Code（78MS）" class="headerlink" title="Code（78MS）"></a>Code（78MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + (a[i] &gt;= x ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>, ans = sum[k];</span><br><span class="line">    <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        mx = <span class="built_in">min</span>(mx, sum[i - k]); <span class="comment">// 终点</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum[i] - mx); <span class="comment">// 起点</span></span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">check</span>(l + <span class="number">1</span>) ? l + <span class="number">1</span> : l) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/19/codeforces-round-703-div2-d/">https://blog.jujimeizuo.cn/2021/02/19/codeforces-round-703-div2-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU6071 Lazy Running 同余最短路</title>
      <link href="/2021/02/18/hdu6071/"/>
      <url>/2021/02/18/hdu6071/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6071">http://acm.hdu.edu.cn/showproblem.php?pid=6071</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一张图上有4个点，一开始在点2处 ，最终也回到点2处 ，问我们怎样走，使得总路径和大于等于K并且最小。输出最短路径值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>同余思想：</strong> 令$w&#x3D;min(dis_{12},dis_{23})$，取$min$是为了降低时空复杂度，代码里会看到。 w存在的意义就是可以一直在点2和点1或3之间无止境往返。 假设存在一条合法路径2-&gt;2，该路径长度为$len$，则$len+n*2w$也是一条合法路径。而我们要找的就是最短路径。这些个路径会被$\%2w$分成$2w$组，求出每一组同余类$i$的合法路径长度，最后$ans$取$min$。</p><p><strong>Dijkstra的过程中：</strong> dis[i][j]表示2到i的路径中\%w为j的最小值，所以要求出所有的dis[2][i]。</p><p><strong>更新答案：</strong> 若dis[2][i]&gt;&#x3D;k，则ans&#x3D;min(ans, dis[2][i]) 若dis[2][i]&lt;k，则ans&#x3D;min(ans, dis[2][i]+若干2w)</p><h2 id="Code-62MS"><a href="#Code-62MS" class="headerlink" title="Code(62MS)"></a>Code(62MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v; ll w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> now; ll d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; g[<span class="number">5</span>];</span><br><span class="line">ll dis[<span class="number">5</span>][N], w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dij</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; w; j++) &#123;</span><br><span class="line">            dis[i][j] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node p = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = p.now;</span><br><span class="line">        <span class="keyword">if</span>(dis[u][p.d % w] &lt; p.d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : g[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = e.v;</span><br><span class="line">            ll len = e.w + p.d;</span><br><span class="line">            <span class="keyword">if</span>(dis[v][len % w] &gt; len) &#123;</span><br><span class="line">                dis[v][len % w] = len;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;v, len&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll d12, d23, d34, d41, K;</span><br><span class="line">        cin &gt;&gt; K &gt;&gt; d12 &gt;&gt; d23 &gt;&gt; d34 &gt;&gt; d41;</span><br><span class="line">        g[<span class="number">1</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">2</span>, d12&#125;);g[<span class="number">2</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">1</span>, d12&#125;);</span><br><span class="line">        g[<span class="number">2</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">3</span>, d23&#125;);g[<span class="number">3</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">2</span>, d23&#125;);</span><br><span class="line">        g[<span class="number">3</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">4</span>, d34&#125;);g[<span class="number">4</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">3</span>, d34&#125;);</span><br><span class="line">        g[<span class="number">4</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">1</span>, d41&#125;);g[<span class="number">1</span>].<span class="built_in">emplace_back</span>(edge&#123;<span class="number">4</span>, d41&#125;);</span><br><span class="line">        w = <span class="number">2</span> * <span class="built_in">min</span>(d12, d23);</span><br><span class="line">        <span class="built_in">Dij</span>();</span><br><span class="line">        ll ans = <span class="number">1e19</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; w; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[<span class="number">2</span>][i] &gt;= K) ans = <span class="built_in">min</span>(dis[<span class="number">2</span>][i], ans);</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">min</span>(ans, dis[<span class="number">2</span>][i] + (K - dis[<span class="number">2</span>][i] + w - <span class="number">1</span>) / w * w);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>; i++) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/18/hdu6071/">https://blog.jujimeizuo.cn/2021/02/18/hdu6071/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot实现邮件发送、异步功能</title>
      <link href="/2021/02/17/springboot-realize-mail-sending-asynchronous-function/"/>
      <url>/2021/02/17/springboot-realize-mail-sending-asynchronous-function/</url>
      
        <content type="html"><![CDATA[<h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><h4 id="创建一个springboot项目"><a href="#创建一个springboot项目" class="headerlink" title="创建一个springboot项目"></a>创建一个springboot项目</h4><p>用IDEA创建springboot项目。</p><p><img src="/images/2021/02/20210217205938118.png"></p><p>之后可以一直next，依赖之后说。</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>打开pom.xml，添加如下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>打开application.properties，添加如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网易邮箱测试</span></span><br><span class="line">spring.mail.username=xxxxxx@<span class="number">163.</span>com</span><br><span class="line">spring.mail.password=网易账号授权码</span><br><span class="line">spring.mail.host=smtp<span class="number">.163</span>.com</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是QQ邮箱，则需要加一行，网易邮箱不用</span></span><br><span class="line">##spring.mail.properties.mail.smtp.ssl.enable=<span class="literal">true</span> <span class="comment">// 开启加密验证</span></span><br></pre></td></tr></table></figure><p>关于授权码，注意不是你的邮箱密码，位置如下所示。</p><p><img src="/images/2021/02/20210217210531708.png"></p><p>只要选择开启之后发个短信即可获取。</p><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p>首先在测试类要注入<strong>JavaMailSenderImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSenderImpl mailSender;</span><br></pre></td></tr></table></figure><h4 id="运行测试类进行邮件发送"><a href="#运行测试类进行邮件发送" class="headerlink" title="运行测试类进行邮件发送"></a>运行测试类进行邮件发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">simpleMailMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">    simpleMailMessage.setSubject(<span class="string">&quot;主题&quot;</span>);</span><br><span class="line">    simpleMailMessage.setText(<span class="string">&quot;内容&quot;</span>);</span><br><span class="line">    simpleMailMessage.setFrom(<span class="string">&quot;xxxxxx@163.com&quot;</span>); <span class="comment">// 发件人邮箱</span></span><br><span class="line">    simpleMailMessage.setTo(<span class="string">&quot;xxxxxx@163.com&quot;</span>); <span class="comment">// 收件人邮箱</span></span><br><span class="line">    mailSender.send(simpleMailMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许你可能一次成功，或许你失败了，失败的原因80%都是这个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.mail.MailAuthenticationException: Authentication failed; nested exception is javax.mail.AuthenticationFailedException: <span class="number">535</span> Error: xxxxxxx: http:<span class="comment">//service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256</span></span><br></pre></td></tr></table></figure><p>说明你的授权码不对，那就再试试吧。</p><p>到这一步，你已经实现了一封由springboot发送的邮件。</p><hr><h2 id="实现异步"><a href="#实现异步" class="headerlink" title="实现异步"></a>实现异步</h2><p>需要提前添加web依赖。</p><h4 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h4><p>添加@EnableAsync注解，开启异步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启异步操作</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Controller层和Service层"><a href="#创建Controller层和Service层" class="headerlink" title="创建Controller层和Service层"></a>创建Controller层和Service层</h4><p><strong>Service层</strong></p><p>创建一个AsyncService类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// Spring看到这个就知道是一个异步操作了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">async</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); <span class="comment">// 停止10秒</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据正在处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller层</strong> 创建一个AsyncController类： 页面访问，当我们请求服务器时，遇到线程方法会停止10秒。</p><p>随便玩玩，不要求获取方式了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Service.AsyncService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/async&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">async</span><span class="params">()</span> &#123;</span><br><span class="line">        asyncService.async();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加@Async注解，实现异步操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Service.AsyncService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/async&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">async</span><span class="params">()</span> &#123;</span><br><span class="line">        asyncService.async();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/17/springboot-realize-mail-sending-asynchronous-function/">https://blog.jujimeizuo.cn/2021/02/17/springboot-realize-mail-sending-asynchronous-function/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛62 E-水灾 Kruskal重构树</title>
      <link href="/2021/02/17/nowcoder-practice62-e/"/>
      <url>/2021/02/17/nowcoder-practice62-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5205/E">https://ac.nowcoder.com/acm/contest/5205/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个 n 个节点 m 条带权边的无向连通图，有 q 次询问，每次询问图中 ki 个互不相同的点，你可以选择一个数 x，然后将图中所有边权小于等于 x 的边删除。求当删除这些边后 ki 个点互不连通时，x 的最小值。 <strong>强制在线</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>学过kruskal重构树的都知道，这题一定是这种解法。</p><p>要使两点互不连通，在很多条路径中选择最小边权\&lt;x即可。只需要删除一条就可以让他们不连通。</p><p>所以直接找出ki个点之间最小边权的最大值，即是我们要求的x。</p><p>按照边权从大到小建立kruskal重构树，根据重构树的性质，可以得到一个小根堆。</p><p>ans&#x3D;val[lca(u,v)]，但是这题数据量巨大，两两找lca会T。</p><p>我们只需要让树上相邻两点的val&gt;x，他们的父亲就是lca，也是答案。</p><p>将a[]按照dfs序排序，$ans&#x3D;max(ans, val[lca(a[i],a[i-1])])$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, M = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; rhs.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> val[N], f[N], cnt;</span><br><span class="line"><span class="type">int</span> dep[N], son[N], fa[N], siz[N], top[N], dfn[N], tim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u] = par] + (siz[u] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(!son[u]  siz[v] &gt; siz[son[u]])</span><br><span class="line">            son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++tim;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]  v == son[u])  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EX_Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = n; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; (n &lt;&lt; <span class="number">1</span>); i++) f[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(E[i].u);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">find</span>(E[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        val[++cnt] = E[i].w;</span><br><span class="line">        f[u] = f[v] = cnt;</span><br><span class="line">        g[u].<span class="built_in">emplace_back</span>(cnt); g[cnt].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">        g[v].<span class="built_in">emplace_back</span>(cnt); g[cnt].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(cnt == (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rt = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(rt, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[x] &lt; dfn[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;_);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        E[i] = &#123;u, v, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EX_Kruskal</span>();</span><br><span class="line">    <span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> k; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]), a[i] ^= lastans;</span><br><span class="line">        lastans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; k; i++) &#123;</span><br><span class="line">            lastans = <span class="built_in">max</span>(lastans, val[<span class="built_in">lca</span>(a[i], a[i - <span class="number">1</span>])]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lastans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/17/nowcoder-practice62-e/">https://blog.jujimeizuo.cn/2021/02/17/nowcoder-practice62-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4768 归程 最短路+Kruskal重构树</title>
      <link href="/2021/02/16/luogu-p4768/"/>
      <url>/2021/02/16/luogu-p4768/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P4768">https://www.luogu.com.cn/problem/P4768</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个雨天漫步的无向联通城市，有n个点，m条边，已知小明的家是1号点。 每条边有u,v,l,a，分别代表起点，中点，长度和海拔。</p><p>给Q个询问，每次给一个v出发点和p水位线(强制在线)。 小明从点v乘车出发，当一条边的海拔小于等于p时，汽车可以通过，否则必须弃车步行。 步行不需要考虑水位线。 请输出小明在一次询问中步行的最小步行距离。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先这一题，题目很长，很难读！！！</p><p>题意转化一下，小明先乘车到一个点，由于水位线的原因不得不弃车，即先乘车后步行。</p><p>这个点就是与v联通的所有点中，与1距离最短的点。所以怎么找到这个关键点呢？</p><p>这就要请出今天的主角：Kruskal重构树</p><p>我们以海拔为边权，建立一棵边权从大到小的重构树。</p><p>假设我们找到了一棵子树的根节点u，且$val[u]&gt;p\;\;\&amp;\&amp;\;\;val[fa[u]]&lt;&#x3D;p$. 那么从u出发到子树的任意节点不需要步行，所以要在很多叶子结点找距离1最短距离的点—关键点。</p><p>总结一下算法流程：</p><ul><li>第一步，先跑最短路，找到1到任意点的最短距离，方便第三步更新。</li><li>第二步，建重构树，把问题转化成树形结构。</li><li>第三步，处理关键点，可树形dp，可树上倍增，找到与1距离最短的点且满足val[u]&gt;p。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>, M = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------最短路-------------*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next, w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> head[M], cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> now, d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) head[i] = <span class="number">-1</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[cnt] = &#123;v, head[u], w&#125;;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) dis[i] = INF, vis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node p = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = p.now;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + e[i].w) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(&#123;v, dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------Kruskal重构树---------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; rhs.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;E[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> f[N], val[N], tot;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">33</span>], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    d[u] = (u &lt;= n ? dis[u] : INF);</span><br><span class="line">    fa[u][<span class="number">0</span>] = par;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">32</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        d[u] = <span class="built_in">min</span>(d[u], d[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    g[u].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">32</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val[fa[u][i]] &gt; p) u = fa[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EX_Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; (n &lt;&lt; <span class="number">1</span>); i++) f[i] = i, val[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(E[i].u);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">find</span>(E[i].v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        val[++tot] = E[i].w;</span><br><span class="line">        f[u] = f[v] = tot;</span><br><span class="line">        g[u].<span class="built_in">emplace_back</span>(tot); g[tot].<span class="built_in">emplace_back</span>(u);</span><br><span class="line">        g[v].<span class="built_in">emplace_back</span>(tot); g[tot].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(tot == (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rt = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(rt, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v, l, a; cin &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; a;</span><br><span class="line">            E[i] = &#123;u, v, a&#125;;</span><br><span class="line">            <span class="built_in">add</span>(u, v, l); <span class="built_in">add</span>(v, u, l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Dijkstra</span>(<span class="number">1</span>); <span class="comment">// 先跑最短路</span></span><br><span class="line">        <span class="built_in">EX_Kruskal</span>(); <span class="comment">// 在建重构树</span></span><br><span class="line">        <span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Q, K, S; cin &gt;&gt; Q &gt;&gt; K &gt;&gt; S;</span><br><span class="line">        <span class="keyword">while</span>(Q--) &#123;</span><br><span class="line">            <span class="type">int</span> v, p; cin &gt;&gt; v &gt;&gt; p;</span><br><span class="line">            v = (v + K * lastans - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">            p = (p + K * lastans) % (S + <span class="number">1</span>);</span><br><span class="line">            cout &lt;&lt; (lastans = d[<span class="built_in">get</span>(v, p)]) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/16/luogu-p4768/">https://blog.jujimeizuo.cn/2021/02/16/luogu-p4768/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 104 Div. 2 A~E</title>
      <link href="/2021/02/16/educational-codeforces-round-104-div-2-ae/"/>
      <url>/2021/02/16/educational-codeforces-round-104-div-2-ae/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1487">https://codeforces.com/contest/1487</a></p><h2 id="A-Arena"><a href="#A-Arena" class="headerlink" title="A-Arena"></a>A-Arena</h2><p>输出n-最小数的个数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            mp[x]++;</span><br><span class="line">            mx = <span class="built_in">min</span>(mx, x);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n - mp[mx] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Cat-Cycle"><a href="#B-Cat-Cycle" class="headerlink" title="B - Cat Cycle"></a>B - Cat Cycle</h2><p>因为猫B首先呆在1的位置，所以k要减1，最后位置加1即可。</p><p>当n为奇数时，直接输出$(k-1)\%n+1$ 当n为偶数时，因为会有相遇问题。 而相遇时间为$(n-1)&#x2F;2$，总相遇次数为$\frac{(k-1)}{(n-1)&#x2F;2}$. 最后位置为$(k-1+\frac{(k-1)}{(n-1)&#x2F;2})\%n+1$.</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        k -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; (k + k / ((n - <span class="number">1</span>) / <span class="number">2</span>)) % n + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; k % n + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Minimum-Ties"><a href="#C-Minimum-Ties" class="headerlink" title="C - Minimum Ties"></a>C - Minimum Ties</h2><p>当n为奇数时，那么每个队都是$\frac{n}{2}$的赢和输。所以输出1、-1、1…即可。</p><p>当n为偶数时，那么每个队都是$\frac{n}{2}-1$的赢和输还有一场平局。</p><p>平局场就是1和2，3和4，5和6等等。剩下场都是一半赢一半输。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= (n - <span class="number">1</span>) * n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &amp; <span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">                t++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; (t &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(i &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-Pythagorean-Triples"><a href="#D-Pythagorean-Triples" class="headerlink" title="D - Pythagorean Triples"></a>D - Pythagorean Triples</h4><p>三个条件：</p><ul><li>$c&#x3D;a^2-b$</li><li>$c^2&#x3D;a^2+b^2$</li><li>$1\leq a,b,c\leq n$</li></ul><p>问这样(a,b,c)的组数有多少？</p><p>来化简一下，二式-一式得$c^2-c&#x3D;b^2+b\;\;\;\;\;(c+b)(c-b)&#x3D;b+c$ 继续化简$c-b&#x3D;1\;\;b&#x3D;c-1$，带入一式得$2c&#x3D;a^2+1$。</p><p>所以整个条件就变为，a一定要是奇数，并且$a\leq n$，得：</p><p>$$ans&#x3D;\left \lceil \frac{\sqrt{2*n-1}}{2} \right \rceil-1$$</p><p>这个减1是因为c&#x3D;1时，b&#x3D;0，错误组。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll n; cin &gt;&gt; n;</span><br><span class="line">        ll a = <span class="built_in">sqrt</span>(<span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; a / <span class="number">2</span> + (a % <span class="number">2</span> == <span class="number">1</span>) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Cheap-Dinner"><a href="#E-Cheap-Dinner" class="headerlink" title="E - Cheap Dinner"></a>E - Cheap Dinner</h2><p>因为限制只在相邻的两种食物之间，所以我们可以把这个问题分割成三个子问题：对于每种第二种食物来说，与他能在一起且价格最低的食物是谁，对于第三种和第四种同理求即可，最后把答案合并起来。那么如何找最小值，并且在限制关系中又可以有删除的操作呢，就可以用map实现。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[<span class="number">5</span>], <span class="built_in">n</span>(<span class="number">5</span>);</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que, tt;</span><br><span class="line">map&lt;<span class="type">int</span>, set&lt;<span class="type">int</span>&gt;&gt; mp[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) cin &gt;&gt; n[i], a[i].<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n[i]; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            a[i].<span class="built_in">pb</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            mp[i][x].<span class="built_in">insert</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n[<span class="number">1</span>]; i++) que.<span class="built_in">pb</span>(&#123;a[<span class="number">1</span>][i], i&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n[k]; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : que) &#123;</span><br><span class="line">                <span class="type">int</span> x = j.first, y = j.second;</span><br><span class="line">                <span class="keyword">if</span> (mp[k - <span class="number">1</span>][y].<span class="built_in">find</span>(i) == mp[k - <span class="number">1</span>][y].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    tt.<span class="built_in">pb</span>(&#123;a[k][i] + x, i&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que = tt;</span><br><span class="line">        tt.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (que.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; que[<span class="number">0</span>].first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/16/educational-codeforces-round-104-div-2-ae/">https://blog.jujimeizuo.cn/2021/02/16/educational-codeforces-round-104-div-2-ae/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 K-means算法（二维）</title>
      <link href="/2021/02/15/k-means/"/>
      <url>/2021/02/15/k-means/</url>
      
        <content type="html"><![CDATA[<p>2021年数学建模美赛用到该算法，特记此文。</p><p><strong>K-means算法中文名为K-均值聚类算法。</strong></p><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p><strong>聚类（Clustering）</strong>：就是对大量未知标注的数据集，按数据的内在 相似性将数据集划分为多个族（Cluster），使族内的数据相似度 尽可能大而类别间的数据相似度尽可能小。</p><p><strong>为什么要聚类</strong>：客户分割（segmentation）是一种发现用户特性的方法。 v 将一个基于数据的客户信息分组；从而给你一个客户信息的概况， 这可以直接转化为针对不同客户的营销策略。</p><p><strong>应用领域</strong>：</p><p>经济领域：</p><ul><li>帮助市场分析人员从客户数据库中发现不同的客户群</li><li>对住宅区进行聚类，确定自动提款机ATM的安放位置</li><li>股票市场板块分析，找出最具活力的板块龙头股</li><li>企业信用等级分类</li></ul><p>生物学领域：</p><ul><li>推导植物和动物的分类</li><li>对基因分类，获得对种群的认识</li></ul><p>其他：</p><ul><li>作为其他数学算法的预处理步骤，获得数据分布状况</li></ul><p><strong>原理</strong>：</p><p>聚类分析中“类”的特征：</p><ul><li>聚类所说的类不是事先给定的，而是根据数据的相似性和距 离来划分；</li><li>聚类的数目和结构都没有事先假定</li></ul><p>聚类方法的目的是寻找数据中：</p><ul><li>潜在的自然分组结构</li><li>感兴趣的关系</li></ul><h2 id="K-means算法概述"><a href="#K-means算法概述" class="headerlink" title="K-means算法概述"></a>K-means算法概述</h2><p>K是什么？ K是聚类算法当中类的个数。</p><p>means是什么？ means是均值算法。</p><p>Summary：K-means是采用均值算法把数据分成K个类的硬聚类算法！</p><p>对于<strong>连续型属性</strong>具有较好的聚类效果，不适合处理离散型属性。</p><h2 id="K-means评价标准"><a href="#K-means评价标准" class="headerlink" title="K-means评价标准"></a>K-means评价标准</h2><p>一个好的聚类方法要能产生高质量的聚类结果—簇，这些簇要具备以 下两个特点：</p><ul><li>高的簇内相似性</li><li>低的簇间相似性</li></ul><p>基本思想：属于划分方法（partitioning method），通过迭代把数据集 划分为不同的类别（或称簇），使得评价聚类性能的准则函数达到最 优，使得每个聚类类内紧凑，类间独立。</p><h2 id="算法基本流程"><a href="#算法基本流程" class="headerlink" title="算法基本流程"></a>算法基本流程</h2><ol><li>随机抽取k 个点作为初始聚类的中心，由各中心代表各聚类</li><li>计算所有点到这k个中心的距离，并将点归到离其最近的聚类</li><li>调整聚类中心，即将聚类的中心移动到聚类的几何中心（即平均值）</li><li>重复第2、3步直到聚类的中心不再移动，此时算法收敛</li></ol><h2 id="K-means算法主要因素"><a href="#K-means算法主要因素" class="headerlink" title="K-means算法主要因素"></a>K-means算法主要因素</h2><p><img src="/images/2021/02/20210215172244122.png"></p><h2 id="K-means优缺点"><a href="#K-means优缺点" class="headerlink" title="K-means优缺点"></a>K-means优缺点</h2><p><strong>优点</strong>:</p><ol><li>思想简单易行</li><li>时间杂度接近线性</li><li>对大数据集，具有高效性和可伸缩性</li></ol><p><strong>缺点</strong>：</p><ol><li>依赖于初始均值的选择</li><li>须事先给定聚类数k值</li><li>对噪声和孤立数据敏感</li></ol><h2 id="python实现二维K-means算法并用matplotlib实现画图"><a href="#python实现二维K-means算法并用matplotlib实现画图" class="headerlink" title="python实现二维K-means算法并用matplotlib实现画图"></a>python实现二维K-means算法并用matplotlib实现画图</h2><p><strong>这里的数据是随机数据，只需要改一下输入方式即可。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">e1, e2</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt((e1[<span class="number">0</span>] - e2[<span class="number">0</span>]) ** <span class="number">2</span> + (e1[<span class="number">1</span>] - e2[<span class="number">1</span>]) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">means</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array([np.mean([e[<span class="number">0</span>] <span class="keyword">for</span> e <span class="keyword">in</span> arr]), np.mean([e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> arr])])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">farthest</span>(<span class="params">k_arr, arr</span>):</span><br><span class="line">    f = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    max_d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_arr.__len__()):</span><br><span class="line">            d = d + np.sqrt(distance(k_arr[i], e))</span><br><span class="line">        <span class="keyword">if</span> d &gt; max_d:</span><br><span class="line">            max_d = d</span><br><span class="line">            f = e</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closest</span>(<span class="params">a, arr</span>):</span><br><span class="line">    c = arr[<span class="number">1</span>]</span><br><span class="line">    min_d = distance(a, arr[<span class="number">1</span>])</span><br><span class="line">    arr = arr[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">        d = distance(a, e)</span><br><span class="line">        <span class="keyword">if</span> d &lt; min_d:</span><br><span class="line">            min_d = d</span><br><span class="line">            c = e</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    arr = np.random.randint(<span class="number">100</span>, size=(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>))[:, <span class="number">0</span>, :]</span><br><span class="line"></span><br><span class="line">    m = <span class="number">5</span></span><br><span class="line">    r = np.random.randint(arr.__len__() - <span class="number">1</span>)</span><br><span class="line">    k_arr = np.array([arr[r]])</span><br><span class="line">    cla_arr = [[]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):</span><br><span class="line">        k = farthest(k_arr, arr)</span><br><span class="line">        k_arr = np.concatenate([k_arr, np.array([k])])</span><br><span class="line">        cla_arr.append([])</span><br><span class="line"></span><br><span class="line">    n = <span class="number">20</span></span><br><span class="line">    cla_temp = cla_arr</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> arr:</span><br><span class="line">            ki = <span class="number">0</span></span><br><span class="line">            min_d = distance(e, k_arr[ki])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k_arr.__len__()):</span><br><span class="line">                <span class="keyword">if</span> distance(e, k_arr[j]) &lt; min_d:</span><br><span class="line">                    min_d = distance(e, k_arr[j])</span><br><span class="line">                    ki = j</span><br><span class="line">            cla_temp[ki].append(e)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(k_arr.__len__()):</span><br><span class="line">            <span class="keyword">if</span> n - <span class="number">1</span> == i:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            k_arr[k] = means(cla_temp[k])</span><br><span class="line">            cla_temp[k] = []</span><br><span class="line"></span><br><span class="line">    col = [<span class="string">&#x27;HotPink&#x27;</span>, <span class="string">&#x27;Aqua&#x27;</span>, <span class="string">&#x27;Chartreuse&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;LightSalmon&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        plt.scatter(k_arr[i][<span class="number">0</span>], k_arr[i][<span class="number">1</span>], linewidth=<span class="number">10</span>, color=col[i])</span><br><span class="line">        plt.scatter([e[<span class="number">0</span>] <span class="keyword">for</span> e <span class="keyword">in</span> cla_temp[i]], [e[<span class="number">1</span>] <span class="keyword">for</span> e <span class="keyword">in</span> cla_temp[i]], color=col[i])</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/2021/02/20210215172842839.png"></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/15/k-means/">https://blog.jujimeizuo.cn/2021/02/15/k-means/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep-learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces237 E. Build String 最小费用最大流</title>
      <link href="/2021/02/15/codeforces237-e/"/>
      <url>/2021/02/15/codeforces237-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/237/problem/E">https://codeforces.com/contest/237/problem/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个模式串S和n个字符串，问能不能在这n个字符串中选取字符从而组成一个S。 在t_i中取一个字符的费用为i，每个字符串最大取字符个数为$a_i$。</p><p>若能组成，则输出最小费用，否则输出-1.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这个费用，在转化成网络流模型，这题就A了。</p><p><strong>设点：</strong> 设每个字符为1-26，n个串的为$26+i(i\epsilon n)$。源点为0，汇点为n+26+1。</p><p><strong>建边：</strong></p><ul><li>源点连接每个字符add(s,i,num[i],0)，字符i的个数。</li><li>每个字符连接n个字符串add(i,j+26,mp[j][i],0)，第j个字符串中字符i的个数。</li><li>$个字符串连接汇点，add(i+26,t,a[i],j)，第j个字符串中最大可取字符个数a[i]，费用为j。</li></ul><p>跑一遍MCMF，判断是否满流，即maxflow&#x3D;n，输出mincost，否则输出-1。</p><h2 id="Code（62MS）"><a href="#Code（62MS）" class="headerlink" title="Code（62MS）"></a>Code（62MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1005</span>;      <span class="comment">//点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, cap, flow, cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f, <span class="type">int</span> cc)</span><br><span class="line">            : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(cc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MCMF</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="type">int</span> inq[maxn];  <span class="comment">//是否在队列中</span></span><br><span class="line">    <span class="type">int</span> d[maxn];    <span class="comment">//bellmanford</span></span><br><span class="line">    <span class="type">int</span> p[maxn];    <span class="comment">//上一条弧</span></span><br><span class="line">    <span class="type">int</span> a[maxn];    <span class="comment">//可改进量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap, <span class="type">int</span> cost)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>, cost));</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>, -cost));</span><br><span class="line">        m = <span class="built_in">int</span>(edges.<span class="built_in">size</span>());</span><br><span class="line">        G[from].<span class="built_in">emplace_back</span>(m - <span class="number">2</span>);</span><br><span class="line">        G[to].<span class="built_in">emplace_back</span>(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = INF;</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="built_in">sizeof</span>(inq));</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        inq[s] = <span class="number">1</span>;</span><br><span class="line">        p[s] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        a[s] = INF;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            inq[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(G[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">                Edge &amp;e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123;</span><br><span class="line">                    d[e.to] = d[u] + e.cost;</span><br><span class="line">                    p[e.to] = G[u][i];</span><br><span class="line">                    a[e.to] = <span class="built_in">min</span>(a[u], e.cap - e.flow);</span><br><span class="line">                    <span class="keyword">if</span> (!inq[e.to]) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                        inq[e.to] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        flow += a[t];</span><br><span class="line">        cost += d[t] * a[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MincostMaxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">spfa</span>(s, t, flow, cost));</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mcmf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, mincost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string S; cin &gt;&gt; S;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num, mp[n + <span class="number">1</span>];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; S.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        num[S[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        string T;</span><br><span class="line">        cin &gt;&gt; T &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; T.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            mp[i][T[j] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, t = n + <span class="number">26</span> + <span class="number">1</span>;</span><br><span class="line">    mcmf.<span class="built_in">init</span>(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!num[i]) <span class="keyword">continue</span>;</span><br><span class="line">        mcmf.<span class="built_in">add</span>(s, i, num[i], <span class="number">0</span>); <span class="comment">// 源点连接每个字符，流量为S串每个字符点个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[j][i]) <span class="keyword">continue</span>;</span><br><span class="line">            mcmf.<span class="built_in">add</span>(i, j + <span class="number">26</span>, mp[j][i], j); <span class="comment">// 每个字符连接n个字符串，流量为该字符串中i的个数，费用为行标j</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        mcmf.<span class="built_in">add</span>(i + <span class="number">26</span>, t, a[i], <span class="number">0</span>); <span class="comment">// 每个字符串连接汇点，流量为a[i]，即最大使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxflow = mcmf.<span class="built_in">MincostMaxflow</span>(s, t, mincost);</span><br><span class="line">    <span class="keyword">if</span>(maxflow == S.<span class="built_in">length</span>()) cout &lt;&lt; mincost &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/15/codeforces237-e/">https://blog.jujimeizuo.cn/2021/02/15/codeforces237-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces277 E. Binary Tree on Plane 最小费用最大流</title>
      <link href="/2021/02/15/codeforces277-e/"/>
      <url>/2021/02/15/codeforces277-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/277/problem/E">https://codeforces.com/contest/277/problem/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你平面上 n 个点 (2≤n≤400)，要求用这些点组成一个二叉树。 定义每条边的权值为两个点之间的欧几里得距离。求一个权值和最小的二叉树，并输出。 点 i 的 y 坐标比 j 的 y 坐标大，则点i可以成为点j的父亲。 如果不存在满足条件的二叉树，输出 −1 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果没有二叉树的限制，那么就是最小生成树了。可以考虑网络流模型。</p><hr><p>对于一个二叉树，一个根节点最多可以连接两个子节点。</p><p>所以我们对于一个点i，进行拆点，拆成根节点i和子节点n+i。</p><p>对于二叉树的边，一定是根结点连接子节点，权值为两点的欧式距离。</p><p>根节点最多1个，子节点最多两个，所以我们根据上面所述： add(点i，点j，流，费用)</p><ul><li>源点连接子节点-add(s, n + i, 2, 0)，表示每个节点最多两个子节点。</li><li>根结点连接汇点-add(i, t, 1, 0)，表示每个节点最多一个根节点。</li><li>根节点连接子节点-add(n+i,j,1,Dis(i,j))，表示i可以成为j的根节点。</li></ul><p>跑一遍MCMF，如果满流即maxflow&#x3D;n-1，则该二叉树存在，否则输出-1。</p><h2 id="Code（467MS）"><a href="#Code（467MS）" class="headerlink" title="Code（467MS）"></a>Code（467MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1005</span>;      <span class="comment">//点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="type">double</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f, <span class="type">double</span> cc)</span><br><span class="line">            : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(cc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MCMF</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="type">int</span> inq[maxn];  <span class="comment">//是否在队列中</span></span><br><span class="line">    <span class="type">double</span> d[maxn];    <span class="comment">//bellmanford</span></span><br><span class="line">    <span class="type">int</span> p[maxn];    <span class="comment">//上一条弧</span></span><br><span class="line">    <span class="type">int</span> a[maxn];    <span class="comment">//可改进量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cap, <span class="type">double</span> cost)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>, cost));</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>, -cost));</span><br><span class="line">        m = <span class="built_in">int</span>(edges.<span class="built_in">size</span>());</span><br><span class="line">        G[from].<span class="built_in">emplace_back</span>(m - <span class="number">2</span>);</span><br><span class="line">        G[to].<span class="built_in">emplace_back</span>(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> &amp;flow, <span class="type">double</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = INF;</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="built_in">sizeof</span>(inq));</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        inq[s] = <span class="number">1</span>;</span><br><span class="line">        p[s] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        a[s] = INF;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            inq[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(G[u].<span class="built_in">size</span>()); ++i) &#123;</span><br><span class="line">                Edge &amp;e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123;</span><br><span class="line">                    d[e.to] = d[u] + e.cost;</span><br><span class="line">                    p[e.to] = G[u][i];</span><br><span class="line">                    a[e.to] = <span class="built_in">min</span>(a[u], e.cap - e.flow);</span><br><span class="line">                    <span class="keyword">if</span> (!inq[e.to]) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                        inq[e.to] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        flow += a[t];</span><br><span class="line">        cost += d[t] * a[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MincostMaxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">double</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">        cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">spfa</span>(s, t, flow, cost));</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mcmf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dis</span><span class="params">(pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(((a.first - b.first) * (a.first - b.first)) + (a.second - b.second) * (a.second - b.second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second == b.second ? a.first &lt; b.first : a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    mcmf.<span class="built_in">init</span>(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; p[maxn];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;p[i].first, &amp;p[i].second);</span><br><span class="line">        mcmf.<span class="built_in">addEdge</span>(s, n + i, <span class="number">2</span>, <span class="number">0</span>); <span class="comment">// 源点连接子节点</span></span><br><span class="line">        mcmf.<span class="built_in">addEdge</span>(i, t, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 根节点连接汇点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">1</span>].second == p[<span class="number">2</span>].second) &#123; <span class="comment">// 两个根结点？不存在的</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].second == p[j].second) <span class="keyword">continue</span>;</span><br><span class="line">            mcmf.<span class="built_in">addEdge</span>(n + i, j, <span class="number">1</span>, <span class="built_in">Dis</span>(p[i], p[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> mincost;</span><br><span class="line">    <span class="keyword">auto</span> ans = mcmf.<span class="built_in">MincostMaxflow</span>(s, t, mincost);</span><br><span class="line">    <span class="keyword">if</span>(ans == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.8lf\n&quot;</span>,mincost);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/15/codeforces277-e/">https://blog.jujimeizuo.cn/2021/02/15/codeforces277-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/02/13/codeforces-round-701-d/"/>
      <url>/2021/02/13/codeforces-round-701-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1485/problem/D">https://codeforces.com/contest/1485/problem/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n*m的矩阵，每一位数都能乘任意倍数，且要满足相邻数的差绝对值是$k^4(k \ge 1)$，输出构造完的矩阵，并且构造之后的每一位数都不能大于1e6。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题只要想到了就没什么难度，感觉还没有C题推的爽。</p><p>每一位都$\leq 16$，这很重要。他们的lcm不会太大，最大为$2*3*5*7*11*13$。</p><p>当k可以为0的时候，直接输出lcm，相邻差为$0^4$.</p><p>但是$k \ge 1$，没关系，我们隔项+$a[i][j]^4$就行，这样相邻差为$a[i][j]^4$。</p><h2 id="Code（124MS）"><a href="#Code（124MS）" class="headerlink" title="Code（124MS）"></a>Code（124MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    ll g;</span><br><span class="line">    ll sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            sum *= a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">2</span>)&#123;</span><br><span class="line">                g = a[<span class="number">1</span>][<span class="number">1</span>] * a[<span class="number">1</span>][<span class="number">2</span>] / <span class="built_in">gcd</span>(a[<span class="number">1</span>][<span class="number">1</span>], a[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                g = g * a[i][j] / <span class="built_in">gcd</span>(g, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) cout &lt;&lt; g &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; g + a[i][j] * a[i][j] * a[i][j] * a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/13/codeforces-round-701-d/">https://blog.jujimeizuo.cn/2021/02/13/codeforces-round-701-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/02/13/codeforces-round-701-c/"/>
      <url>/2021/02/13/codeforces-round-701-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/1485/problem/C">https://codeforces.com/contest/1485/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$给一个x和y，求\left \lfloor \frac{a}{b}\right \rfloor &#x3D;a\;mod\;b成立的个数。$ $1\leq a \leq x\;\;\;1\leq b \leq y$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然这题是围绕$\left \lfloor \frac{a}{b}\right \rfloor &#x3D;a\;mod\;b.$ 没有限制的话，会有b-1个（0不存在）。</p><p>我们可以手推出$\frac{3}{2},\frac{4}{3}$都可以，并且$\frac{8}{3}$也可以。 所以$\frac{b+1}{b}&#x3D;1，\frac{2(b+1)}{b}&#x3D;2$等等。</p><p>所以我们得出来$\frac{k(b+1)}{b}&#x3D;k&#x3D;a\;mod\;b。k(b+1)\leq a$</p><p>枚举b，但是题目是有限制条件的，取min就行。</p><p>$$\sum_{i&#x3D;2}^bmin(i-1,\frac{a}{i+1})$$</p><p>首先要算一下中间值$i-1&#x3D;\frac{a}{i+1},i&#x3D;\sqrt{a+1}$，最后得：</p><p>$$\sum_{i&#x3D;2}^{\sqrt{a+1}}i-1+\sum_{i&#x3D;\sqrt{a+1}+1}^b\frac{a}{i+1}$$</p><p>前半部分就等差数列求和，后半部分整除分块即可。</p><h2 id="Code（62MS）"><a href="#Code（62MS）" class="headerlink" title="Code（62MS）"></a>Code（62MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll t = <span class="built_in">sqrt</span>(a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &gt; b) &#123;</span><br><span class="line">            t = b;</span><br><span class="line">            ans += t * (t - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += t * (t - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll l = t + <span class="number">1</span>, r; l &lt;= <span class="built_in">min</span>(a, b); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a / (l + <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> r = <span class="built_in">min</span>(b, <span class="built_in">min</span>(a, a / (a / (l + <span class="number">1</span>)) - <span class="number">1</span>));</span><br><span class="line">                ans += (r - l + <span class="number">1</span>) * (a / (l + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/13/codeforces-round-701-c/">https://blog.jujimeizuo.cn/2021/02/13/codeforces-round-701-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/02/05/codeforces-round-290-div-1-c/"/>
      <url>/2021/02/05/codeforces-round-290-div-1-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/512/problem/C">https://codeforces.com/contest/512/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个数，问能不能把n个数分成k桌，且要求如下</p><ul><li>每桌至少3个数以上</li><li>一桌上相邻的数相加为素数</li></ul><p>问能不能构造出k桌，能则输出，否则输出-1.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求相连的数相加为素数，我们知道，这两个数一定是一奇一偶。 而奇数相邻两个一定是偶数，偶数相邻两个一定是奇数。所以可以建立网络流模型。</p><p>先判断两个数相加是否为素数，是的话就将奇数向偶数连一条有向边，并且容量为1。 而这个奇数可以连接两个偶数，所以将源点向这个奇数连接一条有向边，容量为2。 同样，每个偶数都要向汇点连接一条有向边，容量为2。</p><p>跑一遍最大流，如果最大流&#x3D;n，则是可以得到k桌。在残留网络上跑一遍DFS即可。</p><p>注意：n为奇数一定是不存在。</p><h2 id="Code（30MS）"><a href="#Code（30MS）" class="headerlink" title="Code（30MS）"></a>Code（30MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">405</span>, M = <span class="number">10005</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="type">int</span> maxflow;</span><br><span class="line"><span class="type">int</span> deep[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next, cap;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[M &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(head, <span class="number">-1</span>);</span><br><span class="line">    cnt = maxflow = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].cap = cap;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line"></span><br><span class="line">    e[cnt].v = u;</span><br><span class="line">    e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">    e[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= t; i++) &#123;</span><br><span class="line">        deep[i] = <span class="number">-1</span>; cur[i] = head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); deep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(deep[v] == <span class="number">-1</span> &amp;&amp; e[i].cap) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[t] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> mx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(e[i].cap &amp;&amp; deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; (a = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(mx, e[i].cap)))) &#123;</span><br><span class="line">            e[i].cap -= a;</span><br><span class="line">            e[i ^ <span class="number">1</span>].cap += a;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">            <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">            maxflow += res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> is_prime[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i;j &lt; maxn; j += i) &#123;</span><br><span class="line">                is_prime[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> ver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    ans[ver].<span class="built_in">push_back</span>(u); <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].cap) <span class="keyword">continue</span>;</span><br><span class="line">        v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>;</span><br><span class="line">        ans[ver].<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[v]; ~i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i ^ <span class="number">1</span>].cap) <span class="keyword">continue</span>;</span><br><span class="line">        v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">405</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) <span class="built_in">add</span>(s, i, <span class="number">2</span>); <span class="comment">// 源点连接奇数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(i, t, <span class="number">2</span>); <span class="comment">// 偶数连接汇点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!is_prime[a[i] + a[j]]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">add</span>(i, j, <span class="number">1</span>); <span class="comment">// 奇数连接偶数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">if</span>(maxflow != n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; (a[i] &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(i); <span class="comment">// 搜索每一桌</span></span><br><span class="line">            ver++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ver &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ver; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; ans[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/05/codeforces-round-290-div-1-c/">https://blog.jujimeizuo.cn/2021/02/05/codeforces-round-290-div-1-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces653D Delivery Bears 二分答案+最大流</title>
      <link href="/2021/02/04/codeforces653d/"/>
      <url>/2021/02/04/codeforces653d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/653/problem/D">https://codeforces.com/contest/653/problem/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n个点m条边的有向图，每条边都有最大的货物通道，有x个工人，每个工人都可以拿同样重量的货物，问走完这个图之后可以得到最多多少重量的货物。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们不知道工人的流向，因为会有流量限制。 所以我们可以先确定货物是多少，然后就知道每条边可以通过多少个工人。</p><p>设重量为w，则每条边通过人数为$min(x,cap[i]&#x2F;w)$，跑一下最大流，检查到达汇点的工人数是不是最大流。</p><p>而这个货物重量w我们可以通过二分得出。</p><h2 id="Code（31MS）"><a href="#Code（31MS）" class="headerlink" title="Code（31MS）"></a>Code（31MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, M = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t, x;</span><br><span class="line"><span class="type">int</span> maxflow;</span><br><span class="line"><span class="type">int</span> deep[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">&#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[M &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(head, <span class="number">-1</span>);</span><br><span class="line">    cnt = maxflow = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].cap = cap;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line"></span><br><span class="line">    e[cnt].v = u;</span><br><span class="line">    e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">    e[cnt].next = head[v];</span><br><span class="line">    head[v] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        deep[i] = <span class="number">-1</span>;</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    deep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (deep[v] == <span class="number">-1</span> &amp;&amp; e[i].cap) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[t] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> mx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (e[i].cap &amp;&amp; deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; (a = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(mx, e[i].cap)))) &#123;</span><br><span class="line">            e[i].cap -= a;</span><br><span class="line">            e[i ^ <span class="number">1</span>].cap += a;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">            <span class="keyword">if</span> (!res) <span class="keyword">break</span>;</span><br><span class="line">            maxflow += res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u[M &lt;&lt; <span class="number">1</span>], v[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cap[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">add</span>(u[i], v[i], (<span class="type">int</span>)<span class="built_in">min</span>(<span class="number">1.0</span> * x, cap[i] / w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">if</span> (maxflow &gt;= x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    s = <span class="number">1</span>; t = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; cap[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1e18</span>;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; ans * x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/04/codeforces653d/">https://blog.jujimeizuo.cn/2021/02/04/codeforces653d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6808 Go Running 二分图最小点覆盖</title>
      <link href="/2021/02/04/hdu-6808/"/>
      <url>/2021/02/04/hdu-6808/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6808">http://acm.hdu.edu.cn/showproblem.php?pid=6808</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://blog.csdn.net/kaka03200/article/details/107711487">https://blog.csdn.net/kaka03200/article/details/107711487</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一条跑道上，有n个时间，在每个时间里一个人的位置在x处，每个人可以往左或者往右跑，问推断出最少有多少人？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这题不是贪心！！！</strong></p><p>我们可以建立一个t-x坐标系，横坐标为时间，纵坐标为位置x。 所以左右跑的概念等价于斜率为1或-1的直线，所以要求的就是最少多少条线可以覆盖所有的点。</p><p>每个点经过-1或1斜率的直线都可以得到在y轴上的截距。 我们将这两个点连接，说明可以通过一条边就可以连接这两个点（同一点而已）。</p><p>所以建图完成之后，用匈牙利算法跑最大匹配即可。$</p><p>但是这题n有1e5（可以先离散化），所以匈牙利会T，没关系，我们用Dinic跑最大流也行。 不过要在原来的二分图中加源点和汇点，并且建边。</p><h2 id="Code（1326MS）"><a href="#Code（1326MS）" class="headerlink" title="Code（1326MS）"></a>Code（1326MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> n, m, s, t, maxflow;</span><br><span class="line">    <span class="type">int</span> deep[N], cur[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, next;</span><br><span class="line">        <span class="type">int</span> cap;</span><br><span class="line">    &#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> head[M &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">mem</span>(head, <span class="number">-1</span>);</span><br><span class="line">        cnt = maxflow = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">        e[cnt].v = v;</span><br><span class="line">        e[cnt].cap = cap;</span><br><span class="line">        e[cnt].next = head[u];</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line"></span><br><span class="line">        e[cnt].v = u;</span><br><span class="line">        e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">        e[cnt].next = head[v];</span><br><span class="line">        head[v] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= t; i++) &#123;</span><br><span class="line">            deep[i] = <span class="number">-1</span>; cur[i] = head[i];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s); deep[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">                <span class="type">int</span> v = e[i].v;</span><br><span class="line">                <span class="keyword">if</span>(deep[v] == <span class="number">-1</span> &amp;&amp; e[i].cap) &#123;</span><br><span class="line">                    deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deep[t] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mx)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> mx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            cur[u] = i;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap &amp;&amp; deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; (a = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(mx, e[i].cap)))) &#123;</span><br><span class="line">                e[i].cap -= a;</span><br><span class="line">                e[i ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                res = <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">                <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">                maxflow += res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        mf.<span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span>, <span class="title">y</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            x[i] = a + b; y[i] = a - b;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(x[i]);</span><br><span class="line">            v2.<span class="built_in">push_back</span>(y[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">        v1.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>()), v1.<span class="built_in">end</span>());</span><br><span class="line">        v2.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>()), v2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = v1.<span class="built_in">size</span>();</span><br><span class="line">        mf.s = <span class="number">0</span>; mf.t = v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= len; i++) &#123; <span class="comment">// 源点与左</span></span><br><span class="line">            mf.<span class="built_in">add</span>(mf.s, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len + <span class="number">1</span>;i &lt;= mf.t - <span class="number">1</span>; i++) &#123; <span class="comment">// 右与汇点</span></span><br><span class="line">            mf.<span class="built_in">add</span>(i, mf.t, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123; <span class="comment">// 拆点建图</span></span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">lower_bound</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), x[i]) - v1.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> v = <span class="built_in">lower_bound</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), y[i]) - v2.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">            mf.<span class="built_in">add</span>(u, v + len, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mf.<span class="built_in">dinic</span>();</span><br><span class="line">        cout &lt;&lt; mf.maxflow &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/04/hdu-6808/">https://blog.jujimeizuo.cn/2021/02/04/hdu-6808/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第二场】F题 牛牛与交换排序 平衡树区间翻转</title>
      <link href="/2021/02/03/2021-nowcoder-hanjia-2-f/"/>
      <url>/2021/02/03/2021-nowcoder-hanjia-2-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9982/F">https://ac.nowcoder.com/acm/contest/9982/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个序列，让你找一个k，k代表区间，从左到右可以将区间翻转，问可以不可以将整个序列升序排列。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>赛中的这道题，大多数都是暴力过的，可能是数据太弱了。</p><p>一开始就能想到的就是splay区间翻转了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n, cnt, root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> val, fa;</span><br><span class="line">    <span class="type">int</span> siz, tag;</span><br><span class="line">&#125; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    t[x].siz = t[t[x].ch[<span class="number">0</span>]].siz + t[t[x].ch[<span class="number">1</span>]].siz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; t[x].tag) &#123;</span><br><span class="line">        t[t[x].ch[<span class="number">0</span>]].tag ^= <span class="number">1</span>;</span><br><span class="line">        t[t[x].ch[<span class="number">1</span>]].tag ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(t[x].ch[<span class="number">0</span>], t[x].ch[<span class="number">1</span>]);</span><br><span class="line">        t[x].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == t[t[x].fa].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> fa, <span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    t[x].fa = fa;</span><br><span class="line">    t[fa].ch[d] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = t[x].fa;</span><br><span class="line">    <span class="type">int</span> ff = t[f].fa;</span><br><span class="line">    <span class="built_in">push_down</span>(x);</span><br><span class="line">    <span class="built_in">push_down</span>(f);</span><br><span class="line">    <span class="type">int</span> fson = <span class="built_in">id</span>(x);</span><br><span class="line">    <span class="type">int</span> ffson = <span class="built_in">id</span>(f);</span><br><span class="line">    <span class="type">int</span> son = t[x].ch[fson ^ <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">connect</span>(f, son, fson);</span><br><span class="line">    <span class="built_in">connect</span>(x, f, fson ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">connect</span>(ff, x, ffson);</span><br><span class="line">    <span class="built_in">update</span>(f), <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> to)</span> </span>&#123; <span class="comment">// 将 x 转到 to 的子节点位置</span></span><br><span class="line">    <span class="keyword">while</span> (t[x].fa != to) &#123;</span><br><span class="line">        <span class="type">int</span> f = t[x].fa;</span><br><span class="line">        <span class="keyword">if</span> (t[f].fa != to) &#123;</span><br><span class="line">            <span class="built_in">rotate</span>(<span class="built_in">id</span>(x) == <span class="built_in">id</span>(f) ? f : x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!to) &#123; <span class="comment">// 在 splay(l, 0) 时起作用</span></span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = ++cnt;</span><br><span class="line">    t[x].fa = fa;</span><br><span class="line">    t[x].siz = <span class="number">1</span>;</span><br><span class="line">    t[x].val = a[mid];</span><br><span class="line">    t[x].ch[<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, x);</span><br><span class="line">    t[x].ch[<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (rank &lt;= t[t[x].ch[<span class="number">0</span>]].siz) &#123;</span><br><span class="line">            x = t[x].ch[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rank -= t[t[x].ch[<span class="number">0</span>]].siz + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!rank) &#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            x = t[x].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    l = <span class="built_in">find</span>(l);</span><br><span class="line">    r = <span class="built_in">find</span>(r);</span><br><span class="line">    <span class="built_in">splay</span>(l, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">splay</span>(r, l);</span><br><span class="line">    <span class="type">int</span> pos = t[t[root].ch[<span class="number">1</span>]].ch[<span class="number">0</span>];</span><br><span class="line">    t[pos].tag ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(x);</span><br><span class="line">    <span class="built_in">print</span>(t[x].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (t[x].val != INF &amp;&amp; t[x].val != -INF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t[x].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(t[x].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>] = -INF; a[n + <span class="number">2</span>] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    k = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root=<span class="built_in">build</span>(<span class="number">1</span>, n + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="built_in">find</span>(i + <span class="number">1</span>)].val != i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[<span class="built_in">find</span>(i + k)].val != i) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">reverse</span>(i, i + k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/03/2021-nowcoder-hanjia-2-f/">https://blog.jujimeizuo.cn/2021/02/03/2021-nowcoder-hanjia-2-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第二场】J题 牛牛想要成为hacker 构造</title>
      <link href="/2021/02/03/2021-nowcoder-hanjia-2-j/"/>
      <url>/2021/02/03/2021-nowcoder-hanjia-2-j/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9982/J">https://ac.nowcoder.com/acm/contest/9982/J</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个n，构造一个数组，问三层循环中（能不能构造一个三角形） 执行次数次数能不能超过$min(C_n^3,n^2log_2n)。$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>三角形成立条件：最短的两条边&gt;最长边，所以相等的话是可以的。</p><p>想到2个数相加等于第三个数，这是什么？这是斐波那契数。</p><p>而1e9的斐波那契数有45个，所以n&#x3D;1e5的时候，45*n*n的执行次数是可以的。</p><p>注意，最前面的1和1是不能要的，这一点好好想想，所以代码就很简单了。</p><h2 id="Code-3MS"><a href="#Code-3MS" class="headerlink" title="Code(3MS)"></a>Code(3MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll MAX = <span class="number">1e9</span>;</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; log2(N) &lt;&lt; endl;</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>; f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &gt; MAX)  &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                f[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    cout &lt;&lt; min(1ll * n * n * (int)log2(n), 1ll * n * (n - 1) * (n - 2) / 6) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cout &lt;&lt; f[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/03/2021-nowcoder-hanjia-2-j/">https://blog.jujimeizuo.cn/2021/02/03/2021-nowcoder-hanjia-2-j/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2021牛客寒假第一场】H题 幂塔个位数的计算 欧拉降幂</title>
      <link href="/2021/02/01/2021-nowcoder-hanjia-1-h/"/>
      <url>/2021/02/01/2021-nowcoder-hanjia-1-h/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9981/H">https://ac.nowcoder.com/acm/contest/9981/H</a> <strong>今天被大一按在地上摩擦，很不爽（估计以后都是，呜呜呜</strong></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2021/02/20210201232512185.png"></p><p>求$a \uparrow \uparrow n$的最后一位。</p><p>小知识：$\uparrow$ 这个符号是高德纳箭头，感兴趣的小伙伴可以自行百度，和已知的最大数有关联。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在我学欧拉降幂的时候，做过这样的一个题目，求$2^{2^{2^{…}}} mod\;p$。 <strong>注意：</strong>是无穷多个，而不是有限个。</p><p>所以这很好地告诉我们，当幂次巨大时，mod之后基本上不会发生什么变化了。这一题只不过是\%10而已。</p><p>$要解决这一题，我们需要知道一个知识点：欧拉降幂</p><p><img src="/images/2021/02/20210201233024375.png"></p><p>因为我们的p是10，不一定满足朴素版欧拉降幂。所以需要下面的广义欧拉降幂。</p><p>当我们要求$a^{a^{a^{a…}}} \%10$时，用广义欧拉降幂可得：</p><p>$$a^{a^{a^{a^{a^{…} \%1} \%2 + 2}} \%4 + 4} \%10$$</p><p>我们会发现，当n&gt;3时，整个式子变成了$a^{a \%4+4}\%10$ 所以我们有三种讨论方式：</p><ul><li>n&#x3D;1时，直接输出最后一位</li><li>n&#x3D;2时，答案为$a^{a \%4+4} \%10$</li><li>n&#x3D;3时，答案为$a^{a^{a \%2+2} \%4+4} \% 10$</li><li>n&gt;3时，答案为$a^{a \%4+4} \%10$</li></ul><p>所以，就完事了。</p><p>题解给的就是找规律暴力求解，但它内含的就是欧拉降幂的思想。</p><h2 id="Code-9MS"><a href="#Code-9MS" class="headerlink" title="Code(9MS)"></a>Code(9MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a, n; cin &gt;&gt; a &gt;&gt; n;</span><br><span class="line">    ll t = a[a.<span class="built_in">length</span>() - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ll tmp1, tmp2;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="string">&quot;2&quot;</span>) tmp1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tmp1 = t % <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        ll mod4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            mod4 = mod4 * <span class="number">10</span> + a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            mod4 %= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tmp1; i++) &#123;</span><br><span class="line">            tmp2 = tmp2 * mod4 % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp2 += <span class="number">4</span>;</span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tmp2; i++) &#123;</span><br><span class="line">            ans = ans * t % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/02/01/2021-nowcoder-hanjia-1-h/">https://blog.jujimeizuo.cn/2021/02/01/2021-nowcoder-hanjia-1-h/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 190 D - Staircase Sequences唯一分解定理</title>
      <link href="/2021/01/30/atcoder-beginner-contest-190-d/"/>
      <url>/2021/01/30/atcoder-beginner-contest-190-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://atcoder.jp/contests/abc190/tasks/abc190_d">https://atcoder.jp/contests/abc190/tasks/abc190_d</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个N，问有多少种等差数列（公差为1）的和等于N，输出个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设我们选择的等差数列为[a,b]，则根据题意可以得到 $\frac{(b+a)(b-a+1)}{2}&#x3D;N$ $(b+a)(b-a + 1)&#x3D;2N$</p><p>不管a和b的奇偶性。都可以得到(b+a)和(b-a+1)一定是一奇一偶。 所以我们只用求出2*N的奇数因子个数，用算数基本定理求。 由于是奇数，所以2的因子就不用了，所以直接求N的奇数因子个数。</p><p>注意：任何一组解都能在左边加上一正一负给抵消掉，所以最后结果*2.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_Count</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>;i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">2</span>)</span><br><span class="line">                ans *= (a + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)  ans *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_Count</span>(n) * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/30/atcoder-beginner-contest-190-d/">https://blog.jujimeizuo.cn/2021/01/30/atcoder-beginner-contest-190-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2021/01/29/codeforces-round-698-div-2-a-e/"/>
      <url>/2021/01/29/codeforces-round-698-div-2-a-e/</url>
      
        <content type="html"><![CDATA[<h2 id="A-Nezzar-and-Colorful-Balls"><a href="#A-Nezzar-and-Colorful-Balls" class="headerlink" title="A - Nezzar and Colorful Balls"></a>A - Nezzar and Colorful Balls</h2><p>输出序列中出现最多次数的个数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            mp[x]++;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, mp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Nezzar-and-Lucky-Number"><a href="#B-Nezzar-and-Lucky-Number" class="headerlink" title="B - Nezzar and Lucky Number"></a>B - Nezzar and Lucky Number</h2><p>题意：有一个luck数d，问能不能将一个x拆成任意多个数之和，并且每个数之中都要有一个d？</p><p>思路： 首先盲猜写$x&gt;d*10$都是可以的，因为都可以拆成10个数，每个数无非多加了很多个10而已。 所以打表$d*10$之内的数即可，只需要判断尾部，尾部对了，并且小于x，无非就多加几个10而已。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> q, d; cin &gt;&gt; q &gt;&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= d * <span class="number">10</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> t = j * d;</span><br><span class="line">                <span class="keyword">if</span>(t &lt;= x &amp;&amp; (t % <span class="number">10</span> == x % <span class="number">10</span>)) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Nezzar-and-Symmetric-Array"><a href="#C-Nezzar-and-Symmetric-Array" class="headerlink" title="C - Nezzar and Symmetric Array"></a>C - Nezzar and Symmetric Array</h2><p>题意:给有$2*n$个数字的数组d，问能不能构造出一组“对称数组”（有一个整数a，必然有一个负数-a，0不行），并且一个数和其他所有数之差的绝对值之和都能在原数组找到。即$\sum_{j&#x3D;1}^na_i-a_j&#x3D;d_{某个数}$。</p><p>思路： 因为是对称数组，所以原数组中的数必须有不同的n个偶数，奇数是不行的，因为$\sum_{j&#x3D;1}^na_i-a_j$得出来一定是个偶数。</p><p>加入我们设要构造的数组为$a_1,a_2…a_n,-a_1,-a_2…-a_n$，所以$\sum_{j&#x3D;1}^na_i-a_j$最小的数为$2(a_1+a_2+…+a_n)$，这就是为什么一定要是偶数了，方便起见，将d数组每个数都除2判断一下，设$a_1+a_2+…+a_n&#x3D;sum$那么我们可以得到所有的数： (将d数组从小到大排序)</p><ul><li>$第一小：sum&#x3D;d[1]$</li><li>$第二小：sum+a_2-a_1&#x3D;d[2]$</li><li>$第三小:sum+a_3-a_2+a_3-a_1&#x3D;d[3]$</li></ul><p>这样我们是看不出来什么样的，前后做一个差分可以得到：</p><p>$sum&#x3D;d[1]$ $a_2-a_1&#x3D;d[2]-d[1]$ $2(a_3-a_2)&#x3D;d[3]-d[2]$ $3(a_4-a_3)&#x3D;d[4]-d[3]$ … $(n-1)(a_n-a_{n-1})&#x3D;d[n]-d[n-1]$</p><p>我们可以解这n个方程，得到a数组的n个正数，但不不好解它，我们先假设$a_1&#x3D;1(不能等于0，对称数组，0是不允许的)$，然后解出所有的$a_i$，最后算出$sum$是$a_1+…+a_n$。</p><p>$a_2&#x3D;d[2]-d[1]+a_1$ $a_3&#x3D;\frac{d[3]-d[2]}{2}+a_2$ $a_4&#x3D;\frac{d[4]-d[3]}{3}+a_3$ … $a_n&#x3D;\frac{d[n]-d[n-1]}{n-1}+a_{n-1}$</p><p>如何判断YES还是NO呢？</p><p>我们发现，$a_1$每+1都会使所有数+1，即sum加了n，所以我们判断如果$sum&lt;&#x3D;d[1]，并且(d[1]-sum]\%n)&#x3D;&#x3D;0，输出YES，反之NO。$</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        vector&lt;ll&gt;<span class="built_in">v</span>(n * <span class="number">2</span>);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            <span class="keyword">if</span>(v[i] &amp; <span class="number">1</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> v[i] /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() != n) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll t = <span class="number">1</span>;</span><br><span class="line">        ll sum = t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((v[i] - v[i - <span class="number">1</span>]) % i == <span class="number">0</span>) &#123;</span><br><span class="line">                ll a = (v[i] - v[i - <span class="number">1</span>]) / i + t;</span><br><span class="line">                sum += a;</span><br><span class="line">                t = a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag &amp;&amp; (sum &lt;= v[<span class="number">0</span>] &amp;&amp; (v[<span class="number">0</span>] - sum) % n == <span class="number">0</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Nezzar-and-Board"><a href="#D-Nezzar-and-Board" class="headerlink" title="D - Nezzar and Board"></a>D - Nezzar and Board</h2><p>题意：给n个数$x_1,x_2…x_n$，从中选择两个数x和y，将$2*x-y$放入数组中，可以操作多次，问能不能得到一个k。</p><p>思路： $2*x-y&#x3D;x+x-y$，因为两个数一直辗转相减是可以得到这两个数的最大公因数，所以两个数的差即为最大公因数的倍数，所以为了每个数都可以被用到，我们先求出$n-1$个差的$gcd$，这样我们可以得到任意多个$gcd$的和，然后还剩下一个$x$，就看看$k$能不能等于$x_i+任意多个gcd$，即判断$(k-x_i)\%gcd&#x3D;&#x3D;0$。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        ll k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        vector&lt;ll&gt;<span class="built_in">v</span>(n + <span class="number">1</span>);</span><br><span class="line">        ll GCD;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">                GCD = v[i] - v[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                GCD = <span class="built_in">gcd</span>(v[i] - v[i - <span class="number">1</span>], GCD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((k - v[i]) % GCD == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Nezzar-and-Binary-String"><a href="#E-Nezzar-and-Binary-String" class="headerlink" title="E - Nezzar and Binary String"></a>E - Nezzar and Binary String</h2><p>题意：给两个01串，问经过q天之后能不能把s1转化成s2，每一天给一个区间，可以将该区间严格小于一半的字符数变成另一种，最后，如果可以转化输出YES，反之NO。</p><p>思路： 从第一天开始，后面的操作是基于前面的，所以我们需要时间逆序。 每一次操作，会有三种情况：</p><ul><li>当前1的个数严格小于区间一半，将区间全部变成0</li><li>当前0的个数严格小于区间一半，将区间全部变成1</li><li>当前1和0的个数相同，直接输出NO</li></ul><p>所以需要区间覆盖，想到区间问题，线段树是居家旅行的好东西。 直接用最简单的线段树模拟这个过程即可。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">string s1, s2;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].sum = t[lc].sum + t[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[u].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    t[lc].sum = t[u].tag * (t[lc].r - t[lc].l + <span class="number">1</span>);</span><br><span class="line">    t[rc].sum = t[u].tag * (t[rc].r - t[rc].l + <span class="number">1</span>);</span><br><span class="line">    t[lc].tag = t[u].tag;</span><br><span class="line">    t[rc].tag = t[u].tag;</span><br><span class="line">    t[u].tag = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    t[u].sum = <span class="number">0</span>;</span><br><span class="line">    t[u].tag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].sum = s2[l - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        t[u].sum = v * (t[u].r - t[u].l + <span class="number">1</span>);</span><br><span class="line">        t[u].tag = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(lc, ql, qr, v);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify</span>(rc, ql, qr, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans += <span class="built_in">query</span>(lc, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  ans += <span class="built_in">query</span>(rc, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(q + <span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(q + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q; i++) &#123;</span><br><span class="line">            cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = q;i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> len = r[i] - l[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> v = <span class="built_in">query</span>(<span class="number">1</span>, l[i], r[i]);</span><br><span class="line">            <span class="keyword">if</span>(v * <span class="number">2</span> &lt; len) <span class="built_in">modify</span>(<span class="number">1</span>, l[i], r[i], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v * <span class="number">2</span> &gt; len) <span class="built_in">modify</span>(<span class="number">1</span>, l[i], r[i], <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(<span class="number">1</span>, i, i) != s1[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/29/codeforces-round-698-div-2-a-e/">https://blog.jujimeizuo.cn/2021/01/29/codeforces-round-698-div-2-a-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC济南站 A题 Matrix Equation高斯消元求异或方程组</title>
      <link href="/2021/01/27/2020-icpc-jinan-a/"/>
      <url>/2021/01/27/2020-icpc-jinan-a/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/10662/A">https://ac.nowcoder.com/acm/contest/10662/A</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>设$A×C&#x3D;B⋅C，$求C的个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比赛的时候猜答案是2的幂次，确实没错，然后想解法是先求A的逆，最后答案为$C&#x3D;A^{-1}×B⋅C$，那么就意味着，$A^{-1}×B$这个结果，如果为0，那么可以去0或1，如果是1，那么只能取1，所以答案为$2^{0的个数}$,可是，A可能没有逆，所以这个方法是行不通的。</p><p>先来观察式子：</p><p><img src="/images/2021/01/fangchengzu.jpg"></p><p>所以每列都是相互独立的，所以我们求每列的种数，最后全部乘起来就好。</p><p>由于这个矩阵乘法有一个要求，最后求得的要相加并\%2，这是什么？这不就是异或吗？</p><p>那么答案是多少？每一列的种数是多少？答案就是上面每一个异或方程组的自由元的个数n-r，r为方程组的秩。每个值都可以取0或1，即答案为$2^{n-r}$。最后将所有列的种数相乘即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FZT_ACM_LOCAL 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];<span class="comment">//增广矩阵</span></span><br><span class="line"><span class="type">int</span> x[N];<span class="comment">//解集</span></span><br><span class="line"><span class="type">int</span> freeX[N];<span class="comment">//自由变元</span></span><br><span class="line"><span class="comment">// equ:方程个数 var:变量个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Gauss</span><span class="params">(<span class="type">int</span> equ, <span class="type">int</span> var)</span> </span>&#123;<span class="comment">//返回自由变元个数</span></span><br><span class="line">    <span class="comment">/*初始化*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= var; i++) &#123;</span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">        freeX[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*转换为阶梯阵*/</span></span><br><span class="line">    <span class="type">int</span> col = <span class="number">0</span>;<span class="comment">//当前处理的列</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//自由变元的序号</span></span><br><span class="line">    <span class="type">int</span> k;<span class="comment">//当前处理的行</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; equ &amp;&amp; col &lt; var; k++, col++) &#123;<span class="comment">//枚举当前处理的行</span></span><br><span class="line">        <span class="type">int</span> maxr = k;<span class="comment">//当前列绝对值最大的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; equ; i++) &#123;<span class="comment">//寻找当前列绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (a[i][col] &gt; a[maxr][col]) &#123;</span><br><span class="line">                maxr = i;</span><br><span class="line">                <span class="built_in">swap</span>(a[k], a[maxr]);<span class="comment">//与第k行交换</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[k][col] == <span class="number">0</span>) &#123;<span class="comment">//col列第k行以下全是0，处理当前行的下一列</span></span><br><span class="line">            freeX[num++] = col;<span class="comment">//记录自由变元</span></span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; equ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = col; j &lt; var + <span class="number">1</span>; j++) &#123;<span class="comment">//对于下面出现该列中有1的行，需要把1消掉</span></span><br><span class="line">                    a[i][j] ^= a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*求解*/</span></span><br><span class="line">    <span class="comment">//无解：化简的增广阵中存在(0,0,...,a)这样的行，且a!=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; equ; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i][col] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无穷解: 在var*(var+1)的增广阵中出现(0,0,...,0)这样的行</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; var)<span class="comment">//返回自由变元数</span></span><br><span class="line">        <span class="keyword">return</span> var - k;<span class="comment">//自由变元有var-k个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一解: 在var*(var+1)的增广阵中形成严格的上三角阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = var - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//计算解集</span></span><br><span class="line">        x[i] = a[i][var];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; var; j++)</span><br><span class="line">            x[i] ^= (a[i][j] &amp;&amp; x[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A[N][N];</span><br><span class="line"><span class="type">int</span> B[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; B[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                a[i][j] = A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (B[i][k]) a[i][i] ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">Gauss</span>(n, n);</span><br><span class="line">        ans += cnt &gt; <span class="number">0</span> ? cnt : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_pow</span>(<span class="number">2</span>, ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/27/2020-icpc-jinan-a/">https://blog.jujimeizuo.cn/2021/01/27/2020-icpc-jinan-a/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛76 C-CG的通关秘籍 组合+数学推导</title>
      <link href="/2021/01/15/nowcoder-practice76-c/"/>
      <url>/2021/01/15/nowcoder-practice76-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/10845/C">https://ac.nowcoder.com/acm/contest/10845/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个位置，[1..m]中的数无穷多个，构造所有可能的序列。 每个序列的贡献取决于，若$a_i&gt;a_{i-1}$，贡献+1，若$a_i&lt;a_{i-1}$，贡献-1.相等没有贡献。</p><p>问：构造完所有可能的序列之后的贡献和，请$mod\;1e9+7$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为贡献只取决于第i位和第i-1位，然后其他位置随便取，则为该贡献$*m^{n-2}.$</p><p>然后从第二个位置开始枚举，假设枚举到了第i位。</p><p>第i位上可以取[1,m]之间的所有数，假设取一个j，则对于前一位来说有j-1个比它小,m-j个比它大。</p><p>所以贡献为$(j-1)+2*(m-j)。$</p><p>所以该位置上的总贡献为$[\sum_{j&#x3D;1}^m(j-1)+(m-j)]*m^{n-2}$</p><p>最后结合一下所有位置(注意是从第二位开始取)，贡献和为$$\sum_{i&#x3D;2}^n[\sum_{j&#x3D;1}^m(j-1)+2*(m-j)]*m^{n-2}$$</p><p>整理一下得： $$\frac{3m^2-3m}{2}*m^{n-2}*(n-1)$$</p><h2 id="Code（702MS）"><a href="#Code（702MS）" class="headerlink" title="Code（702MS）"></a>Code（702MS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    ll inv2 = <span class="built_in">quick_pow</span>(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = m * (<span class="number">3</span> * m - <span class="number">3</span>) % mod * inv2 % mod;</span><br><span class="line">        ans = ans * <span class="built_in">quick_pow</span>(m, n - <span class="number">2</span>) % mod * (n - <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/15/nowcoder-practice76-c/">https://blog.jujimeizuo.cn/2021/01/15/nowcoder-practice76-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛76 F-phi and phi 莫比乌斯反演+差分</title>
      <link href="/2021/01/15/nowcoder-practice76-f/"/>
      <url>/2021/01/15/nowcoder-practice76-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/10845/F">https://ac.nowcoder.com/acm/contest/10845/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解ans[i]&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\varphi (ij)\varphi [gcd(i,j)]$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前置技能：$\varphi(ij)&#x3D;\frac{\varphi(i) \varphi(j)gcd(i,j)}{\varphi[gcd(i,j)]}$</p><p>根据上式得： $$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\varphi (i)\varphi(j)gcd(i,j)$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\varphi (i)\varphi(j)[gcd(i,j)&#x3D;k]$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k}\right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k}\right \rfloor}\varphi (ik)\varphi(jk)[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k}\right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k}\right \rfloor}\varphi (ik)\varphi(jk)\sum_{di\;dj}\mu(d)$$</p><p>交换枚举顺序：</p><p>$$\sum_{k&#x3D;1}^nk\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k}\right \rfloor}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd}\right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{kd}\right \rfloor}\varphi (ikd)\varphi(jkd)$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k}\right \rfloor}\mu(d)[\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{kd}\right \rfloor}\varphi (ikd)]^2$$</p><p>令T&#x3D;kd并交换枚举顺序：</p><p>$$\sum_{T&#x3D;1}^{n}\sum_{kT}k\mu(\frac{T}{k})[\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{T}\right \rfloor}\varphi (iT)]^2$$</p><p>$由\varphi &#x3D; id*\mu得：$</p><p>$$\sum_{T&#x3D;1}^{n}\varphi(T)[\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{T}\right \rfloor}\varphi (iT)]^2$$</p><p>$设f(n&#x2F;T)&#x3D;\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{T}\right \rfloor}\varphi (iT)，则最终式为：$</p><p>$$ans[n]&#x3D;\sum_{T&#x3D;1}^n\varphi(T)[f(n&#x2F;T)]^2$$</p><p>但是这题要求的是ans[1 - n]，我们发现</p><p>$在枚举T时，n在[i*T,(i+1)*T)之间,\frac{n}{T}的值都一样，\varphi(T)[f(n&#x2F;T)]^2的贡献不变。$</p><p>$所以我们在求ans[n]的过程中，对i*T做一个差分，最后在求一个前缀和即可。$</p><h2 id="Code-445MS"><a href="#Code-445MS" class="headerlink" title="Code(445MS)"></a>Code(445MS)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">##pragma GCC <span class="title function_">optimize</span><span class="params">(<span class="number">2</span>)</span></span><br><span class="line">##include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">typedef <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">##define INF <span class="number">0x3f3f3f3f</span></span><br><span class="line">##define <span class="title function_">lowbit</span><span class="params">(x)</span> x &amp; (-x)</span><br><span class="line">##define <span class="title function_">mem</span><span class="params">(a, b)</span> memset(a , b , sizeof(a))</span><br><span class="line">##define <span class="title function_">FOR</span><span class="params">(i, x, n)</span> <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x;i &lt;= n; i++)</span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"> const <span class="type">ll</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line">const <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N * <span class="number">3</span>], prime[N * <span class="number">3</span>], num;</span><br><span class="line">ll phi[N * <span class="number">3</span>], ans[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>; num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++num] = i; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= num &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n; scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> <span class="number">1</span>;T &lt;= n; T++) &#123;</span><br><span class="line">        <span class="type">ll</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n / T; i++) &#123;</span><br><span class="line">            sum = (sum + phi[i * T]) % mod;</span><br><span class="line">            ans[i * T] = (ans[i * T] + phi[T] * sum % mod * sum % mod + mod) % mod;</span><br><span class="line">            ans[(i + <span class="number">1</span>) * T] = (ans[(i + <span class="number">1</span>) * T] - phi[T] * sum % mod * sum % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ans[i] = ((ans[i] + ans[i - <span class="number">1</span>]) % mod + mod) % mod;</span><br><span class="line">        printf(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/15/nowcoder-practice76-f/">https://blog.jujimeizuo.cn/2021/01/15/nowcoder-practice76-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 188 F- +1-1x2 记忆化搜索</title>
      <link href="/2021/01/14/atcoder-beginner-contest-188-f/"/>
      <url>/2021/01/14/atcoder-beginner-contest-188-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://atcoder.jp/contests/abc188/tasks/abc188_f">https://atcoder.jp/contests/abc188/tasks/abc188_f</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在只能在+1-1和*2三种操作的情况下，如果将X变为Y?</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为每次操作都会经过三次选择，是+1呢还是-1呢还是*2呢？</p><p>因为这个转移是从后往前转移，所以是将Y如何变为X即可，只不过*2变为&#x2F;2而已。</p><p>所以有一下转移方案：$()^{-1}$表示逆过程</p><p>在转移到为n时</p><ul><li>当n&lt;&#x3D;x时，$return \;\;n-x((-1)^{-1}$转移）</li><li>当n为任意数时，$return \;\;x-n（(+1)^{-1}$转移）</li><li>当n为偶数时，$return \;\;DFS(n &#x2F; 2)+1((*2)^{-1}$转移)</li><li>当n为奇数时，$return \;\;DFS((n-1) &#x2F; 2)+2(+1*2)^{-1}$转移</li><li>当n为奇数时，$return \;\;DFS((n+1)&#x2F;2)+2(-1*2)^{-1}$转移 <strong>最后取min即可。</strong></li></ul><p>看到上面有很多状态转移，所以我们可以在DFS过程中记忆化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">##include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll X, Y;</span><br><span class="line">map&lt;ll, ll&gt; dp;</span><br><span class="line"></span><br><span class="line">ll DFS(ll n) &#123;</span><br><span class="line">    if(X &gt;= n) return X - n; // 直接-1转移</span><br><span class="line">    if(dp[n]) return dp[n]; // 记忆化搜索</span><br><span class="line">    ll ans = n - X; // 直接+1转移</span><br><span class="line">    ans = min(ans, DFS(n / 2) + 1 + n % 2); // 偶数直接*2 或者 先+1在*2</span><br><span class="line">    if(n % 2) ans = min(ans, DFS(n / 2 + 1) + 2); // 先-1在*2</span><br><span class="line">    return dp[n] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">    cin &gt;&gt; X &gt;&gt; Y;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; DFS(Y) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/14/atcoder-beginner-contest-188-f/">https://blog.jujimeizuo.cn/2021/01/14/atcoder-beginner-contest-188-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> uncategorized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces - 786B Legacy 线段树建图+最短路</title>
      <link href="/2021/01/13/codeforces-786b/"/>
      <url>/2021/01/13/codeforces-786b/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/contest/786/problem/B">https://codeforces.com/contest/786/problem/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个星球，q条路径，问从一个起点为s的星球到其他星球的距离。</p><p>每条路径可能有以下三种形式：</p><ul><li>$1\;u\;v\;w$：一个点u到另一点v，路程为w</li><li>$2\;u\;l\;r\;w$：从一点u到[l,r]区间任意一个星球，路程为w</li><li>$3\;u\;l\;r\;w$：从[l,r]区间任意一个星球到另一点u，路程为w</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最短路问题，直接Dijkatra跑出来。不过这题考查的点是区间和点怎么建边。区间？线段树！！！</p><p>因为线段树里的一个点能代表一个区间，所以我们可以利用线段树建图。</p><p>因为有的操作是点连接区间，有的是区间连接点，所以一棵线段树是不够的，需要两棵线段树-一棵入树、一棵出树。</p><p>对于入树，我们认为他是区间连接点的线段树，所以叶子结点都要往父节点走，如图所示。</p><p><img src="/images/2021/01/20210131152026846.png"></p><p>对于出树，我们认为他是点连接区间的线段树，所以父节点要往叶子结点走，如图所示。</p><p><img src="/images/2021/01/20210131152112438.png"></p><p>这两棵线段树内部的边在建树的时候就建边，并且认为不需要路程。 而两棵树的叶子结点没有连，虽方便起见，我们可以整合成一幅图，如图所示：</p><p><img src="/images/2021/01/20210131152311495.png"></p><p>我们默认边都是从下指向上的（统一）。 这样就方便我们的三个操作： 如果是点与点建边，将入树的叶子结点与出树的叶子结点相连。 如果是点与区间建边，将入树的叶子结点与出树的区间结点相连。 如果是区间与点建边，将入树的区间结点与入树的叶子结点相连。</p><p>最后跑一遍最短路即可。</p><h2 id="Code-374MS"><a href="#Code-374MS" class="headerlink" title="Code(374MS)"></a>Code(374MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> head[maxn &lt;&lt; <span class="number">4</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idin[maxn &lt;&lt; <span class="number">4</span>], idout[maxn &lt;&lt; <span class="number">4</span>]; <span class="comment">// 入树和出树上点的编号</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">&#125;tin[N &lt;&lt; <span class="number">4</span>], tout[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot; <span class="comment">// 动态开点内存池</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up_in</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="comment">// 叶子结点向父节点连线</span></span><br><span class="line">    <span class="built_in">add</span>(tin[lc].id, tin[u].id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add</span>(tin[rc].id, tin[u].id, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up_out</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="comment">// 父节点向叶子结点连线</span></span><br><span class="line">    <span class="built_in">add</span>(tout[u].id, tout[lc].id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add</span>(tout[u].id, tout[rc].id, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_in</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tin[u].l = l; tin[u].r = r;</span><br><span class="line">    tin[u].id = ++tot;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        idin[l] = tin[u].id;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build_in</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build_in</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up_in</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_out</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tout[u].l = l; tout[u].r = r;</span><br><span class="line">    tout[u].id = ++tot;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        idout[l] = tout[u].id;</span><br><span class="line">        <span class="built_in">add</span>(idout[l], idin[l], <span class="number">0</span>); <span class="comment">// 两棵树的叶子结点以0距离连接</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build_out</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build_out</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up_out</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_in</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v, ll w)</span> </span>&#123; <span class="comment">// 点连接区间</span></span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= tout[u].l &amp;&amp; tout[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="built_in">add</span>(idin[v], tout[u].id, w);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tout[u].l + tout[u].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify_in</span>(lc, ql, qr, v, w);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify_in</span>(rc, ql, qr, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_out</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v, ll w)</span> </span>&#123; <span class="comment">// 区间连接点</span></span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= tin[u].l &amp;&amp; tin[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="built_in">add</span>(tin[u].id, idout[v], w);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tin[u].l + tin[u].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify_out</span>(lc, ql, qr, v, w);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify_out</span>(rc, ql, qr, v, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[maxn &lt;&lt; <span class="number">4</span>];</span><br><span class="line">ll dis[maxn &lt;&lt; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> now;</span><br><span class="line">    ll d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dij</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = p.now;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + e[i].w) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;v, dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="built_in">build_in</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">build_out</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> opt, l, r, u, v;</span><br><span class="line">        ll w;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="comment">// 规定连接都是由下往上，入树的点连接出树的点</span></span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(idin[u], idout[v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>) &#123; <span class="comment">// 点连接区间</span></span><br><span class="line">            cin &gt;&gt; u &gt;&gt; l &gt;&gt; r &gt;&gt; w;</span><br><span class="line">            <span class="built_in">modify_in</span>(<span class="number">1</span>, l, r, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>) &#123; <span class="comment">// 区间连接点</span></span><br><span class="line">            cin &gt;&gt; u &gt;&gt; l &gt;&gt; r &gt;&gt; w;</span><br><span class="line">            <span class="built_in">modify_out</span>(<span class="number">1</span>, l, r, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理所有点，线段树的叶子结点编号会超过n，，所以要多开几倍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">8</span> * n; i++) dis[i] = INF;</span><br><span class="line">    <span class="built_in">Dij</span>(idin[s]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[idin[i]] != INF) cout &lt;&lt; dis[idin[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/13/codeforces-786b/">https://blog.jujimeizuo.cn/2021/01/13/codeforces-786b/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客挑战赛47 F-简单题 莫比乌斯反演</title>
      <link href="/2021/01/12/nowcoder-challenge47-f/"/>
      <url>/2021/01/12/nowcoder-challenge47-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/10743/F">https://ac.nowcoder.com/acm/contest/10743/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^mgcd(i,j)\mu(ij)\varphi (ij)$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据积性函数和$\mu$的性质，只有i和j互质时才有贡献，不然$\mu(ij)&#x3D;0$ i和j互质时，$\varphi (ij)&#x3D;\varphi (i)\varphi (j)\;\;\mu(ij)&#x3D;\mu(i)\mu(j)\;\;gcd(i,j)&#x3D;1$</p><p>根据上述可得：</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;1]\varphi (i)\mu(i)\varphi (j)\mu(j)$$ $设f(i)&#x3D;\varphi (i)*\mu(i)，g(j)&#x3D;\varphi (j)*\mu(j)，则$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;1]f(i)g(j)$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^mf(i)g(j)\sum_{di\;dj}\mu(d)$$</p><p>交换枚举顺序：</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}\mu(d)\sum_{i&#x3D;1}^nf(i)[di]\sum_{j&#x3D;1}^mg(j)[dj]$$</p><p>根据上式，可以预处理$\varphi,\mu,f,g$函数。然后暴力求解，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) f[i] = phi[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) g[j] = phi[j];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>;d &lt;= <span class="built_in">min</span>(n, m); d++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mu[d]) <span class="keyword">continue</span>;</span><br><span class="line">    ll sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = d;i &lt;= n; i += d) sum1 += f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = d;j &lt;= m; j += d) sum2 += g[j];</span><br><span class="line">    ans = (ans + sum1 \* sum2 \* mu[d]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会T掉，因为d&#x3D;1时，n过大，那复杂度就是$O(n^2)$了。</p><p>需要 Dirichlet 前缀和优化即可。这是前缀和的几个版本：<a href="https://blog.csdn.net/weixin_45697774/article/details/111052242">Dirichlet 前缀和</a></p><p>Dirichlet 前缀和优化之后的复杂度为$O(n\log \log n)$，完全可以接受。</p><h2 id="Code-2512-MS"><a href="#Code-2512-MS" class="headerlink" title="Code(2512 MS)"></a>Code(2512 MS)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = (<span class="number">1ll</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> mu[N];</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) phi[i] *= mu[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) f[i] = phi[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) g[j] = phi[j];</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = n / prime[i];j &gt;= <span class="number">1</span>; j--) f[j] += f[j * prime[i]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = m / prime[i];j &gt;= <span class="number">1</span>; j--) g[j] += g[j * prime[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="built_in">min</span>(n, m); i++) &#123;</span><br><span class="line">            ans += <span class="number">1ll</span> * f[i] * g[i] * mu[i] % mod;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (ans + mod) % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2021/01/12/nowcoder-challenge47-f/">https://blog.jujimeizuo.cn/2021/01/12/nowcoder-challenge47-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 101 (Rated for Div. 2) D题 思维、构造</title>
      <link href="/2020/12/29/educational-codeforces-round-101-rated-for-div-2-d/"/>
      <url>/2020/12/29/educational-codeforces-round-101-rated-for-div-2-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/contest/1469/problem/D">https://codeforces.ml/contest/1469/problem/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一段序列$a_1…a_n，a_i&#x3D;i$，最多n+5次操作后，使序列变为n-1个1和1个2。 这个操作为，先选择两个数x和y，然后使$ax&#x3D;\left \lceil \frac{ax}{ay} \right \rceil$.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>辗转根号，这个操作在n&#x3D;2e5时，最多5*2次，每次$(n,\sqrt n)$需要两次。</p><p>对于每个区间$(\sqrt n, n)$，只需要选择(i,i+1)操作一次就变成1了。</p><p>总次数为n-7+5*2&#x3D;n+3次。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; v, <span class="built_in">x</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> t = n;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            a[++k] = t;</span><br><span class="line">            t = (<span class="type">int</span>) (<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        t = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == a[t]) &#123;</span><br><span class="line">                x[t * <span class="number">2</span>] = &#123;i, (<span class="type">int</span>)(<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(i)))&#125;;</span><br><span class="line">                x[t * <span class="number">2</span> - <span class="number">1</span>] = &#123;i, (<span class="type">int</span>)(<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(i)))&#125;;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> v.<span class="built_in">push_back</span>(&#123;i, i + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">size</span>() + k * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">            cout &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span> * k; i++) &#123;</span><br><span class="line">            cout &lt;&lt; x[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x[i].second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/29/educational-codeforces-round-101-rated-for-div-2-d/">https://blog.jujimeizuo.cn/2020/12/29/educational-codeforces-round-101-rated-for-div-2-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC济南站 铸铜记</title>
      <link href="/2020/12/28/2020icpc-jinan-summary/"/>
      <url>/2020/12/28/2020icpc-jinan-summary/</url>
      
        <content type="html"><![CDATA[<p>这是我大二第一枚铜牌，也是acm生涯第一枚铜牌，特记此站，再接再厉。</p><h2 id="赛前队内纠纷"><a href="#赛前队内纠纷" class="headerlink" title="赛前队内纠纷"></a>赛前队内纠纷</h2><p>在比赛的前几天，实验室里开了一场南京站的复现，本来队里还是兴致勃勃地比赛，很快的A掉了两题，比实验室里在南京站的银牌队A两题的速度还快一点点。但是到了第三题，已经有两题是可以写的，而且都过了100多人，但是yl选择写一道30多人过的题，而且有思路，所以我们让他先写完，过了40分钟，还是没有写完，然后居然和我说01背包怎么写，我的性子还好，跟他说了，又让他写了20多分钟，这时候我忍无可忍，就起了一点小矛盾，然后yl有事情就先走了，就剩下我和sg继续奋斗，但那个时候我哪有心情继续泄题呢？最终只A掉了两题，成为全实验室最菜的一队，虽然有队伍嘲讽我们，但是我还是没有理他，心态好才是真，不要在乎别人的眼光。</p><h2 id="赛前队内会议"><a href="#赛前队内会议" class="headerlink" title="赛前队内会议"></a>赛前队内会议</h2><p>由于队里起了矛盾，所以我们在星期五晚上开了1个多小时会议，我认为我们是有拿牌的实力，因为之前的省赛、CCPC长春站、ICPC上海站，题量都够了，但是罚时太高，所以场场打铁，为什么呢？因为某个人真的很容易上头，这可能和他的性格也有关系。但是我和另外一名队友都一直在劝说他不要上头，不要激动，但是南京站的模拟赛充分地表示这个会非开不可！在开会的过程中，每个人总结了自己的弱点，而yl也认识到自己的错误，在长达一个多小时的会议中，队里的心结算是好了一点点。</p><h2 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a>热身赛</h2><p>在热身赛的过程中，我充分地观察了yl的比赛情绪，发现是比以前好很多，并且在热身赛里，我们也A掉了两题，第三题由于没有时间了，所以就放弃了，但是我已经看到明天正式赛的我们是不会打铁的！</p><h2 id="正式赛拿牌！"><a href="#正式赛拿牌！" class="headerlink" title="正式赛拿牌！"></a>正式赛拿牌！</h2><p>在11点比赛前，每个人的心情都是非常激动的，同时情绪也是稳定的，所以我们等待迎接比赛的开始。 比赛开始后，很快啊，很快就A掉了4题，MGC三题我几乎几秒钟就能想到思路并且写出代码，但是由于怕wa掉，所以多测了几组样例，不过都是一发ac的，D题是yl立马想到了思路，然后也是一发ac。 在一个小时A掉了4题，而且都是一发入魂，这个时候我们排在第68名，在比赛一个小时后，我们队已经感到无比兴奋，但是这个时候不能松懈，因为在A掉一题或者两题有可能有银牌的希望。所以我们三个人继续读题、想思路，最先看的是L题，由于是找[0,L]之间满足的个数，所以我立马想到了数位dp，但是由于我不知道怎么转移的策略，并且看了过题人数很少，所以就放弃，转攻A题去了。A题是线代的题，我们队两个人有一点点线代的基础，所以这一题我认为是可以写的，而且过题人数很多，是非常有希望的。看了看样例，我就打保票，答案一定是是2的次方，高斯消元一定要的，但是不知道怎么写，而且没有一套完美的思路，一开始往异或方面想，然后发现A移过去就行了，只要求个矩阵求逆就行了，这个时候我非常自责，因为我是数学选手，但是我没有矩阵求逆的板子，赛后发现是异或方程组，那没事了，这锅我不背。所以这一题到最后也没有A掉。我们再看A的同时，yl继续看了J题，并且很快地写出了J的代码，他说就是一个染色问题，所以电脑一直交给他，我们造了好几组特殊样例都过了，但是始终都是wa，所以也没抱多大希望，就让他随便交题了，但是突然一瞬间！！！J题过了，那个时候我呆住了，而且不同以往，只wa了7发就过了，后来他说就少写了一行代码，不然可以不wa的，这已经没关系了，5题的我们对于拿牌已经无可阻挡了。赛后看排名，如果J题少wa几发，真的可以银牌了。（这个故事告诉我们，不要让队友随便交题，不然可以拿银牌哟~）。最终还是拿了铜牌，那个时候我无比地高兴，同时也期待以后的ACM比赛，希望再接再厉。</p><h2 id="赛后聚餐"><a href="#赛后聚餐" class="headerlink" title="赛后聚餐"></a>赛后聚餐</h2><p>比赛之后，我们队里去外面聚餐，同时分析了自己在这次比赛中的感想。大二的ICPC也结束了，所以只能打打cf啥的了。希望自己的cf先上个1600，在上个紫名。</p><p><strong>2020.12.17 狙击美佐</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/28/2020icpc-jinan-summary/">https://blog.jujimeizuo.cn/2020/12/28/2020icpc-jinan-summary/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC南京站 F题 Firworks 几何分布 + 三分</title>
      <link href="/2020/12/25/2020-icpc-nanjing-f/"/>
      <url>/2020/12/25/2020-icpc-nanjing-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/10272/F">https://ac.nowcoder.com/acm/contest/10272/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>n分钟做一个烟花，m分钟放掉所有做完的烟花。p的概率制造出完美的烟花。问最少的期望时间可以做出完美的烟花。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个烟花只有是不是完美的两种，所以是几何分布。而几何分布的期望为$\frac{1}{p}$，所以我们需要知道一次性做多少个烟花可以做出完美的烟花。</p><p>假设我们制造出k个烟花，然后一次性花m分钟释放完，其中就有完美的烟花，所以我们的总时间为$(n*k+m)$，而存在完美烟花的概率为$1-(1-p)^k$,所以做出一个完美烟花的期望为$\frac{1}{1-(1-p)^k}$，乘上时间，总期望时间为$\frac{(n*k+m)}{1-(1-p)^k}$。</p><p><strong>所以我们想知道这个k是多少。回答：三分答案。</strong></p><p>因为总期望时间函数不是单调的，所以二分不行的，需要三分。 即三分答案，枚举k，刚开始的区间为[1,10000]。取最小ans即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">quick_pow</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Clac</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (k * n + m) / (<span class="number">1</span> - <span class="built_in">quick_pow</span>(<span class="number">1</span> - p, k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lf&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">        p *= <span class="number">0.0001</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">100000</span>;</span><br><span class="line">        <span class="type">double</span> ans = (n + m) / p;</span><br><span class="line">        <span class="keyword">while</span>(r - l &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Clac</span>(mid1) &lt; <span class="built_in">Clac</span>(mid2)) r = mid2;</span><br><span class="line">            <span class="keyword">else</span> l = mid1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l;i &lt;= r; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">Clac</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/25/2020-icpc-nanjing-f/">https://blog.jujimeizuo.cn/2020/12/25/2020-icpc-nanjing-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019南昌邀请赛网络赛 J题 Distance on the tree 边权树剖 + 树上DFS序建主席树</title>
      <link href="/2020/12/23/2019-icpc-nanchang-yaoqing-j/"/>
      <url>/2020/12/23/2019-icpc-nanchang-yaoqing-j/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://nanti.jisuanke.com/t/38229">https://nanti.jisuanke.com/t/38229</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n个点，n-1条边，每条边都有边权。 m此询问，输出u到v这条简单路径上边权&lt;&#x3D;k的边数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先看到这道题，找到几个关键点。<strong>u到v、区间小于k的个数</strong></p><ul><li>u到v的简单路径，可以树剖将树化为数列进行模拟.</li><li>区间&lt;&#x3D;k的个数，在树的dfs序上建主席树。</li></ul><p>这题是边权，我们树剖完成之后，根据每个节点的深度，将边权给儿子作为点权。 <strong>根节点1就没有权值，所以我们将根节点的点权设为最大值，使主席树不影响。</strong></p><p>然后根据dfs序，建n颗主席树，最后利用前缀和的思想，得出答案。</p><p>root[0]这棵初始主席树建不建无所谓，都ok。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------建边-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[maxn &lt;&lt; <span class="number">1</span>], t;</span><br><span class="line"><span class="type">int</span> eg[N &lt;&lt; <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++t].v = v;</span><br><span class="line">    e[t].next = head[u];</span><br><span class="line">    head[u] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------轻重链剖分-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N], siz[N], fa[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u] = par] + (siz[u] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(!son[u]  siz[v] &gt; siz[son[u]])</span><br><span class="line">            son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tim, dfn[N], nodeof[N], top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">    nodeof[dfn[u] = ++tim] = u;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]  v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------树上主席树-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">int</span> cnt, root[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;hjt[N * <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x) - v.<span class="built_in">begin</span>() + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> l , <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    now = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(hjt[now].l, l, m);</span><br><span class="line">    <span class="built_in">build</span>(hjt[now].r, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> &amp;now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    hjt[now = ++cnt] = hjt[pre];</span><br><span class="line">    hjt[now].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="built_in">insert</span>(hjt[pre].l, hjt[now].l, l, m, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(hjt[pre].r, hjt[now].r, m + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> hjt[R].sum - hjt[L].sum;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= m) ans += <span class="built_in">query</span>(hjt[L].l, hjt[R].l, l, m, k);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans += hjt[hjt[R].l].sum - hjt[hjt[L].l].sum;</span><br><span class="line">        ans += <span class="built_in">query</span>(hjt[L].r, hjt[R].r, m + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_chain</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ans += <span class="built_in">query</span>(root[dfn[top[x]] - <span class="number">1</span>], root[dfn[x]], <span class="number">1</span>, n, k);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    ans += <span class="built_in">query</span>(root[dfn[x]], root[dfn[y]], <span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="comment">// 剖分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">        eg[i][<span class="number">0</span>] = u; eg[i][<span class="number">1</span>] = v; eg[i][<span class="number">2</span>] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 建树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[eg[i][<span class="number">0</span>]] &gt; dep[eg[i][<span class="number">1</span>]]) <span class="built_in">swap</span>(eg[i][<span class="number">0</span>], eg[i][<span class="number">1</span>]);</span><br><span class="line">        a[eg[i][<span class="number">1</span>]] = eg[i][<span class="number">2</span>];</span><br><span class="line">        v.<span class="built_in">push_back</span>(eg[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">build</span>(root[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">getid</span>(a[nodeof[i]]);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) x = n + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">insert</span>(root[i - <span class="number">1</span>], root[i], <span class="number">1</span>, n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        k = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), k) - v.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 第一个比k大于等于的数的下标</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_chain</span>(l, r, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line"><span class="comment">//    int size=40&lt;&lt;20;</span></span><br><span class="line"><span class="comment">//    __asm__ (&quot;movq %0,%%rsp\n&quot;::&quot;r&quot;((char*)malloc(size)+size));</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/23/2019-icpc-nanchang-yaoqing-j/">https://blog.jujimeizuo.cn/2020/12/23/2019-icpc-nanchang-yaoqing-j/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 186 A~F</title>
      <link href="/2020/12/21/atcoder-beginner-contest-186-af/"/>
      <url>/2020/12/21/atcoder-beginner-contest-186-af/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://atcoder.jp/contests/abc186/tasks">https://atcoder.jp/contests/abc186/tasks</a></p><hr><h2 id="A-Brick-签到"><a href="#A-Brick-签到" class="headerlink" title="A - Brick 签到"></a>A - Brick 签到</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; n / m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="B-Blocks-on-Grid-暴力"><a href="#B-Blocks-on-Grid-暴力" class="headerlink" title="B - Blocks on Grid 暴力"></a>B - Blocks on Grid 暴力</h2><p>先找矩阵最小值mx,最后找$ans&#x3D;mp[i][j] - mx$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">99999999</span>;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; mp[i][j];</span><br><span class="line">            mx = <span class="built_in">min</span>(mx, mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            ans += mp[i][j] - mx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="C-Unlucky-7-暴力"><a href="#C-Unlucky-7-暴力" class="headerlink" title="C - Unlucky 7 暴力"></a>C - Unlucky 7 暴力</h2><p>分别找十进制下和八进制中不出现7这个数的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">7</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tt = i;</span><br><span class="line">        <span class="type">bool</span> flag1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tt % <span class="number">10</span> == <span class="number">7</span>) &#123;</span><br><span class="line">                flag1 = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tt /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tt = i;</span><br><span class="line">        <span class="type">bool</span> flag2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tt % <span class="number">8</span> == <span class="number">7</span>) &#123;</span><br><span class="line">                flag2 = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tt /= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1  flag2) ans--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="D-Sum-of-difference-思维"><a href="#D-Sum-of-difference-思维" class="headerlink" title="D - Sum of difference 思维"></a>D - Sum of difference 思维</h2><p>先排序，在对每个数$a_j-a_i$取贡献。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    v[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += (sum[n] - sum[i]) - (n - i) * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="E-Throne-扩展欧几里得"><a href="#E-Throne-扩展欧几里得" class="headerlink" title="E - Throne 扩展欧几里得"></a>E - Throne 扩展欧几里得</h4><p>求$Kx+Ny&#x3D;N-S$的最小正整数x，有则输出，无则输出-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ex_gcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res, t;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">ex_gcd</span>(b, a % b, x, y);</span><br><span class="line">    t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve_ex_gcd</span><span class="params">(ll a, ll b, ll c, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll d = <span class="built_in">ex_gcd</span>(a, b, x, y);</span><br><span class="line">    <span class="keyword">if</span>(c % d)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>;</span><br><span class="line">        y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x *= (c / d);</span><br><span class="line">    b = <span class="built_in">abs</span>(b / d);</span><br><span class="line">    x %= b;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += b;</span><br><span class="line">    &#125;</span><br><span class="line">    y = (c - a * x) / b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll x, y;</span><br><span class="line">        ll N, S, K; cin &gt;&gt; N &gt;&gt; S &gt;&gt; K;</span><br><span class="line">        <span class="built_in">solve_ex_gcd</span>(K, N, N - S, x, y);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="F-Rook-on-Grid-扫描线-BIT"><a href="#F-Rook-on-Grid-扫描线-BIT" class="headerlink" title="F - Rook on Grid 扫描线 + BIT"></a>F - Rook on Grid 扫描线 + BIT</h2><p>我们到达一个点，有两种走法，<strong>先右在下和先下在右</strong>。 但是对于x&#x3D;1或y&#x3D;1的情况，有一个障碍堵在中间，那么也是走不到的，所以我们先找最小的x&#x3D;1是的y和最小的y&#x3D;1时的x，在把这两个障碍之后的所有格子都设为障碍。 然后记得去重（可能重复添加障碍）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> upx = H + <span class="number">1</span>, upy = W + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= M; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">        <span class="keyword">if</span>(p[i].x == <span class="number">1</span>) upy = <span class="built_in">min</span>(upy, p[i].y);</span><br><span class="line">        <span class="keyword">if</span>(p[i].y == <span class="number">1</span>) upx = <span class="built_in">min</span>(upx, p[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = upx + <span class="number">1</span>;i &lt;= H; i++) &#123;</span><br><span class="line">        p[++M].x = i; p[M].y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = upy + <span class="number">1</span>;j &lt;= W; j++) &#123;</span><br><span class="line">        p[++M].y = j; p[M].x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们怎么找那些去不到的格子呢？ 答：我们利用扫描线的思想，先纵向扫描，在横向搜索，在做ans贡献。</p><p>如果一个格子既不能右下走也不能下右走，那么这个格子到达不了。 纵向扫描： 用BIT维护右下路径被堵住的列，将这些格子视为到达不了。</p><p>横向搜索： 对于每一行，计算区间和，因为右下到不了，但是下右可能到达，所以我们将这些重新加回来。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        t[x]++;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ans += t[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Point &amp;a,<span class="type">const</span> Point &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> H, W, M;</span><br><span class="line">    cin &gt;&gt; H &gt;&gt; W &gt;&gt; M;</span><br><span class="line">    <span class="type">int</span> upx = H + <span class="number">1</span>, upy = W + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= M; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">        <span class="keyword">if</span>(p[i].x == <span class="number">1</span>) upy = <span class="built_in">min</span>(upy, p[i].y);</span><br><span class="line">        <span class="keyword">if</span>(p[i].y == <span class="number">1</span>) upx = <span class="built_in">min</span>(upx, p[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = upx + <span class="number">1</span>;i &lt;= H; i++) &#123;</span><br><span class="line">        p[++M].x = i; p[M].y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = upy + <span class="number">1</span>;j &lt;= W; j++) &#123;</span><br><span class="line">        p[++M].y = j; p[M].x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + M + <span class="number">1</span>);</span><br><span class="line">    M = <span class="built_in">unique</span>(p + <span class="number">1</span>, p + M + <span class="number">1</span>) - (p + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= M; i++) &#123;</span><br><span class="line">        <span class="comment">// 纵向扫描</span></span><br><span class="line">        <span class="keyword">if</span>(vis[p[i].y] == <span class="number">0</span>) &#123;</span><br><span class="line">            vis[p[i].y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">modify</span>(p[i].y, W);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 横向扫描</span></span><br><span class="line">        <span class="keyword">if</span>(i == M  p[i + <span class="number">1</span>].x != p[i].x) &#123;</span><br><span class="line">            ans += <span class="built_in">query</span>(W) - <span class="built_in">query</span>(p[h].y - <span class="number">1</span>);</span><br><span class="line">            h = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="number">1ll</span> * H * W - ans) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/21/atcoder-beginner-contest-186-af/">https://blog.jujimeizuo.cn/2020/12/21/atcoder-beginner-contest-186-af/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2020/12/21/codeforces-round-692-div2-c/"/>
      <url>/2020/12/21/codeforces-round-692-div2-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/contest/1465/problem/C">https://codeforces.ml/contest/1465/problem/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n*n的棋盘，有m个棋子，每个棋子都有一个坐标(x,y)。 问怎么移动使每个棋子都移动到棋盘的主对角线上，求最小移动数。</p><p>注意：每移动依次，不能使两个棋子在同一列或同一行。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有两种情况：</p><ul><li><strong>x等于y，不需要移动，理想情况</strong></li><li><strong>x不等于y，我们可以一步将棋子移到(x,x)或(y,y)，但是在那一列或那一行中已经有棋子了，所以将那一颗棋子移走，但是还有下一颗棋子也会占掉它的位置。</strong></li></ul><p>如果没有出现环的情况，而是一条链，那直接按照上面操作。 如果出现环的情况，先把一个棋子从环上移动变成链，只不过操作数+1而已。</p><p>处理有没有环只要用并查集判断即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) fa[i] = i;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="type">int</span> u = <span class="built_in">find</span>(x);</span><br><span class="line">                <span class="type">int</span> v = <span class="built_in">find</span>(y);</span><br><span class="line">                <span class="keyword">if</span> (u == v) cnt++;</span><br><span class="line">               fa[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/21/codeforces-round-692-div2-c/">https://blog.jujimeizuo.cn/2020/12/21/codeforces-round-692-div2-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 185 A~F</title>
      <link href="/2020/12/20/atcoder-beginner-contest-185-af/"/>
      <url>/2020/12/20/atcoder-beginner-contest-185-af/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://atcoder.jp/contests/abc185/tasks">https://atcoder.jp/contests/abc185/tasks</a></p><h2 id="A-ABC-Preparation-签到"><a href="#A-ABC-Preparation-签到" class="headerlink" title="A - ABC Preparation 签到"></a>A - ABC Preparation 签到</h2><p>取4个数中最小的一个。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(a, <span class="built_in">min</span>(b, <span class="built_in">min</span>(c, d))) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Smartphone-Addiction-模拟"><a href="#B-Smartphone-Addiction-模拟" class="headerlink" title="B - Smartphone Addiction 模拟"></a>B - Smartphone Addiction 模拟</h2><p>暴力模拟，只要中中途中电量&lt;0，直接输出No。 注意最后一次完成后回家的那一段。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll A, B;</span><br><span class="line">&#125;t[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m, T;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) cin &gt;&gt; t[i].A &gt;&gt; t[i].B;</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        ans -= t[i].A - t[i - <span class="number">1</span>].B;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + t[i].B - t[i].A &gt; n ? n : ans + t[i].B - t[i].A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt; T - t[m].B) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Duodecim-Ferra-排列组合"><a href="#C-Duodecim-Ferra-排列组合" class="headerlink" title="C - Duodecim Ferra 排列组合"></a>C - Duodecim Ferra 排列组合</h2><p>简单推导一波$ans&#x3D;C_{n-1}^{11}$</p><p>注意会爆long long，所以我选择Java大数。</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> Scanner in = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> PrintStream out = <span class="keyword">new</span> <span class="built_in">PrintStream</span>(System.out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> BigInteger ans = BigInteger.<span class="built_in">valueOf</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = in.<span class="built_in">nextInt</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">11</span>;i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans = ans.<span class="built_in">multiply</span>(BigInteger.<span class="built_in">valueOf</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            ans = ans.<span class="built_in">divide</span>(BigInteger.<span class="built_in">valueOf</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        out.<span class="built_in">println</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Stamp-思维"><a href="#D-Stamp-思维" class="headerlink" title="D - Stamp 思维"></a>D - Stamp 思维</h2><p>找每两个都涂了颜色区间的最小值，然后计算贡献。 注意m&#x3D;0时直接输出1，因为1次就可以涂完。</p><h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line">ll a[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">    ll k = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) k = a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> k = <span class="built_in">min</span>(k, a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &amp;&amp; n != a[m]) k = <span class="built_in">min</span>(k, n - a[m]);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += (<span class="type">int</span>) <span class="built_in">ceil</span>(<span class="number">1.0</span> * (a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>) / k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n != a[m]) ans += (<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * (n - a[m]) / k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) ans = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Sequence-Matching-线性dp"><a href="#E-Sequence-Matching-线性dp" class="headerlink" title="E - Sequence Matching 线性dp"></a>E - Sequence Matching 线性dp</h2><p>有两个数组a和b，长度分别为n和m，求解删掉x个数后，a数组和b数组不同数的个数y，输出x+y。 考虑dp，dp[i][j]表示a数组选到了i个，b数组选到了第j个的x+y答案。</p><p>所以我们有以下四种状态转移：</p><ul><li>选择删掉$a_i$，保留b_j$，$f[i][j] &#x3D; min(f[i][j], f[i - 1][j] + 1)$</li><li>选择保留$a_i$，删掉b_j$，$f[i][j] &#x3D; min(f[i][j], f[i][j - 1] + 1)$</li><li>选择保留$a_i$，保留b_j$，$f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1])$</li><li>选择删掉$a_i$，保留b_j$，$f[i][j] &#x3D; min(f[i][j], f[i - 1][j - 1] + 1)$</li></ul><p>注意dp数组的初始化。</p><h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">B</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i++) cin &gt;&gt; B[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; j++)</span><br><span class="line">            f[i][j] = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == B[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Range-Xor-Query-线段树"><a href="#F-Range-Xor-Query-线段树" class="headerlink" title="F - Range Xor Query 线段树"></a>F - Range Xor Query 线段树</h2><p>一道单点修改，维护区间异或和的裸线段树。</p><h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].sum = t[lc].sum ^ t[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].sum = A[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[u].l == t[u].r) &#123;</span><br><span class="line">        t[u].sum = t[u].sum ^ v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">modify</span>(lc, p, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rc, p, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans ^= <span class="built_in">query</span>(lc, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  ans ^= <span class="built_in">query</span>(rc, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="type">int</span> opt, x, y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, x, y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这一场非常友好，我很喜欢。</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/20/atcoder-beginner-contest-185-af/">https://blog.jujimeizuo.cn/2020/12/20/atcoder-beginner-contest-185-af/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 5274 Dylans loves tree 树链剖分</title>
      <link href="/2020/12/20/hdu-5274/"/>
      <url>/2020/12/20/hdu-5274/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5274">http://acm.hdu.edu.cn/showproblem.php?pid=5274</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个树，每个节点都有权值，有两种操作：</p><ol><li>$0 \;x\; y$ 将x的权值改成y</li><li>$1 \;x \;y$ 将树上x到y的最短路径上权值出现奇数次的权值输出来，没有输出-1</li></ol><p>题目保证x到y的最短路径的出现次数的权值的奇数次最多有一个，（可能是0个）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目查询的树上x到y的最短路径，所以可以用树链剖分。 而且题目说奇数个最多出现1个，所以我们可以用树状数组维护区间异或和。</p><p>因为偶数次的异或和为0，但是如果区间的a[i]全是0，但是出现偶数次，那答案是-1，而不是0，所以我们维护w[i]+1，最后查询的答案-1，这样即使是0，也正好输出-1。</p><h2 id="Code（218MS）"><a href="#Code（218MS）" class="headerlink" title="Code（218MS）"></a>Code（218MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[maxn], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[maxn], dep[maxn], siz[maxn], son[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u] = par] + (siz[u] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i ; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(!son[u]  siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">            son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tim, dfn[maxn], top[maxn], nodeof[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">    nodeof[dfn[u] = ++tim] = u;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == son[u]  v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[maxn], n;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        t[x] ^= val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ans ^= t[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_chain</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ans ^= (<span class="built_in">query</span>(dfn[top[x]] - <span class="number">1</span>) ^ <span class="built_in">query</span>(dfn[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    ans ^= (<span class="built_in">query</span>(x - <span class="number">1</span>) ^ <span class="built_in">query</span>(y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        w[i]++;</span><br><span class="line">        <span class="built_in">modify</span>(dfn[i], w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> opt, x, y; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(dfn[x], w[x]);</span><br><span class="line">            <span class="built_in">modify</span>(dfn[x], w[x] = y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query_chain</span>(x, y) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/20/hdu-5274/">https://blog.jujimeizuo.cn/2020/12/20/hdu-5274/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces-235E-Number Challenge 莫比乌斯反演 + 记忆化gcd</title>
      <link href="/2020/12/18/codeforces-235e/"/>
      <url>/2020/12/18/codeforces-235e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.ml/problemset/problem/235/E">https://codeforces.ml/problemset/problem/235/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^a\sum_{j&#x3D;1}^b\sum_{k&#x3D;1}^cd(i\cdot j\cdot k)$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前置技能：$d(i\cdot j)&#x3D;\sum_{xi}\sum_{yj}[gcd(x,y)&#x3D;1]$</p><p>$$\sum_{i&#x3D;1}^a\sum_{j&#x3D;1}^b\sum_{k&#x3D;1}^cd(i\cdot j\cdot k)$$</p><p>$$\sum_{i&#x3D;1}^a\sum_{j&#x3D;1}^b\sum_{k&#x3D;1}^c\sum_{xi}\sum_{yj}\sum_{zk}[gcd(i,j)&#x3D;1][gcd(i,k)&#x3D;1][gcd(j,k)&#x3D;1]$$</p><p>改变枚举顺序：</p><p>$$\sum_{x&#x3D;1}^a\sum_{y&#x3D;1}^b\sum_{z&#x3D;1}^c\left \lfloor \frac{a}{x} \right \rfloor \left \lfloor \frac{b}{y} \right \rfloor \left \lfloor \frac{c}{z} \right \rfloor [gcd(x,y)&#x3D;1][gcd(x,z)&#x3D;1][gcd(y,z)&#x3D;1]$$</p><p>x,y,z看得不习惯，还是换成i,j,k吧。</p><p>$$\sum_{i&#x3D;1}^a\sum_{j&#x3D;1}^b\sum_{k&#x3D;1}^c\left \lfloor \frac{a}{i} \right \rfloor \left \lfloor \frac{b}{j} \right \rfloor \left \lfloor \frac{c}{k} \right \rfloor [gcd(i,j)&#x3D;1][gcd(i,k)&#x3D;1][gcd(j,k)&#x3D;1]$$</p><p>$$\sum_{i&#x3D;1}^a\sum_{j&#x3D;1}^b\sum_{k&#x3D;1}^c\left \lfloor \frac{a}{i} \right \rfloor \left \lfloor \frac{b}{j} \right \rfloor \left \lfloor \frac{c}{k} \right \rfloor[gcd(i,j)&#x3D;1][gcd(i,k)&#x3D;1]\sum_{dj\;dk}\mu(d)$$</p><p>枚举d：</p><p>$$\sum_{i&#x3D;1}^a\left \lfloor \frac{a}{i} \right \rfloor\sum_{d&#x3D;1}^{min(b,c)}\mu(d)\sum_{j&#x3D;1}^{\left \lfloor \frac{b}{d} \right \rfloor}\left \lfloor \frac{b}{jd} \right \rfloor[gcd(i,jd)&#x3D;1]\sum_{k&#x3D;1}^{\left \lfloor \frac{c}{d} \right \rfloor} \left \lfloor \frac{c}{kd} \right \rfloor[gcd(i,kd)&#x3D;1]$$</p><p>枚举i和d，先使gcd(i,d)&#x3D;1，在枚举j，使gcd(i,j)&#x3D;1，即可使gcd(i,jd)&#x3D;1 k部分同理。</p><p>在计算gcd的过程中，用f[][]记忆化gcd，会有很大的优化。</p><h2 id="Code（622MS）"><a href="#Code（622MS）" class="headerlink" title="Code（622MS）"></a>Code（622MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1073741824</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>; is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ll f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[a][b]) <span class="keyword">return</span> f[a][b];</span><br><span class="line">    <span class="keyword">return</span> f[a][b] = (b ? <span class="built_in">gcd</span>(b, a % b) : a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> d, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i][d]) <span class="built_in">gcd</span>(i, d);</span><br><span class="line">    <span class="keyword">if</span>(f[i][d] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n / d; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i][j]) <span class="built_in">gcd</span>(i, j);</span><br><span class="line">        <span class="keyword">if</span>(f[i][j] == <span class="number">1</span>) res += n / (j * d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= a; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>;d &lt;= <span class="built_in">min</span>(b, c); d++) &#123;</span><br><span class="line">            ans = (ans + (a / i) * mu[d] * <span class="built_in">sum</span>(i, d, b) * <span class="built_in">sum</span>(i, d, c)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/18/codeforces-235e/">https://blog.jujimeizuo.cn/2020/12/18/codeforces-235e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3979 遥远的国度 树剖换根</title>
      <link href="/2020/12/18/luogu-p3979/"/>
      <url>/2020/12/18/luogu-p3979/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P3979">https://www.luogu.com.cn/problem/P3979</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵点数为n的树，每个点都有一个权值，（初始根不一定为1），接下来m个操作：</p><ul><li>$1\;id$，将根修改为id</li><li>$2\;x\;y\;val$，将x到y的简单路径上所有点的权值修改为val</li><li>$3\;x$，在根为root下，询问以x为根的子树的最小值。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>虽然树根不一定为1，但是我们轻重链剖分，线段树维护序列，都按照以1为根来做。 操作二我们还是一样，线段树修改x到y的简单路径上的权值。$modify \_ chain(x,y,val)$。</p><p>关键是操作三，如果树根一直都是1的话，就是$query(1,dfn[x],dfn[x]+siz[x]-1)$</p><p><strong>但是树根一直在变！！！</strong>所以这是一道树剖换根!</p><p>如果我们每次在换根的时候重新剖分，那复杂度会爆炸！所以不可能一直剖分。</p><p>先来观察树根和x的位置关系。</p><ul><li>$root&#x3D;&#x3D;x\;$答案就是[1,n]区间最小的值，即t[1].mn</li></ul><p><img src="/images/2020/12/20201218171300292.png"></p><ul><li><p>$LCA(root,x)&#x3D;&#x3D;x \;\&amp;\&amp;\; dep[root]&gt;dep[x]$</p><p><img src="/images/2020/12/20201218171820439.png"></p></li></ul><p>这种情况要求x的子树中最小值，只需要去除LCA的儿子$LCA\_son$的子树区域，剩下的取最小即可。</p><p>$ans&#x3D;min(query(1,1,dfn[LCA\_son]-1),query(1,dfn[LCA\_son]+siz[LCA\_son],n))$</p><ul><li>else</li></ul><p><img src="/images/2020/12/20201218172242239.png"></p><p>x不是root的LCA，那么只需要查询x的子树即可。 $ans &#x3D; query(1,dfn[x],dfn[x]+siz[x]-1)$</p><h2 id="Code（85MS）"><a href="#Code（85MS）" class="headerlink" title="Code（85MS）"></a>Code（85MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line">ll w[<span class="number">10000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------前向星建边---------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">&#125;e[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------轻重链剖分----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> siz[N], dep[N], fa[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u] = par] + (siz[u] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(!son[u]  siz[v] &gt; siz[son[u]])</span><br><span class="line">            son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top[N], dfn[N], nodeof[N], tim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">    nodeof[dfn[u] = ++tim] = u;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]  v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------线段树维护---------------*/</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll mn, tag;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].mn = <span class="built_in">min</span>(t[lc].mn, t[rc].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t[u].tag) <span class="keyword">return</span> ;</span><br><span class="line">    t[lc].mn = t[u].tag;</span><br><span class="line">    t[rc].mn = t[u].tag;</span><br><span class="line">    t[lc].tag = t[u].tag;</span><br><span class="line">    t[rc].tag = t[u].tag;</span><br><span class="line">    t[u].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r; t[u].tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].mn = w[nodeof[l]];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        t[u].mn = v;</span><br><span class="line">        t[u].tag = v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(lc, ql, qr, v);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify</span>(rc, ql, qr, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) <span class="keyword">return</span> t[u].mn;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    ll ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(lc, ql, qr));</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  ans = <span class="built_in">min</span>(ans, <span class="built_in">query</span>(rc, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_chain</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, dfn[top[x]], dfn[x], v);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, dfn[x], dfn[y], v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------LCA---------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> LCA_son; <span class="comment">// 公共祖先儿子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    LCA_son = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(fa[top[x]] == y) LCA_son = top[x];</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(!LCA_son) LCA_son = son[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;root);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> opt; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;opt);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> id; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;id);</span><br><span class="line">            root = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y; ll v; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;v);</span><br><span class="line">            <span class="built_in">modify_chain</span>(x, y, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x == root)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,t[<span class="number">1</span>].mn);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">LCA</span>(x, root) == x &amp;&amp; dep[root] &gt; dep[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfn[LCA_son] + siz[LCA_son] &lt;= n)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">min</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, dfn[LCA_son] - <span class="number">1</span>), <span class="built_in">query</span>(<span class="number">1</span>, dfn[LCA_son] + siz[LCA_son], n)));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, dfn[LCA_son] - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>, dfn[x], dfn[x] + siz[x] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="type">int</span> size=<span class="number">40</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    __asm__ (<span class="string">&quot;movq %0,%%rsp\n&quot;</span>::<span class="string">&quot;r&quot;</span>((<span class="type">char</span>*)<span class="built_in">malloc</span>(size)+size));</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/18/luogu-p3979/">https://blog.jujimeizuo.cn/2020/12/18/luogu-p3979/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC上海站 E题 The Journey of Geor Autumn 组合数学 + dp</title>
      <link href="/2020/12/18/2020-icpc-shanghai-e/"/>
      <url>/2020/12/18/2020-icpc-shanghai-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9925/E">https://ac.nowcoder.com/acm/contest/9925/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有多少个满足1…n的全排列中，i &gt; k时，$a_i&gt;min_{j\in[i-k,i)}a_j。(n\ge10^7\;k\ge10^7)$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>[1，n]的区间里，因为i&gt;k时才会有要求，所以将最小的数放在[1,k]当中。</p><p>设位置为pos，则</p><ul><li>[1,pos)的数随便放，有$C_{n-1}^{pos-1}*(pos-1)!$种方案</li><li>(pos,n]的方法就又要要求了，假设方案数为$f[n-pos]$</li></ul><p>所以我们得出</p><p>$$f[n]&#x3D;\sum_{j&#x3D;1}^{min(n,k)}C_{n-1}^{j-1}*(j-1)!*f[n-j]$$</p><p>这样我们就要递归出子问题了，即：</p><p>$$f[i]&#x3D;\sum_{j&#x3D;1}^{min(i,k)}C_{i-1}^{j-1}*(j-1)!*f[i-j]$$</p><p>所以暴力O(nk)的状态转移的话，就应该这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">zhuanyi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="built_in">min</span>(i, k); j++) &#123;</span><br><span class="line">            f[i] += f[i - j] \* <span class="built_in">C</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) \* fac[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是O(nk)是1e14的复杂度，这远远超标了，所以我们要优化以下，将转移方程优化为：</p><p>$$f[i]&#x3D;(i-1)!*\sum_{j&#x3D;1}^{min(i,k)}\frac{f[i-j]}{(i-j)!}$$</p><p>可以看到，等式右边就是一个前缀和，所以转移的过程中维护前缀和即可。</p><p>所以我们先预处理阶乘和阶乘逆元，在前缀和优化即可。</p><h2 id="Code（345MS）"><a href="#Code（345MS）" class="headerlink" title="Code（345MS）"></a>Code（345MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[N], invfac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    invfac[N - <span class="number">1</span>] = <span class="built_in">quick_pow</span>(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>;i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        invfac[i - <span class="number">1</span>] = invfac[i] * i % mod;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">     cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">     f[<span class="number">0</span>] = sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">         f[i] = (sum[i - <span class="number">1</span>] - (i - k - <span class="number">1</span> &gt;= <span class="number">0</span> ? sum[i - k - <span class="number">1</span>] : <span class="number">0</span>)) * fac[i - <span class="number">1</span>] % mod;</span><br><span class="line">         sum[i] = (sum[i - <span class="number">1</span>] + f[i] * invfac[i] % mod) % mod;</span><br><span class="line">     &#125;</span><br><span class="line">     cout &lt;&lt; (f[n] % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/18/2020-icpc-shanghai-e/">https://blog.jujimeizuo.cn/2020/12/18/2020-icpc-shanghai-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC上海站 D题 Walker 分类讨论+二分</title>
      <link href="/2020/12/17/2020-icpc-shanghai-d/"/>
      <url>/2020/12/17/2020-icpc-shanghai-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9925/D">https://ac.nowcoder.com/acm/contest/9925/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一段[0,n]的区间内，有两个人分别站在p1和p2的位置，都有各自的速度v1,v2。 问：如何用最少时间能覆盖[0,n]区间，也就是怎么走完全程？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果一直分类讨论的话，官方解答是有13种，不过就凭我们这个猪脑子怎么可能想出来，所以我们就按以下三种分别讨论。</p><ul><li>一个人走完全程 $ans &#x3D; min((min(n - p1, p1)+n)&#x2F;v1,(min(n-p2,p2)+n)&#x2F;v2)$</li><li>两个人对向走完全程 $ans&#x3D;min(ans, max((n-p1)&#x2F;v1, p2&#x2F;v2))$</li><li>两个人分别以一个间断点mid，p1走[0,mid]，p2走[mid,n]，走完全程 二分mid，然后取最小值。</li></ul><h2 id="Code（55MS）"><a href="#Code（55MS）" class="headerlink" title="Code（55MS）"></a>Code（55MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Clac</span><span class="params">(<span class="type">double</span> n, <span class="type">double</span> p, <span class="type">double</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>(n - p, p) + n) / v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="type">double</span> n, p1, v1, p2, v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf%lf&quot;</span>,&amp;n,&amp;p1,&amp;v1,&amp;p2,&amp;v2);</span><br><span class="line">        <span class="keyword">if</span>(p1 &gt; p2) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(p1, p2); <span class="built_in">swap</span>(v1, v2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> ans;</span><br><span class="line">        <span class="comment">// 一个人走完</span></span><br><span class="line">        ans = <span class="built_in">min</span>(<span class="built_in">Clac</span>(n, p1, v1), <span class="built_in">Clac</span>(n, p2, v2));</span><br><span class="line">        <span class="comment">// 两个人对向走完</span></span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>((n - p1) / v1, p2 / v2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以mid为分界线，二分求最小</span></span><br><span class="line">        <span class="type">double</span> l = p1, r = p2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">double</span> mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="type">double</span> ans1 = <span class="built_in">Clac</span>(mid, p1, v1);</span><br><span class="line">            <span class="type">double</span> ans2 = <span class="built_in">Clac</span>(n - mid, p2 - mid, v2);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(ans1, ans2));</span><br><span class="line">            <span class="keyword">if</span>(ans1 &lt;= ans2) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sovle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果当时没有死磕这道题，那就会有大量的时间做其他题了。</strong> <strong>这是第三次死盯一道题，如果还有下次，不可能有下次了！！！</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/17/2020-icpc-shanghai-d/">https://blog.jujimeizuo.cn/2020/12/17/2020-icpc-shanghai-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC上海站 I题 Sky Garden 数学推导+思维</title>
      <link href="/2020/12/17/2020-icpc-shanghai-i/"/>
      <url>/2020/12/17/2020-icpc-shanghai-i/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/9925/I">https://ac.nowcoder.com/acm/contest/9925/I</a> 参考：<a href="https://blog.csdn.net/qq_43750980/article/details/111297783">https://blog.csdn.net/qq_43750980&#x2F;article&#x2F;details&#x2F;111297783</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个同心圆，圆心都为（0，0），半径依次递增1,2…n 有m条直线将这n个圆等分成2*m份，直线和圆会有交点。 一个交点走向另一个交点只能走有线的路径。</p><p>求所有点对距离和。</p><p>$$\sum_{i,j\in R\;i\ne j}dis(i,j)$$</p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>这题关键是一个点怎么走向另一个点，这很重要！ 首先猜测两个结论：</p><ul><li><p><strong>结论一：在同一圆上的两点，最短距离为min(两点最短弧长，圆的直径)。</strong></p><p><img src="/images/2020/12/20201217202523462.png"></p></li><li><p><strong>结论二：不同圆上的两点，外圆需要沿直径走向内圆的大一圈的外圆，再按照结论一走。</strong></p><p><img src="/images/2020/12/.png"></p></li></ul><p>所以我们可以从小圆推到大圆，接下来就开始操作。</p><ol><li><p><strong>首先预处理半径为1时，一个点到其他所有点的距离和。</strong></p></li><li><p><strong>维护两个数组，a[i]和b[i]</strong> a[i]表示[1,i]个圆内，从1个点出发到该圆内其他所有点的距离和</p><p>b[i]表示在第i个圆上，从1个点出发到该圆上其他所有点的距离和</p></li><li><p><strong>从i&#x3D;2开始递推，从第i-1个圆推向第i个圆时</strong> b[i]只是从半径为1增大了i倍，所以b[i] &#x3D; b[1] * i（结论一） a[i]首先要先加b[i]和a[i -1]，所以第i和i-1层以内都处理好了。 接着就是第i层的点到所有内层点的距离怎么算? 只需要将第i个圆内层所有点（包括第i个圆上所有点）往里进一层即可（结论二）</p><ol start="4"><li><strong>O(n)处理每一层圆得答案</strong></li></ol></li></ol><p>具体看代码</p><h2 id="Code（3MS）"><a href="#Code（3MS）" class="headerlink" title="Code（3MS）"></a>Code（3MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"> <span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  一个点到其他所有点的总距离和（半径为1）   */</span></span><br><span class="line">    <span class="type">double</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(PI * i &lt; <span class="number">2.0</span> * m) cnt += PI * i / m;</span><br><span class="line">        <span class="keyword">else</span> cnt += <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt *= <span class="number">2.0</span>; cnt += <span class="number">2.0</span>;</span><br><span class="line">    a[<span class="number">1</span>] = b[<span class="number">1</span>] = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a[i]表示[1,i]个圆内，从1个点出发到该圆内其他所有点的距离和</span></span><br><span class="line">    <span class="comment">// b[i]表示在第i个圆上，从1个点出发到该圆上其他所有点的距离和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  O(n)递推，从第1个圆推到第n个圆  */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 半径扩大i倍（结论一支撑）</span></span><br><span class="line">        b[i] = b[<span class="number">1</span>] * i;</span><br><span class="line">        <span class="comment">// 内层的每一个点都要往里走一层，每一层的一个点需要走2*m次，然后的2*m的走法根据之前推的走法走（结论二支撑）</span></span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + b[i] + <span class="number">2.0</span> * m * (i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  O(n)求解答案  */</span></span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ans += <span class="number">2.0</span> * m * (a[i] - b[i]) + <span class="number">2.0</span> * m / <span class="number">2.0</span> * b[i];</span><br><span class="line">        <span class="comment">// m * b[i] 表示，第i个圆上，任意两点之间的距离和，因为2*m点，但是会重复计算1倍，所以要除2</span></span><br><span class="line">        <span class="comment">// 2 * m * (a[i] - b[i]) 表示，第i个圆上任意一点到该圆内其他所有点的距离和，因为有2*m个点（去掉第i个圆上的点距离和）</span></span><br><span class="line">        <span class="keyword">if</span>(m &gt; <span class="number">1</span>) ans += <span class="number">2.0</span> * i * m; <span class="comment">// m&gt;1即原点也算一点，特殊处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sovle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/17/2020-icpc-shanghai-i/">https://blog.jujimeizuo.cn/2020/12/17/2020-icpc-shanghai-i/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第七场】C题 A National Pandemic</title>
      <link href="/2020/12/10/2020-nowcoder-shujia7-c/"/>
      <url>/2020/12/10/2020-nowcoder-shujia7-c/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5672/C">https://ac.nowcoder.com/acm/contest/5672/C</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，每个节点的初始权值为0，有以下三种操作：</p><ul><li>$1\; x\; w$，将所以点的权值都加上w-dis(x,y)，dis为x到y的最短路径的边数</li><li>$2\; x$，将x点与0取较小值min(x, 0)。</li><li>$3\; x$，查询x点的权值。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一个操作中，不难想到与LCA的联系，即：</p><p>$&#x3D;w-dis(1,x)-dis(1,y)+dis(1, lca(x, y))$ $&#x3D;w-dep[x]-dep[y]+dis[lca(x,y)]$</p><p><strong>这里的dep[1]是从0开始算的，不是dep[1] &#x3D;1;</strong></p><p>每次操作1的时候，都会对每个点增加w-dep[x]和减去每个点的dep[y] 所以用一个全局变量Sum维护w-dep[x]，用num维护的操作一的次数即可。</p><p>那么怎么维护dis[lca(x,y)]呢？先来看看这个图：</p><p><img src="/images/2020/12/20201211140940270.png"></p><p>所以我们不用每次求两个点的LCA，那样做复杂度爆炸!</p><p><strong>我们只需要将根节点1到节点x之间的简单路径每次增加2即可。</strong></p><p><strong>因为对于其他点，当我们查询dis(1,y)时，只增加经过lca到节点1之间的权值，而y到lca之间的权值没有增加，我们也不想要增加，这样就得到我们想要的效果。</strong></p><p>对于维护树上路径的权值，我们可以先轻重链剖分，再用线段树维护即可。</p><p>=&#x3D;注意：我们用线段树维护的是树上路径的点权值，而不是边权值，dis是边数，又n个点有n-1条边，也就是每次进行操作一的时候重复加上1个2了，所以我们减去num*2。&#x3D;&#x3D;</p><p>对于操作2，只有x的权值&gt;0时，才会与0进行比较。</p><p>可以先求出x点的权值，如果大于0，开一个del数组维护一下 即$del[x] +&#x3D; (f &gt; 0 ?: f:0)$</p><p>这样做之后，每次求权值的时候都减去del[x]就行了。</p><p><strong>最后注意一下初始化就ac了。</strong></p><h2 id="Code（336MS）"><a href="#Code（336MS）" class="headerlink" title="Code（336MS）"></a>Code（336MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------建边-----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, next;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------轻重链剖分----------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> siz[N], fa[N], dep[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[fa[u] = par] + (siz[u] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == par) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(!son[u]  siz[v] &gt; siz[son[u]])</span><br><span class="line">            son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top[N], nodeof[N], dfn[N], tim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">    nodeof[dfn[u] = ++tim] = u;</span><br><span class="line">    top[u] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u];i ; i = e[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == son[u]  v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------线段树------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, tag;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].sum = t[lc].sum + t[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t[u].tag) <span class="keyword">return</span> ;</span><br><span class="line">    t[lc].sum += t[u].tag * (t[lc].r - t[lc].l + <span class="number">1</span>);</span><br><span class="line">    t[rc].sum += t[u].tag * (t[rc].r - t[rc].l + <span class="number">1</span>);</span><br><span class="line">    t[lc].tag += t[u].tag;</span><br><span class="line">    t[rc].tag += t[u].tag;</span><br><span class="line">    t[u].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r; t[u].tag = t[u].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        t[u].sum += (t[u].r - t[u].l + <span class="number">1</span>) * v;</span><br><span class="line">        t[u].tag += v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(lc, ql, qr, v);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify</span>(rc, ql, qr, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans += <span class="built_in">query</span>(lc, ql, qr);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  ans += <span class="built_in">query</span>(rc, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_chain</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, dfn[top[x]], dfn[x], val);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, dfn[x], dfn[y], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query_chain</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ans += <span class="built_in">query</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    ans += <span class="built_in">query</span>(<span class="number">1</span>, dfn[x], dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll Sum, num;</span><br><span class="line">ll del[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = tim = Sum = num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">mem</span>(dfn, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mem</span>(siz, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mem</span>(e, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mem</span>(son, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mem</span>(del, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mem</span>(dep, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">mem</span>(head, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _; cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            <span class="built_in">add</span>(u, v);</span><br><span class="line">            <span class="built_in">add</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">// w - dep[x] - dep[y] + 2 * dep[lca(x, y)]</span></span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="type">int</span> opt; cin &gt;&gt; opt;</span><br><span class="line">            <span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x, val; cin &gt;&gt; x &gt;&gt; val;</span><br><span class="line">                Sum += val - dep[x];</span><br><span class="line">                num++;</span><br><span class="line">                <span class="built_in">modify_chain</span>(<span class="number">1</span>, x, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">                ll f = Sum - num * dep[x] + <span class="built_in">query_chain</span>(<span class="number">1</span>, x) - del[x] - <span class="number">2</span> * num;</span><br><span class="line">                <span class="keyword">if</span>(f &gt; <span class="number">0</span>) del[x] += f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">                cout &lt;&lt; Sum - num * dep[x] + <span class="built_in">query_chain</span>(<span class="number">1</span>, x) - del[x] - <span class="number">2</span> * num &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/10/2020-nowcoder-shujia7-c/">https://blog.jujimeizuo.cn/2020/12/10/2020-nowcoder-shujia7-c/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-2019 ICPC (NWERC 2018) A题 Access Points 构造单调</title>
      <link href="/2020/12/06/2018-2019-icpc-nwerc-2018-a/"/>
      <url>/2020/12/06/2018-2019-icpc-nwerc-2018-a/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://codeforces.com/gym/102483/problem/A">https://codeforces.com/gym/102483/problem/A</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出n个点的$a（x_i,y_i）$，然后在二维平面中构造n个点，构造的点可以重合。 构造点的要求为：若为第i和第j个点，$（i&lt;j）$，则$(x_i&lt;&#x3D;x_j，y_i&lt;&#x3D;y_j)$ 贡献为$\sum_{i&#x3D;1}^np_i-a_i^2$，求最小贡献。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先将题面转化一下为:$\sum_{i&#x3D;1}^n(p_{ix}-a_{i_x})^2+(p_{iy}-a_{i_y})^2$</p><p>看到x和y是相互独立的，所以只需要写出一个函数，然后在套一个即可。</p><p>根据题意，我们构造的p在[1,n]上要是单调递增的。 $那么怎么求最小的\sum_{i&#x3D;1}^n(p_{ix}-a_{ix})^2？$</p><p>分析以下几种情况：</p><ul><li>a是单调递增的，那根本不用想，让$p_{ix}&#x3D;a_{ix}$，答案为0.</li><li>a全为一个数，那p也为a的平均值，答案也为0.</li><li>a是不递增的，这是本题的关键，因为p是递增的，如果a越来越小，而p越来越大，那该怎么构造呢？</li></ul><p>当a是单调递增的时候，非常好构造所以我们不让a有递减的部分，也就是把任意形式的a都转化为单调递增。</p><p>我们对于a中一段的串，取一个平均值，再处理下一个串，使当前串的平均值要大于上一个串的平均值，我们要做到将一段长度的平均值递增即可。</p><p>问题：怎么维护一段长度平均值递增？</p><p>回答：暴力$O(n^2) No$，单调栈即可。</p><p>我们用单调栈维护一段串的平均值递增即可，因为x和y独立，所以y也是如此。</p><h4 id="Code（62MS）"><a href="#Code（62MS）" class="headerlink" title="Code（62MS）"></a>Code（62MS）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll x[N], y[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(ll *A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    stack&lt;pair&lt;ll, <span class="type">int</span>&gt; &gt; s;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ll a = A[i]; <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>().first * l &gt;= s.<span class="built_in">top</span>().second * a) &#123; <span class="comment">// 使栈内平均值递增</span></span><br><span class="line">            l += s.<span class="built_in">top</span>().second;</span><br><span class="line">            a += s.<span class="built_in">top</span>().first;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(&#123;a, l&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = n;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">double</span> tmp = <span class="number">1.0</span> * s.<span class="built_in">top</span>().first / s.<span class="built_in">top</span>().second;</span><br><span class="line">        <span class="type">int</span> l = s.<span class="built_in">top</span>().second;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; l; j++) &#123;</span><br><span class="line">            ans += (tmp - A[i - j]) * (tmp - A[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        i -= l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;x[i], &amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span> ,<span class="built_in">sum</span>(x, n) + <span class="built_in">sum</span>(y, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/06/2018-2019-icpc-nwerc-2018-a/">https://blog.jujimeizuo.cn/2020/12/06/2018-2019-icpc-nwerc-2018-a/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPOJ COT Count on a tree 树上主席树 + LCA</title>
      <link href="/2020/12/04/spoj-cot-count-on-a-tree-%E6%A0%91%E4%B8%8A%E4%B8%BB%E5%B8%AD%E6%A0%91-lca/"/>
      <url>/2020/12/04/spoj-cot-count-on-a-tree-%E6%A0%91%E4%B8%8A%E4%B8%BB%E5%B8%AD%E6%A0%91-lca/</url>
      
        <content type="html"><![CDATA[<h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><p>可持久化线段树、LCA</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵树，求(u,v)的最短路径之间第k小的值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到第k小值就是到可以用主席树维护了。 但是一般的主席树是维护一段数列，求区间内的第k值。 不过没关系，我们可以在遍历树的同时建主席树。</p><p>那么怎么能求第k值呢？</p><p>我们知道主席树也有前缀和的思想，所以我们需要一个媒介点，通过这个点达到前缀和的目的。</p><p>与树上两个点有联系的点，那就是LCA–最近公共祖先。</p><p>所以我们可以在求LCA_DFS(u, pre)的同时建主席树，同时有需要建的根节点和前一版本的根节点。</p><p>然后就是查询部分，根据下图：</p><p><img src="/images/2020/12/20201204164217510.png"></p><p>答案为： $query(root[l], \;root[r],\; root[lca],\; root[fa[lca][0]],\; 1,\; n,\;k)$</p><p>在递归过程中，比较hjt[hjt[ql].l].val + hjt[hjt[qr].l].val - hjt[hjt[lca].l].val - hjt[hjt[falca].l].val与k的大小来判断要进入左子树还是右子树。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, next;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> idx, head[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">55</span>], depth[N], lg[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;hjt[N * <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], root[N], cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++idx].v = v;</span><br><span class="line">    e[idx].next = head[u];</span><br><span class="line">    head[u] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), x) - vec.<span class="built_in">begin</span>() + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> &amp;now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    hjt[now = ++cnt] = hjt[pre];</span><br><span class="line">    hjt[now].val++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) <span class="built_in">insert</span>(hjt[pre].l, hjt[now].l, l, m, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(hjt[pre].r, hjt[now].r, m + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> lca, <span class="type">int</span> falca, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tmp = hjt[hjt[ql].l].val + hjt[hjt[qr].l].val - hjt[hjt[lca].l].val - hjt[hjt[falca].l].val;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= tmp) <span class="keyword">return</span> <span class="built_in">query</span>(hjt[ql].l, hjt[qr].l, hjt[lca].l, hjt[falca].l, l, m, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(hjt[ql].r, hjt[qr].r, hjt[lca].r, hjt[falca].r, m + <span class="number">1</span>, r, k - tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u1, <span class="type">int</span> u2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[u1] &lt; depth[u2]) <span class="built_in">swap</span>(u1, u2);</span><br><span class="line">    <span class="keyword">while</span>(depth[u1] &gt; depth[u2])</span><br><span class="line">        u1 = fa[u1][lg[depth[u1] - depth[u2]] - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(u1 == u2) <span class="keyword">return</span> u1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = lg[depth[u1]] - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u1][i] != fa[u2][i]) &#123;</span><br><span class="line">            u1 = fa[u1][i];</span><br><span class="line">            u2 = fa[u2][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u1][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LCA_DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = pre;</span><br><span class="line">    depth[u] = depth[pre] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">insert</span>(root[pre], root[u], <span class="number">1</span>, n, <span class="built_in">getid</span>(a[u])); <span class="comment">// 沿路径建主席树（前缀和）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= lg[depth[u]]; i++) &#123;</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].v != pre)</span><br><span class="line">            <span class="built_in">LCA_DFS</span>(e[i].v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; vec.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    vec.<span class="built_in">erase</span>(<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] == i);</span><br><span class="line">    <span class="built_in">LCA_DFS</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> lca = <span class="built_in">LCA</span>(l, r);</span><br><span class="line">        <span class="comment">// root[l] + root[r] - root[lca] - root[fa[lca][0]]前缀和思想</span></span><br><span class="line">        cout &lt;&lt; vec[<span class="built_in">query</span>(root[l], root[r], root[lca], root[fa[lca][<span class="number">0</span>]], <span class="number">1</span>, n, k) - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/04/spoj-cot-count-on-a-tree-%E6%A0%91%E4%B8%8A%E4%B8%BB%E5%B8%AD%E6%A0%91-lca/">https://blog.jujimeizuo.cn/2020/12/04/spoj-cot-count-on-a-tree-树上主席树-lca/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6562 Lovers 2018CCPC-吉林站 线段树（超硬核）</title>
      <link href="/2020/12/04/hdu-6562/"/>
      <url>/2020/12/04/hdu-6562/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6562">http://acm.hdu.edu.cn/showproblem.php?pid=6562</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n个空串和m个操作，操作有两种：</p><ul><li>$wrap：l，r，d，将[l,r]所有的串首尾都加上一个d，例如33，首尾加个5就变成5335.$</li><li>$query：l，r，输出\sum_{i&#x3D;l}^{r}a[i]$</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到更新和查询操作，就知道这题百分之九十九是线段树了，然后看到数据量很大，就知道要懒惰标记了。</p><p>所有我们建一棵线段树维护什么呢？</p><ul><li>首先就是[l,r]的区间和sum。$sum&#x3D;\sum_{i&#x3D;l}^{r}a[i].$<ul><li>字符串首尾增加字符，需要这段数字的长度，所以还需要len来存。$len&#x3D;\sum_{i&#x3D;l}^r10^{len(a[i])}.$</li><li>剩下就是懒惰标记了，维护字符串首更新的值lazl，维护字符串尾更新的值lazr，还有一个lazlen，来维护长度的变化。</li></ul></li></ul><p>所以我们有下面的树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum, len;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lazl, lazr, lazlen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>线段树有建树、区间更新、区间查询三种操作，当然还有标记上传、下传等。</p><ul><li>建树略。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    t[u].sum = t[u].lazl = t[u].lazr = <span class="number">0</span>;</span><br><span class="line">    t[u].lazlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u); <span class="comment">// 标记上传</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>区间查询略。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u); <span class="comment">// 标记下传</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans = (ans + <span class="built_in">query</span>(lc, ql, qr)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  ans = (ans + <span class="built_in">query</span>(rc, ql, qr)) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最难的就是区间更新，希望读者能手动自己写一写。</li></ul><p>首先给出Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].sum = (t[lc].sum + t[rc].sum) % mod;</span><br><span class="line">    t[u].len = (t[lc].len + t[rc].len) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[u].lazlen == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    t[lc].sum = (t[lc].sum * t[u].lazlen % mod + (mid - t[u].l + <span class="number">1</span>) * t[u].lazr % mod + t[u].lazl * t[lc].len % mod * t[u].lazlen % mod) % mod;</span><br><span class="line">    t[rc].sum = (t[rc].sum * t[u].lazlen % mod + (t[u].r - mid) * t[u].lazr % mod + t[u].lazl * t[rc].len % mod * t[u].lazlen % mod) % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].len = t[lc].len * t[u].lazlen % mod * t[u].lazlen % mod;</span><br><span class="line">    t[rc].len = t[rc].len * t[u].lazlen % mod * t[u].lazlen % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].lazl = (t[lc].lazl + t[u].lazl * t[lc].lazlen) % mod;</span><br><span class="line">    t[rc].lazl = (t[rc].lazl + t[u].lazl * t[rc].lazlen) % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].lazr = (t[lc].lazr * t[u].lazlen + t[u].lazr) % mod;</span><br><span class="line">    t[rc].lazr = (t[rc].lazr * t[u].lazlen + t[u].lazr) % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].lazlen = t[lc].lazlen * t[u].lazlen % mod;</span><br><span class="line">    t[rc].lazlen = t[rc].lazlen * t[u].lazlen % mod;</span><br><span class="line"></span><br><span class="line">    t[u].lazl = t[u].lazr = <span class="number">0</span>;</span><br><span class="line">    t[u].lazlen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        t[u].sum = (t[u].sum * <span class="number">10</span> + (t[u].r - t[u].l + <span class="number">1</span>) * v + t[u].len * <span class="number">10</span> * v) % mod;</span><br><span class="line">        t[u].len = t[u].len * <span class="number">100</span> % mod;</span><br><span class="line">        t[u].lazl = (t[u].lazl + t[u].lazlen * v) % mod;</span><br><span class="line">        t[u].lazr = (t[u].lazr * <span class="number">10</span> + v) % mod;</span><br><span class="line">        t[u].lazlen = t[u].lazlen * <span class="number">10</span> % mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(lc, ql, qr, v);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify</span>(rc, ql, qr, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$区间更新：$</p><ul><li>sum：首先原数字sum乘10给新增数字留一个尾位，由于是区间内每一个数都要加上d，所以加上(r-l+1)*d，还有还剩下一个首位，只需加上sum的长度len * 10 * d即可。</li><li>len：加了两个是数字，所以乘10^2即可。</li><li>lazl：原来的lazl加上新增的，为维护长度的lazlen*d。</li><li>lazr：在末尾在加一个v，为原来的lazr*10+v。</li><li>lazlen：新增两个数字，每次只需乘1个10就行了，需要用的时候乘两个lazlen即可。</li></ul><p>懒惰标记下传（可以直接手操一波）：</p><ul><li>孩子的sum：中间（孩子的sum乘父亲的lazlen）加上左边（父亲的lazr乘父亲的lazlen乘孩子的长度len）再加上右边（孩子的区间长度乘父亲的lazr）。</li><li>孩子的len：孩子的len乘父亲的lazlen乘父亲的lazlen。</li><li>孩子的lazl：孩子的lazl加上父亲的lazl乘上孩子的lazlen。</li><li>孩子的lazr：孩子的lazr乘父亲的lazlen+父亲的lazr。</li><li>孩子的lazlen：孩子的lazlen乘父亲的lazlen。</li><li>最后初始化父亲的懒惰变量。</li></ul><p>线段树代码量大不是没有原因的，但这一题还永远不是尽头！</p><h2 id="Code（2012MS）"><a href="#Code（2012MS）" class="headerlink" title="Code（2012MS）"></a>Code（2012MS）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, len;</span><br><span class="line">    ll lazl, lazr, lazlen;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    t[u].sum = (t[lc].sum + t[rc].sum) % mod;</span><br><span class="line">    t[u].len = (t[lc].len + t[rc].len) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[u].lazlen == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    t[lc].sum = (t[lc].sum * t[u].lazlen % mod + (mid - t[u].l + <span class="number">1</span>) * t[u].lazr % mod + t[u].lazl * t[lc].len % mod * t[u].lazlen % mod) % mod;</span><br><span class="line">    t[rc].sum = (t[rc].sum * t[u].lazlen % mod + (t[u].r - mid) * t[u].lazr % mod + t[u].lazl * t[rc].len % mod * t[u].lazlen % mod) % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].len = t[lc].len * t[u].lazlen % mod * t[u].lazlen % mod;</span><br><span class="line">    t[rc].len = t[rc].len * t[u].lazlen % mod * t[u].lazlen % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].lazl = (t[lc].lazl + t[u].lazl * t[lc].lazlen) % mod;</span><br><span class="line">    t[rc].lazl = (t[rc].lazl + t[u].lazl * t[rc].lazlen) % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].lazr = (t[lc].lazr * t[u].lazlen + t[u].lazr) % mod;</span><br><span class="line">    t[rc].lazr = (t[rc].lazr * t[u].lazlen + t[u].lazr) % mod;</span><br><span class="line"></span><br><span class="line">    t[lc].lazlen = t[lc].lazlen * t[u].lazlen % mod;</span><br><span class="line">    t[rc].lazlen = t[rc].lazlen * t[u].lazlen % mod;</span><br><span class="line"></span><br><span class="line">    t[u].lazl = t[u].lazr = <span class="number">0</span>;</span><br><span class="line">    t[u].lazlen = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u].l = l; t[u].r = r;</span><br><span class="line">    t[u].sum = t[u].lazl = t[u].lazr = <span class="number">0</span>;</span><br><span class="line">    t[u].lazlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        t[u].len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rc, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        t[u].sum = (t[u].sum * <span class="number">10</span> + (t[u].r - t[u].l + <span class="number">1</span>) * v + t[u].len * <span class="number">10</span> * v) % mod;</span><br><span class="line">        t[u].len = t[u].len * <span class="number">100</span> % mod;</span><br><span class="line">        t[u].lazl = (t[u].lazl + t[u].lazlen * v) % mod;</span><br><span class="line">        t[u].lazr = (t[u].lazr * <span class="number">10</span> + v) % mod;</span><br><span class="line">        t[u].lazlen = t[u].lazlen * <span class="number">10</span> % mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) <span class="built_in">modify</span>(lc, ql, qr, v);</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  <span class="built_in">modify</span>(rc, ql, qr, v);</span><br><span class="line">    <span class="built_in">push_up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(u);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) ans = (ans + <span class="built_in">query</span>(lc, ql, qr)) % mod;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)  ans = (ans + <span class="built_in">query</span>(rc, ql, qr)) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _, Case = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; Case++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            string s; cin &gt;&gt; s &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;wrap&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>, l, r, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, l, r) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/12/04/hdu-6562/">https://blog.jujimeizuo.cn/2020/12/04/hdu-6562/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白月赛17 J-计数 组合计数</title>
      <link href="/2020/11/19/nowcoder-newbie17-j/"/>
      <url>/2020/11/19/nowcoder-newbie17-j/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/1085/J">https://ac.nowcoder.com/acm/contest/1085/J</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个含有n个数字的序列，每个数的大小是不超过1000的正整数，同时这个序列是个单调不增序列。但是很不幸的是，序列在保存过程中有些数字丢失了，请你根据上述条件，计算出有多少种不同的序列满足上述条件，答案对1000000007取模。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="方法一：隔板法"><a href="#方法一：隔板法" class="headerlink" title="方法一：隔板法"></a>方法一：隔板法</h4><p>假如连续一段有n个0，所以需要在这n个位置中插入数，而插入的数为[1,m]（大家应该能看出来）。 所以我们假设[1,m] 中1出现$a_1$次，m出现$a_m$次。即i出现$a_i$次。 所以要将这些数字插入n个位置中，即统计他们可以出现的次数，即</p><p>$$n&#x3D;a_1+a_2+…+a_m（0\leq a_i \leq n）$$</p><p>等价于n个小球放进m个盒子里，隔板法即可，由于$a_i$可以等于0，所以我们让每一个盒子都是事先放进1个小球，即n+m，这样求出的方案为$C_{n+m-1}^{m-1}$，每一种方案为一种序列。</p><h2 id="Code（159MS）"><a href="#Code（159MS）" class="headerlink" title="Code（159MS）"></a>Code（159MS）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll fac[N];</span><br><span class="line">ll inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span>()</span> &#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[N - <span class="number">1</span>] = quick_pow(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = N - <span class="number">2</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    ll ans = fac[m] * inv[n] % mod * inv[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>();</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">int</span> pre = <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(!x) cnt++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> len = pre - x + <span class="number">1</span>;</span><br><span class="line">            ans = ans * C(cnt + len - <span class="number">1</span>, len - <span class="number">1</span>) % mod;</span><br><span class="line">            pre = x;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt) &#123;</span><br><span class="line">        ans = ans * C(cnt + pre - <span class="number">1</span>, pre - <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：单调不增变单调递减"><a href="#方法二：单调不增变单调递减" class="headerlink" title="方法二：单调不增变单调递减"></a>方法二：单调不增变单调递减</h3><p>$将单调不增序列变为点掉递减序列，只需将i位置上的数+(n-i+1)即可。$</p><p>$对于一段连续为0的区间，就不需要考虑会取同样的值，直接在可以选择的数中选出n个即可。$</p><p>$假设可以取的值有m个，那么方案数为C_{m}^n$</p><p>$注意0和n位置也要处理。$</p><h3 id="Code（159MS）-1"><a href="#Code（159MS）-1" class="headerlink" title="Code（159MS）"></a>Code（159MS）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll fac[N];</span><br><span class="line">ll inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span>()</span> &#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[N - <span class="number">1</span>] = quick_pow(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = N - <span class="number">2</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    ll ans = fac[m] * inv[n] % mod * inv[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>();</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1000</span> + n; a[n] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i])</span><br><span class="line">            a[i] += n - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> suf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(suf)</span><br><span class="line">                ans = ans * C(a[suf] - a[i] - <span class="number">1</span>, i - suf - <span class="number">1</span>) % mod;</span><br><span class="line">            suf = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/19/nowcoder-newbie17-j/">https://blog.jujimeizuo.cn/2020/11/19/nowcoder-newbie17-j/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC 江西省大学生程序设计竞赛A-A Simple Math Problem 莫比乌斯反演</title>
      <link href="/2020/11/16/2020-ccpc-jiangxi-shengsai-a/"/>
      <url>/2020/11/16/2020-ccpc-jiangxi-shengsai-a/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/8827/A">https://ac.nowcoder.com/acm/contest/8827/A</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^i[gcd(i,j)&#x3D;1]F[j]$$ $F[j]为j各个数位之和，例如F[123]&#x3D;1+2+3&#x3D;6。$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$前置技能：\varphi * id&#x3D;\mu\;\;\;\;\mu*I&#x3D;\varepsilon $ $先来看\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^iF[j]，可以直接等价于\sum_{i&#x3D;1}^n\sum_{j&#x3D;i}^nF[i]，可手动验证一下。$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^i[gcd(i,j)&#x3D;1]F[j]$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;i}^nF[i]\sum_{di\;dj}\mu(d)$$</p><p>$枚举d：$ $$\sum_{i&#x3D;1}^nF[i]\sum_{di}\mu(d)\sum_{\left \lfloor \frac{i}{d} \right \rfloor }^{\left \lfloor \frac{n}{d} \right \rfloor }1$$</p><p>$$\sum_{i&#x3D;1}^nF[i]\left ( \sum_{di}\mu(d)*(\frac{n-i}{d}) \right ) $$</p><p>$$\sum_{i&#x3D;1}^nF[i]\left ( \sum_{di}\mu(d)\frac{n}{d}-\sum_{di}\mu(d)\frac{i}{d}\right )$$</p><p>$设f(i)&#x3D;\sum_{di}\mu(d)\frac{n}{d}，\sum_{di}\mu(d)\frac{i}{d}&#x3D;\varphi，得：$</p><p>$$\sum_{i&#x3D;1}^nF[i]*(f(i)-\varphi(i))$$</p><p>$\mu、\varphi、F和f预处理，然后O(n)得答案。$</p><h2 id="Code（20MS）"><a href="#Code（20MS）" class="headerlink" title="Code（20MS）"></a>Code（20MS）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N], f[N], phi[N];</span><br><span class="line"><span class="built_in">int</span> F[N];</span><br><span class="line"><span class="built_in">bool</span> is_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Clac</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        res += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j]) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        F[i] = Clac(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = i;j &lt;= n; j += i) &#123;</span><br><span class="line">            f[j] += mu[i] * (n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Init();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        ans += <span class="number">1l</span>l * F[i] * (f[i] - phi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/16/2020-ccpc-jiangxi-shengsai-a/">https://blog.jujimeizuo.cn/2020/11/16/2020-ccpc-jiangxi-shengsai-a/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014 ICPC 西安区域赛 F - color 容斥原理</title>
      <link href="/2020/11/15/2014-icpc-%E8%A5%BF%E5%AE%89%E5%8C%BA%E5%9F%9F%E8%B5%9B-f-color-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2020/11/15/2014-icpc-%E8%A5%BF%E5%AE%89%E5%8C%BA%E5%9F%9F%E8%B5%9B-f-color-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://codeforces.com/gym/100548/attachments">http://codeforces.com/gym/100548/attachments</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n朵花，m种颜色，让你在m种颜色种选择k种在n多花种涂色，k种的每一种都要用到，而且相邻的花不能涂相同的颜色。问有多少种涂色方法？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先可知，m种选k种有$C_m^k$，然后每个人都可以想到这样的公式：$C_m^k*k*(k-1)^{n-1}$。 这个式子是说明n朵花中有涂大于1种并且小于等于k种颜色，也就是2，3…k-1，k种颜色的方案都有，而我们只要整好k种，那该怎么半呢？答案就是容斥。</p><p>怎么个容斥法呢？</p><p>例如有4种颜色1，2，3，4，在里面找3种颜色涂，可以找（1，2，3）和（1，2，4）。 根据$k*(k-1)^{n-1}$： 在（1，2，3）中，你会选择（1，2）这个方案，因为是小于等于k种，而在（1，2，4）中你也会选择（1，2）这个方案，所以我们重复选择了，需要把这种减掉。</p><p>学过容斥的都知道，容斥就是干这个事情的，那该怎么减去重复呢？</p><p>那就是k种的减去k-1种的，然后在加上k-2种的，就这样一加一减，减是因为要减掉重复的，加是因为把需要的也给减掉了，所以需要加上，容斥都是这个道理，总式子如下所示：</p><p>$$C_m^k\left ( \sum_{i&#x3D;1}^k(-1)^{k-i+1}C_k^i*i*(i-1)^{n-1} \right ) $$</p><p>O(n)预处理阶乘和阶乘逆元，方便组合数O(1)求出，$C_m^k$由于m太大，数组存不下，但是k只有1e6，所以直接暴力算就可以了，$C_m^k&#x3D;\frac{m!}{k!(m-k)!}&#x3D;invF[k]*\prod_{i&#x3D;m-k+1}^mi$，次幂直接快速幂即可。复杂度为$O(n)+O(Tn\log n)$</p><h2 id="Code（1996ms）"><a href="#Code（1996ms）" class="headerlink" title="Code（1996ms）"></a>Code（1996ms）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll f[N], invF[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++)&#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    invF[N - <span class="number">1</span>] = quick_pow(f[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = N - <span class="number">2</span>;i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        invF[i] = (invF[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span>(<span class="params">ll m, ll n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = f[m];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[m - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rongchi</span>(<span class="params">ll n, ll k</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = k;i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        ll res = <span class="number">1l</span>l * opt * i * quick_pow(i - <span class="number">1</span>, n - <span class="number">1</span>) % mod * C(k, i) % mod;</span><br><span class="line">        ans = (ans + res + mod) % mod;</span><br><span class="line">        opt *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">int</span> _;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="built_in">int</span> Case = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        ll n, m, k;</span><br><span class="line">        scanf(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        ll ans = rongchi(n, k);</span><br><span class="line">        <span class="keyword">for</span>(ll i = m - k + <span class="number">1</span>;i &lt;= m; i++) ans = ans * i % mod;</span><br><span class="line">        ans = ans * invF[k] % mod;</span><br><span class="line">        printf(<span class="string">&quot;Case ##%d: %lld\n&quot;</span>,Case++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/15/2014-icpc-%E8%A5%BF%E5%AE%89%E5%8C%BA%E5%9F%9F%E8%B5%9B-f-color-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/">https://blog.jujimeizuo.cn/2020/11/15/2014-icpc-西安区域赛-f-color-容斥原理/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020浙江省赛E Easy DP Problem 主席树</title>
      <link href="/2020/11/12/2020-zhejiang-shengsai-e/"/>
      <url>/2020/11/12/2020-zhejiang-shengsai-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/1319565562453364740">https://zoj.pintia.cn/problem-sets/91827364500/problems/1319565562453364740</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>根据题目dp的方向，直接判断出最后答案为1到(r-l+1)的平方和加上l到r区间前k大的值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>平方和直接可以公式$\frac{n(n+1)(2n+1)}{6}$。 区间前k大可以主席树套一下。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> a[N];</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; v;</span><br><span class="line"><span class="built_in">int</span> cnt, root[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">    <span class="built_in">int</span> l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="built_in">int</span> num;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">&#125;hjt[N * <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getid</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; <span class="keyword">return</span> lower_bound(v.begin(), v.end(), x) - v.begin() + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span>(<span class="params"><span class="built_in">int</span> pre, <span class="built_in">int</span> &amp;now, <span class="built_in">int</span> l, <span class="built_in">int</span> r, <span class="built_in">int</span> p, <span class="built_in">int</span> val</span>)</span> &#123;</span><br><span class="line">    now = ++cnt;</span><br><span class="line">    hjt[now] = hjt[pre];</span><br><span class="line">    hjt[now].num++; hjt[now].sum += val;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        hjt[now].val = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) insert(hjt[pre].l, hjt[now].l, l, m, p, val);</span><br><span class="line">    <span class="keyword">else</span> insert(hjt[pre].r, hjt[now].r, m + <span class="number">1</span>, r, p, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span>(<span class="params"><span class="built_in">int</span> L, <span class="built_in">int</span> R, <span class="built_in">int</span> l, <span class="built_in">int</span> r, <span class="built_in">int</span> k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> hjt[R].val * k;</span><br><span class="line">    <span class="built_in">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> tmp = hjt[hjt[R].r] .num - hjt[hjt[L].r].num;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= tmp) <span class="keyword">return</span> query(hjt[L].r, hjt[R].r, m + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> hjt[hjt[R].r].sum - hjt[hjt[L].r].sum + query(hjt[L].l, hjt[R].l, l, m, k - tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    v.clear();</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        v.push_back(a[i]); root[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    v.erase(unique(v.begin(), v.end()), v.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> _;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> t = getid(a[i]);</span><br><span class="line">            insert(root[i - <span class="number">1</span>], root[i], <span class="number">1</span>, n, t, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> q;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">int</span> l, r, k;</span><br><span class="line">            scanf(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">            <span class="built_in">int</span> t = r - l + <span class="number">1</span>;</span><br><span class="line">            ll ans = query(root[l - <span class="number">1</span>], root[r], <span class="number">1</span>, n, k);</span><br><span class="line">            printf(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1l</span>l * t * (t + <span class="number">1</span>) * (<span class="number">2</span> * t + <span class="number">1</span>) / <span class="number">6</span> + ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要是当时会写主席树就能有牌子了，可惜了。</strong></p><p><strong>这篇博客好水</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/12/2020-zhejiang-shengsai-e/">https://blog.jujimeizuo.cn/2020/11/12/2020-zhejiang-shengsai-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛72 D-brz的函数 莫比乌斯反演 + 差分</title>
      <link href="/2020/11/11/nowcoder-practice72-d/"/>
      <url>/2020/11/11/nowcoder-practice72-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/8282/D">https://ac.nowcoder.com/acm/contest/8282/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\mu(ij)$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$由积性函数的性质，当m和n互质的时候，\mu(mn)&#x3D;\mu(m)\mu(n)。即$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\mu(ij)&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\mu(i)\mu(j)[gcd(i,j)&#x3D;1]$$</p><p>$$&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\mu(i)\mu(j)\sum_{di\;\;dj}\mu(d)$$</p><p>$枚举d：$</p><p>$$&#x3D;\sum_{d&#x3D;1}^n\mu(d)\sum_{di}\mu(i)\sum_{dj}\mu(j)$$</p><p>$$&#x3D;\sum_{d&#x3D;1}^n\mu(d)\left ( \sum_{di}^n\mu(i) \right ) ^2$$</p><p>$$&#x3D;\sum_{d&#x3D;1}^n\mu(d)\left ( \sum_{i&#x3D;1}^{\frac{n}{d}}\mu(i*d) \right ) ^2$$ 我们枚举d，对于每一个n，都会有$kd\leq n &lt; (k+1)d$，所以在$kd$和$(k+1)d-1$之间都会对答案有贡献，所以可以先差分在取前缀和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> is_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"><span class="built_in">int</span> ans[N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> d = <span class="number">1</span>;d &lt; N; d++) &#123;</span><br><span class="line">        <span class="built_in">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = d;i &lt; N; i += d) &#123;</span><br><span class="line">            <span class="built_in">int</span> l = i;</span><br><span class="line">            <span class="built_in">int</span> r = min(l + d - <span class="number">1</span>, N);</span><br><span class="line">            tmp += mu[l];</span><br><span class="line">            ans[l] += mu[d] * tmp * tmp;</span><br><span class="line">            ans[r + <span class="number">1</span>] -= mu[d] * tmp * tmp;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">init</span>();</span><br><span class="line">    <span class="built_in">int</span> _;</span><br><span class="line">    cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        <span class="built_in">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; ans[x] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/11/nowcoder-practice72-d/">https://blog.jujimeizuo.cn/2020/11/11/nowcoder-practice72-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 ICPC 南昌邀请赛-Polynomial（拉格朗日插值法）</title>
      <link href="/2020/11/06/2019-icpc-nanchang-yaoqing-polnomial/"/>
      <url>/2020/11/06/2019-icpc-nanchang-yaoqing-polnomial/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://nanti.jisuanke.com/t/40254">https://nanti.jisuanke.com/t/40254</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$f(x)&#x3D;a_0+a_1x+…+a_nx^n，没有给出a_0,a_1…a_n，只知道f(0),f(1)…f(n)，求$ $$\sum_{i&#x3D;L}^Rf(i)\;\;mod\;\;9999991$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这个形式，就知道用拉格朗日插值法了，即</p><p>$$f[k]&#x3D;\sum_{i&#x3D;0}^ny_i\prod_{i\ne j}\frac{k-x[j]}{x[i]-x[j]}$$</p><p>但是题目中给出的点都是连续的，$(0,f(0))、(1,f(1))…(n,f(n))$，也就是x连续，所以插值式变为 $$f[k]&#x3D;\sum_{i&#x3D;0}^ny_i\prod_{i\ne j}\frac{k-j}{i-j}$$</p><p>所以一般的拉格朗日插值的复杂度为$O(n^2)$，而当x连续的时候，复杂度一度降为O(n)。</p><p>将上式展开：</p><p>$$f[k]&#x3D;\sum_{i&#x3D;0}^ny_i\frac{k(k-1)(k-2)…(k-n)}{[i(i-1)(i-2)…1]*[(-1)*(-2)*…*(i-n)]}$$</p><p>$$f[k]&#x3D;\sum_{i&#x3D;0}^ny_i\frac{\prod_{j&#x3D;0}^{i-1}(k-j)\prod_{j&#x3D;i+1}^n(k-j)}{i!*(i-n)!}$$</p><p>$$f[k]&#x3D;\sum_{i&#x3D;0}^ny_i\frac{pre[i-1]*suf[i+1]}{fac[i]*fac[n-i]}[(n-i) \&amp;1 ?-1:1]$$</p><p>对于分母，可以预处理阶乘和阶乘逆元。 对于分子，做一个前缀积和一个后缀积。</p><p>所以首先，先插出一个f(n+1)，在对f进行一个前缀和sum数组，然后直接对sum数组进行插值，计算sum[R]-sum[l-1]即可。</p><p>注意：为什么要插出一个f(n+1)，是因为要先对sum数组有插值这个影响，而sum又是f的前缀和，所以要先插出一个f(n+1)来，所以也可以插f(n+2)、f(n+3)都可以，只要有这个影响就行。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> MAXN = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">9999991</span>;</span><br><span class="line">ll F[N];</span><br><span class="line">ll pre[N], suf[N];</span><br><span class="line">ll fac[N], invf[N];</span><br><span class="line">ll sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span>()</span> &#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    invf[N - <span class="number">1</span>] = quick_pow(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = N - <span class="number">1</span>;i &gt;= <span class="number">1</span>; i--) invf[i - <span class="number">1</span>] = invf[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lagrange</span>(<span class="params">ll *f, <span class="built_in">int</span> k, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= n) <span class="keyword">return</span> f[k];</span><br><span class="line">    pre[<span class="number">0</span>] = suf[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) pre[i] = pre[i - <span class="number">1</span>] * (k - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = n;i &gt;= <span class="number">1</span>; i--) suf[i - <span class="number">1</span>] = suf[i] * (k - i) % mod;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> opt = (n - i) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        ans = (ans + <span class="number">1l</span>l * opt * pre[i] % mod * suf[i] % mod * invf[i] % mod * invf[n - i] % mod * f[i] % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[k] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">init</span>();</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">int</span> n, q;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= n; i++) cin &gt;&gt; F[i];</span><br><span class="line">        F[n + <span class="number">1</span>] = Lagrange(F, n + <span class="number">1</span>, n);</span><br><span class="line">        sum[<span class="number">0</span>] = F[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) sum[i] = (sum[i - <span class="number">1</span>] + F[i]) % mod;</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="built_in">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            cout &lt;&lt; (Lagrange(sum, r, n + <span class="number">1</span>) - Lagrange(sum, l - <span class="number">1</span>, n + <span class="number">1</span>) + mod) % mod &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/06/2019-icpc-nanchang-yaoqing-polnomial/">https://blog.jujimeizuo.cn/2020/11/06/2019-icpc-nanchang-yaoqing-polnomial/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式优化常系数齐次线性递推</title>
      <link href="/2020/11/04/polynomial-optimization-constant-coefficient-homogeneous-linear-recursion/"/>
      <url>/2020/11/04/polynomial-optimization-constant-coefficient-homogeneous-linear-recursion/</url>
      
        <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Troywar/p/9078013.html">https://www.cnblogs.com/Troywar/p/9078013.html</a> <a href="https://www.cnblogs.com/cjyyb/p/10152566.html">https://www.cnblogs.com/cjyyb/p/10152566.html</a> <a href="https://www.cnblogs.com/BAJimH/p/10574975.html">https://www.cnblogs.com/BAJimH/p/10574975.html</a> <a href="https://blog.csdn.net/jokerwyt/article/details/85345981?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.channel_param">https://blog.csdn.net/jokerwyt/article/details/85345981?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.channel_param&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.channel_param</a></p><h2 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h2><p>给出长为k的a数列$&lt;a_0,a_1…a_{k-1}&gt;$和一个无穷数列f的前k项$&lt;f_1,f_2…f_{k}&gt;$，求f_n。</p><p>$$f_n&#x3D;\sum_{i&#x3D;1}^ka_if_{k-i}$$</p><h2 id="不同做法的复杂度比较"><a href="#不同做法的复杂度比较" class="headerlink" title="不同做法的复杂度比较"></a>不同做法的复杂度比较</h2><ul><li>$暴力O(nk)$</li><li>$矩阵快速幂优化O(k^3\log n)$</li><li>$暴力多项式快速幂优化O(k^2\log n)$</li><li>$快速幂套NTT多项式取模优化O(k\log k\log n)$</li></ul><h2 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h2><p>矩阵快速幂求线性地推，从一个初始矩阵开始递推，用矩阵乘法，最后在和f相乘得答案。 这里主要的复杂度在于矩阵的阶数k，如果k很大很大，那还不如直接暴力，所以就有多项式的做法了。</p><p>和快速幂一样，把矩阵乘法换成多项式乘法，取模换成多项式取模。</p><p>多项式乘法可以用NTT加速。</p><p>多项式取模： $$A(x)&#x3D;B(x)D(x)+R(x)$$</p><p>已知A(x)和B(x)，求商D(x)和余数R(x)。</p><p>步骤：</p><ul><li>将多项式系数反转，使得最高次幂为n-m。设反转之后为$A_R(x)&#x3D;B_R(x)D_R(x) \;\;mod \;x^{n-m+1}$</li><li>$D(x)&#x3D;reverse(A_R(x)*B_R^{-1}(x))$，即A乘B的逆再反转即可。</li><li>R(x)直接用A(x)-B(x)D(x)得到。</li></ul><p>然后就到为什么可以用多项式处理常系数齐次线性递推。</p><p>由于笔者能力有限，只能看着大佬们的博客敲敲模板，详细解法不再赘述。</p><p>整理一下思路：</p><p>已知$f_n$，通过以下步骤得到$f_{2n}$：</p><ul><li>将表达系数多项式平方，使用FFT加速。$O(k \log k)$</li><li>将求得的多项式对特征多项式取模。$O ( k \log ⁡ k )$</li></ul><p>因此，要求得$f_n, 从f_1$倍增即可，就是上文说的多项式快速幂。而代码里的一些操作就是黑科技了。</p><p>笔者没有用NTT，直接用的任意模数MTT。使用方法为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">MTT</span>(<span class="params">ll *x, ll *y, ll *z, <span class="built_in">int</span> len</span>)</span></span><br><span class="line"><span class="function"><span class="comment">// 多项式x与y相乘得到z并返回，len为乘法中需要的长度。</span></span></span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">double</span> PI = acos(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Complex &#123;</span><br><span class="line">    <span class="built_in">double</span> x, y;</span><br><span class="line">    Complex(<span class="built_in">double</span> a = <span class="number">0</span>, <span class="built_in">double</span> b = <span class="number">0</span>): x(a), y(b) &#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> Complex(x + rhs.x, y + rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> Complex(x - rhs.x, y - rhs.y); &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex &amp;rhs) &#123; <span class="keyword">return</span> Complex(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span>()</span> &#123; <span class="keyword">return</span> Complex(x, -y); &#125;</span><br><span class="line">&#125; w[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getLen</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> len = <span class="number">1</span>; <span class="keyword">while</span> (len &lt; (n &lt;&lt; <span class="number">1</span>)) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  (i &amp; <span class="number">1</span> ? len &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) w[i] = w[i] = Complex(cos(<span class="number">2</span> * PI * i / len), sin(<span class="number">2</span> * PI * i / len));</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rever</span>(<span class="params">ll *f, <span class="built_in">int</span> n</span>)</span> &#123; <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;i &lt; j; i++, j--) swap(f[i], f[j]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span>(<span class="params">Complex *A, <span class="built_in">int</span> len</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span>(i &lt; tr[i]) swap(A[i], A[tr[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>, lyc = len &gt;&gt; <span class="number">1</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>, lyc &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; len; j += i) &#123;</span><br><span class="line">            Complex *l = A + j, *r = A + j + (i &gt;&gt; <span class="number">1</span>), *p = w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; i &gt;&gt; <span class="number">1</span>; k++) &#123;</span><br><span class="line">                Complex tmp = *r * *p;</span><br><span class="line">                *r = *l - tmp, *l = *l + tmp;</span><br><span class="line">                ++l, ++r, p += lyc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">MTT</span>(<span class="params">ll *x, ll *y, ll *z, <span class="built_in">int</span> len</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;</span><br><span class="line">    <span class="keyword">static</span> Complex a[N], b[N];</span><br><span class="line">    <span class="keyword">static</span> Complex dfta[N], dftb[N], dftc[N], dftd[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = Complex(x[i] &amp; <span class="number">32767</span>, x[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = Complex(y[i] &amp; <span class="number">32767</span>, y[i] &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    FFT(a, len), FFT(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> j = (len - i) &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">static</span> Complex da, db, dc, dd;</span><br><span class="line">        da = (a[i] + a[j].conj()) * Complex(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        db = (a[i] - a[j].conj()) * Complex(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">        dc = (b[i] + b[j].conj()) * Complex(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        dd = (b[i] - b[j].conj()) * Complex(<span class="number">0</span>, <span class="number">-0.5</span>);</span><br><span class="line">        dfta[j] = da * dc;</span><br><span class="line">        dftb[j] = da * dd;</span><br><span class="line">        dftc[j] = db * dc;</span><br><span class="line">        dftd[j] = db * dd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = dfta[i] + dftb[i] * Complex(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[i] = dftc[i] + dftd[i] * Complex(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    FFT(a, len), FFT(b, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> da = (ll)(a[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="built_in">int</span> db = (ll)(a[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="built_in">int</span> dc = (ll)(b[i].x / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        <span class="built_in">int</span> dd = (ll)(b[i].y / len + <span class="number">0.5</span>) % mod;</span><br><span class="line">        z[i] = (da + ((ll)(db + dc) &lt;&lt; <span class="number">15</span>) + ((ll)dd &lt;&lt; <span class="number">30</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Inv</span>(<span class="params">ll *f, ll *g, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123; g[<span class="number">0</span>] = quick_pow(f[<span class="number">0</span>], mod - <span class="number">2</span>); <span class="keyword">return</span> ; &#125;</span><br><span class="line">    Get_Inv(f, g, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> len = getLen(n);</span><br><span class="line">    <span class="keyword">static</span> ll c[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; len; i++) c[i] = i &lt; n ? f[i] : <span class="number">0</span>;</span><br><span class="line">    MTT(c, g, c, len); MTT(c, g, c, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++) g[i] = (<span class="number">2l</span>l * g[i] - c[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = n;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; len; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> len;</span><br><span class="line"><span class="built_in">int</span> n, k;</span><br><span class="line">ll a[N], h[N];</span><br><span class="line">ll ans[N], s[N];</span><br><span class="line">ll invG[N], G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mod</span>(<span class="params">ll *f,ll *g</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ll tmp[N];</span><br><span class="line">    rever(f, k + k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; k; i++) tmp[i] = f[i];</span><br><span class="line">    MTT(tmp, invG, tmp, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = k - <span class="number">1</span>; i &lt; len; i++) tmp[i] = <span class="number">0</span>;</span><br><span class="line">    rever(f, k + k - <span class="number">1</span>); rever(tmp, k - <span class="number">1</span>);</span><br><span class="line">    MTT(tmp, G, tmp, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; k; i++) g[i] = (f[i] + mod - tmp[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = k;i &lt; len; i++) g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; len; i++) tmp[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fpow</span>(<span class="params"><span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">    s[<span class="number">1</span>] = <span class="number">1</span>; ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123; MTT(ans, s, ans, len);</span><br><span class="line">        Mod(ans, ans); &#125;</span><br><span class="line">        MTT(s, s, s, len);</span><br><span class="line">        Mod(s, s);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">DITI</span>(<span class="params">ll *a, ll *h, ll *ans, <span class="built_in">int</span> n, <span class="built_in">int</span> k</span>)</span> &#123;</span><br><span class="line">    G[k] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= k; i++) G[k - i] = (mod - a[i]) % mod;</span><br><span class="line">    rever(G, k + <span class="number">1</span>);</span><br><span class="line">    len = getLen(k + <span class="number">1</span>);</span><br><span class="line">    Get_Inv(G, invG, k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = k + <span class="number">1</span>;i &lt; len; i++) invG[i] = <span class="number">0</span>;</span><br><span class="line">    rever(G, k + <span class="number">1</span>);</span><br><span class="line">    fpow(n);</span><br><span class="line">    ll Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; k; i++) Ans = (Ans + <span class="number">1l</span>l * h[i] * ans[i] % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= k; i++)&#123; cin &gt;&gt; a[i]; a[i] = a[i] &lt; <span class="number">0</span> ? a[i] + mod : a[i]; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; k; i++) &#123; cin &gt;&gt; h[i]; h[i] = h[i] &lt; <span class="number">0</span> ? h[i] + mod : h[i]; &#125;</span><br><span class="line"></span><br><span class="line">    ll Ans = DITI(a, h, ans, n, k);</span><br><span class="line">    cout &lt;&lt; Ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-–多项式是真的难！！！–</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/04/polynomial-optimization-constant-coefficient-homogeneous-linear-recursion/">https://blog.jujimeizuo.cn/2020/11/04/polynomial-optimization-constant-coefficient-homogeneous-linear-recursion/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020（ICPC）亚洲网上区域赛模拟赛 A-Easy Equation 差分 + 前缀和</title>
      <link href="/2020/11/03/2020-icpc-online-a/"/>
      <url>/2020/11/03/2020-icpc-online-a/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/8688/A">https://ac.nowcoder.com/acm/contest/8688/A</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出$a、b、c、d，x+y+z&#x3D;k$的个数$（0\leq x \leq a\;;\;0\leq y \leq b\;;\;0\leq z \leq c\;;\;0\leq k \leq d）$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑枚举x，则x+y的值域范围为[x, x + b]。 所以枚举x从0到a中，x到x+b中都要+1，这是就可以用一维差分即可。然后前缀和复原。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= a; i++) &#123;</span><br><span class="line">    d1[i]++;</span><br><span class="line">    d1[i + a + <span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= a + b; i++) &#123;</span><br><span class="line">    d1[i] += d1[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，在考虑枚举x+y，则x+y+z的值域范围为[x+y，x+y+c]。 枚举x+y从0到a+b中，x+y到x+y+c中都要+1，差分在复原。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= a + b; i++) &#123;</span><br><span class="line">    d2[i] += d1[i];</span><br><span class="line">    d2[i + c + <span class="number">1</span>] -= d1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= a + b + c; i++) &#123;</span><br><span class="line">    d2[i] += d2[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后取0到d中的贡献即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> PI = acos(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line">ll d1[N], d2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ll a, b, c, d;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= a; i++) &#123;</span><br><span class="line">        d1[i]++;</span><br><span class="line">        d1[i + a + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= a + b; i++) &#123;</span><br><span class="line">        d1[i] += d1[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= a + b; i++) &#123;</span><br><span class="line">        d2[i] += d1[i];</span><br><span class="line">        d2[i + c + <span class="number">1</span>] -= d1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= a + b + c; i++) &#123;</span><br><span class="line">        d2[i] += d2[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= d; i++) &#123;</span><br><span class="line">        ans += d2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/11/03/2020-icpc-online-a/">https://blog.jujimeizuo.cn/2020/11/03/2020-icpc-online-a/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6470 Count 矩阵快速幂优化线性递推</title>
      <link href="/2020/10/30/hdu-6470/"/>
      <url>/2020/10/30/hdu-6470/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6470">http://acm.hdu.edu.cn/showproblem.php?pid=6470</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$已知f(1) &#x3D; 1, f(2) &#x3D;2，且f(n)&#x3D;f(n-1)+2f(n-2)+n^3\;\;(mod\;\;1234567789)$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于线性递推，仿照快速幂，我们可以用矩阵快速幂优化（这就是线代吗？爱了爱了）。</p><p>考虑F_n为第n个矩阵，那就需要构造新的“递推矩阵”。</p><p>因为递推中有个$f_n$中$n^3$，所以$f_{n-1}$中需要有$(n-1)^3$，结合二项式定理可得：</p><p>$$n^3&#x3D;[(n-1)+1]^3&#x3D;C_{3}^0(n-1)^3+C_3^1(n-1)^2+C_{3}^2(n-1)^1+C_3^3(n-1)^0$$</p><p><img src="/images/2020/10/ditui1.jpg"></p><p><img src="/images/2020/10/ditui2.jpg"></p><p>所以说线性递推可以用矩阵快速幂优化。</p><p>但是！最近被mod坑死了，如果在矩阵乘法中每次都用mod，大概最高会有4秒，但是先判断在mod的话只有两秒，足足差了2秒！！！模运算是真的太慢了。。。</p><h2 id="Code-（967MS）"><a href="#Code-（967MS）" class="headerlink" title="Code （967MS）"></a>Code （967MS）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mm (l + r) / 2</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line">ll mod = <span class="number">123456789</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Martix&#123;</span><br><span class="line">    ll m[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Martix ans;</span><br><span class="line"></span><br><span class="line">Martix E;</span><br><span class="line"></span><br><span class="line">Martix <span class="keyword">operator</span> * (Martix a, Martix b) &#123;</span><br><span class="line">    Martix c;</span><br><span class="line">    mem(c.m, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]);</span><br><span class="line">                <span class="keyword">if</span>(c.m[i][j] &gt; mod)</span><br><span class="line">                    c.m[i][j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Martix <span class="title">quick_pow_Martix</span>(<span class="params">ll n</span>)</span> &#123;</span><br><span class="line">    Martix <span class="keyword">base</span> = E;</span><br><span class="line">    mem(ans.m, <span class="number">0</span>);</span><br><span class="line">    ans.m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    ans.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ans.m[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line">    ans.m[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    ans.m[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    ans.m[<span class="number">5</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = <span class="keyword">base</span> * ans;</span><br><span class="line">        <span class="keyword">base</span> = <span class="keyword">base</span> * <span class="keyword">base</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    E.m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; E.m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>; E.m[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>; E.m[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">3</span>; E.m[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">3</span>; E.m[<span class="number">0</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    E.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    E.m[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>; E.m[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">3</span>; E.m[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">3</span>; E.m[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    E.m[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>; E.m[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">2</span>; E.m[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    E.m[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">1</span>; E.m[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    E.m[<span class="number">5</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        scanf(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ans = quick_pow_Martix(n - 2);</span></span><br><span class="line">        printf(<span class="string">&quot;%lld\n&quot;</span>,quick_pow_Martix(n - <span class="number">2</span>).m[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/30/hdu-6470/">https://blog.jujimeizuo.cn/2020/10/30/hdu-6470/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC·小米 网络选拔赛第一场 J-Matrix Subtraction</title>
      <link href="/2020/10/25/2020-icpc-xiaomi/"/>
      <url>/2020/10/25/2020-icpc-xiaomi/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/7501/J">https://ac.nowcoder.com/acm/contest/7501/J</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个$n\times m$的矩阵和一个$a\times b$的单位矩阵，然后在$n \times m$的矩阵中任取$a\times b$的子矩阵，使其每一位都减1，问能否使原始矩阵变为0。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用二维差分来处理原始矩阵，然后设某一位为(x1，y1)，则只需要对$a\times b$子矩阵进行更新，即(x1，y1)和(x2，y2)。</p><p>每次处理的时候都需要判断差分矩阵当前这一位是否非负，因为只能进行矩阵减法。</p><p>二维差分处理原始矩阵：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">               cin &gt;&gt; mp[i][j];</span><br><span class="line">               p[i][j] = mp[i][j] - mp[i - <span class="number">1</span>][j] - mp[i][j - <span class="number">1</span>] + mp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>差分更新操作如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span>(<span class="params"><span class="built_in">int</span> x1, <span class="built_in">int</span> y1, <span class="built_in">int</span> x2, <span class="built_in">int</span> y2, ll k</span>)</span> &#123;</span><br><span class="line">    p[x1][y1] += k;</span><br><span class="line">    p[x1][y2 + <span class="number">1</span>] -= k;</span><br><span class="line">    p[x2 + <span class="number">1</span>][y1] -= k;</span><br><span class="line">    p[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n - a + <span class="number">1</span> &amp;&amp; flag; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= m - b + <span class="number">1</span> &amp;&amp; flag; j++) &#123;</span><br><span class="line">        <span class="built_in">int</span> i1 = i + a - <span class="number">1</span>, j1 = j + b - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                update(i, j, i1, j1, -p[i][j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总复杂度为$O(mn)$</p><h2 id="Code（97MS）"><a href="#Code（97MS）" class="headerlink" title="Code（97MS）"></a>Code（97MS）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line">ll mp[N][N];</span><br><span class="line">ll p[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span>(<span class="params"><span class="built_in">int</span> x1, <span class="built_in">int</span> y1, <span class="built_in">int</span> x2, <span class="built_in">int</span> y2, ll k</span>)</span> &#123;</span><br><span class="line">    p[x1][y1] += k;</span><br><span class="line">    p[x1][y2 + <span class="number">1</span>] -= k;</span><br><span class="line">    p[x2 + <span class="number">1</span>][y1] -= k;</span><br><span class="line">    p[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">   <span class="built_in">int</span> T;</span><br><span class="line">   cin &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span>(T--) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">int</span> n, m, a, b;</span><br><span class="line">       cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= m; j++) &#123;</span><br><span class="line">               cin &gt;&gt; mp[i][j];</span><br><span class="line">               p[i][j] = mp[i][j] - mp[i - <span class="number">1</span>][j] - mp[i][j - <span class="number">1</span>] + mp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n - a + <span class="number">1</span> &amp;&amp; flag; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= m - b + <span class="number">1</span> &amp;&amp; flag; j++) &#123;</span><br><span class="line">               <span class="built_in">int</span> i1 = i + a - <span class="number">1</span>, j1 = j + b - <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(p[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                   update(i, j, i1, j1, -p[i][j]);</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(p[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   flag = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = n - a;i &lt;= n &amp;&amp; flag; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> j = m - b;j &lt;= m &amp;&amp; flag; j++) &#123;</span><br><span class="line">               p[i][j] += p[i - <span class="number">1</span>][j] + p[i][j - <span class="number">1</span>] - p[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">if</span>(p[i][j]) &#123;</span><br><span class="line">                   flag = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(flag)</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;^_^&quot;</span> &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;QAQ&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/25/2020-icpc-xiaomi/">https://blog.jujimeizuo.cn/2020/10/25/2020-icpc-xiaomi/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC·小米 网络选拔赛热身赛K-Random Point in Triangle</title>
      <link href="/2020/10/24/2020-icpc-xiaomi-k/"/>
      <url>/2020/10/24/2020-icpc-xiaomi-k/</url>
      
        <content type="html"><![CDATA[<h2 id="传送门：https-ac-nowcoder-com-acm-contest-8409-K"><a href="#传送门：https-ac-nowcoder-com-acm-contest-8409-K" class="headerlink" title="传送门：https://ac.nowcoder.com/acm/contest/8409/K"></a>传送门：<a href="https://ac.nowcoder.com/acm/contest/8409/K">https://ac.nowcoder.com/acm/contest/8409/K</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给3个点$(x1,y1),(x2,y2),(x3,y3)$，在三角形内部中取一点p，设$E&#x3D;max(S_{PAB},S_{PAC},S_{PBC})$,求E的概率期望。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于任何三角形，先看看特殊的等边三角形。然后在推广到任意三角形（ACM需要猜！）</p><p><img src="/images/2020/10/20201024161618250.png"></p><p>O点为三角形ABC的内心。所以对于p的位置的选取，只需要在三角形的一半，然后一半即可。即在三角形OSB中选取。</p><p>$然后构造下图为：$</p><p><img src="/images/2020/10/20201024161825683.png"></p><p>设该等边三角形的边长为2a，ON为y，NP为x，则根据相似可得：</p><p>$PH&#x3D;\frac{2}{3}a+x+\frac{\sqrt 3}{3}y$ $PG&#x3D;\frac{\sqrt 3}{2}PH&#x3D;\frac{\sqrt3}{3}a+\frac{\sqrt 3}{2}x+\frac{1}{2}y$</p><p>$则E&#x3D;S_{PAC}&#x3D;\frac{1}{2}*AH*PG&#x3D;\frac{\sqrt3}{3}a^2+\frac{\sqrt 3}{2}ax+\frac{1}{2}ay$</p><p>根据上图，P点的y可在$[0，\frac{\sqrt a}{3}a]$中选取，所以x可以在$[0，\sqrt 3y]$中选取。</p><p>对面积积分如下：</p><p>$$\int_{0}^{\frac{\sqrt a}{3}}dy\int_{0}^{\sqrt 3y}(\frac{\sqrt3}{3}a^2+\frac{\sqrt 3}{2}ax+\frac{1}{2}ay)dx&#x3D;\frac{11}{36}a^4$$</p><p>而P点在该区域的选取面积为$\frac{\sqrt 3}{6}a^2$，期望为$\frac{11}{18}\sqrt 3 a^2$，而等边三角形的面积为$\sqrt 3a^2$ 即期望为$\frac{11}{18}S_{ABC}$，在乘以36得$22S_{ABC}$。</p><p>把等边三角形推广到任意三角形，虽然我不会证明，大胆猜测总没错！</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x1, x2, x3, y1, y2, y3;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3) &#123;</span><br><span class="line">        cout &lt;&lt;  <span class="built_in">abs</span>(x1 * y2 - x2 * y1 + x3 * y1 - x1 * y3 + x2 * y3 - x3 * y2) * <span class="number">11</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/24/2020-icpc-xiaomi-k/">https://blog.jujimeizuo.cn/2020/10/24/2020-icpc-xiaomi-k/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020ICPC·小米 网络选拔赛热身赛 I-Integration</title>
      <link href="/2020/10/24/2020-icpc-xiaomi-i/"/>
      <url>/2020/10/24/2020-icpc-xiaomi-i/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/8409/I">https://ac.nowcoder.com/acm/contest/8409/I</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\int_{0}^{+\infty }\frac{1}{\prod_{i&#x3D;1}^n(a_i^2+x^2)}dx$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>想要用分部积分求该定积分是非常非常困难的，而题目给出了$\int_{0}^{+\infty}\frac{1}{1+x^2}dx&#x3D;\frac{\pi}{2}$，所以我们就想办法把这个连乘变成连加，这样就好求了。</p><p>当n&#x3D;1时：</p><p>$$\int_{0}^{+\infty}\frac{1}{a^2+x^2}dx&#x3D;\frac{1}{a^2}arctan(\frac{x}{a})_0^{+\infty}&#x3D;\frac{\pi}{2a}$$</p><p>当n&#x3D;2时：</p><p>只看让式子分解的部分：</p><p>$$\frac{1}{a^2+x^2}\frac{1}{b^2+x^2}&#x3D;\frac{\alpha}{a^2+x^2}+\frac{\beta }{b^2+x^2}&#x3D;\frac{\alpha b^2+\beta a^2 + x^2(\alpha + \beta)}{(a^2+x^2)(b^2+x^2)}$$</p><p><img src="/images/2020/10/matrix1.jpg"></p><p>转化为：</p><p>$$\int_{0}^{+\infty }(\frac{1}{b^2-a^2})(\frac{1}{a^2+x^2})+(\frac{1}{a^2-b^2})(\frac{1}{b^2+x^2})dx&#x3D;\frac{1}{b^2-a^2}*\frac{1}{2a}+\frac{1}{a^2-b^2}*\frac{1}{2b}$$</p><p>当n&#x3D;3时：</p><p>$$\frac{1}{a^2+x^2}\frac{1}{b^2+x^2}\frac{1}{c^2+x^2}&#x3D;\frac{\alpha}{a^2+x^2}+\frac{\beta}{b^2+x^2}+\frac{\gamma}{c^2+x^2}$$ $$&#x3D;\frac{\alpha b^2c^2+\beta a^2c^2+\gamma a^2b^2+x^2(\alpha (b^2+c^2)+\beta (a^2+c^2)+\gamma (a^2+b^2))+x^4(\alpha+\beta+\gamma)}{(a^2+x^2)(b^2+x^2)(c^2+x^2)}$$</p><p><img src="/images/2020/10/matrix2.jpg"></p><p>$$\int_{0}^{+\infty }\frac{1}{(a^2+x^2)(b^2+x^2)(c^2+x^2)}dx$$ $$&#x3D;\frac{1}{(b^2-a^2)(c^2-a^2)} \frac{1}{2a}+\frac{1}{(a^2-b^2)(c^2-b^2)}\frac{1}{2b}+ \frac{1}{(a^2-c^2)(b^2-c^2)}\frac{1}{2c}$$</p><p>根据上面的列举，大大推断出该式子的规律，即对于</p><p>$$\int_{0}^{+\infty }\frac{1}{\prod_{i&#x3D;1}^n(a_i^2+x^2)}dx$$</p><p>$$ans&#x3D;\sum_{i&#x3D;1}^n\frac{1}{2a_i}\left (\prod_{j&#x3D;1\;j\neq i}^n\frac{1}{a_j^2-a_i^2} \right )$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"> <span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">dis</span>(<span class="params"><span class="built_in">double</span> x1, <span class="built_in">double</span> y1, <span class="built_in">double</span> x2, <span class="built_in">double</span> y2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll a[<span class="number">30005</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            ll t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                t = t * (((a[j] * a[j] % mod - a[i] * a[i] % mod) % mod + mod) % mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t * <span class="number">2</span> % mod * a[i] % mod;</span><br><span class="line">            ans = (ans + quick_pow(t, mod - <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/24/2020-icpc-xiaomi-i/">https://blog.jujimeizuo.cn/2020/10/24/2020-icpc-xiaomi-i/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6467 简单数学题 广东工业大学第十四届程序设计竞赛</title>
      <link href="/2020/10/15/hdu-6467/"/>
      <url>/2020/10/15/hdu-6467/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6467">http://acm.hdu.edu.cn/showproblem.php?pid=6467</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求F(n)&#x3D;\sum_{i&#x3D;1}^n(i*\sum_{j&#x3D;i}^nC_j^i)\;\;mod \;\;(1e9+7)$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先将F(n)展开： $$F(n)&#x3D;1*\sum_{j&#x3D;1}^nC_j^1+2*\sum_{j&#x3D;2}^nC_j^2+…+(n-1)\sum_{j&#x3D;n-1}^nC_j^{n-1}+n\sum_{j&#x3D;n}^nC_j^n$$ 将F(n-1)展开： $$F(n)&#x3D;1*\sum_{j&#x3D;1}^{n-1}C_j^1+2*\sum_{j&#x3D;2}^{n-1}C_j^2+…+(n-1)\sum_{j&#x3D;n-1}^{n-1}C_j^{n-1}$$</p><p>上式减下式得：</p><p>$F(n)-F(n-1)&#x3D;$ $$C_n^1+2*C_n^2+…+(n-1)C_{n}^{n-1}+nC_{n}^n$$</p><p>$$n*C_{n-1}^0+n*C_{n-1}^1+…+n*C_{n-1}^{n-1}$$</p><p>这里可能有点看不清楚，比如$rC_n^r&#x3D;r*\frac{n!}{r!*(n-r)!}$，拿出一个n，消去一个r得$n*\frac{(n-1)!}{(r-1)!(n-r)!}&#x3D;n*C_{n-1}^{r-1}$。</p><p>由二项式定理得：</p><p>$$F(n)-F(n-1)&#x3D;n*2^{n-1}$$</p><p>即得到如下式子：</p><p>$$ F(n) &#x3D; 1 \; (n &#x3D; 1) \; \; \; F(n) &#x3D; F(n - 1) + n * 2^{n-1} \; (n &gt; 1) $$</p><p>上式明显是一个递推公式，所以F(n)是一个差比数列的前n项和，错位相减法即可。</p><p>有一个差比数列的公式，高中还记得，现在就不记得。。。</p><p>对于数列$(An+B)q^{n-1}，(1-q)S_n&#x3D;(A+B)+(\frac{A}{1-q})q-(An+B+\frac{A}{1-q})q^n$。</p><p>最后得出F(n)&#x3D;(n-1)*2^{n}+1，快速幂处理一下即可。</p><h2 id="Code（405MS）"><a href="#Code（405MS）" class="headerlink" title="Code（405MS）"></a>Code（405MS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">##include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">const <span class="type">ll</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">quick_pow</span><span class="params">(ll a, ll b)</span> &#123;</span><br><span class="line">    <span class="type">ll</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">&quot;%lld&quot;</span>,&amp;n) != EOF) &#123;</span><br><span class="line">        printf(<span class="string">&quot;%lld\n&quot;</span>,(<span class="number">1</span> + (n - <span class="number">1</span>) % mod * quick_pow(<span class="number">2</span>, n) % mod + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/15/hdu-6467/">https://blog.jujimeizuo.cn/2020/10/15/hdu-6467/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4609 3-idiots</title>
      <link href="/2020/10/09/hdu-4609/"/>
      <url>/2020/10/09/hdu-4609/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4609">http://acm.hdu.edu.cn/showproblem.php?pid=4609</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n条边，问任取三条边是否能构成三角形的概率。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先把题意转化一下，即找下列式子的个数： $$\frac{\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\sum_{k&#x3D;1}^na_i+a_j&gt;a_k}{C_n^3}\;\;(i\ne j\ne k且a_i和a_j是较小的两条边)$$</p><p>看到三角形，首先想到就是把所有的$a_i+a_j$的个数存在一个数组里，然后再逐一判断每一个a_k是否符合。</p><p>但是，O(n^2)的复杂度是会T的，但是O(nlogn)的复杂度不会T，那么就需要用到FFT的知识了。</p><p>FFT是两个多项式相乘，但是上面是要让我们两个相加，没关系，我们让a_i为x的指数，a_i出现的次数为该x的系数，用一个cnt数组保存，即：</p><p>$$A(x)&#x3D;cnt[a[0]]x^{a[0]}+cnt[a[1]]x^{a[1]}+…+cnt[a[n - 1]]x^{a[n-1]}$$</p><p>所以我们让$A(x)\times A(x)$，就可以得到任意两条边之和，并且得到该和的个数，并存在num数组里。当然，这里会出现很多问题。</p><p>$1、i\ne j，所以要让a_i+a_i的个数减1,即num[a[i]+a[i]]–;$ $2、先取a_1后取a_3和先取a_3后取a_1是一样的，所以我们需要让每一个和都要除2，即num[i]&#x2F;&#x3D;2;$</p><p>然后我们用一个sum数组存下num数组的前缀和，然后遍历每条边，取两条边之和比该条边大的个数，即$ans+&#x3D;sum[a[n - 1]*2]-sum[a[i]]$，前面的$a[n-1]*2$是前缀和最大的地方。</p><p>但是，还是有很多问题！！！在刚开始的时候说过，两条边之和必须是两条较小的边，所以还要处理下面几种情况：</p><p>1、两条边都大于a[i]，即$ans-&#x3D;(n-i-1)*(n-i-1)&#x2F;2;$ 2、一条边大于a[i]，一条边小于a[i]，即$ans-&#x3D;(n-i-1)*i;$ 3、两条边中有一条边等于a[i],即$ans-&#x3D;(n-1);$</p><p>最后的ans就是满足条件的所有个数，然后计算$C_n^3$，最后算概率，保留7位小数。</p><p>但是，博主tsb了！！！明知道n有1e5，然后计算$C_n^3$会爆int，所以我还用一个longlong的变量保存下来，即t&#x3D;n*(n-1)*(n-2)&#x2F;6，是不是有一点问题，那就是要在n之前加一个(longlong)强制转换一下，我不过在这个地方错了10多发吧。。。</p><h2 id="Code（826MS）"><a href="#Code（826MS）" class="headerlink" title="Code（826MS）"></a>Code（826MS）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> PI = acos(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Complex &#123;</span><br><span class="line">    <span class="built_in">double</span> r, i;</span><br><span class="line">    Complex() &#123;r == <span class="number">0</span>; i = <span class="number">0</span>;&#125;;</span><br><span class="line">    Complex(<span class="built_in">double</span> real, <span class="built_in">double</span> imag) : r(real), i(imag) &#123;&#125;;</span><br><span class="line">&#125;A[N], B[N];</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex a, Complex b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(a.r + b.r, a.i + b.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> - (Complex a, Complex b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(a.r - b.r, a.i - b.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> * (Complex a, Complex b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> rev[N], len, lim = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span>(<span class="params">Complex *a, <span class="built_in">int</span> opt</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; lim; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i])</span><br><span class="line">            swap(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> dep = <span class="number">1</span>;dep &lt;= log2(lim); dep++) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = <span class="number">1</span> &lt;&lt; dep;</span><br><span class="line">        Complex wn = Complex(cos(<span class="number">2.0</span> * PI / m), opt * sin(<span class="number">2.0</span> * PI / m));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">0</span>;k &lt; lim; k += m) &#123;</span><br><span class="line">            Complex w = Complex(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j &lt; m / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                Complex t = w * a[k + j + m / <span class="number">2</span>];</span><br><span class="line">                Complex u = a[k + j];</span><br><span class="line">                a[k + j] = u + t;</span><br><span class="line">                a[k + j + m / <span class="number">2</span>] = u - t;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt == <span class="number">-1</span>) &#123; <span class="comment">// 逆变换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i].r /= lim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getBit</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(lim &lt; (n &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N], cnt[N];</span><br><span class="line">ll sum[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        mem(rev, <span class="number">0</span>);</span><br><span class="line">        mem(A, <span class="number">0</span>);</span><br><span class="line">        mem(num, <span class="number">0</span>);</span><br><span class="line">        mem(cnt, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        len = <span class="number">0</span>, lim = <span class="number">1</span>;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            scanf(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]); <span class="comment">// 把a[i]看成x的指数，使乘法变加法</span></span><br><span class="line">            cnt[a[i]]++; <span class="comment">// 把a[i]看成每个x^&#123;a_i&#125;的系数，然后再FFT</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        getBit(a[n - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">int</span> Max = a[n - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= a[n - <span class="number">1</span>]; i++) &#123;</span><br><span class="line">            A[i].r = cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        FFT(A, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; lim; i++) &#123;</span><br><span class="line">            A[i] = A[i] * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        FFT(A, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; lim; i++) &#123;</span><br><span class="line">            num[i] = A[i].r = (ll)(A[i].r + <span class="number">0.5</span>); <span class="comment">// FFT之后每个a_i+a_j的系数存在num里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            num[a[i] + a[i]]--; <span class="comment">// 把i=j的部分减掉</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt;= Max; i++) &#123;</span><br><span class="line">            num[i] /= <span class="number">2</span>; <span class="comment">// 重复取，除2即可</span></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + num[i]; <span class="comment">// 取前缀和，最后判断的时候方便一点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            ans += sum[Max] - sum[a[i]]; <span class="comment">// 统计大于a[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123; <span class="comment">// 处理符合两边大于a_k但是不正确的个数(因为判断是否为三角形必须是两条较小的边大于最长边)</span></span><br><span class="line">            ans -= ll(n - i - <span class="number">1</span>) * (n - i - <span class="number">2</span>) / <span class="number">2</span>; <span class="comment">// 两边都大于a[i]</span></span><br><span class="line">            ans -= ll(n - i - <span class="number">1</span>) * i; <span class="comment">// 一边大于a[i]，一边小于a[i]</span></span><br><span class="line">            ans -= ll(n - <span class="number">1</span>); <span class="comment">// 两边边中有一条边等于a[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll t = <span class="number">1l</span>l * n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        printf(<span class="string">&quot;%.7lf\n&quot;</span>,(<span class="built_in">double</span>)ans / t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/09/hdu-4609/">https://blog.jujimeizuo.cn/2020/10/09/hdu-4609/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3338 [ZJOI2014]力</title>
      <link href="/2020/10/08/luogu-p3338/"/>
      <url>/2020/10/08/luogu-p3338/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P3338">https://www.luogu.com.cn/problem/P3338</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$F_j&#x3D;\sum_{i&#x3D;1}^{j-1}\frac{q_i\times q_j}{(i-j)^2}-\sum_{i&#x3D;j+1}^{n}\frac{q_i\times q_j}{(i-j)^2}$$</p><p>$$求解E_i&#x3D;\frac{F_i}{q_i}$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$首先来看看什么是卷积：C_k&#x3D;\sum_{i&#x3D;0}^kA_iB_{k-i}，所以要想办法将上式转化成卷积的形式，然后FFT加速求解。$</p><p>$左右都加上一个i&#x3D;j的情况（式子总体不变）。$ $$E_j&#x3D;\frac{F_j}{q_j}&#x3D;\sum_{i&#x3D;1}^{j}\frac{q_i}{(i-j)^2}-\sum_{i&#x3D;j}^{n}\frac{q_i}{(i-j)^2}$$</p><p>$设f[i]&#x3D;q_i，g[i]&#x3D;\frac{1}{i^2}得（并且f[0]&#x3D;g[0]&#x3D;0）：$</p><p>$$E_j&#x3D;\sum_{i&#x3D;0}^{j}f[i][j - i]-\sum_{i&#x3D;j}^{n}f[i]g[i-j]$$</p><p>$这时候，左边 已经是卷积的形式了，所以就只要将右边转化一下即可。$</p><p>$先将右边展开得：$</p><p>$\sum_{i&#x3D;j}^{n}f[i]g[i-j]&#x3D;f[j]g[0]+f[j+1][1]+…+f[n]g[n-j]$ $\sum_{i&#x3D;j}^{n}f[i]g[i-j]&#x3D;\sum_{i&#x3D;0}^{n-j}f[i+j]g[i]$</p><p>$怎么转化成卷积形式呢，只需要将f翻转一下变成f’即可，即f’[i]&#x3D;f[n-i]，并令t&#x3D;n-j，得下式：$</p><p>$$\sum_{i&#x3D;0}^{n-j}f[i+j]g[i]&#x3D;\sum_{i&#x3D;0}^tf’[t-i]g[i]$$</p><p>$合并一下，得下式：$</p><p>$$E_j&#x3D;\sum_{i&#x3D;0}^{j}f[i][j - i]-\sum_{i&#x3D;0}^tf’[t-i]g[i]$$</p><p>$令L(x)&#x3D;\sum_{i&#x3D;0}^nf(n)\times g(n)，R(x)&#x3D;\sum_{i&#x3D;0}^nf’(n)\times g(n)$</p><p>$则E_i&#x3D;L(i)-R(n-i)$</p><p>$先预处理f,f’,g，最后用FFT加速卷积即可。$</p><h2 id="Code（921ms）"><a href="#Code（921ms）" class="headerlink" title="Code（921ms）"></a>Code（921ms）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> r, i;</span><br><span class="line">    <span class="built_in">Complex</span>() &#123;r == <span class="number">0</span>; i = <span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag) : <span class="built_in">r</span>(real), <span class="built_in">i</span>(imag) &#123;&#125;;</span><br><span class="line">&#125;A[N], B[N], C[N];</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex a, Complex b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(a.r + b.r, a.i + b.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> - (Complex a, Complex b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(a.r - b.r, a.i - b.i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span> * (Complex a, Complex b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rev[N], len, lim = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *a, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; lim; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i])</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dep = <span class="number">1</span>;dep &lt;= <span class="built_in">log2</span>(lim); dep++) &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">1</span> &lt;&lt; dep;</span><br><span class="line">        Complex wn = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2.0</span> * PI / m), opt * <span class="built_in">sin</span>(<span class="number">2.0</span> * PI / m));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; lim; k += m) &#123;</span><br><span class="line">            Complex w = <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                Complex t = w * a[k + j + m / <span class="number">2</span>];</span><br><span class="line">                Complex u = a[k + j];</span><br><span class="line">                a[k + j] = u + t;</span><br><span class="line">                a[k + j + m / <span class="number">2</span>] = u - t;</span><br><span class="line">                w = w * wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt == <span class="number">-1</span>) &#123; <span class="comment">// 逆变换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; lim; i++) a[i].r /= lim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(lim &lt;= (n &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        lim &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>)  ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;A[i].r);</span><br><span class="line">        B[i].r = (<span class="type">double</span>)(<span class="number">1.0</span> / i / i);</span><br><span class="line">        C[n - i].r = A[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FFT</span>(A, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(B, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(C, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= lim; i++) &#123;</span><br><span class="line">        A[i] = A[i] * B[i];</span><br><span class="line">        C[i] = C[i] * B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FFT</span>(A, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(C, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,A[i].r - C[n - i].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/08/luogu-p3338/">https://blog.jujimeizuo.cn/2020/10/08/luogu-p3338/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4157 [SCOI2006]整数划分</title>
      <link href="/2020/10/08/luogu-p4157/"/>
      <url>/2020/10/08/luogu-p4157/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.com.cn/problem/P4157">https://www.luogu.com.cn/problem/P4157</a></p><p>借鉴大佬：<a href="https://blog.csdn.net/oampamp1/article/details/108919448">https://blog.csdn.net/oampamp1/article/details/108919448</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个整数N，将他拆成若干整数，求他们乘积最大值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$先将题目转化一下：$</p><p>$$已知\sum_{i&#x3D;1}^n x_i&#x3D;N，求max{\prod_{i&#x3D;1}^n x_i}\;\;\;\;(n表示x_i有几项)$$</p><p>$首先根据均值不等式（调和\leq 几何\leq 算术 \leq 平方）：$ $$\frac{n}{\sum_{i&#x3D;1}^n\frac{1}{x_i}}\leq \sqrt[n]{\prod_{i&#x3D;1}^nx_i}\leq \frac{\sum_{i&#x3D;1}^nx_i}{n}\leq \sqrt[n]\frac{\sum_{i&#x3D;1}^nx_i^2}{n}$$</p><p>$所以可以得到：$ $$\frac{\sum_{i&#x3D;1}^nx_i}{n}\ge \sqrt[n]{\prod_{i&#x3D;1}^nx_i}$$</p><p>$$\left( \frac{\sum_{i&#x3D;1}^nx_i}{n} \right)^n\ge \prod_{i&#x3D;1}^nx_i$$</p><p>$观察上式，要使乘积最大，那需要尽量取等号，所以x_i要尽量平均，所以得到下式：$</p><p>$$\left( \frac{N}{n} \right)^n&#x3D; \prod_{i&#x3D;1}^nx_i$$</p><p>$令y&#x3D;(\frac{N}{n})^n，两边同时取对数得：$</p><p>$$\ln y&#x3D;n\ln N-n\ln n$$</p><p>$两边同时对n求导得：$</p><p>$$\frac{y’}{y}&#x3D;\ln N-ln n - 1$$</p><p>$$得y’&#x3D;(\ln N-\ln n - 1)(\frac{N}{n})^n$$</p><p>$令y’&#x3D;0，因为(\frac{N}{n})^n&gt;0，所以\ln N-\ln n - 1&#x3D;0，即：$</p><p>$$n&#x3D;e^{\ln N - 1}&#x3D;\frac{N}{e}$$</p><p>$由于n是在整数域里，所以n只有两个选择\frac{N}{2}和\frac{N}{3}，那么该取哪一个呢？$</p><p>$刚开始的\prod_{i&#x3D;1}^nx_i&#x3D;(\frac{N}{n})^n&#x3D;2^{\frac{N}{2}}或3^{\frac{N}{3}}，现在就看哪个大。$</p><p><img src="/images/2020/10/20201008144708195.png"></p><p>$根据上图可知，2^{\frac{N}{2}}&lt;3^{\frac{N}{3}},当然也可以手动算一下。$</p><p>$所以得\prod_{i&#x3D;1}^nx_i&#x3D;3^{\frac{N}{3}}最大，即优先取3，没有3取2，总之，推导到最后就是个憨憨题。总结一下：$</p><p>$让N mod \;3:$</p><p>$- N mod\; 3&#x3D;0，全部拆成3，ans&#x3D;3^{\frac{N}{3}}$ $- Nmod\;3&#x3D;1，拿出一个3然后加1组成4，其他都为3，ans&#x3D;3^{\frac{N-1}{3}-1}*4$ $-Nmod\;3&#x3D;2，拿出一2，其他都为3，ans&#x3D;3^{\frac{N-2}{3}}*2$</p><p>由于答案爆longlong，所以用JAVA大数，这不比高精度香吗？</p><h2 id="Code（67MS）"><a href="#Code（67MS）" class="headerlink" title="Code（67MS）"></a>Code（67MS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> N;</span><br><span class="line">        N = in.nextInt();</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(N % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = BigInteger.valueOf(<span class="number">3</span>).pow((N / <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(N % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = BigInteger.valueOf(<span class="number">3</span>).pow((N / <span class="number">3</span> - <span class="number">1</span>)).multiply(BigInteger.valueOf(<span class="number">4</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(N % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            ans = BigInteger.valueOf(<span class="number">3</span>).pow((N / <span class="number">3</span>)).multiply(BigInteger.valueOf(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ans.toString();</span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; min(<span class="number">100</span>, s.length()); i++) &#123;</span><br><span class="line">            System.out.print(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/08/luogu-p4157/">https://blog.jujimeizuo.cn/2020/10/08/luogu-p4157/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020杭电多校第六场】 6833 Very Easy Math Problem</title>
      <link href="/2020/10/07/hdu-6833/"/>
      <url>/2020/10/07/hdu-6833/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6833">http://acm.hdu.edu.cn/showproblem.php?pid=6833</a></p><p>借鉴大佬： <a href="https://blog.csdn.net/weixin_44282912/article/details/107844614">https://blog.csdn.net/weixin_44282912&#x2F;article&#x2F;details&#x2F;107844614</a> <a href="https://blog.csdn.net/oampamp1/article/details/107865300">https://blog.csdn.net/oampamp1/article/details/107865300</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$$求解\sum_{a_1&#x3D;1}^n\sum_{a_2&#x3D;1}^n…\sum_{a_x&#x3D;1}^n\left(\prod_{j&#x3D;1}^xa_j^k\right)f(gcd(a_1,a_2…a_x))gcd(a_1,a_2…a_x)$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$令d&#x3D;gcd(a_1,a_2…a_x)得：$</p><p>$$\sum_{a_1&#x3D;1}^n\sum_{a_2&#x3D;1}^n…\sum_{a_x&#x3D;1}^n\left(\prod_{j&#x3D;1}^xa_j^k\right)f(d)d$$</p><p>$枚举d得：$</p><p>$$\sum_{d&#x3D;1}^ndf(d)\sum_{a_1&#x3D;1}^n\sum_{a_2&#x3D;1}^n…\sum_{a_x&#x3D;1}^n\left(\prod_{j&#x3D;1}^xa_j^k\right)[gcd(a_1,a_2…a_x)&#x3D;d]$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{a_1&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\sum_{a_2&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }…\sum_{a_x&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\left(\prod_{j&#x3D;1}^xa_j^k\right)[gcd(a_1,a_2…a_x)&#x3D;1]$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{a_1&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\sum_{a_2&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }…\sum_{a_x&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\left(\prod_{j&#x3D;1}^xa_j^k\right)\sum_{ta_1\;ta2\;…\;ta_x}\mu(t)$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }i^k\right)^x\sum_{ta_1\;ta2\;…\;ta_x}\mu(t)$$</p><p>$枚举t得：$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{t&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\mu(t)\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{dt} \right \rfloor }(it)^k\right)^x$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{t&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\mu(t)t^{kx}\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{dt} \right \rfloor }i^k\right)^x$$</p><p>$令T&#x3D;dt并枚举T得：$</p><p>$$\sum_{T&#x3D;1}^n\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{dt} \right \rfloor }i^k\right)^xT^{kx}\sum_{dT}df(d)\mu(\frac{T}{d})$$</p><p>$令g(T)&#x3D;\sum_{dT}df(d)\mu(\frac{T}{d})，则$</p><p>$$\sum_{T&#x3D;1}^n\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{T} \right \rfloor }i^k\right)^xT^{kx}g(T)$$</p><p>$O(nlogn)筛f和g，并对T^{kx}g(T)和\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{T} \right \rfloor }i^k做前缀和，最后\sqrt n分块计算，复杂度为O(nlogn+T\sqrt n)$</p><h2 id="Code（2121MS）"><a href="#Code（2121MS）" class="headerlink" title="Code（2121MS）"></a>Code（2121MS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double pi = acos(-1);</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll T, k, x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">ll g[N], f[N];</span><br><span class="line">ll sumG[N], sumi[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mobi</span><span class="params">()</span> <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 筛f函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">2</span>;d * d &lt; N; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = d * d;i &lt; N; i += d * d) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 筛g函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>;d &lt; N; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = d;i &lt; N; i += d) &#123;</span><br><span class="line">            g[i] = (g[i] + <span class="number">1ll</span> * d * f[d] % mod * mu[i / d] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理sumG函数和sumi函数前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        ll t = <span class="built_in">quick_pow</span>(i, k);</span><br><span class="line">        sumi[i] = (sumi[i - <span class="number">1</span>] + t) % mod;</span><br><span class="line">        sumG[i] = (sumG[i - <span class="number">1</span>] + <span class="built_in">quick_pow</span>(t, x) * g[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    <span class="built_in">Mobi</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r;l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = <span class="built_in">min</span>(n, n / (n / l));</span><br><span class="line">            ans = (ans + (sumG[r] - sumG[l - <span class="number">1</span>] + mod) % mod * <span class="built_in">quick_pow</span>(sumi[n / l], x) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/07/hdu-6833/">https://blog.jujimeizuo.cn/2020/10/07/hdu-6833/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1074 Doing Homework</title>
      <link href="/2020/10/07/hdu-1074/"/>
      <url>/2020/10/07/hdu-1074/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1074">http://acm.hdu.edu.cn/showproblem.php?pid=1074</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n本作业，每本都有一个完成时间和提交截止时间，当完成作业后提交，每超过截止时间1分就扣1分，问怎么最小化扣的分数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于n只有15，所以就可以用状压dp。 定义状态为$1~(1&lt;&lt;n)-1$，我们先枚举每个状态$i$，在枚举该状态的上一个状态，那怎么枚举呢？先枚举$0 ~ n-1$每个科目$j$，在判断下$i\&amp;(1&lt;&lt;j)$是否为$1$，如果是，说明该状态的上一个状态为$i-(1&lt;&lt;j)$，再根据上一个状态来更新该状态。</p><p>1、判断上一个状态的扣分+j科目扣的分是否小于该状态的扣分。 2、满足1的情况下，更新该状态所需的时间，扣分，科目和该状态的父亲，因为最后还要输出路径。</p><p>所以需要定义一个结构体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">homework</span> &#123;</span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// 记录科目</span></span><br><span class="line">    <span class="type">int</span> time; <span class="comment">// 记录所需时间</span></span><br><span class="line">    <span class="type">int</span> cost; <span class="comment">// 记录扣分</span></span><br><span class="line">    <span class="type">int</span> fa; <span class="comment">// 记录父亲，也就是上一个状态</span></span><br><span class="line">&#125;dp[<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br></pre></td></tr></table></figure><h2 id="Code（15MS）"><a href="#Code（15MS）" class="headerlink" title="Code（15MS）"></a>Code（15MS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll P = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double pi = acos(-1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">homework</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">105</span>];</span><br><span class="line">    <span class="type">int</span> d, c;</span><br><span class="line">&#125;a[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">zy</span> &#123;</span><br><span class="line">    <span class="type">int</span> fa, cost, time;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;dp[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">mem</span>(dp, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i].name &gt;&gt; a[i].d &gt;&gt; a[i].c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">            dp[i].cost = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = n - <span class="number">1</span>;j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> temp = <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">if</span>(temp &amp; i) &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = i - temp;</span><br><span class="line">                    <span class="type">int</span> t = dp[tmp].time + a[j].c - a[j].d;</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">                        t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(t + dp[tmp].cost &lt; dp[i].cost) &#123;</span><br><span class="line">                        dp[i].cost = dp[tmp].cost + t;</span><br><span class="line">                        dp[i].fa = tmp;</span><br><span class="line">                        dp[i].id = j;</span><br><span class="line">                        dp[i].time = dp[tmp].time + a[j].c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>].cost &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(dp[t].time) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(dp[t].id);</span><br><span class="line">            t = dp[t].fa;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> q = s.<span class="built_in">top</span>();</span><br><span class="line">            cout &lt;&lt; a[q].name &lt;&lt; endl;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/07/hdu-1074/">https://blog.jujimeizuo.cn/2020/10/07/hdu-1074/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛69 F-解方程</title>
      <link href="/2020/10/03/nowcoder-practice69-f/"/>
      <url>/2020/10/03/nowcoder-practice69-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/7329/F">https://ac.nowcoder.com/acm/contest/7329/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求解：$f_i\;\;mod\;\;998244353\;\;(1\leq i\leq n)$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>前置技能：$\mu*I &#x3D;\varepsilon \;\;\;\; \sigma _q&#x3D;id_q*I\;\;\;\;F(n)&#x3D;\sum_{dn}\mu(i)f(\frac{n}{d})$</p><p>$$\sum_{in}f(i)\sigma_p(\frac{n}{i})&#x3D;\sigma _q(n)\;\;-&gt;\;\;(f*\sigma_p )n&#x3D;\sigma_q(n)$$</p><p>先将$\sigma$ 分解：</p><p>$$(f*id_p*I)n&#x3D;(id_q*I)n$$</p><p>左右都乘上$\mu:$</p><p>$$(f*id_p)n&#x3D;id_q(n)$$</p><p>$$\sum_{in}f(i)\frac{n^p}{i^p}&#x3D;n^q$$</p><p>$$\sum_{in}\frac{f(i)}{i^p}&#x3D;n^{q-p}&#x3D;id_{q-p}(n)$$</p><p>反演得：</p><p>$$\frac{f(n)}{n^p}&#x3D;\sum_{in}\frac{\mu(i)*n^{q-p}}{i^{q-p}}$$</p><p>$$\frac{f(n)}{n^q}&#x3D;\sum_{in}\frac{\mu(i)}{i^{q-p}}$$</p><p>因为积性函数卷积性函数之后还是积性函数，所以能得到$\frac{f(n)}{n^q}$是积性函数。我们考虑与n互质的d，计算$f(d^k)$并且由莫比乌斯函数的性质得：</p><p>$$\frac{f(d^k)}{d^{kq}}&#x3D;1-\frac{[k\ne 0]}{d^{q-p}}$$ $(根据上式，只有i&#x3D;1或d时才\mu(i)满足，其他都是0)$</p><p>$所以再来看n，由基本算数定理得：n&#x3D;p_1^{k_1}p_2^{k_2}…p_m^{k_m}，即：$</p><p>$$\frac{f(n)}{n^q}&#x3D;\frac{f(p_1^{k_1})}{p_1^{qk_1}}\frac{f(p_2^{k_2})}{p_2^{qk_2}}…\frac{f(p_m^{k_m})}{p_m^{qk_m}}$$</p><p>$$\frac{f(n)}{n^q}&#x3D;\prod_{dn \&amp;\&amp;d\;is\;a\;prime}(1-\frac{1}{d^{q-p}})$$</p><p>提前用欧拉筛处理$f(p^k)$即可，注意g数组的含义，因为当$i%prime[j]&#x3D;0$时，$prime[j]$已经是$prime[j]*i$的因子的，而$f[i]$和$f[i*prime[j]]$两者之间的区别就是$prime[j]^q$，这还是比较难想到的。</p><h2 id="Code-477MS"><a href="#Code-477MS" class="headerlink" title="Code(477MS)"></a>Code(477MS)</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const ll P = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double pi = acos(-1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">bool</span> is_prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line">ll q, p, n;</span><br><span class="line">ll f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eluer</span>()</span> &#123;</span><br><span class="line">    is_prime[<span class="number">1</span>] = is_prime[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i]) &#123;</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            g[i] = quick_pow(i, q);</span><br><span class="line">            f[i] = (g[i] - quick_pow(i, p)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i * prime[j]] = f[i] * g[prime[j]] % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i * prime[j]] = f[i] * f[prime[j]] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; q;</span><br><span class="line">    Eluer();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = (f[i] % mod + mod) % mod;</span><br><span class="line">        ans ^= f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start_clock_for_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end_clock_for_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.putback(acm_local_for_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/03/nowcoder-practice69-f/">https://blog.jujimeizuo.cn/2020/10/03/nowcoder-practice69-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020牛客国庆集训派对day2 F-SUM OF SUB RECTANGLE AREAS</title>
      <link href="/2020/10/02/2020-nowcoder-guoqing-2-f/"/>
      <url>/2020/10/02/2020-nowcoder-guoqing-2-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/7818/F">https://ac.nowcoder.com/acm/contest/7818/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个N * N的矩阵，每一位上都是1，求所有子矩阵的权值之和。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$设n &#x3D; 3；$ 考虑子矩阵大小为$i * j$的个数$x$，即该大小的所有子矩阵的权值为$x* i * j$。 $1 * 2$子矩阵:每行个数为$2$个，有$3$列，即总权值为$2 * 3 * （1 * 2）–2 * 3$为该矩阵在n*n矩阵中的个数，$1 * 2$为该子矩阵里的权值。 $2 <em>3$子矩阵：每两行有$1$个，一共$2$个两行，权值为$2</em> 3$，即总权值为$1 * 2 * 2 * 3$。</p><p>根据上面推导出：在$n*n$的矩阵中，有$i*j$子矩阵的个数为$(n - i + 1) * (n - j + 1)$，即总权值为$(n - i + 1) * (n - j + 1) * i * j$。 即总答案为： $$ans&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n(n - i + 1) * (n - j + 1) * i * j$$</p><p>$$ans&#x3D;[\sum_{i&#x3D;1}^n(n-i+1)i]^2$$</p><p>$$ans&#x3D;[\frac{n^2(n+1)}{2}-\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2}]^2$$</p><p>$$ans&#x3D;[\frac{n * (n + 1)*(n+ 2)}{6}]^2$$</p><p>因为题目说会爆longlong，所以我这里用的是JAVA大数BigInteger，python也可（不过我不会）。</p><h2 id="Code-71MS"><a href="#Code-71MS" class="headerlink" title="Code(71MS)"></a>Code(71MS)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> T;</span><br><span class="line">        T = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= T; i++) &#123;</span><br><span class="line">            <span class="type">long</span> n;</span><br><span class="line">            n = in.nextLong();</span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            ans = ans.multiply(BigInteger.valueOf(n));</span><br><span class="line">            ans = ans.multiply(BigInteger.valueOf(n + <span class="number">1</span>));</span><br><span class="line">            ans = ans.multiply(BigInteger.valueOf(n + <span class="number">2</span>));</span><br><span class="line">            ans = ans.divide(BigInteger.valueOf(<span class="number">6</span>));</span><br><span class="line">            ans = ans.multiply(ans);</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/10/02/2020-nowcoder-guoqing-2-f/">https://blog.jujimeizuo.cn/2020/10/02/2020-nowcoder-guoqing-2-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客练习赛69 D-火柴排队</title>
      <link href="/2020/09/11/nowcoder-practice69-d/"/>
      <url>/2020/09/11/nowcoder-practice69-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/7329/D">https://ac.nowcoder.com/acm/contest/7329/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给长度为n的序列和一个d，分别在n个数中选k(1&lt;&#x3D;k&lt;&#x3D;n)个数，将这k个数增加d之后不影响排名，要求$ai+d&lt;&#x3D;aj$。 分别输出每一个k的概率。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要是想在每个k中找出合法的方案，不管是正向的DFS还是反向的容斥，这都会导致T掉（主要是不会做，做了也会错）。看到n&#x3D;5000时，O(n^2)的复杂度是可以的，那就可以考虑dp了。</p><p>设dp[i][j][1&#x2F;0]表示前i个人中选了j个增加d，并且当前这一位选1&#x2F;不选0。</p><p>所以就有两种选择，选或不选。</p><p>当前这一位没有被选，状态转移就是：</p><p>$dp[i][j][0] &#x3D; dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] * (a[i - 1] + d &lt;&#x3D; a[i] )$</p><p>如果上一位被选了，这一就要判断上一位选了之后增加的d是否合法，合法就可要，不合法就不要。</p><p>当前这一位被选，状态转移就是：</p><p>$dp[i][j][1]&#x3D;dp[i - 1][j- 1][0] + dp[i - 1][j-1][1]$</p><p>由于n&#x3D;5000，dp[5000][5000][2]可能会爆掉，那么就需要用到滚动数组（因为转移只会与上一行有关）。</p><p>$设now&#x3D;i\%2,pre &#x3D;now \wedge 1，则状态转移为：$ $f[now][j][0] &#x3D; f[pre][j][0] + f[pre][j][1] * (a[i - 1] + d &lt;&#x3D; a[i])$ $f[now][j][1] &#x3D; f[pre][j - 1][0] + f[pre][j - 1][1]$</p><p>最后，预处理所有的阶乘、逆元、阶乘逆元。</p><h2 id="Code-64ms"><a href="#Code-64ms" class="headerlink" title="Code(64ms)"></a>Code(64ms)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lc t[u].ls</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> rc t[u].rs</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> m (l + r) / 2</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const double pi = acos(-1);</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll F[N + <span class="number">10</span>]; <span class="comment">// 阶乘</span></span><br><span class="line">ll invF[N + <span class="number">10</span>]; <span class="comment">// 阶乘逆元</span></span><br><span class="line">ll invn[N + <span class="number">10</span>];</span><br><span class="line">ll a[N + <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[N + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">2</span>][N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>] = F[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = invn[<span class="number">0</span>] = invn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        invn[i] = (mod - mod / i) * invn[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * invn[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getC</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = F[k];</span><br><span class="line">    ans = ans * invF[n] % mod;</span><br><span class="line">    ans = ans * invF[k - n] % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    a[n + <span class="number">1</span>] = a[n] + d * <span class="number">2</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> now = i % <span class="number">2</span>, pre = now ^ <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mem</span>(f[now], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= i; j++) &#123;</span><br><span class="line">            f[now][j][<span class="number">0</span>] = (f[pre][j][<span class="number">0</span>] + f[pre][j][<span class="number">1</span>] * (a[i - <span class="number">1</span>] + d &lt;= a[i])) % mod;</span><br><span class="line">            f[now][j][<span class="number">1</span>] = (f[pre][j - <span class="number">1</span>][<span class="number">0</span>] + f[pre][j - <span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = n % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; (f[now][i][<span class="number">0</span>] + f[now][i][<span class="number">1</span>]) * <span class="built_in">quick_pow</span>(<span class="built_in">getC</span>(i, n), mod - <span class="number">2</span>) % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/09/11/nowcoder-practice69-d/">https://blog.jujimeizuo.cn/2020/09/11/nowcoder-practice69-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学</title>
      <link href="/2020/08/19/comb/"/>
      <url>/2020/08/19/comb/</url>
      
        <content type="html"><![CDATA[<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><ul><li>圆排列:n个中选k个组成一个圈的方案数：$\frac{A_{n}^k}{k}$</li><li>项链排列:${\frac{A_{n}^k}{2k}}$</li><li>错位排列:n个数的所有错排方案数的递推公式为${f(n)&#x3D;(n-1)*(f(n-1)+f(n-2))}$,前几项为$0、1、2、9、44、265$</li><li>多重排列:设$S&#x3D;{n1*a1,n2*a2,…,nk*ak}$，则所有的方案数为$\frac{n!}{n1!*n2!*…*nk!}$</li><li>不相邻组合:[1,n]个中选k个组成不相邻的排列的方案数为：$C_{n-k+1}^k$</li><li>可重组合:设S&#x3D;${n1*a1,n2*a2,…,nk*ak}$，在S中选r个，则所有的方案数为${C_{r+k-1}^{k-1}}$</li></ul><p>方法：隔板法，捆绑法…</p><p>扩展:</p><ul><li>二项式定理:$(a+b)^n&#x3D;\sum_{k&#x3D;0}^nC_n^ka^{n-k}b^k$</li><li>多项式定理:$(x1+x2+…+xk)^n&#x3D;\sum_{n1+n2+…+nk&#x3D;n}\frac{n!}{n1!n2!…nk!}\prod_{i&#x3D;1}^kx_i^{ni}$</li><li>格路问题:$(0,0)$点走到$(m,n)$点的方案数为$C_{m+n}^n$</li></ul><h2 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h2><h4 id="普通型母函数"><a href="#普通型母函数" class="headerlink" title="普通型母函数"></a>普通型母函数</h4><p>主要求组合的方案数。 形如${a_0+a_1x^1+a_2x^2+…+a_nx^n}$</p><h4 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h4><p>主要求多重排列数。 形如${a_0+\frac{a_1x}{1!}+\frac{a_2x^2}{2!}+…\frac{a_nx^n}{n!}}$</p><h2 id="特殊的数"><a href="#特殊的数" class="headerlink" title="特殊的数"></a>特殊的数</h2><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><ul><li>递推式:$f(n)&#x3D;f(n-1)+f(n-2)$</li><li>二阶常系数递归公式:$f(n)&#x3D;\frac{1}{\sqrt 5}[(\frac{1+\sqrt 5}{2})^n-(\frac{1-\sqrt 5}{2})^n]$</li></ul><p>前几项为1、1、2、3、5、8…</p><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><ul><li><p>常见公式：</p><ul><li>$H_n&#x3D;\frac{C_{2n}^n}{n+1}$</li><li>$H_n&#x3D;\frac{H_{n-1}(4n-2)}{n+1}$</li><li>$H_n&#x3D;1 \;\;(n&#x3D;0n&#x3D;1)$ $H_n&#x3D;\sum_{i&#x3D;1}^nH_{n-i}H_{i-1} (n\geq 2)$</li><li>$H_n&#x3D;C_{2n}^n-C_{2n}^{n-1}$</li></ul></li></ul><p>前几项为：1、1、2、5、14、42、132…</p><h2 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h2><h4 id="第一类Stirling数"><a href="#第一类Stirling数" class="headerlink" title="第一类Stirling数"></a>第一类Stirling数</h4><ul><li>递推式:${S_u(n,k)&#x3D;S_u(n-1,k-1)+(n-1)*S_u(n-1,k)}\;\;\;S_u(0,0)&#x3D;1$</li></ul><h4 id="第二类Stirling数"><a href="#第二类Stirling数" class="headerlink" title="第二类Stirling数"></a>第二类Stirling数</h4><ul><li><p>递推式:${S(n,k)&#x3D;S(n-1,k-1)+k*S(n-1.k)}\;\;\;S(0,0)&#x3D;1$</p></li><li><p>线性公式:${S(n,k)&#x3D;\frac{1}{k!}\sum_{i&#x3D;0}^k(-1)^iC_k^i(k-i)^n}$</p></li></ul><h2 id="贝尔数"><a href="#贝尔数" class="headerlink" title="贝尔数"></a>贝尔数</h2><ul><li><p>递推式:${B_{n+1}&#x3D;\sum_{k&#x3D;0}^nC_n^kB_k}$</p></li><li><p>根据第二类斯特林数:${B_n&#x3D;\sum_{k&#x3D;0}^nS(n,k)}$</p></li></ul><p>拓展：贝尔三角形求解。</p><p>前几项为：1、1、2、5、15、52、203…</p><h2 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h2><ul><li>等幂求和:</li></ul><p>$S_mn&#x3D;\frac{1}{m+1}\sum_{k&#x3D;0}^mC_{m+1}^kn^{m-k+1}$</p><ul><li><p>$\sum_{i&#x3D;1}^ni^k&#x3D;\frac{1}{k+1}\sum_{i&#x3D;1}^{k+1}C_{k+1}^iB_{k-i+1}(n+1)^i$</p></li><li><p>递推式:${\sum_{k&#x3D;0}^nB_kC_{n+1}^k&#x3D;0}\;\;\;(B_0&#x3D;1)$</p></li><li><p>$B_n&#x3D;-\frac{1}{n+1}[C_{n+1}^0B0+C_{n+1}^1B1+…+C_{n+1}^{n-1}B_{n-1}]$</p></li></ul><p>前几项为：$1、-\frac{1}{2}、\frac{1}{6}、0、\frac{1}{30}…$</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/19/comb/">https://blog.jujimeizuo.cn/2020/08/19/comb/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第九场】6869 Slime and Stones</title>
      <link href="/2020/08/18/hdu-6869/"/>
      <url>/2020/08/18/hdu-6869/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6869">http://acm.hdu.edu.cn/showproblem.php?pid=6869</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有两堆石子，有两种拿取的方式，一：在一堆中拿任意多个石子，二：在两堆中拿相差不能超过k的石子个数，问最后谁赢。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题就是威佐夫博弈的扩展，本来的威佐夫博弈是k&#x3D;0，但是这里，k&gt;&#x3D;0，那该怎么办呢？</p><p>还是从最开始的思路推起，对于两堆的石子分别为x和y时（x&lt;y）：</p><p>d&#x3D;0时，第k个奇异局势为$([\frac{1+\sqrt 5}{2}k],[\frac{3+\sqrt 5}{2}k])，k&#x3D;y-x$</p><p>这是要求$dx-dy&lt;1$</p><p>这是根据Betty定理推出来的，$\frac{1}{x}+\frac{1}{x+1}\;&#x3D;\;1$，这里的一个正解为$\frac{1+\sqrt 5}{2}$，只要判断$\frac{1+\sqrt 5}{2}*(y-x)&#x3D;&#x3D;x \&amp;\&amp; \frac{3+\sqrt 5}{2}*(y-x)&#x3D;&#x3D;y$就代表先手必输，一般的模板只要求其中的一个条件即可，因为d&#x3D;0不需要考虑精度问题，但是当d!&#x3D;0时，考虑精度问题，还是两个条件都判断一下。</p><p>d&gt;0时，第k个奇异局势为$([\frac{2-d+\sqrt{d^2+4}}{2}k],[\frac{2+d+\sqrt {d^2+4}}{2}k])，k&#x3D;\frac{y-x}{d}$,x和y也就相差个dk，就是上面为什么可以取两个条件。</p><p>{这里要求$dx-dy&lt;d$</p><p>根据Betty定理，这里的解为$\frac{1}{x}+\frac{1}{x+d}&#x3D;1$，所以我们只需要判断以下两个条件即可。</p><p>$$[\frac{2-d+\sqrt{d^2+4}}{2}k]&#x3D;&#x3D;x\;\;\&amp;\&amp;\;\;[\frac{2+d+\sqrt {d^2+4}}{2}k]&#x3D;&#x3D;y(先手必输)$$</p><p>注意d输入之后要++，这里的k是$\frac{y-x}{d}$，向下取整，所以由于精度问题，需要判断两个条件更精准。</p><p>参考：<a href="https://www.cnblogs.com/Khada-Jhin/p/9609561.html">大佬</a></p><h2 id="Code-109MS"><a href="#Code-109MS" class="headerlink" title="Code(109MS)"></a>Code(109MS)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll P = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weizuofu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="type">double</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lf&quot;</span>,&amp;a,&amp;b,&amp;k);</span><br><span class="line">    k += <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="built_in">swap</span>(a , b);</span><br><span class="line">    ll temp = (b - a) / k;</span><br><span class="line">    ll ans1 = temp * ((<span class="built_in">sqrt</span>(<span class="number">4.0</span> + k * k) - k + <span class="number">2.0</span>) / <span class="number">2.0</span>);</span><br><span class="line">    ll ans2 = temp * ((<span class="built_in">sqrt</span>(<span class="number">4.0</span> + k * k) + k + <span class="number">2.0</span>) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans1 == a &amp;&amp; ans2 == b)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">weizuofu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于我一直没有注意到把&amp;&amp;写成，导致一直都在WA，但是一想到我是个傻逼，所有事情都迎刃而解了，哈哈哈！</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/18/hdu-6869/">https://blog.jujimeizuo.cn/2020/08/18/hdu-6869/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P2051 中国象棋 状压dp</title>
      <link href="/2020/08/12/luogu-p2051/"/>
      <url>/2020/08/12/luogu-p2051/</url>
      
        <content type="html"><![CDATA[<h2 id="P2051-AHOI2009-中国象棋-状压dp"><a href="#P2051-AHOI2009-中国象棋-状压dp" class="headerlink" title="P2051 [AHOI2009]中国象棋 状压dp"></a><a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋 状压dp</a></h2><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为在同一行或同一列中最多放两个炮，所以可以放0、1、2个炮，三个以上的就不合法，因为可以互相打。</p><p>对于状态压缩dp，首先需要假设状态，这题的状态就是0、1、2，（列是指第i行中1~m列）0代表一列中没有炮，1代表一列中有一个炮，2代表一列中有2个炮，从第一行往下遍历，寻找所有的状态。</p><p>所以我们定义一个数组dp[i][j][k]，第一维表示前i行，第二维表示有j列只有一个炮，第三维表示只有k列有两个炮</p><p>那么根据容斥原理可知，没有炮的列数有m-j-k列。</p><p>因为一列中最多放两个棋子，且对于每一行，每一列只能放一个，不能说放两个，难道让他们结合吗？这里笔者就想当然的结合了，然后就错了。 所以我们可以讨论以下三种情况（所有情况的第i行都是由第i-1行继承下来）：</p><ul><li>不放棋子 第i行的状态可以由第i-1行状态继承，即$dp[i][j][k]&#x3D;dp[i - 1][j][k]$。<ul><li>放一个棋子 该棋子放在有一个棋子的列上 在j列中拿出一列+1个棋子成为k列中的一员，即$dp[i][j][k]&#x3D;dp[i-1][j][k+1]*(j+1)$ 该棋子放在空列上 在空列中拿出一列成为j列的一员，即$dp[i][j][k]&#x3D;dp[i-1][j-1][k]*(m-j-k+1)$</li></ul></li><li>放两个棋子 两个棋子分别放在两个空列上 在空列中拿出两列成为j列的两员，即$dp[i][j][k]&#x3D;dp[i-1][j-2][k]*C_{m-j-k+2}^2$</li><li>两个棋子一个在有棋子的列一个在空列中 在j列中拿出一个成为k列的一员，在空列中拿出一个成为j列的一员，即 $dp[i][j][k]&#x3D;dp[i-1][j][k-1]*j*(m-j-k+1)$</li><li>两个棋子分别放在两个有棋子的列上 在j列拿出两个成为k列的两员，即 $dp[i][j][k]&#x3D;dp[i-1][j+2][k-2]*C_{j+2}^2$</li><li>两个棋子放在没有棋子的一列上 这是错误的，上面说道，对于每一行，只能在一列中放一个，不能放两个，否则就会“结合”了。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod =  <span class="number">9999973</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= m - j; k++) &#123;</span><br><span class="line">                dp[i][j][k] = dp[i - <span class="number">1</span>][j][k]; <span class="comment">// 不放棋子</span></span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">1</span>) dp[i][j][k] += dp[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * (j + <span class="number">1</span>); <span class="comment">// 放一个棋子在有一个棋子的列</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">1</span>) dp[i][j][k] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * (m - j + <span class="number">1</span> - k); <span class="comment">// 放一个棋子在没有棋子的列</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">2</span>) dp[i][j][k] += dp[i - <span class="number">1</span>][j - <span class="number">2</span>][k] * ((m - j - k + <span class="number">2</span>) * (m - j - k + <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// 放两个棋子在没有棋子的两列</span></span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">1</span>) dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * j * (m - j - k + <span class="number">1</span>); <span class="comment">// 放两个在一列有棋子一列无棋子</span></span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">2</span>) dp[i][j][k] += dp[i - <span class="number">1</span>][j + <span class="number">2</span>][k - <span class="number">2</span>] * ((j + <span class="number">2</span>) * (j + <span class="number">1</span>) / <span class="number">2</span>); <span class="comment">// 放两个在两列都有棋子</span></span><br><span class="line">                dp[i][j][k] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= m - j; k++) &#123;</span><br><span class="line">            ans = (ans + dp[n][j][k]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/12/luogu-p2051/">https://blog.jujimeizuo.cn/2020/08/12/luogu-p2051/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演例题集---（自用）</title>
      <link href="/2020/08/10/mobius-inversion/"/>
      <url>/2020/08/10/mobius-inversion/</url>
      
        <content type="html"><![CDATA[<h4 id="参考：大佬1-大佬2-大佬3-大佬4"><a href="#参考：大佬1-大佬2-大佬3-大佬4" class="headerlink" title="参考：大佬1 大佬2 大佬3 大佬4"></a>参考：<a href="https://blog.csdn.net/weixin_44282912/article/details/105417215">大佬1</a> <a href="https://blog.csdn.net/weixin_43973966/article/details/85338976">大佬2</a> <a href="https://www.luogu.com.cn/blog/Althen-Way-Satan/mu-bi-wu-si-fan-yan-yu-du-jiao-shai">大佬3</a> <a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">大佬4</a></h4><h4 id="P3455-POI2007-ZAP-Queries"><a href="#P3455-POI2007-ZAP-Queries" class="headerlink" title="P3455 [POI2007]ZAP-Queries"></a><a href="https://www.luogu.com.cn/problem/P3455">P3455 [POI2007]ZAP-Queries</a></h4><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;k]$$ $反演过程：$ $$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;k]$$</p><p>$$\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{m}{k} \right \rfloor}\varepsilon[gcd(i,j)&#x3D;1]$$</p><p>$枚举d：$</p><p>$$\sum_{d&#x3D;1}^{\left \lfloor min(\left \lfloor \frac{n}{k} \right \rfloor,\left \lfloor \frac{m}{k} \right \rfloor)\right \rfloor}\mu(d)\left \lfloor \frac{n}{kd} \right \rfloor \left \lfloor \frac{m}{kd} \right \rfloor$$</p><p>$\ {先预处理\mu，然后整数分块做，复杂度为O(n + T\sqrt n)}$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line">ll sum[N]; <span class="comment">// 记录莫比乌斯函数前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>(<span class="params">ll n, ll m</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    n /= k, m /= k;</span><br><span class="line">    <span class="built_in">int</span> mx = min(n, m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">1</span>, r;l &lt;= mx; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (n / l) \* (m / l) \* (sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    Mobi();</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; Ans(n, m) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2257-YY的GCD"><a href="#P2257-YY的GCD" class="headerlink" title="P2257 YY的GCD"></a><a href="https://www.luogu.com.cn/problem/P2257">P2257 YY的GCD</a></h4><p>$$求解\sum_{p\in prime}\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;p]$$ $反演过程和上面几乎一样，就多了一维p为质数的情况，直接化简为：$</p><p>$$\sum_{p\in prime}\sum_{d&#x3D;1}^{\left \lfloor min(\left \lfloor \frac{n}{p} \right \rfloor,\left \lfloor \frac{m}{p} \right \rfloor)\right \rfloor}\mu(d)\left \lfloor \frac{n}{pd} \right \rfloor \left \lfloor \frac{m}{pd} \right \rfloor$$</p><p>$这里的复杂度为O(n+T\sqrt n \sqrt n)，但明显不够，所以需要继续化简，这里的优化可以用T替换pd，则d&#x3D;\frac{T}{p}，替换后的式子为：$</p><p>$$\sum_{T&#x3D;1}^{min(n,m)})\left \lfloor \frac{n}{T} \right \rfloor \left \lfloor \frac{m}{T} \right \rfloor\sum_{pT\;p\in prime}\mu(\frac{T}{p})$$</p><p>$$令\ {F(x)&#x3D;\sum_{px\;p\in prime}\mu(\frac{x}{p})}$$</p><p>$得：$</p><p>$$\sum_{p\in prime}\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;p]&#x3D;\sum_{T&#x3D;1}^{min(n,m)}\left \lfloor \frac{n}{T} \right \rfloor \left \lfloor \frac{m}{T} \right \rfloor F(T)$$</p><p>$\ {O(n)处理\mu，O(nlogn)处理F，O(\sqrt n)询问分块，即复杂度为O(nlogn + T\sqrt n)}$</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line">ll sum[N]; <span class="comment">// 记录莫比乌斯函数前缀和</span></span><br><span class="line">ll F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j \* prime[i] &lt; N; j++) &#123;</span><br><span class="line">            F[j \* prime[i]] += mu[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        F[i] += F[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>(<span class="params">ll N, ll M</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll n = N, m = M;</span><br><span class="line">    <span class="built_in">int</span> mx = min(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> l = <span class="number">1</span>, r; l &lt;= mx; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (n / l) \* (m / l) \* (F[r] - F[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    Mobi();</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        cout &lt;&lt; Ans(n, m) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1390-公约数的和"><a href="#P1390-公约数的和" class="headerlink" title="P1390 公约数的和"></a><a href="https://www.luogu.com.cn/problem/P1390">P1390 公约数的和</a></h4><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;i+1}^ngcd(i,j)$$</p><p>$先来看看基本形式：$ $$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^ngcd(i,j)$$ $则\ {ans&#x3D;\frac{Calc(n,n)-\frac{n(n+1)}{2}}{2}}，首先减去gcd(i,i)的个数\frac{n(n+1)}{2}，然后减去gcd(i,j)&#x3D;gcd(j,i)的个数，直接除2即可，则：$ $$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\sum_{k&#x3D;1}^nk[gcd(i,j)&#x3D;k]$$</p><p>$枚举k：$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;\left \lfloor \frac{i+1}{k} \right \rfloor}^{\left \lfloor \frac{n}{k} \right \rfloor}[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{di\;dj}\mu(d)$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}1$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)(\left \lfloor \frac{n}{kd} \right \rfloor)^2$$</p><p>$令\ {T&#x3D;kd并枚举T}，得：$</p><p>$$\sum_{T&#x3D;1}^n\sum_{dT}\mu(d)\frac{T}{d}(\left \lfloor \frac{n}{T} \right \rfloor)^2$$</p><p>$中间部分有\ {\sum_{dT}\mu(d)\frac{T}{d}&#x3D;\varphi (T)，因为\varphi &#x3D;\mu * id}，即得：$</p><p>$$\sum_{T&#x3D;1}^n\varphi (T)(\left \lfloor \frac{n}{T} \right \rfloor)^2$$</p><p>$则最终答案为：$</p><p>$$\ {ans&#x3D;\frac{\sum_{T&#x3D;1}^n\varphi (T)(\left \lfloor \frac{n}{T} \right \rfloor)^2-\frac{n(n+1)}{2}}{2}}$$</p><p>$\ {O(n)预处理\varphi，\sqrt n询问分块，总时间复杂度为O(n+\sqrt n)}$</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll P = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> phi[N];</span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> tot;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            prime[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= tot &amp;&amp; i \* prime[j] &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j]) &#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* (prime[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + phi[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Calc</span>(<span class="params">ll n</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r;l &lt;= n;l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n, n / (n / l));</span><br><span class="line">        ans += (f[r] - f[l - <span class="number">1</span>]) \* (n / l) \* (n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    Euler();</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; (Calc(n) - n \* (n + <span class="number">1</span>) / <span class="number">2</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1829-国家集训队-Crash的数字表格-JZPTAB"><a href="#P1829-国家集训队-Crash的数字表格-JZPTAB" class="headerlink" title="P1829 [国家集训队]Crash的数字表格 &#x2F; JZPTAB"></a><a href="https://www.luogu.com.cn/problem/P1829">P1829 [国家集训队]Crash的数字表格 &#x2F; JZPTAB</a></h3><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^mlcm (i,j)$$</p><p>$由gcd和lcm之间的关系得：$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\frac{ij}{gcd(i,j)}$$</p><p>$$\sum_{k&#x3D;1}^{min(n,m)}\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\frac{ij}{k}[gcd(i,j)&#x3D;k]$$</p><p>$$\sum_{k&#x3D;1}^{min(n,m)}\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{m}{k} \right \rfloor}\frac{ijk^2}{k}[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{k&#x3D;1}^{min(n,m)}k\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{m}{k} \right \rfloor}ij\sum_{di\;dj}\mu(d)$$</p><p>$枚举d得：$</p><p>$$\sum_{k&#x3D;1}^{min(n,m)}k\sum_{d&#x3D;1}^{min(\left \lfloor \frac{n}{k} \right \rfloor,\left \lfloor \frac{m}{k} \right \rfloor)}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}id\sum_{j&#x3D;1}^{\left \lfloor \frac{m}{kd} \right \rfloor}jd$$</p><p>$$\sum_{k&#x3D;1}^{min(n,m)}k\sum_{d&#x3D;1}^{min(\left \lfloor \frac{n}{k} \right \rfloor,\left \lfloor \frac{m}{k} \right \rfloor)}\mu(d)d^2\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}i\sum_{j&#x3D;1}^{\left \lfloor \frac{m}{kd} \right \rfloor}j$$</p><p>$令\ {f(x)&#x3D;\sum_{i&#x3D;1}^{x}i，F(n,m)&#x3D;\sum_{d&#x3D;1}^{min(n,m)}\mu(d)d^2f(\frac{n}{d})f(\frac{m}{d})}，得：$</p><p>$$\sum_{k&#x3D;1}^{min(n,m)}kF(\left \lfloor\frac{n}{k}\right \rfloor,\left \lfloor\frac{m}{k}\right \rfloor)$$</p><p>$\ {O(n)处理\mu,O(1)处理f（等差数列，在计算F的过程中直接直接计算），O(\sqrt {\sqrt n})分块询问F，答案分块询问O(\sqrt n)，总复杂度为O(n+n^{\frac{3}{4}})}$</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">20101009</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + mu[i] \* i % mod \* i % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>(<span class="params">ll n, ll m</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ll inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll p = min(n, m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">1</span>;k &lt;= p; k++) &#123;</span><br><span class="line">        <span class="built_in">int</span> x = n / k, y = m / k, P = min(x, y);</span><br><span class="line">        ll Sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">1</span>, r;l &lt;= P; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = min(x / (x / l), (y / (y / l)));</span><br><span class="line">            Sum = (Sum + (sum[r] - sum[l - <span class="number">1</span>] + mod) % mod \* (<span class="number">1</span> + x / l) % mod \* (x / l) % mod \* inv2 % mod \* (<span class="number">1</span> + y / l) % mod \* (y / l) % mod \* inv2 % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + Sum \* k % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    Mobi();</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; Ans(n, m) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3768-简单的数学题"><a href="#P3768-简单的数学题" class="headerlink" title="P3768 简单的数学题"></a><a href="https://www.luogu.com.cn/problem/P3768">P3768 简单的数学题</a></h4><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^nij(gcd(i,j))\;mod \;p$$ $$\sum_{k&#x3D;1}^n\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^nijk[gcd(i,j)&#x3D;k]$$</p><p>$$\sum_{k&#x3D;1}^nk\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}ijk^2[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{k&#x3D;1}^nk^3\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}ij\sum_{di\;dj}\mu(d)$$</p><p>$$\sum_{k&#x3D;1}^nk^3\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}id\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}jd$$</p><p>$$\sum_{k&#x3D;1}^nk^3\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)d^2\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}i\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}j$$</p><p>$令\ {f(x)&#x3D;\sum_{i&#x3D;1}^xi}，则式子变为：$</p><p>$$\sum_{k&#x3D;1}^nk^3\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)d^2f^2(\frac{n}{kd})$$</p><p>$到这里，时间复杂度为O(n+n\sqrt n)，我没尝试过，但是还可以继续化简，化简方法有替换，用T替换kd，则：$</p><p>$$\sum_{T&#x3D;1}^nf^2(\frac{n}{T})T^2\sum_{kT}k*\mu(\frac{T}{k})$$</p><p>$$\sum_{T&#x3D;1}^nf^2(\frac{n}{T})T^2\ {(id*\mu)T}$$</p><p>$$\sum_{T&#x3D;1}^nf^2(\frac{n}{T})T^2\ {\varphi (T)}$$</p><p>$\ {可以杜教筛筛T^2\varphi (T)的前缀和，因为n最高有10^{10}，明显数组存不下，所以对于5e6可以用数组直接过度求前缀和，对于后面就可以用杜教筛求前缀和，然后用map存下（STL的好处），过程如下：}$</p><p>$参考：$<a href="https://www.luogu.com.cn/blog/Althen-Way-Satan/mu-bi-wu-si-fan-yan-yu-du-jiao-shai">杜教筛</a></p><p>$先看杜教筛的基本形式(与上面无关)：设S(n)&#x3D;\sum_{i&#x3D;1}^{n}f(i)，定义一个新函数为g，则有$</p><p>$$\sum_{i&#x3D;1}^n(f*g)i$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{xy&#x3D;i}f(x)g(y)$$</p><p>$$\sum_{y&#x3D;1}^ng(y)\sum_{xy\leq n}f(x)$$</p><p>$$\sum_{y&#x3D;1}^ng(y)\sum_{x&#x3D;1}^{\left \lfloor \frac{n}{y} \right \rfloor}f(x)$$</p><p>$$\sum_{y&#x3D;1}^ng(y)S(\left \lfloor \frac{n}{y} \right \rfloor)$$</p><p>$则有：$</p><p>$$\sum_{i&#x3D;1}^n(f*g)i&#x3D;g(1)S(n)+\sum_{y&#x3D;2}^ng(y)S(\left \lfloor \frac{n}{y} \right \rfloor)$$</p><p>$$\ {S(n)&#x3D;\frac{\sum_{i&#x3D;1}^n(f*g)i-\sum_{y&#x3D;2}^ng(y)S(\left \lfloor \frac{n}{y} \right \rfloor)}{g(1)}}$$</p><p>$对于本题，要找到合适的g函数，因为我们求的前缀和为S(n)&#x3D;\sum_{i&#x3D;1}^ni^2\varphi(i),f(i)&#x3D;i^2\varphi(i)，所以设g(n)&#x3D;n^2。$</p><p>$\sum_{i&#x3D;1}^ng(i)&#x3D;\frac{x(x+1)(2x+1)}{6}$</p><p>$(f*g)x&#x3D;\sum_{dx}f(d)g(\frac{x}{d})&#x3D;\sum_{dx}d^2\varphi(d)\frac{x^2}{d^2}&#x3D;x^2\sum_{dx}\varphi(d)&#x3D;x^2id(x)&#x3D;x^3$</p><p>$\sum_{i&#x3D;1}^n(f*g)i&#x3D;\sum_{i&#x3D;1}^ni^3&#x3D;\frac{x^2(x+1)^2}{4}$</p><p>$$\ {S(n)&#x3D;\frac{n^2(n+1)^2}{4}-\sum_{y&#x3D;2}^ng(y)S(\left \lfloor \frac{n}{y} \right \rfloor)}$$</p><p>$\ {O(n^{\frac{2}{3}})处理T^2\varphi (T)的前缀和，f可以O(1)算出，O(\sqrt n) 询问分块，总时间复杂度为O(n^\frac{2}{3})}$</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, mod, inv4, inv6;</span><br><span class="line">ll phi[N];</span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> tot;</span><br><span class="line"></span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Get\_phi() &#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            prime[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= tot &amp;&amp; i \* prime[j] &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j]) &#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* (prime[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + (ll)phi[i] \* i % mod \* i % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans \* a % mod;</span><br><span class="line">        a = a \* a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum1</span>(<span class="params">ll x</span>)</span> &#123;x %= mod; <span class="keyword">return</span> (<span class="number">1</span> + x) % mod \* x % mod \* (<span class="number">1</span> + x) % mod \* x % mod \* inv4 % mod;&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum2</span>(<span class="params">ll x</span>)</span> &#123;x %= mod; <span class="keyword">return</span> x % mod \* (<span class="number">1</span> + x) % mod \* (<span class="number">2</span> \* x + <span class="number">1</span>) % mod \* inv6 % mod;&#125;</span><br><span class="line"></span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Calc</span>(<span class="params">ll x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N) <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll num = sum1(x);</span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">2</span>, r;l &lt;= x;l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        num = (num - Calc(x / l) % mod \* (sum2(r) - sum2(l - <span class="number">1</span>) + mod) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>()</span> &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r;l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ans = (ans + sum1(n / l) % mod \* (Calc(r) - Calc(l - <span class="number">1</span>) % mod + mod) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; mod &gt;&gt; n;</span><br><span class="line">    Get\_phi();</span><br><span class="line">    inv4 = quick\_pow(<span class="number">4</span>, mod - <span class="number">2</span>);</span><br><span class="line">    inv6 = quick\_pow(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; Ans() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3327-SDOI2015-约数个数和"><a href="#P3327-SDOI2015-约数个数和" class="headerlink" title="P3327 [SDOI2015]约数个数和"></a><a href="https://www.luogu.com.cn/problem/P3327">P3327 [SDOI2015]约数个数和</a></h4><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^md (ij)$$</p><p>$$\ {约数的重要性质:(ij)&#x3D;\sum_{xi}\sum_{yj}[gcd(x,y )&#x3D;1]}$$</p><p><a href="https://www.cnblogs.com/sun123zxy/p/12295533.html">https://www.cnblogs.com/sun123zxy/p/12295533.html</a></p><p>$得：$ $$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\sum_{xi}\sum_{yj}[gcd(x,y )&#x3D;1]$$</p><p>$改变枚举顺序，枚举x和y:$</p><p>$$\sum_{x&#x3D;1}^n\sum_{y&#x3D;1}^m\left \lfloor \frac{n}{x} \right \rfloor\left \lfloor \frac{n}{y} \right \rfloor[gcd(x,y)&#x3D;1]$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\left \lfloor \frac{n}{i} \right \rfloor\left \lfloor \frac{n}{j} \right \rfloor[gcd(i,j)&#x3D;1]$$</p><p>$后面套用前面得：$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\left \lfloor \frac{n}{i} \right \rfloor\left \lfloor \frac{n}{j} \right \rfloor\sum_{di\;dj}\mu(d)$$</p><p>$枚举d得：$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}\mu(d)\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\left \lfloor \frac{n}{i} \right \rfloor\left \lfloor \frac{n}{j} \right \rfloor[dgcd(i,j)]$$</p><p>$由于[dgcd(i,j)]成立的条件为d是gcd(i,j)的约数，所以可以把枚举i,j变换为枚举di,dj，从而[1gcd(i,j)]可以省略。得：$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor\frac{m}{d}\right \rfloor}\left \lfloor \frac{n}{id} \right \rfloor\left \lfloor \frac{n}{jd} \right \rfloor$$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor}\left \lfloor \frac{n}{id} \right \rfloor\sum_{j&#x3D;1}^{\left \lfloor\frac{m}{d}\right \rfloor}\left \lfloor \frac{n}{jd} \right \rfloor$$</p><p>$令\ {f(x)&#x3D;\sum_{i&#x3D;1}^x\left \lfloor \frac{x}{i} \right \rfloor}，则：$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}\mu(d)f(\frac{n}{d})f(\frac{m}{d})$$</p><p>$\ {O(n)处理\mu和其前缀和，O(n\sqrt n)处理f，O(\sqrt n)询问分块，总复杂度为O(n\sqrt n+T\sqrt n)}$</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">1</span>, r;l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            ans += (r - l + <span class="number">1</span>) \* (i / l);</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>(<span class="params">ll n, ll m</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll k = min(n, m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r;l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (mu[r] - mu[l - <span class="number">1</span>]) \* f[m / l] \* f[n / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    Mobi();</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        cout &lt;&lt; Ans(n, m) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3312-SDOI2014-数表"><a href="#P3312-SDOI2014-数表" class="headerlink" title="P3312 [SDOI2014]数表"></a><a href="https://www.luogu.com.cn/problem/P3312">P3312 [SDOI2014]数表</a></h4><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\sum_{di\;dj}d[\sum_{di\;dj}d\leq a]$$</p><p>$令\ {F(x)&#x3D;\sum_{ix}i}，则得：$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m F(gcd(i,j))[F(gcd(i,j))\leq a]$$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m F(d)[gcd(i,j)&#x3D;d][F(d)\leq a]$$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}F(d)[F(d)\leq a]\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;d]$$</p><p>$后半部分就套用前面得：$</p><p>$$\sum_{d&#x3D;1}^{min(n,m)}F(d)[F(d)\leq a]\sum_{d^{‘}&#x3D;1}^{min(\left \lfloor \frac{n}{d} \right \rfloor, \left \lfloor \frac{m}{d} \right \rfloor)}\mu(d^{‘})\left \lfloor \frac{n}{dd^{‘}} \right \rfloor \left \lfloor \frac{m}{dd^{‘}} \right \rfloor$$</p><p>$令T替换dd^{‘}得：$</p><p>$$\sum_{T&#x3D;1}^{min(n,m)}\sum_{dT}F(d)\mu(\frac{T}{d})\left \lfloor \frac{n}{T} \right \rfloor \left \lfloor \frac{m}{T} \right \rfloor[F(d)\leq a]$$</p><p>$$\sum_{T&#x3D;1}^{min(n,m)}\left \lfloor \frac{n}{T} \right \rfloor \left \lfloor \frac{m}{T} \right \rfloor\sum_{dT}F(d)\mu(\frac{T}{d})[F(d)\leq a]$$</p><p>$令\ {f(x)&#x3D;\sum_{dx}F(d)\mu(\frac{x}{d})[F(d)\leq a]}得：$</p><p>$$\sum_{T&#x3D;1}^{min(n,m)}\left \lfloor \frac{n}{T} \right \rfloor \left \lfloor \frac{m}{T} \right \rfloor f(T)$$</p><p>$\ {O(n)处理\mu，O(nlogn)处理F，对于每次询问的a值可以离线排序，树状数组维护f，处理时间为O(nlog^{2}n)，O(\sqrt n\; logn)询问分块，总时间复杂度为O(nlog^2n)+T\sqrt n\; logn}$</p><h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lc u &lt;&lt; 1</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> rc u &lt;&lt; 1  1</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> m (l + r) / 2</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mid (t[u].l + t[u].r) / 2</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double PI = acos(-1);</span></span><br><span class="line"><span class="comment">// const double R = 0.57721566490153286060651209;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line">ll mod = (<span class="number">1l</span>l \* <span class="number">1</span>) &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">    <span class="built_in">int</span> id;</span><br><span class="line">    ll data;</span><br><span class="line">&#125;F[N];</span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">    <span class="built_in">int</span> nn, mm, id;</span><br><span class="line">    ll a;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> cnt, prime[N];</span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> mu[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> cmp\_F(node a, node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.data &lt; b.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> cmp\_Q(Node a, Node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">init</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        F[i].id = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j \* i &lt; N; j++) &#123;</span><br><span class="line">            F[i \* j].data += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(F + <span class="number">1</span>, F + N, cmp\_F);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll t[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; N) &#123;</span><br><span class="line">        t[x] = (t[x] + v) % mod;</span><br><span class="line">        <span class="keyword">if</span>(t[x] &gt; mod)</span><br><span class="line">            t[x] %= mod;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">inline ll <span class="title">query</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ans = (ans + t[x]) % mod;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; mod)</span><br><span class="line">            ans %= mod;</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">inline ll <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> nn, <span class="built_in">int</span> mm</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nn &gt; mm)</span><br><span class="line">        swap(nn, mm);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">1</span>, r;l &lt;= nn; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(nn / (nn / l), mm / (mm / l));</span><br><span class="line">        ans = (ans + <span class="number">1l</span>l \* (nn / l) \* (mm / l) % mod \* (query(r) - query(l - <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct SegMent &#123;</span></span><br><span class="line"><span class="comment">//    int l, r;</span></span><br><span class="line"><span class="comment">//    int sum;</span></span><br><span class="line"><span class="comment">//&#125;t[N &lt;&lt; 2];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void push\_up(int u) &#123;</span></span><br><span class="line"><span class="comment">//    t[u].sum = t[lc].sum + t[rc].sum;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void build(int u, int l, int r) &#123;</span></span><br><span class="line"><span class="comment">//    t[u].l = l;</span></span><br><span class="line"><span class="comment">//    t[u].r = r;</span></span><br><span class="line"><span class="comment">//    if(l == r) &#123;</span></span><br><span class="line"><span class="comment">//        t[u].sum = a[l];</span></span><br><span class="line"><span class="comment">//        return ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    build(lc, l, m);</span></span><br><span class="line"><span class="comment">//    build(rc, m + 1, r);</span></span><br><span class="line"><span class="comment">//    push\_up(u);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//void update(int u, int p, int v) &#123;</span></span><br><span class="line"><span class="comment">//    if(t[u].l == t[u].r) &#123;</span></span><br><span class="line"><span class="comment">//        t[u].sum += v;</span></span><br><span class="line"><span class="comment">//        return ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    if(p &lt;= mid) update(lc, p, v);</span></span><br><span class="line"><span class="comment">//    else update(rc, p, v);</span></span><br><span class="line"><span class="comment">//    push\_up(u);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int query(int u, int ql, int qr) &#123;</span></span><br><span class="line"><span class="comment">//    if(ql &lt;= t[u].l &amp;&amp; t[u].r &lt;= qr) &#123;</span></span><br><span class="line"><span class="comment">//        return t[u].sum;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    int ans = 0;</span></span><br><span class="line"><span class="comment">//    if(ql &lt;= mid)</span></span><br><span class="line"><span class="comment">//        ans += query(lc, ql, qr);</span></span><br><span class="line"><span class="comment">//    if(qr &gt; mid)</span></span><br><span class="line"><span class="comment">//        ans += query(rc, ql, qr);</span></span><br><span class="line"><span class="comment">//    return ans;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>();</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= T; i++) &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;q[i].nn,&amp;q[i].mm, &amp;q[i].a);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + T + <span class="number">1</span>, cmp\_Q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= T; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(now &lt; N &amp;&amp; F[now].data &lt;= q[i].a) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j \* F[now].id &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">add</span>(j \* F[now].id, mu[j] \* F[now].data);</span><br><span class="line">            &#125;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].id] = (Calc(q[i].nn, q[i].mm) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= T; i++) &#123;</span><br><span class="line">        printf(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3172-CQOI2015-选数"><a href="#P3172-CQOI2015-选数" class="headerlink" title="P3172 [CQOI2015]选数"></a><a href="https://www.luogu.com.cn/problem/P3172">P3172 [CQOI2015]选数</a></h4><p>$$求解\sum_{i&#x3D;L}^H\sum_{j&#x3D;L}^H…\sum_{x&#x3D;L}^H[gcd(i,j…x)&#x3D;k]$$</p><p>$本题求n个数的gcd为k的个数，根据上面套路，将H&#x2F;k,L&#x2F;k，这样就只用求n个数的gcd为1的个数了，注意：如果L整除k，则L&#x3D;L&#x2F;k，否则L&#x3D;L&#x2F;k+1，就是向上取整，那么有一种办法非常好，就让\ {L&#x2F;k+(\frac{k-1}{k})}，即：$</p><p>$$\sum_{i&#x3D;{\left \lfloor \frac{L-1}{k} \right \rfloor+1}}^{\left \lfloor \frac{H}{k}\right \rfloor}\sum_{j&#x3D;{\left \lfloor \frac{L-1}{k} \right \rfloor+1}}^{\left \lfloor \frac{H}{k}\right \rfloor}…\sum_{x&#x3D;{\left \lfloor \frac{L-1}{k} \right \rfloor+1}}^{\left \lfloor \frac{H}{k}\right \rfloor}[gcd(i,j…x)&#x3D;1]$$</p><p>$$\sum_{i&#x3D;{\left \lfloor \frac{L-1}{k} \right \rfloor+1}}^{\left \lfloor \frac{H}{k}\right \rfloor}\sum_{j&#x3D;{\left \lfloor \frac{L-1}{k} \right \rfloor+1}}^{\left \lfloor \frac{H}{k}\right \rfloor}…\sum_{x&#x3D;{\left \lfloor \frac{L-1}{k} \right \rfloor+1}}^{\left \lfloor \frac{H}{k}\right \rfloor}\sum_{di\;dj\;..\;dx}\mu(d)$$</p><p>$枚举d，令\ {l&#x3D;\left \lfloor \frac{L-1}{k} \right \rfloor+1,r&#x3D;\left \lfloor \frac{H}{k}\right \rfloor}：$</p><p>$$\sum_{d&#x3D;1}^r\mu(d)\sum_{i&#x3D;l}^r[di]\sum_{j&#x3D;l}^r[dj]…\sum_{x&#x3D;l}^r[dx]$$</p><p>$只有当i，j…x都是d的倍数的时候，最终答案+1，根据容斥原理，那么在[l,r]中d倍数有\ {\frac{r}{d}-\frac{l-1}{d}}，对于所有的i，j…x，他们当中所有[l,r]的d的倍数的个数有\ {(\frac{r}{d}-\frac{l-1}{d})^n}，即为：$</p><p>$$\sum_{d&#x3D;1}^{r}\mu(d)*(\frac{r}{d}-\frac{l-1}{d})^n$$</p><p>$这里的H非常大，如果用线性筛去处理\mu，会直接Wa掉，因为没法处理到10^9次方那么大的前缀和，数组也开不了那么大。后果：$</p><p><img src="https://img-blog.csdnimg.cn/20200815153844583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6dHNpbGx5,size_16,color_FFFFFF,t_70##pic_center" alt="在这里插入图片描述"> $这里的AC可能就是一小部分的运气罢了。如果用线性筛，RE的RE，WA的WA，所以推荐用杜教筛取筛。$</p><p>$\ {设f(d)&#x3D;\mu(d),S(r)&#x3D;\sum_{d&#x3D;1}^nf(d)，这里的S就是要求的前缀和。}$ $我们选择\ {g&#x3D;I},则\sum_{i&#x3D;1}^r(f*g)i&#x3D;\sum_{i&#x3D;1}^r(\mu*I)i&#x3D;\sum_{i&#x3D;1}^r\varepsilon (i)&#x3D;1。$</p><p>$枚举y：$</p><p>$$\sum_{y&#x3D;1}^rg(y)\sum_{x&#x3D;1}^{\left \lfloor \frac{r}{y} \right \rfloor)}f(x)$$</p><p>$$\sum_{y&#x3D;1}^rg(y)S(\left \lfloor \frac{r}{y} \right \rfloor)$$</p><p>$$\sum_{i&#x3D;1}^r(f*g)i &#x3D;g(1)S(r)+\sum_{y&#x3D;2}^rg(y)S(\left \lfloor \frac{r}{y} \right \rfloor)$$</p><p>$$S(r)&#x3D;\frac{\sum_{i&#x3D;1}^r(f*g)i-\sum_{y&#x3D;2}^rg(y)S(\left \lfloor \frac{r}{y} \right \rfloor)}{g(1)}$$</p><p>$当g&#x3D;I时，即：$</p><p>$$\ {S(r)&#x3D;1-\sum_{y&#x3D;2}^rS(\left \lfloor \frac{r}{y} \right \rfloor)}$$</p><p>$\ {杜教筛的复杂度为O(n\frac{2}{3})，比线性筛还要快一点，总时间复杂度为O(n^{\frac{2}{3}})。}$</p><h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line">ll sum[N];</span><br><span class="line"></span><br><span class="line">ll n, L, H, k;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans \* a % mod;</span><br><span class="line">        a = a \* a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + mu[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;ll , ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Calc</span>(<span class="params">ll x</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)</span><br><span class="line">        <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">if</span>(mp[x])</span><br><span class="line">        <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        num = (num - Calc(x / l) \* (r - l + <span class="number">1</span>) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>()</span> &#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll l = <span class="number">1</span>, r;l &lt;= H;l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(H / (H / l), (L / l) ? L / (L / l) : H + <span class="number">2</span>);</span><br><span class="line">        ans = (ans + (Calc(r) - Calc(l - <span class="number">1</span>) + mod) % mod \* quick\_pow((H / l) - (L / l), n) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; H;</span><br><span class="line">    L = (L - <span class="number">1</span>) / k; <span class="comment">// 因为后面需要L-1，所以这里干脆就不+1了，但是含义不同</span></span><br><span class="line">    H = H / k;</span><br><span class="line">    Mobi();</span><br><span class="line">    cout &lt;&lt; Ans() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AT5200-AGC038C-LCMs"><a href="#AT5200-AGC038C-LCMs" class="headerlink" title="AT5200 [AGC038C] LCMs"></a><a href="https://www.luogu.com.cn/problem/AT5200">AT5200 [AGC038C] LCMs</a></h4><p>$$求解\sum_{i&#x3D;1}^{N}\sum_{j&#x3D;1}^Nlcm(A_i,A_j)$$</p><p>$莫比乌斯反演处理的一般都是枚举变量之间的关系，所以我们要让A_i和A_j变为i和j的形式。$</p><p>$想要用i和j表示A_i和A_j并且不遗漏任何的A，所以让A等于某个i，就是让cnt_i&#x3D;\ {\sum_{d&#x3D;1}^N[A_d&#x3D;i]}，统计所有A等于某个i的个数，即cnt_i，j也同样如此，如下所示：$</p><p>$$\sum_{i&#x3D;1}^{N}\sum_{j&#x3D;1}^Ncnt_icnt_jlcm(i,j)$$</p><p>$这样还不够，因为i只能是[1,N]的，当Ai中有些值大于N的话，再枚举i从[1,N]就会漏掉大于N的Ai的情况，所以想要统计所有情况，即让N&#x3D;Ai中最大的数即可，即\ {M&#x3D;\max_{i&#x3D;1}^N }。$ $所以我们需要反演的式子为：$</p><p>$$\sum_{i&#x3D;1}^{M}\sum_{j&#x3D;1}^Mcnt_i ⋅cnt_j ⋅lcm(i,j)$$</p><p>$$\sum_{i&#x3D;1}^{M}\sum_{j&#x3D;1}^Mcnt_i ⋅cnt_j ⋅\frac{ij}{gcd(i,j)}$$</p><p>$$\sum_{k&#x3D;1}^M\sum_{i&#x3D;1}^{M}\sum_{j&#x3D;1}^Mcnt_i ⋅cnt_j ⋅\frac{ij}{k[gcd(i,j)&#x3D;k]}$$</p><p>$$\sum_{k&#x3D;1}^M\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{M}{k} \right \rfloor}cnt_{ik} ⋅cnt_{jk} ⋅\frac{ijk^2}{k}[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{k&#x3D;1}^Mk\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{M}{k} \right \rfloor}cnt_{ik} ⋅cnt_{jk} ⋅i ⋅j\sum_{di\;dj}\mu(d)$$</p><p>$$\sum_{k&#x3D;1}^Mk\sum_{d&#x3D;1}^{\left \lfloor \frac{M}{k} \right \rfloor}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{kd} \right \rfloor}cnt_{ikd} ⋅id\sum_{j&#x3D;1}^{\left \lfloor \frac{M}{kd} \right \rfloor}cnt_{jkd} ⋅jd$$</p><p>$$\sum_{k&#x3D;1}^Mk\sum_{d&#x3D;1}^{\left \lfloor \frac{M}{k} \right \rfloor}\mu(d)d^2(\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{kd} \right \rfloor}cnt_{ikd} ⋅i)^2$$</p><p>$令T&#x3D;kd则：$</p><p>$$\sum_{T&#x3D;1}^M(\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{T} \right \rfloor}cnt_{iT} ⋅i)^2\sum_{kT}\mu(k)k^2\frac{T}{k}$$</p><p>$$\sum_{T&#x3D;1}^MT(\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{T} \right \rfloor}cnt_{iT} ⋅i)^2\sum_{kT}\mu(k)k$$</p><p>$令\ {f(x)&#x3D;\sum_{ix}\mu(i)i\;,\;g(x)&#x3D;\sum_{i&#x3D;1}^{\left \lfloor \frac{M}{x} \right \rfloor}cnt_{ix} ⋅i&#x3D;\frac{1}{x}\sum_{xt}tcnt_t},则最后的式子为：$</p><p>$$\sum_{T&#x3D;1}^MTg^2(T)f(T)$$</p><p>$\ {O(n)处理A的次数，O(nlogn)处理f和g，总时间复杂度为O(nlogn)}$</p><h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> tot;</span><br><span class="line">ll f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> M, n;</span><br><span class="line"><span class="built_in">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= M; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> x = i;x &lt;= M; x += i) &#123;</span><br><span class="line">            f[x] += mu[i] \* i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">1</span>;x &lt;= M; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> t = x;t &lt;= M; t += x) &#123;</span><br><span class="line">            g[x] += t \* cnt[t];</span><br><span class="line">        &#125;</span><br><span class="line">        g[x] /= x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    M = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cnt[x]++;</span><br><span class="line">        M = max(M, x);</span><br><span class="line">    &#125;</span><br><span class="line">    Mobi();</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= M; i++) &#123;</span><br><span class="line">        ans += i \* g[i] \* g[i] \* f[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SP5971-LCMSUM-LCM-Sum"><a href="#SP5971-LCMSUM-LCM-Sum" class="headerlink" title="SP5971 LCMSUM - LCM Sum"></a><a href="https://www.luogu.com.cn/problem/SP5971">SP5971 LCMSUM - LCM Sum</a></h4><p>$$求解\sum_{i&#x3D;1}^nlcm(i,n)$$</p><p>$\left \lfloor \frac{n}{k} \right \rfloor$</p><p>$$\sum_{i&#x3D;1}^n\frac{in}{gcd(i,n)}$$</p><p>$$\sum_{k&#x3D;1}^n\sum_{i&#x3D;1}^n\frac{in}{k[gcd(i,n)&#x3D;k]}$$</p><p>$$\sum_{k&#x3D;1}^n\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}in[gcd(i,\frac{n}{k})&#x3D;1]$$</p><p>$$n\sum_{k&#x3D;1}^n\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}i[gcd(i,\frac{n}{k})&#x3D;1]$$</p><p>$$n\sum_{kn}\sum_{i&#x3D;1}^ki[gcd(i,k)&#x3D;1]$$</p><p>$$n\sum_{kn}\sum_{i&#x3D;1}^ki\sum_{di\;dk}\mu(d)$$</p><p>$枚举d：$</p><p>$$n\sum_{kn}\sum_{dk}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{k}{d} \right \rfloor}id$$</p><p>$$n\sum_{kn}\sum_{dk}\mu(d)d\sum_{i&#x3D;1}^{\left \lfloor \frac{k}{d} \right \rfloor}i$$</p><p>$$n\sum_{kn}\sum_{dk}\mu(d)d\frac{\left \lfloor \frac{k}{d} \right \rfloor*(\left \lfloor \frac{k}{d} \right \rfloor+1)}{2}$$</p><p>$$\frac{n}{2}\sum_{kn}{\sum_{dk}\mu(d)*\frac{k^2}{d}+\sum_{dk}\mu(d)*k}$$</p><p>$$\frac{n}{2}\sum_{kn}k{\sum_{dk}\mu(d)*\frac{k}{d}+\sum_{dk}\mu(d)}$$</p><p>$\ {这时候发现两个狄利克雷卷积，\varphi (n)&#x3D;\mu*id&#x3D;\sum_{dn}\mu(d)*\frac{n}{d}\;\;,\;\;\varepsilon(n) &#x3D;\mu*I&#x3D;\sum_{dn}\mu(d)。所以我们将其替换得：}$</p><p>$$\frac{n}{2}\sum_{kn}k[\varphi(k)+\varepsilon(k)]$$</p><p>$\ {O(n)处理\varphi，\sqrt n询问答案，总复杂度为O(n+T\sqrt n)。}$</p><h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> phi[N];</span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> tot;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            prime[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>;j &lt;= tot &amp;&amp; i \* prime[j] &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j]) &#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* (prime[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = i;j &lt; N; j += i) &#123;</span><br><span class="line">            f[j]  += <span class="number">1l</span>l \* phi[i] \* i + (i == <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    Euler();</span><br><span class="line">    <span class="built_in">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; f[n] \* n / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P5221-Product"><a href="#P5221-Product" class="headerlink" title="P5221 Product"></a><a href="https://www.luogu.com.cn/problem/P5221">P5221 Product</a></h4><p>$$求解\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^n\frac{lcm(i,j)}{gcd(i,j)}$$</p><p>$首先还是把lcm(i,j)化简得：$</p><p>$$\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^n\frac{ij}{[gcd(i,j)]^2}$$</p><p>$$\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^nij*\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^n\frac{1}{[gcd(i,j)]^2}$$</p><p>$\ {我们很容易推出前半部分的数值为(n!)^{2n }，后半部分的值就是\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^n[gcd(i,j)]^2的逆元的平方。}$</p><p>$所以现在求解：$</p><p>$$\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^ngcd(i,j)$$</p><p>$$\prod_{k&#x3D;1}^n\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^nk[gcd(i,j)&#x3D;k]$$</p><p>$$\prod_{k&#x3D;1}^nk^{\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n[gcd(i,j)&#x3D;k]}$$</p><p>$这个式子的变换，本来是[1,n]中所有的gcd累乘，然后我们单独把gcd(i,j)&#x3D;k的拿出来，k会有[1,n]的范围，然后我们再将这些k累乘就会达到之前的效果。$ $不过，[1,n]中的gcd不单单只有一个，可能会有多个相同的gcd，所以变换之后的式子里还需要统计gcd&#x3D;k出现的次数，那只需要将他们累加即可。$</p><p>$所以没毛病。继续：$</p><p>$$\prod_{k&#x3D;1}^nk^{\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}[gcd(i,j)&#x3D;1]}$$</p><p>$$\prod_{k&#x3D;1}^nk^{\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\sum_{di\;dj}\mu(d)}$$</p><p>$枚举d：$</p><p>$$\prod_{k&#x3D;1}^nk^{\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{kd} \right \rfloor}1}$$</p><p>$$\ {\prod_{k&#x3D;1}^nk^{\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)(\left \lfloor \frac{n}{kd} \right \rfloor)^2}}$$</p><p>$最终答案为：$</p><p>$$\ {(n!)^{2n}\prod_{k&#x3D;1}^nk^{\sum_{d&#x3D;1}^{\left \lfloor \frac{n}{k} \right \rfloor}\mu(d)(\left \lfloor \frac{n}{kd} \right \rfloor)^2}}$$</p><p>$\ {O(n)处理\mu的前缀和,\sqrt n询问指数的分块，可以用欧拉降幂优化，总时间复杂度为O(n+nlog_2n}$</p><h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="comment">// const ll P = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">104857601</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line">ll fac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans \* a % mod;</span><br><span class="line">        a = a \* a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">        mu[i] = mu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">        fac = fac \* i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Ans</span>()</span> &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">1</span>;k &lt;= n; k++) &#123;</span><br><span class="line">        ll p = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> t = n / k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">1</span>, r;l &lt;= t; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = min(t, t / (t / l));</span><br><span class="line">            p = (p + (mu[r] - mu[l - <span class="number">1</span>] + mod - <span class="number">1</span>) \* (t / l) % (mod - <span class="number">1</span>) \* (t / l) % (mod - <span class="number">1</span>)) % (mod - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans \* quick\_pow(k, p) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll k = quick\_pow(ans, mod - <span class="number">2</span>);</span><br><span class="line">    fac = quick\_pow(fac, n);</span><br><span class="line">    <span class="keyword">return</span> quick\_pow(k, <span class="number">2</span>) \* fac % mod \* fac % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Mobi();</span><br><span class="line">    cout &lt;&lt; Ans() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDU-6588-Function"><a href="#HDU-6588-Function" class="headerlink" title="HDU 6588 Function"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6588">HDU 6588 Function</a></h4><p>$$求解\sum_{i&#x3D;1}^ngcd(\left \lfloor \sqrt[3]i \right \rfloor,i)$$</p><p>$我们先将这个一重和式转化为二重和式，得：$</p><p>$$\sum_{a&#x3D;1}^{\left \lfloor \sqrt[3]n \right \rfloor}\sum_{i&#x3D;1}^ngcd(a,i)[\left \lfloor \sqrt[3]i \right \rfloor&#x3D;a]$$</p><p>$我们来看这个式子，只有当\left \lfloor \sqrt[3]i \right \rfloor&#x3D;a时，才会有对答案的贡献为gcd(a,i)，所以\ {a \leq \left \lfloor \sqrt[3]i \right \rfloor &lt; a+1，a^3 \leq i \leq (a+1)^3-1}，所以上式转化为：$</p><p>$$\ {\sum_{a&#x3D;1}^{\left \lfloor \sqrt[3]n \right \rfloor}\sum_{i&#x3D;a^3}^{min(n,(a+1)^3-1)}gcd(a,i)}$$</p><p>$然后我们将这个二重和式拆开得：$</p><p>$${\color{Brown}\sum_{a&#x3D;1}^{\left \lfloor \sqrt[3]n \right \rfloor-1}\sum_{i&#x3D;a^3}^{min(n,(a+1)^3-1)}gcd(a,i)+\sum_{i&#x3D;(\left \lfloor \sqrt[3]n \right \rfloor)^3}^ngcd(\left \lfloor \sqrt[3]n \right \rfloor, i)}$$</p><p>$令\sqrt[3]n&#x3D;N，并使a&#x3D;i,i&#x3D;j（好看一点）得：$</p><p>$${\color{Brown}\sum_{i&#x3D;1}^{N-1}\sum_{j&#x3D;i^3}^{(i+1)^3-1}gcd(i,j)+\sum_{j&#x3D;N^3}^ngcd(N, j)}$$</p><p>$先计算前半部分：$</p><p>$——————————–$</p><h4 id="HDU-6833-A-Very-Easy-Math-Problem"><a href="#HDU-6833-A-Very-Easy-Math-Problem" class="headerlink" title="HDU 6833 A Very Easy Math Problem"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6833">HDU 6833 A Very Easy Math Problem</a></h4><p>$$求解\sum_{a_1&#x3D;1}^n\sum_{a_2&#x3D;1}^n…\sum_{a_x&#x3D;1}^n\left(\prod_{j&#x3D;1}^xa_j^k\right)f(gcd(a_1,a_2…a_x))gcd(a_1,a_2…a_x)$$ $令d&#x3D;gcd(a_1,a_2…a_x)得：$</p><p>$$\sum_{a_1&#x3D;1}^n\sum_{a_2&#x3D;1}^n…\sum_{a_x&#x3D;1}^n\left(\prod_{j&#x3D;1}^xa_j^k\right)f(d)d$$</p><p>$枚举d得：$</p><p>$$\sum_{d&#x3D;1}^ndf(d)\sum_{a_1&#x3D;1}^n\sum_{a_2&#x3D;1}^n…\sum_{a_x&#x3D;1}^n\left(\prod_{j&#x3D;1}^xa_j^k\right)[gcd(a_1,a_2…a_x)&#x3D;d]$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{a_1&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\sum_{a_2&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }…\sum_{a_x&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\left(\prod_{j&#x3D;1}^xa_j^k\right)[gcd(a_1,a_2…a_x)&#x3D;1]$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{a_1&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\sum_{a_2&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }…\sum_{a_x&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\left(\prod_{j&#x3D;1}^xa_j^k\right)\sum_{ta_1\;ta2\;…\;ta_x}\mu(t)$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }i^k\right)^x\sum_{ta_1\;ta2\;…\;ta_x}\mu(t)$$</p><p>$枚举t得：$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{t&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\mu(t)\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{dt} \right \rfloor }(it)^k\right)^x$$</p><p>$$\sum_{d&#x3D;1}^nd^{kx+1}f(d)\sum_{t&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor }\mu(t)t^{kx}\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{dt} \right \rfloor }i^k\right)^x$$</p><p>$令T&#x3D;dt并枚举T得：$</p><p>$$\sum_{T&#x3D;1}^n\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{dt} \right \rfloor }i^k\right)^xT^{kx}\sum_{dT}df(d)\mu(\frac{T}{d})$$</p><p>$令g(T)&#x3D;\sum_{dT}df(d)\mu(\frac{T}{d})，则$</p><p>$$\sum_{T&#x3D;1}^n\left (\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{T} \right \rfloor }i^k\right)^xT^{kx}g(T)$$</p><p>$\ {O(nlogn)筛f和g，并对T^{kx}g(T)和\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{T} \right \rfloor }i^k做前缀和，最后\sqrt n分块计算，复杂度为O(nlogn+T\sqrt n)}$</p><h2 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line">typedef pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> lowbit(x) x &amp; (-x)</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="comment">// const double pi = acos(-1);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll T, k, x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> mu[N]; <span class="comment">// 莫比乌斯函数</span></span><br><span class="line"><span class="built_in">bool</span> <span class="keyword">is</span>\_prime[N];</span><br><span class="line"><span class="built_in">int</span> prime[N];</span><br><span class="line"><span class="built_in">int</span> cnt;</span><br><span class="line">ll g[N], f[N];</span><br><span class="line">ll sumG[N], sumi[N];</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans \* a % mod;</span><br><span class="line">        a = a \* a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mobi</span>() <span class="comment">// 莫比乌斯函数初始化</span></span></span><br><span class="line">&#123;</span><br><span class="line">    f[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">is</span>\_prime[<span class="number">0</span>] = <span class="keyword">is</span>\_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">is</span>\_prime[i]) &#123;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">is</span>\_prime[i \* prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i \* prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i \* prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 筛f函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> d = <span class="number">2</span>;d \* d &lt; N; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = d \* d;i &lt; N; i += d \* d) &#123;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 筛g函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> d = <span class="number">1</span>;d &lt; N; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = d;i &lt; N; i += d) &#123;</span><br><span class="line">            g[i] = (g[i] + <span class="number">1l</span>l \* d \* f[d] % mod \* mu[i / d] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理sumG函数和sumi函数前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        ll t = quick\_pow(i, k);</span><br><span class="line">        sumi[i] = (sumi[i - <span class="number">1</span>] + t) % mod;</span><br><span class="line">        sumG[i] = (sumG[i - <span class="number">1</span>] + quick\_pow(t, x) \* g[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span> &#123;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    Mobi();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> l = <span class="number">1</span>, r;l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = min(n, n / (n / l));</span><br><span class="line">            ans = (ans + (sumG[r] - sumG[l - <span class="number">1</span>] + mod) % mod \* quick\_pow(sumi[n / l], x) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span> &#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">##ifdef FZT\_ACM\_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    signed test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        auto start\_clock\_for\_debug = clock();</span><br><span class="line">        solve();</span><br><span class="line">        auto end\_clock\_for\_debug = clock();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.putback(acm\_local\_for\_debug));</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="huntian-oy"><a href="#huntian-oy" class="headerlink" title="huntian oy"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6706">huntian oy</a></h4><p>$$求解\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^igcd(i^a-j^a,i^b-j^b)[gcd(i,j)&#x3D;1]$$</p><p>$$gcd(i^a-j^a,i^b-j^b)&#x3D;i^{gcd(a,b)}-j^{gcd(a,b)}$$</p><p>$题目说gcd(a,b)&#x3D;1，所以那个复杂的式子直接变成i-j.$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^i(i-j)[gcd(i,j)&#x3D;1]$$</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^ii[gcd(i,j)&#x3D;1]-\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^ij[gcd(i,j)&#x3D;1]$$</p><p>$左边为与i互质的个数，右边为比i小并且互质的数字和，即为：$</p><p>$$\sum_{i&#x3D;1}^ni\varphi (i)-\frac{\sum_{i&#x3D;1}^ni\varphi (i)+1}{2}$$</p><p>$$\frac{\sum_{i&#x3D;1}^ni\varphi (i)-1}{2}$$</p><p>$因为n有1e9，所以需要杜教筛优化。$</p><p>$$f*g(n)&#x3D;\sum_{dn}f(d)g(\frac{n}{d})&#x3D;\sum_{dn}id(d)*\varphi (d)*g(\frac{n}{d})$$</p><p>$很显然，设g&#x3D;id，则：$</p><p>$$f*g(n)&#x3D;\sum_{dn}\varphi (d)id(n)&#x3D;n\sum_{dn}\varphi (d)&#x3D;id(n)(\varphi *I)&#x3D;id^2(n)&#x3D;n^2$$</p><p>$$所以得：S(n)&#x3D;\sum_{i&#x3D;1}^n(f*g)i-\sum_{i&#x3D;2}^ng(i)S(\frac{n}{i})&#x3D;\frac{n(n+1)(2n+1)}{6}-\sum_{i&#x3D;2}^niS(\frac{n}{i})$$</p><h2 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> eb emplace\_back</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// const ll mod = 998244353;</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">0.57721566490153286060651209</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a)</span> </span>&#123;<span class="type">char</span> c = <span class="built_in">getchar</span>();T x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;c = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) &#123;x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">&#x27;0&#x27;</span>;c = <span class="built_in">getchar</span>();&#125;a = f \* x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is\_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line"><span class="type">int</span> phi[N];</span><br><span class="line">ll sum\_i\_phi[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is\_prime[i]) prime[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            is\_prime[i \* prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i \* prime[j]] = phi[i] \* prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i \* prime[j]] = phi[i] \* phi[prime[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i++) &#123;</span><br><span class="line">        sum\_i\_phi[i] = (sum\_i\_phi[i - <span class="number">1</span>] + <span class="number">1ll</span> \* i \* phi[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick\_pow(ll a, ll b) &#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans \* a % mod;</span><br><span class="line">         a = a \* a % mod;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv2;</span><br><span class="line">ll inv6;</span><br><span class="line"></span><br><span class="line">map&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N) <span class="keyword">return</span> sum\_i\_phi[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> mp[x];</span><br><span class="line">    ll ans = x \* (x + <span class="number">1</span>) % mod \* (<span class="number">2</span> \* x + <span class="number">1</span>) % mod \* inv6 % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">2</span>, r;l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = <span class="built_in">min</span>(x, x / (x / l));</span><br><span class="line">        ans = (ans - <span class="number">1ll</span> \* (r + l) % mod \* (r - l + <span class="number">1</span>) % mod \* inv2 % mod \* <span class="built_in">S</span>(x / l)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    inv2 = quick\_pow(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">    inv6 = quick\_pow(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> \_; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;\_);</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        ll n, a, b; <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">        ll ans = (<span class="built_in">S</span>(n) - <span class="number">1</span>) % mod;</span><br><span class="line">        ans = ans \* inv2 % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans % mod + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT\_ACM\_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start\_clock\_for\_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end\_clock\_for\_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm\_local\_for\_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDU-6428-Problem-C-Calculate"><a href="#HDU-6428-Problem-C-Calculate" class="headerlink" title="HDU 6428 Problem C. Calculate"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6428">HDU 6428 Problem C. Calculate</a></h4><p>$$求解\sum_{i&#x3D;1}^A\sum_{j&#x3D;1}^B\sum_{k&#x3D;1}^C\phi (gcd(i,j^2,k^3))\;\;mod\;\;2^{30}$$</p><p>$首先要把\phi和gcd分开，即\phi(n)&#x3D;\sum_{dn}(\phi*\mu)(d)，证明如下：$ $$\phi(n)&#x3D;(\mu*id)(n)$$</p><p>$$\sum_{dn}\mu(d)\frac{n}{d}$$</p><p>$$\sum_{dn}\mu(d)\sum_{d’\frac{n}{d}}\phi(d’)$$</p><p>$$\sum_{dd’n}\mu(d)\phi(d’)$$</p><p>$$\sum_{dn}\sum_{d’d}\mu(d’)\phi(\frac{d}{d’})$$</p><p>$$\sum_{dn}(\phi*\mu)(d)$$</p><p>$所以原式变为：$</p><p>$$\sum_{i&#x3D;1}^A\sum_{j&#x3D;1}^B\sum_{k&#x3D;1}^C\sum_{di\;dj^2\;dk^3}(\phi*\mu)(d)$$</p><p>$$\sum_{d&#x3D;1}^{A}(\phi*\mu)(d)\sum_{i&#x3D;1\;di}^A\sum_{j&#x3D;1\;dj^2}^B\sum_{k&#x3D;1\;dk^3}^C1$$ \left \lceil \right \rceil $观察后面式子，对于一个x^k，若dx^k，先把d分解为\prod p_i^{a_i}.$ $则\prod p_i^{a_i}x^k，得\prod p_i^{\left \lceil \frac{a_i}{k} \right \rceil }x，所以设$</p><p>$$f_k(n)&#x3D;\prod p_i^{\left \lceil \frac{a_i}{k} \right \rceil }$$</p><p>$则：$</p><p>$$ans&#x3D;\sum_{d&#x3D;1}^{A}(\phi * \mu)(d)\frac{A}{f_1(d)}\frac{B}{f_2(d)}\frac{C}{f_3(d)}$$</p><p>$对于f_k(n)，类似分解n的形式。$ $分解质因子的过程中，记录质因子的指数，每次质因子+1时，若\%k&#x3D;1时，说明该向上取整了，于是f_k(n)*&#x3D;该质因子.$</p><p>$由于\phi和\mu都是积性函数，卷积之后还是积性函数，设g(d)&#x3D;(\phi*\mu)(d)，则$</p><p>$$\phi(n)&#x3D;\sum_{dn}g(d)$$</p><p>$那么可以得：$</p><p>$$\phi(p^k)&#x3D;\phi(p^{k-1})+g(p^k)$$</p><p>$$g(p^k)&#x3D;\phi(p^k)-\phi(p^{k-1})$$</p><p>$$g(p^k)&#x3D;(p-1)p^{k-1}-(p-1)p^{k-2}$$</p><p>$$g(p^k)&#x3D;(p-1)^2p^{k-2}$$</p><p>$当我们欧拉筛的过程中：$</p><p>$$g(1)&#x3D;1$$</p><p>$$g(p)&#x3D;p-2$$</p><p>$$g(p^{k})&#x3D;(p-1)^2p^{k-2}$$</p><p>$$g(p_1^{k_1}p_2^{k_2})&#x3D;g(p_1^{k_1})g(p_2^{k_2})$$</p><p>$$……$$</p><h2 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = (<span class="number">1ll</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">bool</span> is\_prime[N];</span><br><span class="line"><span class="type">int</span> prime[N], cnt;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"><span class="type">int</span> f1[N], f2[N], f3[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f1[<span class="number">1</span>] = f2[<span class="number">1</span>] = f3[<span class="number">1</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        f1[i] = i;</span><br><span class="line">        <span class="keyword">if</span>(!is\_prime[i]) prime[++cnt] = f2[i] = f3[i] = i, g[i] = i - <span class="number">2</span>, deg[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i \* prime[j] &lt; N; j++) &#123;</span><br><span class="line">            <span class="type">int</span> now = i \* prime[j];</span><br><span class="line">            is\_prime[now] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                deg[now] = deg[i] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> num = <span class="number">1</span>, tmp = i;</span><br><span class="line">                <span class="keyword">while</span>(num &lt;= <span class="number">3</span> &amp;&amp; tmp % prime[j] == <span class="number">0</span>) num++, tmp /= prime[j];</span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">1</span>) g[now] = g[i] \* g[prime[j]];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span>) g[now] = g[i / prime[j]] \* (prime[j] - <span class="number">1</span>) \* (prime[j] - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> g[now] = g[i] \* prime[j];</span><br><span class="line">                f2[now] = f2[i] \* (deg[now] % <span class="number">2</span> == <span class="number">1</span> ? prime[j] : <span class="number">1</span>);</span><br><span class="line">                f3[now] = f3[i] \* (deg[now] % <span class="number">3</span> == <span class="number">1</span> ? prime[j] : <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                deg[now] = <span class="number">1</span>;</span><br><span class="line">                f2[now] = f2[i] \* f2[prime[j]];</span><br><span class="line">                f3[now] = f3[i] \* f3[prime[j]];</span><br><span class="line">                g[now] = g[i] \* g[prime[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> \_; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;\_);</span><br><span class="line">    <span class="keyword">while</span>(\_--) &#123;</span><br><span class="line">        <span class="type">int</span> A, B, C; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;A,&amp;B,&amp;C);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">1</span>;d &lt;= A; d++) &#123;</span><br><span class="line">            ans = (ans + <span class="number">1ll</span> \* g[d] \* (A / f1[d]) % mod \* (B / f2[d]) % mod \* (C / f3[d]) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans % mod + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios\_base::sync\_with\_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT\_ACM\_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test\_index\_for\_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm\_local\_for\_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm\_local\_for\_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test\_index\_for\_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> runtime\_error(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start\_clock\_for\_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end\_clock\_for\_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test\_index\_for\_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end\_clock\_for\_debug - start\_clock\_for\_debug) / CLOCKS\_PER\_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm\_local\_for\_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm\_local\_for\_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/10/mobius-inversion/">https://blog.jujimeizuo.cn/2020/08/10/mobius-inversion/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第九场】E题 Groundhog Chasing Death</title>
      <link href="/2020/08/09/2020-nowcoder-shujia-9-e/"/>
      <url>/2020/08/09/2020-nowcoder-shujia-9-e/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5674/E">https://ac.nowcoder.com/acm/contest/5674/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2020/08/20200808213125440.png"></p><p>$求\prod_{i&#x3D;a}^b\prod_{i&#x3D;c}^dgcd(x^i, y^j) mod998244353的值$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>观察上式，我们知道$gcd$是$x,y$的所有质因子个数的$min(a,b)$，即$gcd(x,y)&#x3D;\sum_{i&#x3D;1}^np_i^{min(ai,bi）}$（ai,bi分别是x,y公共质因子的次幂） 所以，我们可以统计$x,y$的每个公共质因子的次幂，然后再全部整合累乘得出答案。</p><p>一步一步分析： 要求$\prod_{i&#x3D;a}^b \prod_{i&#x3D;c}^dgcd(x^i, y^j)$ 其实求的就是$\prod_{px ,py}p_k^{\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;c}^dmin(Ai,Bj)}$(A,B分别为x,y分解出质因子p的次幂) 先统计x,y所有的公共质因子的次幂，然后再累乘即可 所以我们可以先质数筛把\sqrt{1e9}以内的所有质数筛出来，所以范围我定为2e5以内的质数了，然后再分解x和y的质因子，分别把公共质因子p和该因子的次幂cx,cy存在数组里，方便下面步骤的实现 然后单独分析单个公共质因子p，得$p^{\sum_{i&#x3D;a}^b\sum_{j&#x3D;c}^d min(Ai,Bj)}$ $先比较Ai和Bj的大小：$ $\qquad当Ai \leq Bj时，即j \geq \left \lceil \frac{Ai}{B}\right \rceil，p^{min(Ai,Bj)}&#x3D;p^{Ai}$ $\qquad当Ai &gt; Bj时，即j &lt; \left \lceil \frac{Ai}{B}\right \rceil，p^{min(Ai,Bj)}&#x3D;p^{Bj}$</p><p>接下来就有两种求解方式了，实质上是一种，只不过枚举顺序有点变化而已。</p><h4 id="方法一：先枚举-i-再枚举公共质因子"><a href="#方法一：先枚举-i-再枚举公共质因子" class="headerlink" title="方法一：先枚举$i$再枚举公共质因子"></a>方法一：先枚举$i$再枚举公共质因子</h4><p>这个方法有点一小麻烦，理解有点困难。</p><p>因为先把$i$确定下来之后，$j$也就确定下来了，因为$j&#x3D; \left \lceil \frac{Ai}{B}\right \rceil$。 再来看这个式子：$\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;c}^dmin(Ai,Bj)$ 因为枚举的是$i$，并且$j$已经确定了，再根据大小比较，所以上面的式子就是两种变化：$$\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;max(\left \lceil \frac{Ai}{B}\right \rceil,c)}^dAi$$ $$\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;c}^dBj$$ 所以就有以下三种情况： $\qquad 当j&lt;c时，\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;c}^dmin(Ai,Bj)&#x3D;Ai*(d+c-1)$</p><p>$\qquad 当j&gt;d时，\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;c}^dmin(Ai,Bj)&#x3D;B*\frac{(c+d)*(d-c+1)}{2}$</p><p>$\qquad 当c\leq j \leq d时，\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;c}^dmin(Ai,Bj)&#x3D;Ai*(d-j+1)+B*\frac{(j+c-1)*(j-c)}{2}$</p><p>当把所有的公共质因子的总次幂求出来之后就可以进行累乘得出答案，再求总次幂的过程中可以用欧拉降幂优化一下， 并且模数$998244353$正好是一个质数，所以$\varphi(998244353)&#x3D;998244353-1$。</p><h3 id="Code（286ms）"><a href="#Code（286ms）" class="headerlink" title="Code（286ms）"></a>Code（286ms）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> px[N], cx[N], py[N], cy[N], mx, my; <span class="comment">// 是x和y分解的质因子和质因子的次幂和质因子的个数</span></span><br><span class="line">ll mi[N]; <span class="comment">// 求解出来每个质因子的总次幂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> cx, cy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; v1; <span class="comment">// x和y的公共质因子的个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2; <span class="comment">// x和y的公共质因子的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> <span class="comment">// 质数筛</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(is_prime, <span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">                is_prime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Divide</span><span class="params">(ll n, <span class="type">int</span> *p, <span class="type">int</span> *c, <span class="type">int</span> &amp;m)</span> <span class="comment">// 分解质因子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p[++m] = i;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                c[m]++;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        p[++m] = n;</span><br><span class="line">        c[m] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    ll a, b, c, d, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;x,&amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Divide</span>(x, px, cx, mx); <span class="comment">// 分解x和y的质因子（值、个数）并存在数组里</span></span><br><span class="line">    <span class="built_in">Divide</span>(y, py, cy, my);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ppx = <span class="number">1</span>, ppy = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ppx &lt;= mx &amp;&amp; ppy &lt;= my) &#123; <span class="comment">// 寻找x和y的公共质因子并存在数组里</span></span><br><span class="line">        <span class="keyword">if</span>(px[ppx] == py[ppy]) &#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(node&#123;cx[ppx], cy[ppy]&#125;);</span><br><span class="line">            v2.<span class="built_in">push_back</span>(px[ppx]);</span><br><span class="line">            ppx++; ppy++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(px[ppx] &lt; py[ppy]) ppx++;</span><br><span class="line">        <span class="keyword">else</span> ppy++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a;i &lt;= b; i++) &#123; <span class="comment">// 枚举i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; v1.<span class="built_in">size</span>(); k++) &#123; <span class="comment">// 每个质因子的个数A和B</span></span><br><span class="line">            <span class="comment">// int p = v2[k]; // 提取质因子</span></span><br><span class="line">            <span class="type">int</span> ccx = v1[k].cx, ccy = v1[k].cy; <span class="comment">// 提取质因子个数</span></span><br><span class="line">            <span class="type">int</span> j = (ccx * i + ccy - <span class="number">1</span>) / ccy; <span class="comment">// 本来是ccx*i/ccy，不过要保证向上取整，即+(B-1)/B就可以保证了，或者使用ceil()函数</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; c) &#123;</span><br><span class="line">                ll t = <span class="number">1ll</span> * (d - c + <span class="number">1</span>);</span><br><span class="line">                mi[k] = (mi[k] + t * i * ccx) % (mod - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; d) &#123;</span><br><span class="line">                ll t = <span class="number">1ll</span> * (d + c) * (d - c + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                mi[k] = (mi[k] + t * ccy) % (mod - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll t1 = <span class="number">1ll</span> * (d - j + <span class="number">1</span>);</span><br><span class="line">                ll t2 = <span class="number">1ll</span> * (j - c) * (c + j - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                mi[k] = (mi[k] + t1 * ccx * i) % (mod - <span class="number">1</span>);</span><br><span class="line">                mi[k] = (mi[k] + t2 * ccy) % (mod - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mi[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = ans * <span class="built_in">quick_pow</span>(v2[i], mi[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：先枚举公共质因子再枚举-i-和-j"><a href="#方法二：先枚举公共质因子再枚举-i-和-j" class="headerlink" title="方法二：先枚举公共质因子再枚举$i$和$j$"></a>方法二：先枚举公共质因子再枚举$i$和$j$</h4><p>这个方法稍微简单一点，便于理解。</p><p>根据下面两个两个大小关系，我们可以先通过枚举每个公共质因子，然后两个循环枚举$i$和$j$比大小，确定每个质因子的总次幂即可。 $当Ai \leq Bj时，即j \geq \left \lceil \frac{Ai}{B}\right \rceil，p^{min(Ai,Bj)}&#x3D;p^{Ai}$ $当Ai &gt; Bj时，即j &lt; \left \lceil \frac{Ai}{B}\right \rceil，p^{min(Ai,Bj)}&#x3D;p^{Bj}$</p><p>所以我们可以得到下面两个式子求解公共质因子$p$的总次幂： $$\sum_{i&#x3D;a}^{b}\sum_{j&#x3D;max(\left \lceil \frac{Ai}{B}\right \rceil,c)}^dAi$$ $$\sum_{j&#x3D;c}^{d}\sum_{i&#x3D;max(\left \lceil \frac{Bj}{A}\right \rceil,a)}^bBj$$</p><p>当然，这里有几个小问题。</p><ul><li>$j \geq \left \lceil \frac{Ai}{B}\right \rceil$，如果这里没有正好整除的时候，那还行，因为我们需要的时向上取整，但是如果正好整除呢，那么我们需要$j+1$即$j&#x3D;\frac{Ai}{B}+1$</li><li>举一个小栗子，枚举$i$的时候，因为$j&#x3D;max(\left \lceil \frac{Ai}{B}\right \rceil,c)$，要是$j&gt;d$，那么就不进行下面的操作，同理枚举$j$。</li></ul><p>每处理一个公共质因子，把他的总次幂求解出来之后，即可将他用快速幂并加到答案$ans$里，因为可以用到欧拉降幂，所以快速幂之前的$pow1+pow2$先$mod$就不是$998244353$，而是$998244353-1$，不然会出错的。</p><h3 id="Code-691ms"><a href="#Code-691ms" class="headerlink" title="Code (691ms)"></a>Code (691ms)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> px[N], cx[N], py[N], cy[N], mx, my; <span class="comment">// 是x和y分解的质因子和质因子的次幂和质因子的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> cx, cy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; v1; <span class="comment">// x和y的公共质因子的个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2; <span class="comment">// x和y的公共质因子的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> <span class="comment">// 质数筛</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(is_prime, <span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++) &#123;</span><br><span class="line">                is_prime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Divide</span><span class="params">(ll n, <span class="type">int</span> *p, <span class="type">int</span> *c, <span class="type">int</span> &amp;m)</span> <span class="comment">// 分解质因子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p[++m] = i;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                c[m]++;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        p[++m] = n;</span><br><span class="line">        c[m] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    ll a, b, c, d, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;x,&amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Divide</span>(x, px, cx, mx); <span class="comment">// 分解x和y的质因子（值、个数）并存在数组里</span></span><br><span class="line">    <span class="built_in">Divide</span>(y, py, cy, my);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ppx = <span class="number">1</span>, ppy = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ppx &lt;= mx &amp;&amp; ppy &lt;= my) &#123; <span class="comment">// 寻找x和y的公共质因子并存在数组里</span></span><br><span class="line">        <span class="keyword">if</span>(px[ppx] == py[ppy]) &#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(node&#123;cx[ppx], cy[ppy]&#125;);</span><br><span class="line">            v2.<span class="built_in">push_back</span>(px[ppx]);</span><br><span class="line">            ppx++; ppy++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(px[ppx] &lt; py[ppy]) ppx++;</span><br><span class="line">        <span class="keyword">else</span> ppy++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; v2.<span class="built_in">size</span>(); k++) &#123; <span class="comment">// 枚举每个公共质因子</span></span><br><span class="line"></span><br><span class="line">        ll pow1 = <span class="number">0</span>, pow2 = <span class="number">0</span>; <span class="comment">// 下面两个循环的次幂</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ll i = a;i &lt;= b; i++) &#123; <span class="comment">// 先枚举i</span></span><br><span class="line">            ll j;</span><br><span class="line">            <span class="keyword">if</span>(v1[k].cx * i % v1[k].cy == <span class="number">0</span>)</span><br><span class="line">                j = <span class="built_in">max</span>(v1[k].cx * i / v1[k].cy, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = <span class="built_in">max</span>(v1[k].cx * i / v1[k].cy + <span class="number">1</span>, c); <span class="comment">// 向上取整并且没有整除</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &lt;= d)</span><br><span class="line">                pow1 = (pow1 + i * (d - j + <span class="number">1</span>) % (mod - <span class="number">1</span>)) % (mod - <span class="number">1</span>); <span class="comment">// 欧拉降幂</span></span><br><span class="line">        &#125;</span><br><span class="line">        pow1 = pow1 * v1[k].cx % (mod - <span class="number">1</span>); <span class="comment">// 不要忘了系数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ll j = c;j &lt;= d; j++) &#123; <span class="comment">// 再枚举j</span></span><br><span class="line"></span><br><span class="line">            ll i = <span class="built_in">max</span>(v1[k].cy * j / v1[k].cx + <span class="number">1</span>, a);<span class="comment">// 因为上面枚举i的时候处理一次重复的情况，所以这里就不需要再考虑了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= b)</span><br><span class="line">                pow2 = (pow2 + j * (b - i + <span class="number">1</span>) % (mod - <span class="number">1</span>)) % (mod - <span class="number">1</span>); <span class="comment">// 欧拉降幂</span></span><br><span class="line">        &#125;</span><br><span class="line">        pow2 = pow2 * v1[k].cy % (mod - <span class="number">1</span>); <span class="comment">// 不要忘了系数</span></span><br><span class="line"></span><br><span class="line">        ans = ans * <span class="built_in">quick_pow</span>(v2[k], (pow1 + pow2) % (mod - <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>感谢赛中和赛后牌王的“热情”指导,牌王无敌！！！</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/09/2020-nowcoder-shujia-9-e/">https://blog.jujimeizuo.cn/2020/08/09/2020-nowcoder-shujia-9-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第六场】6827 Road To The 3rd Building</title>
      <link href="/2020/08/06/hdu-6827/"/>
      <url>/2020/08/06/hdu-6827/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6827">http://acm.hdu.edu.cn/showproblem.php?pid=6827</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Because of the thriller adventure game The 3rd Building, there are fewer and fewer students who would like to go to the 3rd Building. So few students are working in the studio in the 3rd Building. Students are even more reluctant to go to the 3rd Building for experiments, which are also annoying.</p><p>Kanade takes responsibility to improve this status. She thinks it a good idea to decorate the ginkgo trees along the road to the 3rd Building, making them cute. There are n ginkgo trees that are planted along the road, numbered with 1…n. Each tree has a cute value. The cute value of tree i is si.</p><p>Kanade defines a plan as an ordered pair (i,j), here 1≤i≤j≤n. It means a student will appear at the position of the tree i magically, walk along the road, and finally stop walking at the position of the tree j. The cute level of a plan is the average of the cute value of the trees visited. Formally, the cute level of plan (i,j) is 1j−i+1∑jk&#x3D;isk.</p><p>Kanade wants to know the mathematical expectation of the cute level if a student will take a plan among all these plans in a uniformly random way. But she is busy with learning Computer Networking, would you help her?</p><p>Input The first line of the input contains an integer T — the number of testcases. You should process these testcases independently.</p><p>The first line of each testcase contains an integer n — the number of ginkgo trees.</p><p>The second line of each testcase contains n integers si — the cute value of each ginkgo tree, space-separated.</p><p>1≤T≤20,1≤n≤2×105,1≤si≤109</p><p>It is guaranteed that ∑n≤106.</p><p>Output For each testcase, output the answer in the fraction form modulo 109+7 in one line. That is, if the answer is PQ, you should output P⋅Q−1mod(109+7), where Q−1 denotes the multiplicative inverse of Q modulo 109+7.</p><p>Sample Input 3 3 1 3 2 6 1 1 4 5 1 4 9 7325 516 56940 120670 16272 15007 337527 333184 742294</p><p>Sample Output 83333336 188888893 303405448</p><p><strong>有n棵银杏树，每棵树都有可爱价值，当从第i棵树走到第j棵树，则他们的平均可爱价值为$\frac{\sum_{k&#x3D;i}^{j}s[k]}{j-i+1}$，最后求这些可爱价值的数学期望。</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的思路是手动模拟一下每种情况。</p><p><img src="/images/2020/08/20200806190719617.png"></p><p>先从起点为$1$开始，首先是$1$到$1$，那就是这一点的平均可爱价值为$\frac{s[1]}{1}$，然后$1$走到$2$的平均可爱价值为$\frac{s[1]+s[2]}{2}$，然后$1$走到$3$的平均可爱价值为$\frac{s[1]+s[2]+s[3]}{3}$…..最后就是$1$走到$n$的平均可爱价值为$\frac{s[1]+s[2]+…s[n]}{n}$。 然后从起点为$2$开始，首先是$2$到$2$，那就是这一点的平均可爱价值为$\frac{s[2]}{1}$，最后就是$2$走到$n$的平均可爱价值为$\frac{s[2]+…s[n]}{n-1}$。 中间省略很多起点。。。。。 接着就是从起点为$n-1$开始，那这只有两种情况，分别为$\frac{s[n-1]}{1}$和$\frac{s[n-1]+s[n]}{2}$。 最后就是从起点为$n$开始，就是$n$到$n$，平均可爱价值为$\frac{s[n]}{1}$。</p><p>我们这里只是从一个起点到另外一个终点的平均可爱价值求出来，题目说可以$i$到$j$和$j$到$i$两种走法，但是这两种的结果都是一样的平均可爱价值，只需要求一次就可。</p><p>那我们把这些情况重新排列一下，如下所示：</p><p>$i&#x3D;1：\frac{s[1]}{1}+\frac{s[1]+s[2]}{2}+\frac{s[1]+s[2]+s[3]}{3}……+\frac{s[1]+s[2]+…s[n]}{n}$</p><p>$i&#x3D;2:\frac{s[2]}{1}+\frac{s[2]+s[3]}{2}+\frac{s[2]+s[3]+s[4]}{3}……+\frac{s[2]+…s[n]}{n-1}$</p><p>$…$ $i&#x3D;n-1:\frac{s[n-1]}{1}+\frac{s[n-1]+s[n]}{2}$</p><p>$i&#x3D;n:\frac{s[n]}{1}$</p><p>观察上述所有情况，我们把分母相同的分式相加得（设分母为$k$）：</p><p>$k&#x3D;1:\frac{s[1]+s[2]+…+s[n]}{1}$</p><p>$k&#x3D;2:\frac{s[1]+2*(s[2]+…+s[n-1])+s[n]}{2}$</p><p>这里要好好品一下，$s[2]到s[n-1]$都是要乘$2$的。那么下面的情况都是要乘上一些系数，而且都是呈三角形状态。 $k&#x3D;3:\frac{s[1]+2*s[2]+3*(s[3]+…s[n-2])+2*s[n-1]+s[n-1]}{3}$</p><p>省略很多分母。。。。。。</p><p>$k&#x3D;n-2:\frac{s[1]+2*s[2]+3*(s[3]+…s[n-2])+2*s[n-1]+s[n-1]}{n-2}$</p><p>$k&#x3D;n-1:\frac{s[1]+2*(s[2]+…+s[n-1])+s[n]}{n-1}$</p><p>$k&#x3D;n:\frac{s[1]+s[2]+…+s[n]}{n}$</p><p>这里有个规律，k&#x3D;1和k&#x3D;n的分子相同,得出k和n-k+1的分子是相同的，而且分子随着分母的变大$（1 - \frac{n}{2}）$呈现一个上述说的三角形状态，中间的s[i]的系数都是逐渐递增，笔者的语言组织太差，就自行理解一下。所以下面我们求平均可爱价值就可以$O(\frac{n}{2})$求。</p><p>=&#x3D;注意，当n为偶数的时候可以直接上面方法求，但是当n为奇数的时候，最中间的数$s[n&#x2F;2+1]$要另外加上，不要忘记！&#x3D;&#x3D;</p><p>分母我们可以预处理线性逆元，分子我们可以先预处理前缀和，然后根据（分母增大）系数加上相对应的前缀和。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll invn[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; <span class="number">200005</span>; i++)</span><br><span class="line">        invn[i] = mod - (mod / i) * invn[mod % i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            f[i] = (f[i - <span class="number">1</span>] + a[i] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            k = (k + f[n - i + <span class="number">1</span>] - f[i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">            ans = (ans + k * invn[i] % mod) % mod;</span><br><span class="line">            ans = (ans + k * invn[n - i + <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            ans = (ans + (k + a[n / <span class="number">2</span> + <span class="number">1</span>]) % mod * invn[n / <span class="number">2</span> + <span class="number">1</span>] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = (ans * <span class="built_in">quick_pow</span>(((n + <span class="number">1</span>) * n / <span class="number">2</span>) % mod, mod - <span class="number">2</span>)) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于线性逆元的板子我把括号的位置敲错地方，导致一直都是wa的状态，我是傻逼，我是傻逼，我是傻逼，重要的事情说三遍！！！</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/06/hdu-6827/">https://blog.jujimeizuo.cn/2020/08/06/hdu-6827/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第五场】6825 Set1</title>
      <link href="/2020/08/05/hdu-6825/"/>
      <url>/2020/08/05/hdu-6825/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6825">http://acm.hdu.edu.cn/showproblem.php?pid=6825</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>You are given a set S&#x3D;{1..n}. It guarantees that n is odd. You have to do the following operations until there is only 1 element in the set:</p><p>Firstly, delete the smallest element of S. Then randomly delete another element from S.</p><p>For each i∈[1,n], determine the probability of i being left in the S.</p><p>It can be shown that the answers can be represented by PQ, where P and Q are coprime integers, and print the value of P×Q−1 mod 998244353.</p><p>Input The first line containing the only integer T(T∈[1,40]) denoting the number of test cases.</p><p>For each test case:</p><p>The first line contains a integer n .</p><p>It guarantees that: ∑n∈[1,5×106].</p><p>Output For each test case, you should output n integers, i-th of them means the probability of i being left in the S.</p><p>Sample Input 1 3</p><p>Sample Output 0 499122177 499122177</p><p>给出一个$n$，有$[1,n]$中$n$个数。 每次有如下操作：先删去最小的元素，再随机删掉一个元素。 求每个数留下来的概率期望。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="方法一：组合数学-数学推导"><a href="#方法一：组合数学-数学推导" class="headerlink" title="方法一：组合数学+数学推导"></a>方法一：组合数学+数学推导</h4><p>考虑元素$i$留下来的方案数，那么他前面有$i-1$个数，后面有$n-i$个数。 我们易得当$n-i\geq i-1$时，i才会被留下来，即$i\leq\frac{n}{2}$时都是$0$，往后才有值。所以我们可以直接输出前$\frac{n}{2}$个$0$。</p><p>然后在处理后面的数字。 我们设每次删除最小元素为操作一，随机删除元素为操作二。 即$i$后面的$n-i$个数一定是操作二删除的，所以第一步，我们让后面$n-i$个数与前面$i-1$中的$n-i$个一一对应删除就行。（在$i-1$中选$n-i$个数出来在给他排序） 设第$i$个数被留下来的方案数为$cnt[i]$，则 $$cnt[i] &#x3D; C_{i-1}^{n-i}*A_{n-i}^{n-i} &#x3D; \frac{(i-1)!}{(2i-n-1)!}$$</p><p>然后在考虑剩下的$(i-1)-(n-i)&#x3D;(2i-n-1)$个数，根据前面，在其中选择两两删除。 $(2i-n-1)$两两选择有$$C_{2i-n-1}^2*C_{2i-n-3}^2…C_4^2*C_2^2$$ $$\frac{(2i-n-1)!}{2!*(2i-n-3)!}*\frac{(2i-n-3)!}{2!*(2i-n-5)!}*…*\frac{2!}{2!*0!}$$ $$\frac{(2i-n-1)!}{(2!)^{\frac{2i-n-1}{2}}}$$</p><p>到这里还没有结束，然后我想了好久，是我太捞了。 比如$[1,6]$，我们选择的时候会重复选择多次，比如 $(1,2)(3,4)(5,6)$ $(1,2)(5,6)(3,4)$ $(3,4)(1,2)(5,6)$ $(3,4)(5,6)(1,2)$ $(5,6)(1,2)(3,4)$ $(5,6)(3,4)(1,2)$ 这些都是上面包括的情况，因为选的先后次序不同，所以会出现重复的情况，一共出现相同的组合$(\frac{n}{2})!$，所以我们要在上面的基础上再除以$(\frac{2i-n-1}{2})!$ 那么剩下数$(2i-n-1)$中两两选择的方案数为 $$\frac{(2i-n-1)!}{(2!)^{\frac{2i-n-1}{2}}*(\frac{2i-n-1}{2})!}$$ 最后整合上述所有情况，第$i$个数被留下的总方案数为 $$cnt[i] &#x3D; \frac{(i-1)!}{(2i-n-1)!}*\frac{(2i-n-1)!}{(2!)^{\frac{2i-n-1}{2}}*(\frac{2i-n-1}{2})!}$$ 化简得 $$cnt[i] &#x3D; \frac{(i-1)!}{(2!)^{\frac{2i-n-1}{2}}*(\frac{2i-n-1}{2})!}$$</p><p>总方案数为$sum&#x3D;\sum_{i&#x3D;1}^ncnt[i]$ 第$i$个数被留下的概率期望为$p[[i]&#x3D;\frac{cnt[i]}{sum}$ 时间复杂度为$O(n)$</p><p>事先预处理所有的阶乘和阶乘逆元。</p><h4 id="方法二：dp"><a href="#方法二：dp" class="headerlink" title="方法二：dp"></a>方法二：dp</h4><p>参考：<a href="https://www.cnblogs.com/luyouqi233/p/13434815.html">https://www.cnblogs.com/luyouqi233/p/13434815.html</a> dp方法我也不太会，哭了。</p><h2 id="Code-3026MS"><a href="#Code-3026MS" class="headerlink" title="Code(3026MS)"></a>Code(3026MS)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll F[N];</span><br><span class="line">ll invn[N];</span><br><span class="line">ll invF[N];</span><br><span class="line">ll cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>] = F[<span class="number">1</span>] = invn[<span class="number">0</span>] = invn[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N; i++)&#123;</span><br><span class="line">        F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        invn[i] = (mod - mod / i) * invn[mod % i] % mod;</span><br><span class="line">        invF[i] = invF[i - <span class="number">1</span>] * invn[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line"></span><br><span class="line">    ll inv2 = <span class="number">499122177</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n / <span class="number">2</span>; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">                cnt[i] = F[i - <span class="number">1</span>] * invF[(<span class="number">2</span> * i - n - <span class="number">1</span>) / <span class="number">2</span>] % mod * <span class="built_in">quick_pow</span>(inv2, (<span class="number">2</span> * i - n - <span class="number">1</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">                ans = (ans + cnt[i]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ll sum = <span class="built_in">quick_pow</span>(ans, mod - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span> + <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;% lld&quot;</span>,sum * cnt[i] % mod);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/05/hdu-6825/">https://blog.jujimeizuo.cn/2020/08/05/hdu-6825/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第五场】6814 Tetrahedron</title>
      <link href="/2020/08/05/hdu-6814/"/>
      <url>/2020/08/05/hdu-6814/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6814">http://acm.hdu.edu.cn/showproblem.php?pid=6814</a></p><p>Generate three integers a, b, and c in [1,n] with equal probability independently, and use them as the three right-angle side length of a right-angled tetrahedron. Find the expectation of the reciprocal square of the distance from the right-angle apex to the slope (Euclidean distance).</p><p>For each test case, output a line containing the answer mod 998244353.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2FjbS5oZHUuZWR1LmNuL2RhdGEvaW1hZ2VzL0M4ODMtMTAwMS0xLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>Input In the first line, you should read an integer T denoting the number of test cases.</p><p>In every test case, the only line will include an integer n.</p><p>It is guaranteed that T is no larger than 2×106 and n is no larger than 6×106.</p><p>Output For each test case, output the only line containing just one integer denoting the answer mod 998244353.</p><p>Sample Input 3 1 2 3</p><p>Sample Output 3 124780546 194103070</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定n，在[1,n]中等概率随机选出3个数$a,b,c$，做直角四面体（$a,b,c$三遍两两垂直），记顶点到底面的距离为$h$,求数学期望$E(\frac{1}{h^2})$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$a,b,c$为空间直角坐标系的三条坐标轴， 直角四面体的顶点作为坐标系的原点，直角四面体的底在坐标系的平面方程为$\frac{x}{a}+\frac{y}{b}+\frac{z}{c}&#x3D;1$，那么$h$为原点到该平面方程的直线距离。</p><p>$$h&#x3D;\frac{1}{\sqrt{\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}}}$$ $$\frac{1}{h^2}&#x3D;\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}$$</p><p>然后$a,b,c$在$[1,n]$间等概率选取某个数，所有数字出现的次数都是$n$次，所以$\frac{1}{a^2},\frac{1}{b^2},\frac{1}{c^2}$都为[1,n]种的某个$\frac{1}{i^2}$。</p><p>最后求数学期望，每个$a,b,c$都有$n$种选法，所以一共有$n^3$种，对于每个a，都有$n^2$个。 $$E(\frac{1}{h^2})&#x3D;\frac{n^2*3*\sum_{i&#x3D;1}^n\frac{1}{i^2}}{n^3}(n\geq3)$$ $$E(\frac{1}{h^2})&#x3D;\frac{3*\sum_{i&#x3D;1}^n\frac{1}{i^2}}{n}(n\geq3)$$</p><p>所以只要预处理一下，直接$O(1)$得出答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        base = base * base % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll inv[<span class="number">6000005</span>];</span><br><span class="line">ll f[<span class="number">6000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">6000002</span>; i++) &#123;</span><br><span class="line">        inv[i] = mod - (mod / i) * inv[mod % i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">6000002</span>; i++) &#123;</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + (inv[i] * inv[i]) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        ll k = <span class="number">3</span> * f[n] % mod * inv[n] % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">signed</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">             &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; cin.<span class="built_in">putback</span>(acm_local_for_debug));</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赛后又交了已发，发现T了，赛中AC，赛后T了，很迷，最后把cin改成scanf还是对了，差点吓死我。</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/05/hdu-6814/">https://blog.jujimeizuo.cn/2020/08/05/hdu-6814/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第八场】E题 Enigmatic Partition</title>
      <link href="/2020/08/05/2020-nowcoder-shujia-8-e/"/>
      <url>/2020/08/05/2020-nowcoder-shujia-8-e/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/5673/E">https://ac.nowcoder.com/acm/contest/5673/E</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2020/08/20200805140715720.png"></p><p>数$n$的拆分，要求最大值与最小值相差为2，且相邻两个数之间相差小于1，$f[i]$表示拆分的个数。 有T组测试，每组给出l和r，求出$\sum_{i&#x3D;l}^rf[i]$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先知道$n$是由三个连续自然数之和相加组成的，当然，这三个自然数的个数是不知道的，那么就是求$$f[i]&#x3D;a*l+b*(l+1)+c*(l+2)（a，b，c\ge q1）$$</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>根据标程给的题解，它是枚举$l$，所以这三个数为$l,l+1,l+2$，表示为$l,mid,r$，我们知道两个$mid$可以拆成$l和r$，所以当有$m$个$mid$的时候，就有$(m-1)&#x2F;2$中拆法，例如：（下面三个数字分别为$l，mid和r的个数$） $m&#x3D;5：有2种拆法$ $1，2，1$ $2，0，2$ $m&#x3D;8：有3种拆法$ $1，5，1$ $2，3，2$ $3，1，3$</p><p>为什么$mid$可以等于0，因为之前$m-1$,这个1就是$mid$。 为什么$l和r$不可以等于0，这样的话就不保证$a,c\ge q1$。</p><p>这样枚举$l$的过程中，再分别枚举$m$的个数，再枚举往左加$l$的个数和往右加$r$的个数，最后再做个前缀和答案就出来了，不过问题就是$l\leq100$，标程说枚举会比较慢（是非常慢），所以要用dp优化，不过我也不会就咕咕咕了，然后就有了第二种方法。</p><p><img src="/images/2020/08/20200805142832935.png"></p><p>! #### 方法二 应该也算枚举，不过是很巧妙的枚举。我也是看别人的博客才稍微懂一点点点点的。 这里应用了差分的思想。 最后是一阶差分+隔项差分。 参考大佬的博客： [大佬1](<a href="https://blog.csdn.net/zhangchizc/article/details/107784622?utm%5C_medium=distribute.pc%5C_relevant.none-task-blog-baidulandingword-2&spm=1001.2101.3001.4242">https://blog.csdn.net/zhangchizc/article/details/107784622?utm\_medium=distribute.pc\_relevant.none-task-blog-baidulandingword-2&amp;spm=1001.2101.3001.4242</a>) [大佬2](<a href="https://blog.csdn.net/zhangchizc/article/details/107784622?utm%5C_medium=distribute.pc%5C_relevant.none-task-blog-baidulandingword-2&spm=1001.2101.3001.4242">https://blog.csdn.net/zhangchizc/article/details/107784622?utm\_medium=distribute.pc\_relevant.none-task-blog-baidulandingword-2&amp;spm=1001.2101.3001.4242</a> “大佬2”) [大佬3](<a href="https://www.cnblogs.com/rair/p/13430729.html">https://www.cnblogs.com/rair/p/13430729.html</a>) 关于差分，可以参考：[<a href="https://blog.csdn.net/qq/_44786250/article/details/100056975/](https://blog.csdn.net/qq/_44786250/article/details/100056975)">https://blog.csdn.net/qq\_44786250/article/details/100056975\](https://blog.csdn.net/qq\_44786250/article/details/100056975)</a> 一阶差分就是后一项减去前一项$d[i] &#x3D; a[i]-a[i-1]$。 隔项差分就是后一项的后一项减去前一项$d[i] &#x3D;a[i]-a[i-2]$。 然后回到本题。 我们先把式子改变一下。 $m&#x3D;b1+b2+b3$ $n&#x3D;a*b1+(a+1)*b2+(a+2)*b3&#x3D;a*(b1+b2+b3)+b2+2b3&#x3D;am+b2+2b3$ 具体细节请看上面三个大佬的博客。 最后我们得出来： $f[am+3]++，f[(a+1)m+1]–，f[(a+1)m+2]–，f[(a+2)m]++$ 这里一定要看图解，不然真的很昏。 只要我们枚举$a和m$之后，然后对上述位置进行加减操作，最后在隔项差分、一阶差分求出原数组，最后在前缀和得出答案。 ## Code ```c++ ##include &lt;bits&#x2F;stdc++.h&gt; using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;int, int&gt; pdd; ##define INF 0x7f7f7f ##define mem(a, b) memset(a , b , sizeof(a)) ##define FOR(i, x, n) for(int i &#x3D; x;i &lt;&#x3D; n; i++) &#x2F;&#x2F; const ll mod &#x3D; 1e9 + 7; &#x2F;&#x2F; const int maxn &#x3D; 1e5 + 10; &#x2F;&#x2F; const double eps &#x3D; 1e-6; const int N &#x3D; 1e5 + 10; ll f[N * 2]; ll F[N * 2]; void Init() { for(int m &#x3D; 3;m &lt; N; m++) { for(int a &#x3D; 1;a * m &lt; N; a++) { f[a * m + 3]++; f[(a + 1) * m + 1]–; f[(a + 1) * m + 2]–; f[(a + 2) * m]++; } } for(int i &#x3D; 3;i &lt; N; i++) f[i] +&#x3D; f[i - 2]; for(int i &#x3D; 2;i &lt; N; i++) f[i] +&#x3D; f[i - 1]; for(int i &#x3D; 1;i &lt; N; i++) F[i] &#x3D; F[i - 1] + f[i]; } void solve() { Init(); int Case &#x3D; 1; int T; cin &gt;&gt; T; while(T–) { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; “Case ##” &lt;&lt; Case++ &lt;&lt; “: “ &lt;&lt; F[r] - F[l - 1] &lt;&lt; endl; } } signed main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ##ifdef ACM_LOCAL freopen(“in.txt”, “r”, stdin); freopen(“out.txt”, “w”, stdout); solve(); ##else solve(); ##endif return 0; } ``` ## 反思 **比赛再也不在一题上花5个小时了，呜呜呜~~~**</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/05/2020-nowcoder-shujia-8-e/">https://blog.jujimeizuo.cn/2020/08/05/2020-nowcoder-shujia-8-e/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第五场】6822 Paperfolding</title>
      <link href="/2020/08/04/hdu-6822/"/>
      <url>/2020/08/04/hdu-6822/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6822">http://acm.hdu.edu.cn/showproblem.php?pid=6822</a></p><p>There is a piece of paper in rectangular shape with sufficient length and width (lay flat on the table). Execute an operation instruction according to a string of length n from left to right that only contains 4 different characters of L,R,U,D.</p><ol><li><p>L instruction means to fold it from left to right,</p></li><li><p>R instruction means to fold from right to left,</p></li><li><p>U instruction means to fold from top to bottom,</p></li><li><p>D instruction means to fold in half from bottom to top.</p></li></ol><p>Note that the operation is limited due to the limitation of the desktop. Namely, the fold operation is restricted. For example, if you fold the paper from left to right, you should let the left side overlap on the right side with no rotation.</p><p>Now, cut a knife horizontally (completely cut) at the center of the visible part of the paper, and then cut vertically (completely cut).</p><p>The number of pieces of the whole paper split is num(S).</p><p>See the example and the picture for better understanding.</p><p>Now given a nonnegative integer n, the string S is generated from 4n different possible outcomes in equal probability. Find the expected value of the number of pieces of the paper which is split, that is E(num(S)) mod 998244353.</p><p>It can be shown that the answers can be represented by PQ, where P and Q are coprime integers, and print the value of P×Q−1 mod 998244353.</p><p><img src="/images/2020/08/20200804211307771.png"></p><p>Input The first line contains a single integer T (1≤T≤105), the number of testcases.</p><p>Each of the next T lines contains a number n ( 0≤n≤1018 ).</p><p>Output For each testcase, print the answer in one line.</p><p>Sample Input 2 0 1</p><p>Sample Output 4 6</p><p>Source 2020 Multi-University Training Contest 5</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一块无限大的纸上，有四种操作，上折，下折，左折，右折，问k次操作后，折完后取中点，横竖分别切一刀（切十字），问最后纸分成多少片的数学期望（又是数学期望，哎）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>左右折是一样的，上下折是一样的，所以只有两种操作。</p><p>应该实验（手动剪纸）可得，往上下方向折$k$次，会有$2^k$条割线，那么横着切一刀展开后的纸片数有$2^k+1$张，这个$+1$就是最中间折痕左右两边纸片算一个，同理左右折。</p><p>在折$n$次的情况下，设左右折次数为$k$，那么上下折次数为$n-k$。</p><p>根据上面描述，左右折$k$次，则横着切一刀后有纸片数为$2^k+1$，则竖着切一刀后有纸片数为$2^{n-k}+1$，则横竖切一刀后总纸片数为$(2^k+1)*(2^{n-k}+1)$。 这$k$中是在$n$种操作中选出来的$k$种，所以结果还要乘上$C_n^k$。 因为求的是数学期望，每种操作可以选左右折或者上下折，所以结果要乘$\frac{1}{2^n}$。</p><p>最后答案为$$\frac{\sum_{k&#x3D;0}^{n}(2^k+1)*(2^{n-k}+1)C_n^k}{2^n}$$</p><p>一步一步化简： $$\frac{\sum_{k&#x3D;0}^{n}(2^n+2^{n-k}+2^k+1)C_n^k}{2^n}$$</p><p>由二项式定理可得$C_n^k&#x3D;(1+1)^n$，继续化简：</p><p>$$2^n + 1+\frac{\sum_{k&#x3D;0}^{n}(2^{n-k}+2^k)C_n^k}{2^n}$$</p><p>$$2^n + 1+\frac{\sum_{k&#x3D;0}^{n}(2^{n-k}C_n^k+2^kC_n^k)}{2^n}$$</p><p>由$C_n^k&#x3D;C_n^{n-k}$继续化简：</p><p>$$2^n + 1+\frac{\sum_{k&#x3D;0}^{n}(2^{n-k}C_n^{n-k}+2^kC_n^k)}{2^n}$$</p><p>$$2^n + 1+\frac{2*\sum_{k&#x3D;0}^{n}(2^kC_n^k)}{2^n}$$</p><p>由二项式定理可得$\sum_{k&#x3D;0}^{n}2^kC_n^k&#x3D;(2+1)^n$继续化简： $$2^n + 1+\frac{2*3^n}{2^n}$$</p><p>所以这一题可以用快速幂加逆元求解。</p><h2 id="Code-343MS"><a href="#Code-343MS" class="headerlink" title="Code(343MS)"></a>Code(343MS)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const int maxn = 1e5;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"><span class="type">const</span> ll inv2 = <span class="number">499122177</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * base;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        base = base * base % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll k = (<span class="number">2</span> * <span class="built_in">quick_pow</span>(<span class="number">3</span> * inv2 % mod, N) % mod + <span class="built_in">quick_pow</span>(<span class="number">2</span>, N) + <span class="number">1</span>) % mod;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比赛的时候化简的过程中出现的问题，还是我太菜了，呜呜呜。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/04/hdu-6822/">https://blog.jujimeizuo.cn/2020/08/04/hdu-6822/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第六场】K题 K-Bag</title>
      <link href="/2020/08/01/2020-nowcoder-shujia-6-k/"/>
      <url>/2020/08/01/2020-nowcoder-shujia-6-k/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5671/K">https://ac.nowcoder.com/acm/contest/5671/K</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>T组测试，每组输入$n$和$k$，表示下一行有n个包，最多有1~k种包，下一行给出n个包的序列，问符不符合全排列的顺序，输出YES或NO（阳寿题）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为n不一定整除k，所以前一段和后一段不一定是完整的k-全排列序列，先找出前后这一段，然后检查中间一部分是否是k-全排列（注意：k-全排列序列可重复）。当n&lt;k时，只需要判断前一段的长度是否大于后一段长度，如果小于的话，中间一段一定不满足k-全排列序列。</p><p>=&#x3D;重点&#x3D;&#x3D; 怎么判断中间是否为k-全排列序列，如果是暴力判断，可能会T，这时候就需要异或和和前缀和了，我们在输入的时候做一个前缀和、异或和预处理，再从1~k做一个异或和预处理为x，前缀和预处理为s，因为两个相同的数异或为0，所以判断一段序列中是否存在相同数字，只需要判断那一段的异或和是否等于x，这样还不够，还需要判断这一段的前缀和是否等于s，只有这两个条件满足，说明这一段序列是满足k-全排列序列。这样处理会比暴力好很多。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line">ll n, k;</span><br><span class="line">ll f[MAXN];</span><br><span class="line">ll pre1[MAXN];</span><br><span class="line">ll pre2[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;f[i]);</span><br><span class="line">        pre1[i] = pre1[i - <span class="number">1</span>] + f[i];</span><br><span class="line">        pre2[i] = pre2[i - <span class="number">1</span>] ^ f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tot1 = <span class="number">0</span>, tot2 = <span class="number">0</span>;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 找前一段</span></span><br><span class="line">        <span class="keyword">if</span> (mp[f[i]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        mp[f[i]]++;</span><br><span class="line">        tot1 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// 找后一段</span></span><br><span class="line">        <span class="keyword">if</span> (mp[f[i]] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        mp[f[i]]++;</span><br><span class="line">        tot2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot1 + <span class="number">1</span> &gt;= tot2)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s = <span class="number">0</span>; <span class="comment">// 总前缀和</span></span><br><span class="line">    ll x = <span class="number">0</span>; <span class="comment">// 总异或和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s += i;</span><br><span class="line">        x ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">0</span>; len &lt;= tot1; len++) &#123;</span><br><span class="line">        ll i = len, flag2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i + k &lt;= n; i += k) &#123;</span><br><span class="line">            ll v1 = pre1[i + k] - pre1[i];</span><br><span class="line">            ll v2 = pre2[i + k] ^ pre2[i];</span><br><span class="line">            <span class="keyword">if</span> (s != v1  x != v2) &#123;</span><br><span class="line">                flag2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag2 &amp;&amp; i + <span class="number">1</span> &gt;= tot2) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> test_index_for_debug = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> acm_local_for_debug;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acm_local_for_debug == <span class="string">&#x27;$&#x27;</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        cin.<span class="built_in">putback</span>(acm_local_for_debug);</span><br><span class="line">        <span class="keyword">if</span> (test_index_for_debug &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Check the stdin!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> start_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">auto</span> end_clock_for_debug = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="string">&quot; Run Time: &quot;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/08/01/2020-nowcoder-shujia-6-k/">https://blog.jujimeizuo.cn/2020/08/01/2020-nowcoder-shujia-6-k/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第四场】H题 Harder Gcd Problem</title>
      <link href="/2020/07/26/2020-nowcoder-shujia-4-h/"/>
      <url>/2020/07/26/2020-nowcoder-shujia-4-h/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5669/H">https://ac.nowcoder.com/acm/contest/5669/H</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你T组数据，每组给一个n，找到两个集合A，B使得两个集合的元素个数相同并且没有交集并且元素&lt;&#x3D;n。然后尽量使得A和B中的相对应的元素的gcd&gt;1的组数越多越好，先输出gcd&gt;1的组数，在输出A和B中对应的两个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要使的组数更多，那么就先把&lt;&#x3D;n的素数筛选出来（埃式筛法即可），然后我们将每个素数和他的倍数将其匹配，如该素数和&lt;&#x3D;n的倍数的个数为偶数，那么就就将其一一匹配，如果该素数和&lt;&#x3D;n的倍数的个数为奇数，那么就将该素数的两倍留下，然后剩下的一一匹配，到最后，就剩下一堆2*某个素数的数，因为他们有公共的公约数2，gcd&gt;2，所以将他们一一匹配，这样就可以做到组数最大。</p><p>注意：应该从n&#x2F;2往前遍历，因为越大的素数，他的倍数的个数越少。任何一个数都可以由一个素数和任意一个数相乘得到，所以只要n&#x2F;2往前遍历一遍就可以将2~n的所有数遍历到，没有遍历的数就是不可以组成的组数。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"> <span class="keyword">typedef</span> pair pdd; </span><br><span class="line"> #<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"> #<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line"> #<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"> <span class="comment">// const ll mod = 1e9 + 7;const int maxn = 2e5 + 10;</span></span><br><span class="line"> <span class="comment">// const double eps = 1e-6; </span></span><br><span class="line"> <span class="type">int</span> n; </span><br><span class="line"> <span class="type">bool</span> is_prime[maxn + <span class="number">1</span>];</span><br><span class="line"> <span class="type">bool</span> vis[maxn + <span class="number">1</span>];  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mem</span>(is_prime, <span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= maxn; j += i)</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector v;</span><br><span class="line">    vector tmp;</span><br><span class="line">    <span class="built_in">mem</span>(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">2</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(tmp[<span class="number">1</span>], tmp[tmp.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 交换即可留下该素数的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp.<span class="built_in">size</span>() - <span class="number">1</span>; j += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(tmp[j], tmp[j + <span class="number">1</span>]));</span><br><span class="line">            vis[tmp[j]] = <span class="number">1</span>;</span><br><span class="line">            vis[tmp[j + <span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; v[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[i].second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/26/2020-nowcoder-shujia-4-h/">https://blog.jujimeizuo.cn/2020/07/26/2020-nowcoder-shujia-4-h/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第一场】6755 Fibonacci Sum</title>
      <link href="/2020/07/23/hdu-6755/"/>
      <url>/2020/07/23/hdu-6755/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6755">http://acm.hdu.edu.cn/showproblem.php?pid=6755</a></p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><p><strong>二项式定理、二次剩余、等比数列、欧拉降幂、阶乘逆元</strong></p><p>参考：<a href="https://blog.csdn.net/oampamp1/article/details/107508328">牌王无敌</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>计算一个式子</p><p><img src="/images/2020/07/20200723205327414.png"></p><p><img src="/images/2020/07/20200723205336799.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由斐波那契通项公式得 $$F_n&#x3D;\frac{1}{\sqrt 5}((\frac{1+ \sqrt 5}{2})^n-(\frac{1-\sqrt5}{2})^n)$$ 可以通过二次剩余的方法求出$\sqrt5&#x3D;383008016或者616991993$，因为二次剩余的解有两个。下面顺便在给出二次剩余的板子，我也是花了一天的时间才弄懂计算过程。 我们让$A&#x3D;\frac{1+ \sqrt 5}{2}、B&#x3D;\frac{1- \sqrt 5}{2}、D&#x3D;\frac{1}{\sqrt5}$ 进而利用逆元计算出 $A&#x3D;691504013$ $B&#x3D;308495997$ $D&#x3D;276601605$</p><p>所以式子就变成了： $$F_n&#x3D;D(A^n-B^n)(mod 1e9 + 9)$$ 如果这样暴力算的话一定会T，因为N和C都达到了1e18。 我们先尝试列出前几项： $当n&#x3D;1时，F_c^k&#x3D;D^k(A^c-B^c)^k$ 用二项式定理展开后变为 $$F_c^k&#x3D;D^k\sum_{i&#x3D;0}^{k}(-1)^iC_k^i(A^c)^{k-i}(B^c)^{i}$$</p><p>$当n&#x3D;2时F_{2c}^k&#x3D;D^k(A^{2c}-B^{2c})^k$ 用二项式定理展开后变为 $$F_{2c}^k&#x3D;D^k\sum_{i&#x3D;0}^{k}(-1)^iC_k^i(A^{2c})^{k-i}(B^{2c})^{i}$$ $$F_{2c}^k&#x3D;D^k\sum_{i&#x3D;0}^{k}(-1)^iC_k^i(A^{c})^{k-i}(B^{c})^{i}C_k^i(A^{c})^{k-i}(B^{c})^{i}$$ 所以当i相同时，这就是一个等比数列求和。</p><p>首项：$(-1)^i(A^{k-i}B^{i})^c$ 公比：$(A^{k-i}B^{i})^c$</p><p>最后整理一下整个式子得 $$\sum_{i&#x3D;0}^{n}F_{ic}^{K}&#x3D;D^k\sum_{i&#x3D;0}^{K}C_k^i\frac{(-1)^i(A^{k-i}B^{i})^c(((A^{k-i}B^{i})^c)^n-1)}{(A^{k-i}B^{i})^c-1}$$</p><p>当公比为1时，$(A^{k-i}B^{i})^c&#x3D;1$，所以只要计算$C_k^i*(-1)^i*(A^{k-i}B^{i})^c*n$</p><p>为了快速处理$C_m^n$，需要预处理1e5以内的阶乘和阶乘逆元。 $$C_m^n&#x3D;\frac{m!}{n!*(m-n)!}&#x3D;m!*inv[n!]*inv[(m-n)!]$$</p><p>公比的优化，因为随着i的增大，第$i$项和第$i+1$项相差$(\frac{B}{A})^c$，所以我们率先算出$A$的逆元$invA$，就可以$O(1)$递推求出该公比，即： $$q_{i+1} &#x3D; qi *(\frac{B}{A})^c$$</p><p>对于使用快速幂求$c$次方，可以使用欧拉降幂来优化时间，因为题目给的$mod$是个质数，即： $$a^b &#x3D; a^{b\%(1e9+9-1)}(mod 1e9+9)$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> ll B = <span class="number">308495997</span>;</span><br><span class="line"> <span class="type">const</span> ll invA = <span class="number">691504012</span>;</span><br><span class="line"> <span class="type">const</span> ll A = <span class="number">691504013</span>;</span><br><span class="line"> <span class="type">const</span> ll D = <span class="number">276601605</span>;</span><br><span class="line"></span><br><span class="line"> ll F[maxn + <span class="number">10</span>]; <span class="comment">// 阶乘</span></span><br><span class="line"> ll invF[maxn + <span class="number">10</span>]; <span class="comment">// 阶乘逆元</span></span><br><span class="line"> ll invn[maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> ll <span class="title">quick_pow</span><span class="params">(ll a, ll b)</span> <span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     ll ans = <span class="number">1</span>, base = a;</span><br><span class="line">     <span class="keyword">while</span> (b)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             ans = ans * base % mod;</span><br><span class="line">         &#125;</span><br><span class="line">         base = base * base % mod;</span><br><span class="line">         b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans % mod;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     F[<span class="number">0</span>] = F[<span class="number">1</span>] = invF[<span class="number">0</span>] = invF[<span class="number">1</span>] = invn[<span class="number">0</span>] = invn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         F[i] = F[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">         invn[i] = (mod - mod / i) * invn[mod % i] % mod;</span><br><span class="line">         invF[i] = invF[i - <span class="number">1</span>] * invn[i] % mod;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> ll <span class="title">getC</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (m &lt; <span class="number">0</span>  n &lt; <span class="number">0</span>  n &gt; m)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     ll ans = F[m];</span><br><span class="line">     ans = ans * invF[n] % mod;</span><br><span class="line">     ans = ans * invF[m - n] % mod;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> ll <span class="title">MOD</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     a += b;</span><br><span class="line">     <span class="keyword">if</span> (a &gt;= mod)</span><br><span class="line">         a -= mod;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, c, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c &gt;&gt; k;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll a1 = <span class="built_in">quick_pow</span>(<span class="built_in">quick_pow</span>(A, k), c % (mod - <span class="number">1</span>)) % mod; <span class="comment">// 首项(公比)</span></span><br><span class="line">    ll q = <span class="built_in">quick_pow</span>(invA * B % mod, c % (mod - <span class="number">1</span>)) % mod; <span class="comment">// 公比递推</span></span><br><span class="line">    ll n1 = n % mod;</span><br><span class="line">    ll n2 = n % (mod - <span class="number">1</span>); <span class="comment">// 欧拉降幂使用</span></span><br><span class="line">    ll a1power = <span class="built_in">quick_pow</span>(a1, n2) % mod;</span><br><span class="line">    ll qpower = <span class="built_in">quick_pow</span>(q, n2) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum = <span class="built_in">getC</span>(k, i) % mod;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">            sum = mod - sum; <span class="comment">// 负数</span></span><br><span class="line">        <span class="keyword">if</span> (a1 == <span class="number">1</span>) <span class="comment">// 公比为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans + n1 * sum % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum * (a1 * (a1power - <span class="number">1</span> + mod) % mod) % mod;</span><br><span class="line">            sum = sum * <span class="built_in">quick_pow</span>(a1 - <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">            ans = <span class="built_in">MOD</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        a1 = (a1 * q) % mod; <span class="comment">// 更换公比</span></span><br><span class="line">        a1power = a1power * qpower % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="function">ans * <span class="title">quick_pow</span><span class="params">(D, k)</span> % mod &lt;&lt; endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">   <span class="comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">   <span class="comment">// freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="built_in">Init</span>();         </span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二次剩余板子"><a href="#二次剩余板子" class="headerlink" title="二次剩余板子"></a>二次剩余板子</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">##include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span>&#123;</span><br><span class="line">    ll x, y; <span class="comment">// 把求出来的w作为虚部，则为a + bw</span></span><br><span class="line">&#125;num;</span><br><span class="line"></span><br><span class="line"><span class="function">num <span class="title">num_mul</span>(<span class="params">num a, num b, ll w, ll p</span>) <span class="comment">// 复数乘法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    num ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    ans.x = (a.x * b.x % p + a.y * b.y % p * w % p + p) % p;</span><br><span class="line">    ans.y = (a.x * b.y % p + a.y * b.x % p + p) % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">num_pow</span>(<span class="params">num a, ll b, ll w, ll p</span>) <span class="comment">// 复数快速幂</span></span></span><br><span class="line">&#123;</span><br><span class="line">    num ans = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = num_mul(ans, a, w, p);</span><br><span class="line">        &#125;</span><br><span class="line">        a = num_mul(a, a, w, p);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.x % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span>(<span class="params">ll a, ll b, ll p</span>) <span class="comment">// 快速幂求解</span></span></span><br><span class="line">&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, <span class="keyword">base</span> = a;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * <span class="keyword">base</span> % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">base</span> = <span class="keyword">base</span> * <span class="keyword">base</span> % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">legendre</span>(<span class="params">ll a, ll p</span>) <span class="comment">// 勒让德符号 = &#123;1, -1, 0&#125;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> quick_pow(a, (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Cipolla</span>(<span class="params">ll n, ll p</span>) <span class="comment">// 输入a和p，是否存在x使得x^2 = a (mod p)，存在二次剩余返回x，存在二次非剩余返回-1     注意：p是奇质数</span></span></span><br><span class="line">&#123;</span><br><span class="line">    n %= p;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(legendre(n, p) + <span class="number">1</span> == p) <span class="comment">// 二次非剩余</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ll a, w; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="comment">// 找出a，求出w，随机成功的概率是50%，所以数学期望是2</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = rand() % p;</span><br><span class="line">        w = ((a * a - n) % p + p) % p;</span><br><span class="line">        <span class="keyword">if</span>(legendre(w, p) + <span class="number">1</span> == p) <span class="comment">// 找到w，非二次剩余条件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num x = &#123;a, <span class="number">1</span>&#125;;   </span><br><span class="line">    <span class="keyword">return</span> num_pow(x, (p + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, w, p) % p; <span class="comment">// 计算x,一个解是x，另一个解是p-x，这里的w其实要开方，但是由拉格朗日定理可知虚部为0，所以最终答案就是对x的实部用快速幂求解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ll n, p;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    cout &lt;&lt; Cipolla(n, p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><strong>感谢牌王的亲情指导和博客</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/23/hdu-6755/">https://blog.jujimeizuo.cn/2020/07/23/hdu-6755/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年杭电暑假第二场】6768 The Oculus</title>
      <link href="/2020/07/23/hdu-6768/"/>
      <url>/2020/07/23/hdu-6768/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6768">http://acm.hdu.edu.cn/showproblem.php?pid=6768</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个斐波那契数列，每一位是可取或不可取，这取决于输入的b的大小，为0不可取，为1可取，这可以称为广义斐波那契数列。 给A、B、C的广义斐波那契数列，使得C &#x3D; Ａ＊Ｂ，然后改变Ｃ中数列中的一个bi使其从1变为0，并把这三个数列给你，问C中是第几bi改变了，输出它。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先预处理2e6以内的斐波那契数字，记得要mod，但是标准答案没有mod，导致longlong开的数字溢出变为负数，但也能过，可能是数据太弱了。</p><p>然后输入A和B和C，把b&#x3D;1的位置累加并且mod，本来C &#x3D; A * B，然后改了一个位置，所以就变成C+bi&#x3D;A*B，所以只要找到这个bi后输出他在C中的位置即可。</p><p>但是越往后的斐波那契数字，mod一个数后可能相同，就不好判断了到底该取哪一个位置，这时候就要利用斐波那契编码的性质：<a href="https://oi-wiki.org/math/fibonacci/##_2">斐波那契编码</a>。</p><p>斐波那契编码性质，除了最后两位都是1以外，任意相邻位置的编码乘积都为0，就是不可能在由11这一对，所以在判断bi时候要判断一下他更改的位置是否合法。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">// const int maxn = 1e5;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line">ll vis[<span class="number">2000010</span>];</span><br><span class="line"><span class="type">bool</span> f[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    vis[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">2000001</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i] = (vis[i - <span class="number">1</span>] + vis[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, bb, c;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    ll A = <span class="number">0</span>, B = <span class="number">0</span>, C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (b)</span><br><span class="line">            A = (A + vis[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;bb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bb; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (b)</span><br><span class="line">            B = (B + vis[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    A = A * B % mod;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;c);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[c + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i]);</span><br><span class="line">        <span class="keyword">if</span> (f[i])</span><br><span class="line">            C = (C + vis[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == <span class="number">0</span> &amp;&amp; f[i + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; f[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="comment">// 判断位置是否合法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((vis[i] + C) % mod == A) <span class="comment">// 判断bi</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">   <span class="comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">   <span class="comment">// freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>赛后感谢牌王的亲切指导</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/23/hdu-6768/">https://blog.jujimeizuo.cn/2020/07/23/hdu-6768/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第三场】D题Points Construction Problem</title>
      <link href="/2020/07/21/2020-nowcoder-shujia-3-d/"/>
      <url>/2020/07/21/2020-nowcoder-shujia-3-d/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5668/D">https://ac.nowcoder.com/acm/contest/5668/D</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目描述 Imagine you have an infinite 2D plane with Cartesian coordinate system. Initially, all the integral points are painted as white. You are given two integers n, and m. Please paint exactly n integral points to black such that there are exactly m pairs of points which satisfy the following conditions:</p><ol><li>The two points are colored by different colors.</li><li>the two points are adjacent. We call two integral points$(x1,y1)and(x2,y2)$being adjacent if and only if$x1-x2+y1-y2&#x3D;1$(v means the absolute value of v.)</li><li>The x and y coordinates of all black points are in the range$[-10^9,10^9]$</li></ol><p>输入描述</p><p>The first line contains one integer t $(1\leq t\leq 10^3)$— the number of test cases. The only line of each test case contains two integers n and m $(1\leq n \leq 50, 1\leq m \leq 200)$</p><p>输出描述</p><p>For each test, if there exists at least one configuration to choose n points to satisfy the conditions given by statement, you should print n+1 line for this test. The first line contains one string “Yes”. And the following n lines contain the coordinator of these n points which is colored as black. If there are no solution, please print one line containing only one string “No”.</p><p>输入 $6$ $5$ $20$ $1$ $2$ $1$ $3$ $1$ $4$ $1$ $5$ $3$ $8$</p><p>输出 $Yes$ $1$ $1$ $2$ $2$ $3$ $3$ $4$ $4$ $5$ $5$ $No$ $No$ $Yes$ $1$ $1$ $No$ $Yes$ $1$ $1$ $1$ $2$ $2$ $1$</p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给你n个黑点，m个点对，问是否存在一种情况使其满足，若满足则输出Yes并输出每个黑点的坐标，否则输出No。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一个黑点最多与4个白点组成点对，2个相邻的黑点组成6和黑点，4个黑点组成8个黑点，所以黑点越集中（方形）点对越少，最少有2(a+b)，a和b分别是长方形的长和宽，黑点越分散，点对越多，最多有4n个点对。并且加黑点之后总点对会$0、+2、-2、+4、-4$五种操作，所以m不可能为奇数。</p><p>然后我们需要先找出n个黑点组成点对的上下界。 上界：$4_n$ 下界：$2_(a+b)$</p><p>由下界可知，令$x&#x3D;(2*(a+b))&#x2F;2-1$，所以这$x$个黑点组成“$L$”的形状，这个“L”的形状长为$a$，宽为$b$，这就知道为什么要减一了，因为“$L$”的折点会被算上两次。所以m个点对最少由$x$个黑点组成，最多由$a*b$个黑点组成。则当$x&gt;m$时，则将$L$中的$x-m$个黑点移走并使得每个黑点组成4个点对，那么总点数$x +&#x3D; 2$，直到总点对等于$m$，$x&lt;m$时，然后将黑点依次加入到“$L$”中（最多就是一个方形，所以还要判断一下，如果$a*b&lt;n$,那么就不符合，输出$No$），那么每加一个黑点总点数$mm -&#x3D; 2$，直到$x&#x3D;n$</p><p>所有有以下几种情况：</p><ul><li>$m&lt; 4 m为奇数 m&gt;4*n时，无解$</li><li>$m &#x3D; 4*n正好匹配，有解$</li><li>$若n&gt;a*b，无解$</li><li>$判断x和m的大小关系。x&gt;m时，加孤立黑点（有四个点对），x&lt;m时，往“L”里加黑点，并且加在和两个黑点相邻的位置，有解$</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;p[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, tot, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (m &amp; <span class="number">1</span>  m &gt; <span class="number">4</span> * n  m &lt; <span class="number">4</span>) <span class="comment">// 无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n * <span class="number">4</span>) <span class="comment">// 正好匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i * <span class="number">3</span> + <span class="number">1234</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i * <span class="number">3</span> + <span class="number">1234</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    x = m / <span class="number">2</span> - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) <span class="comment">// 需要从n中拿出x-n个使他们每个点对都是4，这样每拿走一个总点对就会+2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x - n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i].x = i * <span class="number">3</span> + <span class="number">1234</span>; </span><br><span class="line">            p[i].y = i * <span class="number">3</span> + <span class="number">1234</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = x - n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i].x = <span class="number">1</span>;</span><br><span class="line">            p[i].y = i;</span><br><span class="line">        &#125;</span><br><span class="line">        tot = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 说明需要往“L”阵加点，每加一个点就会使总点对-2</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = x;</span><br><span class="line">        x = (z + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        y = (z + <span class="number">1</span>) - x;</span><br><span class="line">        <span class="keyword">if</span> (x * y &lt; n) <span class="comment">// x*y的全部点数小于n，那么就是No</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            p[tot].x = i;</span><br><span class="line">            p[tot].y = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= y; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tot++;</span><br><span class="line">            p[tot].x = <span class="number">1</span>;</span><br><span class="line">            p[tot].y = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; i++) <span class="comment">// 往“L”里加点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= y; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tot == n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                tot++;</span><br><span class="line">                p[tot].x = i;</span><br><span class="line">                p[tot].y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p[i].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i].y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">   <span class="comment">// freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">   <span class="comment">// freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/21/2020-nowcoder-shujia-3-d/">https://blog.jujimeizuo.cn/2020/07/21/2020-nowcoder-shujia-3-d/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第三场】F题 Fraction Construction Problem</title>
      <link href="/2020/07/18/2020-nowcoder-shujia-3-f/"/>
      <url>/2020/07/18/2020-nowcoder-shujia-3-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5668/F">https://ac.nowcoder.com/acm/contest/5668/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目描述 There are t queries. In each query, you are given two positive integers$a$ and $b$$(a, b\leq2×10^6)$ Please print a line consists of four positive integers $c,d,e,f$satisfying the following constraints:</p><ul><li>$\frac{c}{d}-\frac{e}{f}&#x3D;\frac{a}{b}$</li><li>$d &lt; b$ and $f &lt; b$</li><li>$1\leq c, e \leq4×10^{12}$</li></ul><p>If there are multiple solutions, you can print anyone.</p><p>If there are no solution, please print “-1 -1 -1 -1” in this line.</p><p>输入描述 The first line contains one integer $t$ $(1\leq t\leq 10^5)$ — the number of test cases.</p><p>The only line of each test case contains two integers $a$ and $b$$(a, b\leq2×10^6)$</p><p>输出描述</p><p>For each test case print four integers — $c,d,e,f$. If there are no solution, $c,d,e,f$ should all be $-1$.</p><p>输入 $3$ $4$ $1$ $1$ $6$ $37$ $111$</p><p>输出 $-1$ $-1$ $-1$ $-1$ $1$ $2$ $1$ $2$ $145$ $87$ $104$ $78$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>情况一：$b &#x3D;&#x3D; 1$和$b$是质数 无解</li><li>情况二：$gcd(a,b)!&#x3D;1$ 假设$k&#x3D;gcd(a,b)$则存在一组解$(a&#x2F;k + 1, b&#x2F;k, 1, b&#x2F;k)$</li><li>情况三：b不是质数 即b可以分成两个相异质因数相乘，所以先找到$d、f$使得$d×f&#x3D;b$且$d、f$互质 找d，f的方法：先打表3e6以内的素数，然后先找出第一个被b整除的素数，这个数就是d，然后f就是b&#x2F;d（类似算数基本定理）</li></ul><p>在d，f找到之后就开始找c和e了。</p><p>已知d*f &#x3D; b，通分后可得$c×f-e×d&#x3D;a$（d、f、a都知道，求c、e）,求解c和e，即用扩展欧几里得算法。</p><p>注意：求出c和e之后判断一下谁正谁负，毕竟d和f和b的两个相异质因数是不知道对应谁的，可以通过c和e的正负性判断。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prime[<span class="number">1005</span>]; <span class="comment">// 素数数组</span></span><br><span class="line"><span class="type">bool</span> is_prime[maxn]; <span class="comment">// is_prime[i]表示i为素数</span></span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> <span class="comment">// 返回n以内的素数个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = maxn;</span><br><span class="line">    <span class="built_in">mem</span>(is_prime, <span class="literal">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    is_prime[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++p] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> * i;j &lt;= n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ex_gcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res, t;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">ex_gcd</span>(b, a % b, x, y);</span><br><span class="line">    t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve_ex_gcd</span><span class="params">(ll a, ll b, ll c, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll inv = <span class="built_in">ex_gcd</span>(a, b, x, y);</span><br><span class="line">    <span class="keyword">if</span>(c % inv)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>;</span><br><span class="line">        y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x *= (c / inv);</span><br><span class="line">    y *= (c / inv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll k = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span>(k != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a /= k;</span><br><span class="line">        b /= k;</span><br><span class="line">        cout &lt;&lt; a + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>  is_prime[b])</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1 -1 -1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll tmp = <span class="number">0</span>, time = <span class="number">0</span>;</span><br><span class="line">        ll bb = b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= p &amp;&amp; bb != <span class="number">1</span>; i++) <span class="comment">// 找两个素因数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bb % prime[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = prime[i];</span><br><span class="line">                <span class="keyword">while</span>(bb % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    time++;</span><br><span class="line">                    bb /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bb == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 -1 -1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        ll d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= time; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            d *= tmp; <span class="comment">// b的一个因数</span></span><br><span class="line">        &#125;</span><br><span class="line">        ll f = bb; <span class="comment">// b的另一个因数</span></span><br><span class="line">        ll c = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">solve_ex_gcd</span>(f, d, a, c, e);</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">0</span> &amp;&amp; e &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; -c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; -e &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">sieve</span>();</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/18/2020-nowcoder-shujia-3-f/">https://blog.jujimeizuo.cn/2020/07/18/2020-nowcoder-shujia-3-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第二场】F题Fake Maxpooling</title>
      <link href="/2020/07/14/2020-nowcoder-shujia-2-f/"/>
      <url>/2020/07/14/2020-nowcoder-shujia-2-f/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5667/F">https://ac.nowcoder.com/acm/contest/5667/F</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目描述 Given a matrix of size$n×m$and an integer$k$,where$A_{i\times j} &#x3D; lcm(i,j)$the least common multiple of $i$ and $j$. You should determine the sum of the maximums among all $k×k$ submatrices.</p><p>输入描述 Only one line containing three integers$n,m,k(1\leq n,m\leq 5000,1\leq k \leq min \{i,j\}$</p><p>输出描述 Only one line containing one integer, denoting the answer.</p><p>输入 $3$ $4$ $2$</p><p>输出 $38$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>队友用的是二维ST表AC的，这里是单调队列。</p><p>矩阵的所有lcm可以在单调过程中记忆化，复杂度会减少，如果先做预处理（单调前全部计算出会加大复杂度）。</p><p>只需要纵向做一遍单调队列，然后把纵向所有的单调队列存在Max二维数组里， 之后在横向做一遍单调队列，这样k*k的方格就能找到最大值了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monotone_queue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5001</span>;</span><br><span class="line">    <span class="type">int</span> n, m, k; <span class="comment">// 个数、窗口大小</span></span><br><span class="line">    <span class="type">int</span> q[maxn], p[maxn], head, tail; <span class="comment">// q是单调队列，p是对应y序号，头节点、尾节点</span></span><br><span class="line">    <span class="type">int</span> Max[maxn][maxn];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Monotone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="number">1</span>; tail = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> val = i * j / <span class="built_in">gcd</span>(i, j);</span><br><span class="line">                <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[tail] &lt;= val)</span><br><span class="line">                    tail--;</span><br><span class="line">                q[++tail] = val;</span><br><span class="line">                p[tail] = j;</span><br><span class="line">                <span class="keyword">while</span>(head &lt;= tail &amp;&amp; p[head] &lt;= j - k)</span><br><span class="line">                    head++;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= k)</span><br><span class="line">                    Max[i][j - k + <span class="number">1</span>] = q[head];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= m - k + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="number">1</span>; tail = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> val = Max[i][j];</span><br><span class="line">                <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[tail] &lt;= val)</span><br><span class="line">                    tail--;</span><br><span class="line">                q[++tail] = val;</span><br><span class="line">                p[tail] = i;</span><br><span class="line">                <span class="keyword">while</span>(head &lt;= tail &amp;&amp; p[head] &lt;= i - k)</span><br><span class="line">                    head++;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                    ans += q[head];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Worker;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Worker.<span class="built_in">read</span>();</span><br><span class="line">    Worker.<span class="built_in">Monotone</span>();</span><br><span class="line">    Worker.<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque模拟单调队列"><a href="#deque模拟单调队列" class="headerlink" title="deque模拟单调队列"></a>deque模拟单调队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向队列模拟</span></span><br><span class="line"></span><br><span class="line">struct num&#123;</span><br><span class="line">    <span class="type">int</span> index, x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deque&lt;num&gt; q; <span class="comment">// max</span></span><br><span class="line">deque&lt;num&gt; p; <span class="comment">// min</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[<span class="number">2</span>][<span class="number">10000005</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, k, x;</span><br><span class="line">    num t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        t.index = i; t.x = x;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; x &gt;= q.back().x)</span><br><span class="line">        &#123;</span><br><span class="line">            q.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!p.empty() &amp;&amp; x &lt;= p.back().x)</span><br><span class="line">        &#123;</span><br><span class="line">            p.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push_back(t);</span><br><span class="line">        p.push_back(t);</span><br><span class="line">        <span class="keyword">while</span>(i - k &gt;= q.front().index)</span><br><span class="line">        &#123;</span><br><span class="line">            q.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i - k &gt;= p.front().index)</span><br><span class="line">        &#123;</span><br><span class="line">            p.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            s[<span class="number">0</span>][cnt] = q.front().x;</span><br><span class="line">            s[<span class="number">1</span>][cnt] = p.front().x;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; cnt; i++)</span><br><span class="line">        cout &lt;&lt; s[<span class="number">1</span>][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; cnt; i++)</span><br><span class="line">        cout &lt;&lt; s[<span class="number">0</span>][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组模拟单调队列"><a href="#数组模拟单调队列" class="headerlink" title="数组模拟单调队列"></a>数组模拟单调队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组模拟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monotone_queue</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000005</span>;</span><br><span class="line">    <span class="type">int</span> n, k, a[maxn]; <span class="comment">// 个数、窗口大小、值</span></span><br><span class="line">    <span class="type">int</span> q[maxn], p[maxn], head, tail; <span class="comment">// q是单调队列，p是对应y序号，头节点、尾节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Monotone_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        head = <span class="number">1</span>; tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[tail] &gt;= a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++tail] = a[i];</span><br><span class="line">            p[tail] = i;</span><br><span class="line">            <span class="keyword">while</span>(p[head] &lt;= i - k)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                cout &lt;&lt; q[head] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Monotone_max</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        head = <span class="number">1</span>; tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[tail] &lt;= a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++tail] = a[i];</span><br><span class="line">            p[tail] = i;</span><br><span class="line">            <span class="keyword">while</span>(p[head] &lt;= i - k)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)</span><br><span class="line">                cout &lt;&lt; q[head] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Worker;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/14/2020-nowcoder-shujia-2-f/">https://blog.jujimeizuo.cn/2020/07/14/2020-nowcoder-shujia-2-f/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第二场】B题 Boundary</title>
      <link href="/2020/07/13/2020-nowcoder-shujia-2-b/"/>
      <url>/2020/07/13/2020-nowcoder-shujia-2-b/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5667/B">https://ac.nowcoder.com/acm/contest/5667/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目描述 Given $n$ points in 2D plane. Considering all circles that the origin point$(0,0)$is on their boundries, find the one with the maximum given points on its boundry. Print the maximum number of points.</p><p>输入描述： The first line contains one integer $n(1\leq n \leq 2000)$, denoting the number of given points. Following $n$ lines each contains two integers$x,y(x,y\leq10000)$,denoting a given point$(x,y)$. It’s guaranteed that the points are pairwise different and no given point is the origin point.</p><p>输出描述： Only one line containing one integer, denoting the answer.</p><p>输入 $4$ $1$ $1$ $0$ $2$ $2$ $2$ $2$ $2$</p><p>输出 $3$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可知三点可得一个圆，所以利用三点求出该圆的圆心。 参考：<a href="http://www.skcircle.com/?id=642">http://www.skcircle.com/?id=642</a></p><p>因为原点是一定在圆上的，所以当我们确定一个圆心时，将该圆心用map保存下来，当另一组两个点加一个原点求出来的圆心还是该值，就可以知道这些求出来圆心相同的点都在同一个圆上，所以求出来之后$mmp[pdd(x0,y0)]++$ ,在和已经知道的圆上最大点数$cnt$比较，取较大者，最后输出时还要$cnt+1$，因为两个点确定一个圆心（原点没算了）。</p><p>我的错误： 在WA和T的道路上永垂不朽，求个数的时候太复杂了，导致心态炸裂.冷静下来还是可以想到的</p><h2 id="错误Code"><a href="#错误Code" class="headerlink" title="错误Code"></a>错误Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mariex</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    map&lt;<span class="type">double</span>, map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; tmp;</span><br><span class="line">&#125;a[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">double</span>, map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> a1 = <span class="number">-0.5</span> * (a[i].x * a[i].x + a[i].y * a[i].y);</span><br><span class="line">            <span class="type">double</span> a2 = <span class="number">-0.5</span> * (a[j].x * a[j].x + a[j].y * a[j].y);</span><br><span class="line">            <span class="type">double</span> det = a[i].y * a[j].x - a[i].x * a[j].y;</span><br><span class="line">            <span class="keyword">if</span>(det == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">double</span> x0 = <span class="number">1.0</span> * (a[j].y * a1 - a[i].y * a2) / det;</span><br><span class="line">            <span class="type">double</span> y0 = <span class="number">1.0</span> * (a[i].x * a2 - a[j].x * a1) / det;</span><br><span class="line">            <span class="keyword">if</span>(!a[i].tmp[x0][y0])</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].tmp[x0][y0] = <span class="number">1</span>;</span><br><span class="line">                mp[x0][y0]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!a[j].tmp[x0][y0])</span><br><span class="line">            &#123;</span><br><span class="line">                a[j].tmp[x0][y0] = <span class="number">1</span>;</span><br><span class="line">                mp[x0][y0]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; mp[x0][y0])</span><br><span class="line">                cnt = mp[x0][y0];</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; n / <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&#x3D;<strong>主要是圆心算出来之后那一块时间T了，我哭了。</strong>=&#x3D;</p><h2 id="正确Code"><a href="#正确Code" class="headerlink" title="正确Code"></a>正确Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">// const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"><span class="comment">// const double eps = 1e-6;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mariex</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;a[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line">map&lt;pdd, <span class="type">int</span>&gt; mmp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;a[i].x,&amp;a[i].y); <span class="comment">// 输入每点坐标</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll x1, x2, x3, y1, y2, y3; <span class="comment">// 三点坐标</span></span><br><span class="line">    ll A1, B1, C1, A2, B2, C2;</span><br><span class="line">    <span class="type">double</span> x0, y0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mmp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            x1 = y1 = <span class="number">0</span>;</span><br><span class="line">            x2 = a[i].x; y2 = a[i].y;</span><br><span class="line">            x3 = a[j].x; y3 = a[j].y;</span><br><span class="line">            A1 = <span class="number">2ll</span> * (x2 - x1);</span><br><span class="line">            B1 = <span class="number">2ll</span> * (y2 - y1);</span><br><span class="line">            C1 = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1;</span><br><span class="line">            A2 = <span class="number">2ll</span> * (x3 - x2);</span><br><span class="line">            B2 = <span class="number">2ll</span> * (y3 - y2);</span><br><span class="line">            C2 = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2;</span><br><span class="line">            ll det = B2 * A1 - B1 * A2;</span><br><span class="line">            <span class="keyword">if</span>(det == <span class="number">0</span>) <span class="comment">// 三点共线</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            x0 = <span class="number">1.0</span> * (B2 * C1 - C2 * B1) / det;</span><br><span class="line">            y0 = <span class="number">1.0</span> * (A1 * C2 - A2 * C1) / det;</span><br><span class="line">            cnt = <span class="built_in">max</span>(cnt, ++mmp[<span class="built_in">pdd</span>(x0, y0)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">//cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">//cout.tie(nullptr);</span></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/13/2020-nowcoder-shujia-2-b/">https://blog.jujimeizuo.cn/2020/07/13/2020-nowcoder-shujia-2-b/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2020年牛客暑假第一场】J题 Easy integration</title>
      <link href="/2020/07/12/2020-nowcoder-shujia-1-j/"/>
      <url>/2020/07/12/2020-nowcoder-shujia-1-j/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5666/J">https://ac.nowcoder.com/acm/contest/5666/J</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目描述 Given n, find the value of$\int_{0}^{1}(x-x^2)^ndx$ It can be proved that the value is a rational number$\frac{p}{q}$ Print the result as$(p⋅q^{-1})mod$ $998244353$.</p><p>输入描述 The input consists of several test cases and is terminated by end-of-file.</p><p>Each test case contains an integer n.</p><p>$1\leq n \leq10^6$. The number of test cases does not exceed $10^5$.</p><p>输出描述 For each test case, print an integer which denotes the result.</p><p>输入 $1$ $2$ $3$</p><p>输出 $166374059$ $432572553$ $591816295$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据$\int_{0}^{1}(x-x^2)^ndx$可得$\int_{0}^{1}x^{n}(1-x)^ndx$。 利用n次分部积分法可得计算式$$\frac{1*2*…*(n-1)*n}{(n + 1)*(n+2)*….*(2n)*(2n+1)}$$ 上下同乘$n!$得 $$\frac{(n!)^2}{(2n+1)!}$$</p><p>先对阶乘做一个预处理，然后就成分子除以分母，可以用逆元（费马小定理）求。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//const ll mod = 1e9 + 7;</span></span><br><span class="line"><span class="comment">// const int maxn = 1e5 + 10;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">2000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">FPM</span><span class="params">(ll x,ll power)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(power &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans * x) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2000001</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">F</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans = f[n] * f[n] % mod;</span><br><span class="line">        ans = (ans * <span class="built_in">FPM</span>(f[<span class="number">2</span> * n + <span class="number">1</span>], mod - <span class="number">2</span>)) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios_base::sync_with_stdio(false);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/07/12/2020-nowcoder-shujia-1-j/">https://blog.jujimeizuo.cn/2020/07/12/2020-nowcoder-shujia-1-j/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黎曼猜想（三）黎曼猜想</title>
      <link href="/2020/06/06/riemann-hypothesis-3/"/>
      <url>/2020/06/06/riemann-hypothesis-3/</url>
      
        <content type="html"><![CDATA[<h2 id="黎曼函数的由来"><a href="#黎曼函数的由来" class="headerlink" title="黎曼函数的由来"></a>黎曼函数的由来</h2><p>到了这里，我们可以看出了$\varepsilon(s)$和素数存在了千丝万缕的关系，于是人们认为$\varepsilon(s)$可能是破解素数规律的至强法宝，在了解黎曼函数与素数的关系之前，我们先来看看素数的分布规律。</p><h4 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h4><p>了解素数定理之前，先了解素数的分布规律，统计一下一段里素数的个数。如下图所示：</p><p>$$ \left[ \begin{array}{ccc} 1-10&amp;&amp;4 \ 1-100&amp;&amp;25 \ 1-1000&amp;&amp;168 \ ….&amp;&amp;…. \end{array} \right] $$</p><p>后来有人想，有没有一个式子，通过给定的x能求出小于x的素数的个数，最早给出这个答案就是高斯大神！</p><p>据说高斯15岁的时候给出了这么一个猜想：对于给定的自然数x，小于x的素数的个数约等于$\frac{x}{\ln{x}}$个，但是高斯没有高调地发表出来。</p><p>后来是同时期的数学家勒让德公布出了这个结果，是当时3L大数学家——拉格朗日、勒让德、拉普拉斯之一。</p><p>但是人们一听说高斯早就发现了这个公式，那这个功劳就揣在高斯的口袋里了，哈哈哈。</p><p>素数定理： 设x≥1，以π(x)表示不超过x的素数的个数，当x→∞时，$\pi(x)$～$Li(x)$（对数积分函数）或$\pi(x)$～$\frac{x}{ln(x)}$（素数计数函数）。</p><p>即： $$\pi(x) ～ \frac{x}{\ln{x}} 或 Li(x) &#x3D; \int_{2} ^{x}{\frac{dt}{\ln{t}}}$$ <strong>x越大，误差越小，但还是存在误差项</strong></p><p><img src="/images/2020/06/20200603173716335.png"></p><p>中间是最准确的素数计数函数，但是看起来$Li(x)$比$\pi(x)$更准确一点，但两个函数都不能准确地描述素数分布的规律，这时，高斯的学生黎曼出现了！！！</p><p>黎曼在欧拉的基础上把$\varepsilon$函数进行了解析延拓就称为黎曼$\zeta$函数，之前提到过s是必须要大于1的，才是收敛，才是有意义的，s小于1是发散的，是无意义的。 那黎曼就想，能不能通过办法，让s在所有的复数域都具有意义，这个方法就是解析延拓。最后黎曼得出来，在所有的复平面内，只有1一个奇点没有意义，其他点都具有意义，也就是都是收敛的。所以这个拓展了定义域之后，这个函数就叫黎曼$\zeta$函数。并且黎曼通过这个函数提出了著名的黎曼猜想。 （关于解析延拓可看上篇博客）</p><p>最终，在黎曼当上了柏林的科学院通讯院士，为了回应这个荣誉，黎曼发表了一篇8页的论文《论小于某给定数值的素数个数》。从此黎曼函数横空出世。</p><h4 id="黎曼函数"><a href="#黎曼函数" class="headerlink" title="黎曼函数"></a>黎曼函数</h4><p>黎曼$\zeta$函数主要是研究素数分布的情况才出现的。 先来看一下$\zeta(x)$的函数式： $$\zeta(s) &#x3D; 1 + \frac{1}{2^{s}} + \frac{1}{3^{s}} + \frac{1}{4^{s}}+…$$ 在来看一下黎曼$\zeta$函数经过解析延拓后的积分形式： $$\zeta(x) &#x3D; \frac{\Gamma (1-s)}{2\pi i}\oint_r\frac{z^{s-1}e^{-z}}{1-e^{z}} dz$$ 这个函数又被称为亚纯函数。</p><p>其中$\Gamma (s)$（伽马函数）就是表示$(s-1)！$（阶乘）。 （这个式子只能看看就好，常人无法理解，卑微的我更无法理解）</p><p>这样，黎曼就把欧拉级数的定义域从s&gt;1通过解析延拓将其扩大，扩大到除了1这一个奇点外的所有复平面内。（复数都知道吧，不单是实数，虚数也可以）</p><p>先尝试带几个数进去看看。 $$\zeta(-1)&#x3D;-\frac{1}{12}\ \zeta(-2) &#x3D; 0\ \zeta(-3) &#x3D; \frac{1}{120} $$</p><p>黎曼通过解析延拓出来的结果和欧拉当时算出来的结果是相同的。那么黎曼猜想是怎么来的呢？</p><p>然后就到了今天的主题——黎曼猜想。</p><h2 id="黎曼猜想"><a href="#黎曼猜想" class="headerlink" title="黎曼猜想"></a>黎曼猜想</h2><p>黎曼通过把黎曼$\zeta$函数推导后，得出下面的式子： $$\zeta(s) &#x3D; 2\Gamma (1-s)(2\pi)^{s-1}\sin(\frac{\pi s}{2})\zeta(1-s)$$</p><p>肉眼可见，上面式子中令$\sin(\frac{\pi s}{2})&#x3D;0$就得到了一些函数零点，比如-2，-4，-6…这些个零点被称为平凡零点。</p><p>然后我们让上面式子强行等于0，就是求$\zeta(s)$除了平凡零点外的非平凡零点，那么黎曼猜想就来了。</p><p>黎曼猜测，所有的非平凡零点的实部都在$x &#x3D; 0$和$x &#x3D; 1$这两条临界线之内，这一块区域叫做临界区域或者关键区域。有可能零点的实部都在$x &#x3D; \frac{1}{2}$这条临界线上。但是黎曼无法证明。</p><p>具体图像如下所示：</p><p><img src="/images/2020/06/20200605165107475.jpg"></p><p>而黎曼$\zeta$函数的零点又与素数的分布情况紧密相连，所以，如果有人能证实黎曼猜想，这将是轰动全球的大事件。</p><h4 id="黎曼猜想的后继故事"><a href="#黎曼猜想的后继故事" class="headerlink" title="黎曼猜想的后继故事"></a>黎曼猜想的后继故事</h4><p>在1900年国际数学大会上，希尔伯特在演讲中提出了23个数学问题，其中第八个就是黎曼猜想，与他并列第八的就是哥德巴赫猜想。</p><p>在2000年的千禧年，美国的克雷数学研究所提出了7个 千禧难题，全是数学猜想，其中黎曼猜想就在其中，只要能证明其中一个就能拿到100万美元，其中的庞加莱猜想已经被证明了。这个人会是你吗？</p><h4 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h4><p>1896年法国的两个学者阿达玛和普森两个人证明了所有的非平凡零点的实部都在$x &#x3D; 0$和$x &#x3D; 1$这两条临界线里；</p><p>1932年，黎曼-西格尔公式出世，以后计算零点的方法要方便得多。</p><p>后来通过计算机，德国的IBM实验室（项目现在已经取消了），已经计算出了有了1万亿个非平凡零点，而这些非平凡零点都在$x &#x3D; \frac{1}{2}$这条线上。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>最后，花了一周的时间来写这几篇博客，以前就想写这方面的博客，这次终于完结了，其实写这些东西对我来说没有太多的帮助，这只是出于对数学的兴趣（其实我数学很垃圾），爱好使然吧！ 不得不说这些人的智慧是非比寻常的。那就来看看黎曼的人生事迹： <a href="https://www.bilibili.com/video/BV1xE411u7Zp">https://www.bilibili.com/video/BV1xE411u7Zp</a></p><p>参考： <a href="https://www.bilibili.com/video/BV1oW411U7Bk?t=589">https://www.bilibili.com/video/BV1oW411U7Bk?t=589</a> <a href="https://www.bilibili.com/video/BV1rW411m7GL">https://www.bilibili.com/video/BV1rW411m7GL</a> <a href="https://www.bilibili.com/video/BV12x41187QH?from=search&seid=17055570753699382374">https://www.bilibili.com/video/BV12x41187QH?from=search&seid=17055570753699382374</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/06/06/riemann-hypothesis-3/">https://blog.jujimeizuo.cn/2020/06/06/riemann-hypothesis-3/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> interesting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黎曼猜想（二）全体自然数之和等于-1/12和解析延拓</title>
      <link href="/2020/06/06/riemann-hypothesis-2/"/>
      <url>/2020/06/06/riemann-hypothesis-2/</url>
      
        <content type="html"><![CDATA[<h2 id="全体自然数之和等于-frac-1-12"><a href="#全体自然数之和等于-frac-1-12" class="headerlink" title="全体自然数之和等于$-\frac{1}{12}$"></a>全体自然数之和等于$-\frac{1}{12}$</h2><p>有人一定听说过全体自然数之和等于$-\frac{1}{12}$，那我们这期就来聊聊这究竟是为什么呢？这个结果又和什么有关系呢？</p><p>之前我们说过这样的一个式子： $$\varepsilon (s) &#x3D; 1 + \frac{1}{2^{s}} + \frac{1}{3^{s}} + \frac{1}{4^{s}} +\frac{1}{5^{s}} + \frac{1}{6^{s}}+… $$</p><p>当s &#x3D; 1时； $$\varepsilon (1) &#x3D; 1 + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} +\frac{1}{5} + \frac{1}{6}+… $$</p><p>这是调和级数，是发散的。</p><p>当s &#x3D; 2时； $$\varepsilon (2) &#x3D; 1 + \frac{1}{2^{2}} + \frac{1}{3^{2}} + \frac{1}{4^{2}} +\frac{1}{5^{2}} + \frac{1}{6^{2}}+… $$</p><p>这就是巴塞尔问题，答案是$\frac{\pi^{2}}{6}$。</p><p>但是当s &lt; 1时，答案又是什么呢？</p><p>欧拉给出了这么几个答案：</p><p>$$\varepsilon (-1) &#x3D; 1 + 2 + 3 + 4 + 5… &#x3D; -\frac{1}{12} \ \varepsilon (-2) &#x3D; 0 \ \varepsilon (-3) &#x3D; -\frac{1}{120}$$</p><p>是不是很神奇，那让我们看一下欧拉的证明方法。</p><p>欧拉把这个函数$\frac{x}{(1-x)^{2}}$幂级数展开得： $$\frac{x}{(1-x)^{2}} &#x3D; x + 2x^{2} + 3x^{3} + 4x^{4} + ….$$</p><p>令x &#x3D; -1得： $$-\frac{1}{4} &#x3D; -1 + 2 - 3 + 4 - …..$$ $$ -\frac{1}{4}&#x3D; -(1 + 3 + 5 + …) + (2 + 4 + 6 + …)$$ $$-\frac{1}{4} &#x3D; -(1 + 2 + 3 + 4 + ..) + (2 *2 +4*2 + 6*2+…)$$ $$-\frac{1}{4}&#x3D;3 * (1 + 2 + 3 + 4 + ….)$$ $$1 + 2 + 3 + 4 + … &#x3D; -\frac{1}{12}$$</p><p>这只是欧拉的证明方法，还有很多其他版本的证明方法后续再补充。</p><p>（全体自然数之和在数学家的眼里是错误的，但是在物理学家的眼里那就不一定错误了。）</p><p>到了这里，为什么全体自然数之和等于$-\frac{1}{12}$，在上一期说过，s在这个欧拉级数里必须是大于1才有意义，当s &#x3D; -1的时候是无意义的，那么怎么会出现这个这个结果，答案就是解析延拓。</p><h2 id="解析延拓"><a href="#解析延拓" class="headerlink" title="解析延拓"></a>解析延拓</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>解析：如果一个函数$f(x)$在某一点a处可导，并且在a的领域也处处可导，即这个函数$f(x)$在a点是解析的，如果$f(x)$在区域D内的任意一点都是解析的，那么$f(x)$在区域D内是解析的。</p><p>通俗的来说，解析延拓就是将一个函数$f(x)$的定义域“扩大”，但这个“扩大”不是随意扩大，解析延拓是唯一的，条件就是$f(x)$是在一个区域内是处处可导的，那么就可以将这个区域扩大到全局，也就是局部函数-&gt;全局函数，而且也是处处可导的。处处可导是什么意思呢？就是处处是光滑。</p><p>那我们来举个栗子。</p><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>我们一定看过这样的一个数列： $$1 + x + x^{2} + x^{3} + ….$$</p><p>用等比数列求和可得(-1 &lt; x &lt; 1)：</p><p>$$1 + x + x^{2} + x^{3} + …. &#x3D; \frac{1}{1 - x}$$</p><p>那我们先把这个函数用图像画出来，当-1 &lt; x &lt; 1时，左边是严格等于右边的，所以图像是：</p><p><img src="/images/2020/06/20200604170224297.png"></p><p>左边的数列只有在-1&lt;x&lt;1时才会是上图所呈现的，但是对于右边，貌似我们还可以画出x的定义域内的图像，图像如下：</p><p><img src="/images/2020/06/20200604170503197.png"></p><p>这样我们就把左边的数列进行了解析延拓，扩大了定义域，但是上图除了-1&lt;x&lt;1，之外的范围都不存在，让我们来带几个值进去。 当$x &#x3D; \frac{1}{2}$时： $$1 + \frac{1}{2} + (\frac{1}{2})^{2} + (\frac{1}{2})^{3} + …. &#x3D; 2$$ 这是完全正确的。 当$x &#x3D; -1$时： $$1 + -1 + 1 - 1 + …. &#x3D; \frac{1}{2}$$</p><p>这个式子对不对自己细品。。。 对于左边x &#x3D; -1是没有意义的，但是对于解析延拓出来的右边函数是具有意义的。</p><p>所以说，全体自然数之和等于$-\frac{1}{12}$是解析延拓出来的结果，是错误的。</p><p>那么欧拉级数解析延拓出来的函数是什么样子呢？让我们下期再来讲讲黎曼函数。</p><p>参考： <a href="https://www.bilibili.com/video/BV1MW411S7Tg">https://www.bilibili.com/video/BV1MW411S7Tg</a> <a href="https://www.bilibili.com/video/BV1oW411U7Bk">https://www.bilibili.com/video/BV1oW411U7Bk</a> <a href="https://blog.csdn.net/qq_40155097/article/details/86670230">https://blog.csdn.net/qq_40155097&#x2F;article&#x2F;details&#x2F;86670230</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/06/06/riemann-hypothesis-2/">https://blog.jujimeizuo.cn/2020/06/06/riemann-hypothesis-2/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> interesting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黎曼猜想（一） 欧拉乘积式</title>
      <link href="/2020/06/06/riemann-hypothesis-1/"/>
      <url>/2020/06/06/riemann-hypothesis-1/</url>
      
        <content type="html"><![CDATA[<h2 id="素数无限的几个证明"><a href="#素数无限的几个证明" class="headerlink" title="素数无限的几个证明"></a>素数无限的几个证明</h2><h4 id="毕达哥拉斯学派证明"><a href="#毕达哥拉斯学派证明" class="headerlink" title="毕达哥拉斯学派证明"></a>毕达哥拉斯学派证明</h4><p>公元前600～公元前500年古希腊时期，为了证明素数有无限个这个问题，毕达哥拉斯学派给出了一个证明：</p><p>素数是从2和3开始的，所以用2 * 3+1 &#x3D; 7； 7是素数，所以用2 * 3 * 7+1 &#x3D; 43； 43是素数，所以用2 * 3 * 7 * 43+1 &#x3D; 1807； 1807不是素数，但是1807 &#x3D; 13 * 139，这两个数都是素数，发现了两个新素数，我们用小的素数与那一堆相乘，所以用2 * 3 * 7 * 43 * 13 + 1 &#x3D; 23479； 23479不是素数，但是23479 &#x3D; 53 * 443，这两个都是素数，又发现了两个新素数； 继续往下，会一直发现新的素数，即证明素数有无限个。 毕达哥拉斯学派在当时能证明出来是非常了得，后200年又出现了这么一位神人——欧几里得！</p><h4 id="欧几里得证明"><a href="#欧几里得证明" class="headerlink" title="欧几里得证明"></a>欧几里得证明</h4><p>欧几里得用的是反证法，证明如下：</p><p>先假设素数是有限个，即P1, P2, P3,……Pk；其中Pk是最大的素数； 我们用A &#x3D; P1 * P2 * P3 * P4 * ……..* Pk + 1；即将所有素数相乘后加1； 一个自然数要么是素数要么是合数（除了1）； 1、A是素数，由于Pk是素数，所以不存在比Pk还大的素数A，即A不可能是素数； 2、A是合数，由于所有的合数都可以由素数相乘得到，即A % Pi &#x3D; 0，所有的素数都是A的因子，而A &#x3D; 所有素数相乘 + 1，即A不可能是合数；</p><p>那么A又不是素数也不是合数，得出原命题素数有限个是错误的，即证明了素数无限个。</p><h4 id="欧拉证明"><a href="#欧拉证明" class="headerlink" title="欧拉证明"></a>欧拉证明</h4><p><img src="/images/2020/06/20200604161236533.jpeg"></p><p>在这里，我们就要介绍欧拉乘积式了，因为这也是证明素数无限个的一个证明方法。</p><p>1735年，欧拉大神发表了一个极其重要的公式，即欧拉乘积式： $$\sum_{n &#x3D;1 }^{\infty }n^{-s} &#x3D; \prod_{p}(1 - \frac{1}{p^{s}})^{-1}$$</p><p>证明之前我们先需要知道以下基本知识。</p><p>我们知道调和级数是发散的，即：</p><p><img src="/images/2020/06/20200603160719623.png"></p><p>门戈利当时提出了一个问题，全体自然数的平方倒数之和是多少呢？当时也没有解决这个问题，后来被约翰伯努利的学生欧拉解决出来了，即上上期博客的巴塞尔问题，可以自行观看，答案是：</p><p><img src="/images/2020/06/20200603161012666.png"></p><p>后来欧拉又把这样的式子进行了拓展，即将自然数上的幂变成s，即得到这样的一个式子： $$\varepsilon (s) &#x3D; 1 + \frac{1}{2^{s}} + \frac{1}{3^{s}} + \frac{1}{4^{s}} +\frac{1}{5^{s}} + \frac{1}{6^{s}}+… \qquad （1）$$</p><p>我们对左右两边同时乘以$\frac{1}{2^{s}}$，即得到： $$ \frac{1}{2^{s}}\varepsilon (s) &#x3D; \frac{1}{2^{s}} + \frac{1}{4^{s}} + \frac{1}{6^{s}} + \frac{1}{8^{s}} + …. \qquad（2）$$</p><p>式(1) - 式(2) 得：</p><p>$$(1 - \frac{1}{2^{s}})\varepsilon (s) &#x3D; 1 + \frac{1}{3^{s}} + \frac{1}{5^{s}} + \frac{1}{7^{s}} +\frac{1}{9^{s}} +… \qquad （3)$$</p><p>这样，所有的2的倍数的自然数都消去了。</p><p>我们在对左右两边同时乘以$\frac{1}{3^{s}}$，即得到：</p><p>$$ \frac{1}{3^{s} }(1 - \frac{1}{2^{s}})\varepsilon (s) &#x3D; \frac{1}{9^{s}} + \frac{1}{15^{s}} + \frac{1}{21^{s}} +\frac{1}{27^{s}} +… \qquad （4)$$</p><p>式(3) - 式(4)得： $$(1-\frac{1}{3^{s} })(1 - \frac{1}{2^{s}})\varepsilon (s) &#x3D; 1 + \frac{1}{3^{s}} + \frac{1}{5^{s}} + \frac{1}{7^{s}} + \frac{1}{11^{s}} + … \qquad (5)$$</p><p>有没有发现这样的一个问题，第一次相减，把所有的自然数的2倍都消去了，第二次相减，把所有的自然数的3倍都消去了，emmmm，埃拉托色尼筛法！！！</p><p>没错，理解到了这一步就已经很快了，类似的运算继续下去，我们每一步都减去$\frac{1}{5^{s}}$倍、$\frac{1}{7^{s}}$倍…也就把素数的倍数都消去。</p><p>最终得到这样一个公式：</p><p>$$…(1 - \frac{1}{13^{s}})(1 - \frac{1}{11^{s}})(1 - \frac{1}{7^{s}})(1 - \frac{1}{5^{s}})(1-\frac{1}{3^{s} })(1 - \frac{1}{2^{s}})\varepsilon (s) &#x3D; 1 \qquad (6)$$</p><p>再将左边变过去，保留$\varepsilon (s)$，即： $$\varepsilon (s) &#x3D; \frac{1}{(1 - \frac{1}{2^{s}})(1 - \frac{1}{3^{s}})(1 - \frac{1}{5^{s}})(1 - \frac{1}{7^{s}})(1-\frac{1}{11^{s} })(1 - \frac{1}{13^{s}})…} \qquad (7)$$</p><p>让我们用连乘符号$\prod$简洁一下得： $$\sum_{n &#x3D;1 }^{\infty }n^{-s} &#x3D; \prod_{p}(1 - \frac{1}{p^{s}})^{-1} \qquad (8)$$</p><p><strong>当n &#x3D; 1时，左边就是调和级数，是发散的，而右边的p是所有素数，若素数是有限个，即调和级数不发散，那怎么可能呢？？？所以得证素数是无限个。</strong></p><p>欧拉大神NB！</p><p>注意： s一定是大于1的，否则会出现一些好玩的东西，比如全体自然数之和竟然是$-\frac{1}{12}!!!$我们下期再聊。</p><p>参考: <a href="https://www.bilibili.com/video/BV1dt4y1179j">https://www.bilibili.com/video/BV1dt4y1179j</a> <a href="https://www.bilibili.com/video/BV1eW411r7cp">https://www.bilibili.com/video/BV1eW411r7cp</a> <a href="https://www.bilibili.com/video/BV13W41167Bb">https://www.bilibili.com/video/BV13W41167Bb</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/06/06/riemann-hypothesis-1/">https://blog.jujimeizuo.cn/2020/06/06/riemann-hypothesis-1/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> interesting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++和Java中STL库入门</title>
      <link href="/2020/05/28/beginner-stl/"/>
      <url>/2020/05/28/beginner-stl/</url>
      
        <content type="html"><![CDATA[<p>参考会长大佬<a href="https://me.csdn.net/m0_43448982">https://me.csdn.net/m0_43448982</a></p><h4 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h4><p>STL简称标准模版库，被容纳在C++标准程序库，包含了许多基本数据结构和基本算法，使程序员写起来得心应手。</p><h4 id="为什么使用STL"><a href="#为什么使用STL" class="headerlink" title="为什么使用STL"></a>为什么使用STL</h4><p>在学习数据结构的时候，在程序中会使用到堆、栈、队列、链表等一些基本的算法，而学习数据结构的时候，这些基本算法写起来十分繁琐，如果不想写这些，那么就可以考虑一下STL了。 但是不要太过于依赖STL！</p><h4 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h4><p>要使用STL，需要理解以下几个基本概念： <strong>容器</strong>：是存放数据的地方，常见的容器有：链表(list) 栈(stack) 动态数组 (vector) 双端队列(deque) 队列(queue) 映射(map) **迭代器(iterator)**：可以理解为C语言里的地址，而迭代器就是容器的一个指针，十分重要！！！ <strong>算法</strong>：可以对容器里的数据做一些基本操作，比如排序，找最大元素等等。</p><h4 id="STL使用前的初始化"><a href="#STL使用前的初始化" class="headerlink" title="STL使用前的初始化"></a>STL使用前的初始化</h4><p>=&#x3D;C++&#x3D;&#x3D;： 1.需要对应的头文件，比如list就需要##include&lt;list&gt;，且没有.h，或者恶心的万能头##include&lt;bits&#x2F;stdc++.h&gt;。 2.添加std命名空间（using namespace std;）不加的话后面可以自己写一堆。。。</p><p>=&#x3D;java&#x3D;&#x3D;: 1.需要import类，可以统一写成import java.util.*;</p><h4 id="C-里STL基本容器详解"><a href="#C-里STL基本容器详解" class="headerlink" title="C++里STL基本容器详解"></a>C++里STL基本容器详解</h4><p>=&#x3D;cmp类&#x3D;&#x3D;： <strong>通过自定义cmp类来完成STL的更加自由的设置</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cmp &#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">operator</span>()(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>=&#x3D;sort&#x3D;&#x3D;: 1.需要头文件##include&lt;algorithm&gt;； 2.复杂度为O(nlogn)，比较排序的极限了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">cmp</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span> , <span class="number">4</span>&#125;;</span><br><span class="line">sort(a, a + <span class="number">4</span>, cmp);</span><br></pre></td></tr></table></figure><p>sort里第一个参数是数组需要排序的第一个地址，第二个参数是数组需要排序的第二个地址，都三个参数是一个自定义函数，对数组排序的函数，上面的cmp函数是使数组元素从大到小排序。</p><p>sort是不稳定排序，即对于相同的值，无法保证其前后顺序 解决办法： 1、增加一个 index 变量，在值相同的使用比较 index 值的大小 2、使用 stable_sort</p><p>=&#x3D;vector&#x3D;&#x3D;： 1.需要头文件##include&lt;vector&gt; 2.不定数组</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; a, b;</span><br><span class="line">a.push_back(<span class="number">1</span>); <span class="comment">// 推入一个新的值到数组最后</span></span><br><span class="line">a.pop_back();       <span class="comment">// 删除数组最后的那个值</span></span><br><span class="line">a.front();          <span class="comment">// 数组开头的值</span></span><br><span class="line">a.back();           <span class="comment">// 数组结尾的值</span></span><br><span class="line">a = b;              <span class="comment">// 数组拷贝</span></span><br><span class="line">a == b;             <span class="comment">// 数组是否相同</span></span><br><span class="line">a[<span class="number">1</span>];               <span class="comment">// 数组中第二个值</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; a;</span><br><span class="line">a.size();               <span class="comment">// 容器内的元素个数</span></span><br><span class="line">a.empty();              <span class="comment">// 容器是否为空</span></span><br><span class="line"><span class="comment">// 除了queue和stack外通用的方法</span></span><br><span class="line">a.clear();              <span class="comment">// 清空容器内的所有元素</span></span><br><span class="line">a.begin();              <span class="comment">// 容器的一个元素的迭代器</span></span><br><span class="line">a.end();                <span class="comment">// 容器尾后迭代器</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt; v;</span><br><span class="line">vector&lt;<span class="built_in">int</span>&gt;::iterator iter    <span class="comment">// 定义迭代器</span></span><br><span class="line">iter = v.begin();               <span class="comment">// 数组头“指针”</span></span><br><span class="line">iter = v.end();             <span class="comment">// 数组尾“指针”</span></span><br></pre></td></tr></table></figure><p>=&#x3D;list&#x3D;&#x3D;: 1.需要头文件##include&lt;int&gt; l; 2.双向链表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="built_in">int</span>&gt; l;</span><br><span class="line">l.push_front(<span class="number">1</span>);            <span class="comment">// 插入元素到开头</span></span><br><span class="line">l.pop_front();          <span class="comment">// 从开头删掉元素</span></span><br><span class="line">l.erase(l.begin());     <span class="comment">// 删除指定迭代器处的元素</span></span><br><span class="line">l.insert(l.begin(), <span class="number">1</span>); <span class="comment">// 在指定迭代器前插入元素</span></span><br><span class="line">l.reverse();                <span class="comment">// 反转整个链表</span></span><br></pre></td></tr></table></figure><p>=&#x3D;string&#x3D;&#x3D;: 1.伪字符串； 2.定义：string s; 3.只能流输入和流输出；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line">a[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>;              <span class="comment">// 得到某个字符</span></span><br><span class="line">a = b;                      <span class="comment">// 字符串拷贝</span></span><br><span class="line">a &gt;= b;                      <span class="comment">// 字典序比较</span></span><br><span class="line">a[<span class="number">1</span>] = b[<span class="number">1</span>];                <span class="comment">// 修改某个字符</span></span><br><span class="line">a += b;                     <span class="comment">// 字符串拼接</span></span><br><span class="line">a = a + b;                  <span class="comment">// 字符串拼接</span></span><br><span class="line">a += <span class="string">&quot;123&quot;</span>;               <span class="comment">// 字符串拼接</span></span><br><span class="line">a = b + <span class="string">&quot;123&quot;</span>;                <span class="comment">// 字符串拼接</span></span><br><span class="line"><span class="built_in">int</span> len = a.lenth();        <span class="comment">// 字符串的长度</span></span><br></pre></td></tr></table></figure><p>=&#x3D;queue&#x3D;&#x3D;： 1.需要头文件##include&lt;queue&gt;； 2.先进先出（内部为链表实现）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="built_in">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>);              <span class="comment">// 将1推入队列</span></span><br><span class="line">q.pop();                <span class="comment">// 推出队列开头的元素</span></span><br><span class="line">q.front();              <span class="comment">// 队列的第一个元素</span></span><br></pre></td></tr></table></figure><p>=&#x3D;stack&#x3D;&#x3D;: 1.需要头文件##include&lt;stack&gt;; 2.后进先出（内部为数组实现）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="built_in">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>);              <span class="comment">// 将1推入堆栈</span></span><br><span class="line">q.pop();                <span class="comment">// 推出堆栈最后的元素</span></span><br><span class="line">q.top();                <span class="comment">// 堆栈的最后的元素</span></span><br></pre></td></tr></table></figure><p>=&#x3D;pair&#x3D;&#x3D;: 1.需要头文件##include&lt;map&gt; 2.表示一组键对（有两个变量的结构体）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; p;</span><br><span class="line">p.first = <span class="number">1</span>;</span><br><span class="line">p.second = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">p = make_pair(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">p = &#123;<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; p[<span class="number">100</span>];</span><br><span class="line">sort(p, p + <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 默认优先first从小到大</span></span><br><span class="line"><span class="comment">// 如果first相同则second从小到大</span></span><br></pre></td></tr></table></figure><p>pair与其他结构嵌套</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; &gt; vp;</span><br><span class="line">queue&lt;pair&lt;<span class="built_in">float</span>, <span class="built_in">int</span>&gt; &gt; qp;</span><br><span class="line">queue&lt;pair&lt;pair&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;, <span class="built_in">int</span>&gt; &gt; qpp;</span><br></pre></td></tr></table></figure><p>=&#x3D;set&#x3D;&#x3D;: 1.需要头文件##include&lt;set&gt;； 2.set保存了不可重复的元素–<strong>二叉搜索树-红黑树</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>&lt;<span class="built_in">int</span>&gt; s;</span><br><span class="line">s.insert(<span class="number">1</span>);                <span class="comment">// 插入到集合中</span></span><br><span class="line">s.erase(<span class="number">1</span>);             <span class="comment">// 从集合中删除</span></span><br><span class="line">s.erase(s.begin());     <span class="comment">// 从集合中删除</span></span><br><span class="line">s.count(<span class="number">1</span>);             <span class="comment">// 集合中是否存在</span></span><br><span class="line">s.find(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回对应值的迭代器（若无则返回尾后迭代器）</span></span><br></pre></td></tr></table></figure><p>·由于set是红黑树，所以满足以下内容 1、内部有序(默认从小到大) 2、没有重复值，如果出现重复值会不断被覆盖 3、几乎所有操作复杂度均为 O(logN) 4、不可以修改节点上的值 5、修改操作只能进行插入和删除两个操作</p><p><strong>set通常作用：保证唯一性，保证数列有序</strong></p><p>=&#x3D;map&#x3D;&#x3D;： 1.需要头文件##include&lt;map&gt;； 2.map字典（键对集合）<strong>——二叉搜索树——红黑树</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">char</span>, <span class="built_in">int</span>&gt; m;</span><br><span class="line">m.insert(make_pair(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));  <span class="comment">// 加入字典</span></span><br><span class="line">m.insert(&#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>&#125;);           <span class="comment">// 加入字典</span></span><br><span class="line">m.erase(<span class="string">&#x27;a&#x27;</span>);                 <span class="comment">// 从字典中删除</span></span><br><span class="line">m.count(<span class="string">&#x27;a&#x27;</span>);                 <span class="comment">// 字典中是否存在</span></span><br><span class="line">m.find(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 返回对应值的迭代器（若无则返回尾后迭代器）</span></span><br></pre></td></tr></table></figure><p>通常称map的first元素为key，second元素为value ·由于map是键对红黑树，所以满足以下内容 1、set的大部分性质； 2、key不能重复，不能修改，只能删除和添加； 3、允许value重复，可以对value进行修改； 4、map是按照key进行排序的； 5、key和value一定是成对出现的； 6、map的迭代器指向的内容是一个pair；</p><p>=&#x3D;priority_queue&#x3D;&#x3D;: 1.需要头文件##include&lt;queue&gt; 2.优先队列–堆</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="built_in">int</span>&gt; prq;</span><br><span class="line">prq.top();              <span class="comment">// 堆顶上的元素</span></span><br><span class="line">prq.pop();              <span class="comment">// 弹出堆顶上的元素</span></span><br><span class="line">prq.push(<span class="number">1</span>);            <span class="comment">// 推入堆</span></span><br></pre></td></tr></table></figure><p>·priority_queue默认为最大堆，即堆顶的元素最大 ·和queue一样，priority_queue不允许访问除了堆顶元素以外的任何一个元素。 ·priority_queue的插入和弹出操作的复杂度均为O(logN)</p><p><strong>priority_queue功能与set接近，而且set的功能更强大，并且理论复杂度相同，为什么有时候反而就是用priority_queue？ ·priority_queue的复杂度为最差情况下的复杂度，而set和map的复杂度均为稳定复杂度的极限值</strong></p><h4 id="Java里STL基本容器详解"><a href="#Java里STL基本容器详解" class="headerlink" title="Java里STL基本容器详解"></a>Java里STL基本容器详解</h4><p>参考<a href="https://blog.csdn.net/qq_38173003/article/details/79733423">https://blog.csdn.net/qq_38173003&#x2F;article&#x2F;details&#x2F;79733423</a> <a href="https://www.cnblogs.com/solvit/p/9600591.html">https://www.cnblogs.com/solvit/p/9600591.html</a> &#x3D;&#x3D;所有的容器都要有import类**import java.util.***&#x3D;&#x3D;</p><p>=&#x3D;vector&#x3D;&#x3D;: 和c++的vector使用方法类似。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Vector&lt;Integer&gt; vec=<span class="keyword">new</span> Vector&lt;&gt; ();</span><br><span class="line">        vec.<span class="keyword">add</span>(<span class="number">1</span>);<span class="comment">//添加元素</span></span><br><span class="line">        vec.<span class="keyword">add</span>(<span class="number">4</span>,<span class="number">6</span>);<span class="comment">//在下表为4前添加6元素</span></span><br><span class="line">        vec.<span class="keyword">set</span>(<span class="number">3</span>, <span class="number">7</span>);<span class="comment">//替换下表为3元素值为7</span></span><br><span class="line">        vec.<span class="keyword">remove</span>(<span class="number">0</span>);<span class="comment">//删除下表为1的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)&#123;  <span class="comment">//size获取长度</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(vec.<span class="keyword">get</span>(i)); <span class="comment">//get获取下表为i的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        vec.clear();<span class="comment">//清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&#x3D;ArrayList&#x3D;&#x3D;: Java.util.ArrayList类是一个动态数组类型，也就是说，ArrayList对象既有数组的特征，也有链表的特征。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="number">1</span>);<span class="comment">//添加</span></span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">        arr.size();<span class="comment">//获取长度</span></span><br><span class="line">        arr.<span class="keyword">set</span>(<span class="number">1</span>, <span class="number">4</span>);<span class="comment">//修改</span></span><br><span class="line">        <span class="built_in">int</span> st=arr.<span class="keyword">remove</span>(<span class="number">0</span>);<span class="comment">//删除</span></span><br><span class="line">        <span class="comment">//arr.clear();//清空</span></span><br><span class="line">        <span class="comment">//arr.get(1);//获取</span></span><br><span class="line">        <span class="built_in">int</span> v=arr.indexOf(<span class="number">3</span>);<span class="comment">//获取索引</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&#x3D;LinkedList&#x3D;&#x3D;： LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; lin=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        lin.addFirst(st);<span class="comment">//在首部加</span></span><br><span class="line">        lin.addLast(st);<span class="comment">//在尾</span></span><br><span class="line">        lin.removeFirst();<span class="comment">//移除首元素</span></span><br><span class="line">        lin.removeLast();<span class="comment">//尾</span></span><br><span class="line">        lin.push(st);<span class="comment">//压入栈</span></span><br><span class="line">        lin.pop();<span class="comment">//弹出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&#x3D;HashSet&#x3D;&#x3D;: 无重复元素</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hashset=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashset.<span class="keyword">add</span>(<span class="number">4</span>);<span class="comment">//添加</span></span><br><span class="line">        hashset.<span class="keyword">remove</span>(<span class="number">2</span>); <span class="comment">//找到值2删除</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(hashset);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&#x3D;HashMap&#x3D;&#x3D;:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//添加元素</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//替换</span></span><br><span class="line">        map.<span class="keyword">remove</span>(<span class="number">4</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(map.<span class="keyword">get</span>(<span class="number">1</span>));</span><br><span class="line">        System.<span class="keyword">out</span>.println(map.size());</span><br><span class="line">        System.<span class="keyword">out</span>.println(map);</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只做入门参考。</strong></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/28/beginner-stl/">https://blog.jujimeizuo.cn/2020/05/28/beginner-stl/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>著名的巴塞尔问题</title>
      <link href="/2020/05/21/basel-problem/"/>
      <url>/2020/05/21/basel-problem/</url>
      
        <content type="html"><![CDATA[<p>今天高数老师上了无穷级数的p级数，不过没有讲到著名的巴塞尔问题，所以我来描述一下。</p><p>巴塞尔问题是在1644年被提出，后来在1735年被<a href="https://baike.baidu.com/item/%E8%8E%B1%E6%98%82%E5%93%88%E5%BE%B7%C2%B7%E6%AC%A7%E6%8B%89/2148998">欧拉大神</a>给解决了。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>计算所有平方数的倒数之和，也就是2-级数：</p><p><img src="/images/2020/05/20200521145734921.png"></p><p>我们知道调和级数是发散的，但是这个级数是不是发散的呢？答案是收敛的，大小大概是1.644934，是不是和提出问题的时间有点相似？</p><h2 id="欧拉大神的想法"><a href="#欧拉大神的想法" class="headerlink" title="欧拉大神的想法"></a>欧拉大神的想法</h2><p>那个时候欧拉的手里有两个正弦函数：</p><p><img src="/images/2020/05/20200521150632848.png"></p><p>这其实就是泰勒展开！</p><p><img src="/images/2020/05/20200521150742419.png"></p><p>将第一个等式左右同除x得第三个等式：</p><p><img src="/images/2020/05/20200521150813493.png"></p><p>那第二个等式是怎么来的呢？ 我们知道sinx &#x2F; x &#x3D; 0的根出现在x &#x3D; nπ，n &#x3D; ±1、±2、±3…所以sinx &#x2F; x可以像因式分解一样转化成上图。</p><p>如果我们把第二个等式右边所有的x^2^的系数加起来得：</p><p><img src="/images/2020/05/20200521151519338.png"></p><p>在和第三个等式中x^2^的系数相等得：</p><p><img src="/images/2020/05/20200521175135342.png"></p><p>等式两边乘-π^2^，得：</p><p><img src="/images/2020/05/2020052115161933.png"></p><p>所以欧拉大神解决了著名的巴塞尔问题在当时是十分轰动的，不得不佩服这些伟人的智慧。</p><p>这很好地将无穷级数和π结合起来，其实π是非常神奇的数字，包括自然底数e也是，这些数字的由来都非常有趣，只要是数学上的都有趣！！！</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/21/basel-problem/">https://blog.jujimeizuo.cn/2020/05/21/basel-problem/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> interesting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白月赛25-J异或和之和——位运算与组合计数</title>
      <link href="/2020/05/20/nowcoder-newbie25-j/"/>
      <url>/2020/05/20/nowcoder-newbie25-j/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5600/J">https://ac.nowcoder.com/acm/contest/5600/J</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2020/05/20200520201444634.png"></p><p>在一个数组中任取三个数的异或和之和。</p><p>异或：二进制下相同为0，不同为1。如： 0 ^ 1 &#x3D; 1, 0 ^ 1 &#x3D; 1, 1 ^ 1 &#x3D; 0, 0 ^ 0 &#x3D; 0。</p><p>在任取三个数中，只有两种情况的异或为1：1 1 1 和 0 0 1 所以一开始就要用一个异或数组来记录每个数二进制下的1的个数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ll k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) <span class="comment">// 二进制下的每一位的1储存下来,N-t[i]就是0的个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>)</span><br><span class="line">                XOR[k]++;</span><br><span class="line">            k++;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当在所有1 1 1的情况下有C(XOR[i], 3)种，所有的1里任取3个；在所有0 0 1的情况下有C(n - XOR[i], 2) * XOR[i])种，所有的0里人任取2个在和任意一个1组合。</p><p>由于处理组合数时，分子分母很大，需要用到<strong>费马小定理</strong></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">##include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">long</span> ll;</span><br><span class="line">typedef <span class="built_in">long</span> <span class="built_in">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line"><span class="meta">##<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const int maxn = 100005;</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">FPM</span>(<span class="params">ll a, ll b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span>(<span class="params">ll n, ll m</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans % mod * (n - i + <span class="number">1</span>) % mod * FPM(i, mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll XOR[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ll k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) <span class="comment">// 二进制下的每一位的1储存下来,N-t[i]就是0的个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>)</span><br><span class="line">                XOR[k]++;</span><br><span class="line">            k++;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; <span class="number">64</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = (sum % mod + k * (C(XOR[i], <span class="number">3</span>) % mod + XOR[i] % mod * C(n - XOR[i], <span class="number">2</span>) % mod) % mod) % mod;</span><br><span class="line">        sum %= mod;</span><br><span class="line">        k = (k &lt;&lt; <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signed <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line">    cout.tie(nullptr);</span><br><span class="line"><span class="meta">##ifdef FZT_ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    freopen(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">##<span class="keyword">else</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        solve();</span><br><span class="line"><span class="meta">##<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/20/nowcoder-newbie25-j/">https://blog.jujimeizuo.cn/2020/05/20/nowcoder-newbie25-j/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客小白月赛B-k-size字符串——逆元求组合数</title>
      <link href="/2020/05/20/nowcoder-newbie-k/"/>
      <url>/2020/05/20/nowcoder-newbie-k/</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/5600/B">https://ac.nowcoder.com/acm/contest/5600/B</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="/images/2020/05/20200520125015523.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不要看它是以字符串的形式呈现，其实本质上是组合数学（自己细品），这就是我为什么不喜欢字符串的原因了，太能花哨了…</p><p>思路：因为连续段是和k有关的，所以k是要分&#x3D;&#x3D;奇偶&#x3D;&#x3D;的。首先先把最少的a和b根据k个排列好，在把剩下的a和b塞进去，可用高中知识的隔板法，可用大神拉马努金的整数拆分（这可是个神人啊！），关于整数拆分，可以看我上篇博客，这次就用排列组合就好了。</p><p>=&#x3D;k为偶&#x3D;&#x3D;：那么最基本的形式就是<strong>abab…ab和baba….ba</strong>，这里用了k&#x2F;2个的a和b，所以之前要判断一下，如果n-k&#x2F;2或者m-k&#x2F;2中有一个小于0，那答案不就是0了吗？好，如果都大于等于0的话，继续往下操作，a剩下n-k&#x2F;2个，b剩下m-k&#x2F;2个，这里就用简单的思路：</p><p>● △ ● △ ● △ ● △ ● △ ● △ ● △ (这里小圆圈代表a，小三角形代表b)</p><p>有k&#x2F;2个a和k&#x2F;2个b，所以只要把剩下的a和剩下的b插进去，如上图有k&#x2F;2-1个插入位置，剩下的a有几种插法呢？<strong>我们给剩下的a+k&#x2F;2，这样都让每个位置都能插一个，避免了有一个位置没有插进去的a，所以有$C_(n - 1, k &#x2F; 2 - 1)$中插法</strong>，请仔细思考一下。那么b的插法不也是和a一样的吗？所以当k为偶时，组合数&#x3D;$2*C_(n-1, k &#x2F; 2 - 1)*C_(m - 1, k &#x2F; 2 -1)$。为什么要乘2呢？有没有忘记上面的abab和baba两种形式？</p><p>=&#x3D;k为奇&#x3D;&#x3D;：根据上面的思路，最基本的形式就是<strong>abab…baba和baba…bab</strong>，这里就又要判断一下，用了多少个a和b，这里就交给你们自己推导一下了，最后的组合数为$C_(n-1, k &#x2F; 2) * C_(m - 1,k &#x2F; 2 -1) + C_(n - 1,k &#x2F; 2 - 1)*C_(m - 1, k &#x2F; 2)$。</p><p>最后这个组合数怎么求呢？因为分子分母太大可能会爆longlong，比如C(10000,5000)，那么该怎么求呢？有没有想起逆元的定义，如果想不起来了可以看我以前的博客<a href="http://www.jujimeizuo.cn/blog/index.php/2020/05/15/mulinv">乘法逆元</a>。</p><p><strong>因为组合也是分子&#x2F;分母的形式，所以可以用逆元把除法转换成乘法，这样就可以用mod了</strong>。然后p是什么呢，1e9+7，这是一个素数啊，就可以知道用<strong>费马小定理求解逆元</strong>了，费马小定理可以用<strong>快速幂</strong>的方法。</p><p>思路大概就是这样，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> INF 0x7f7f7f</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> mem(a,b) memset(a , b , sizeof(a))</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> FOR(i, x, n) for(int i = x;i &lt;= n; i++)</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">// const int maxn = 100005;</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">FPM</span><span class="params">(ll x,ll power)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(power &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans % mod * x % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x % mod * x % mod) % mod;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n * <span class="number">2</span> &gt; m)</span><br><span class="line">        n = m - n;</span><br><span class="line">    ll t = n;</span><br><span class="line">    ll a = m, b = <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (ans % mod * (<span class="built_in">FPM</span>(b, mod - <span class="number">2</span>) % mod * a % mod) % mod) % mod;</span><br><span class="line">        a--;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n - k / <span class="number">2</span>) &lt; <span class="number">0</span>  (m - k / <span class="number">2</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ((<span class="number">2</span> * <span class="built_in">C</span>(n - <span class="number">1</span>, k / <span class="number">2</span> - <span class="number">1</span>) % mod) % mod * <span class="built_in">C</span>(m - <span class="number">1</span>, k / <span class="number">2</span> - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((n - (k + <span class="number">1</span>) / <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (m - k / <span class="number">2</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = (<span class="built_in">C</span>(n - <span class="number">1</span>, (k + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>) % mod * <span class="built_in">C</span>(m - <span class="number">1</span>, k / <span class="number">2</span> - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((n - k / <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (m - (k + <span class="number">1</span>) / <span class="number">2</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = (<span class="built_in">C</span>(n - <span class="number">1</span>, k / <span class="number">2</span> - <span class="number">1</span>) % mod * <span class="built_in">C</span>(m - <span class="number">1</span>, (k + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (a % mod + b % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> FZT_ACM_LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，我还是太菜了，这应该是我的部分，比赛的时候看到字符串就扔了，实在不应该，对不起我的队友。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/20/nowcoder-newbie-k/">https://blog.jujimeizuo.cn/2020/05/20/nowcoder-newbie-k/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数拆分的两种方法——递归和dp</title>
      <link href="/2020/05/20/integer-splitting/"/>
      <url>/2020/05/20/integer-splitting/</url>
      
        <content type="html"><![CDATA[<p>首先来了解整数拆分的创始人——<a href="https://baike.baidu.com/item/%E6%96%AF%E9%87%8C%E5%B0%BC%E7%93%A6%E7%91%9F%C2%B7%E6%8B%89%E9%A9%AC%E5%8A%AA%E9%87%91/15617950?fromtitle=%E6%8B%89%E9%A9%AC%E5%8A%AA%E9%87%91&fromid=2641844&fr=aladdin">拉马努金</a>。</p><p>这位是我数学上最佩服的几个大神之一，当然最佩服的还是欧拉，欧了～</p><p>如果提前了解了离散数学里的集合划分知识，那下面内容会更加易懂。</p><p>问题描述： 有一个正整数n，可以拆分成最大数为m的的拆分方案，要求所有的方案都不重复。 例如n &#x3D; 4， m &#x3D; 4，拆分方案如下： 4 &#x3D; 4； 4 &#x3D; 1 + 3； 4 &#x3D; 2 + 2； 4 &#x3D; 1 + 2 + 1； 4 &#x3D; 1 + 1 + 1 + 1；</p><p>首先，我们先假设n和m的大小。</p><ol><li>n &#x3D; 1，m&gt;0；则f(n,m) &#x3D; 1，即{1};</li><li>n &gt; 0，m &#x3D; 1；则f(n,m) &#x3D; 1，即{1, 1, 1, 1, …};</li><li>n &lt; m；f(n, m) &#x3D; f(n, n);</li><li>n &#x3D; m； (1)n的划分包含m时，则f(n,m) &#x3D; 1，即{m}; (2)n的划分不包含m时，则f(n,m) &#x3D; f(n, m -1)，即{n1, n2, n3…..}; 即n &#x3D; m时，f(n, m) &#x3D; f(n, m - 1) + 1；</li><li>n &gt; m； (1)n的划分包含m时，则f(n,m) &#x3D; f(n - m, m), 即{m, n1, n2,….}，其中n1 + n2 + …. &#x3D; n - m，其中可能还会出现m； (2)n的划分不包含m时，则f(n, m) &#x3D; f(n, m - 1); 即n &gt; m时，f(n, m) &#x3D; f(n, m - 1) + f(n - m, m)；</li></ol><p>流程图为：</p><p><img src="/images/2020/05/20200521150046435.jpg"></p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">PartitionCount</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>  m == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PartitionCount</span>(n , n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == m)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PartitionCount</span>(n , n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PartitionCount</span>(n - m , m) + <span class="built_in">PartitionCount</span>(n , m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于递归法可能会重复计算，耗时方面会巨大，所以就有下面的动态规划。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">10005</span>][<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Partition_DP</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">1</span>;j &lt;= m + <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>  j == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == j)</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">                dp[i][j] = dp[i][i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - j][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数拆分和排列组合息息相关，排列组合里的隔板法就和这个非常像，但是到该用的时候就不会用了…</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/20/integer-splitting/">https://blog.jujimeizuo.cn/2020/05/20/integer-splitting/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样做指针的主人</title>
      <link href="/2020/05/17/pointer/"/>
      <url>/2020/05/17/pointer/</url>
      
        <content type="html"><![CDATA[<p>应学院要求，写了一篇指针的学习心得,顺便也写成博客发了吧… 以下内容可能比较水，如果有错误，请与我联系，并对此修改。</p><h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><p>=&#x3D;先来说说我的理解，我把整个程序想象成一个豪宅，每个变量是这座豪宅的每个房间，而指针就是这么多房间中其中一个房间的门牌号。接下来是官方的定义&#x3D;&#x3D;。 C语言里，变量存放在内存中，而内存其实就是一组有序字节组成的数组，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：指针是一种保存变量地址的变量。如下图所示：</p><p><img src="/images/2020/05/20200517133054938.png"></p><p>左侧连续的十六进制编号就是内存地址，每个内存地址对应一个字节的内存空间。而指针变量保存的就是这个编号，也即内存地址。</p><h2 id="为什么要学习指针"><a href="#为什么要学习指针" class="headerlink" title="为什么要学习指针"></a>为什么要学习指针</h2><p>在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处： 1）指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效； 2）C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等； 3）C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p><h2 id="如何声明一个指针"><a href="#如何声明一个指针" class="headerlink" title="如何声明一个指针"></a>如何声明一个指针</h2><p>指针的声明比普通变量的声明多了一个一元运算符“*”，而“*”是间接寻址或者间接引用运算符。如下图，p是一个指针，保存着一个地址，该地址指向内存中的一个变量，*p则会访问这个地址所指向的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;        <span class="comment">// 声明一个 int 类型的指针 p</span></span><br><span class="line"><span class="type">char</span> *p        <span class="comment">// 声明一个 char 类型的指针 p</span></span><br><span class="line"><span class="type">int</span> *arr[<span class="number">10</span>]   <span class="comment">// 声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针</span></span><br><span class="line"><span class="built_in">int</span> (*arr)[<span class="number">10</span>] <span class="comment">// 声明一个数组指针，该指针指向一个 int 类型的一维数组</span></span><br><span class="line"><span class="type">int</span> **p;       <span class="comment">// 声明一个指针 p ，该指针指向一个 int 类型的指针</span></span><br></pre></td></tr></table></figure><p>=&#x3D;注意指针数组和数组指针的区别&#x3D;&#x3D;</p><h2 id="初始化指针"><a href="#初始化指针" class="headerlink" title="初始化指针"></a>初始化指针</h2><p>声明一个指针变量并不会自动分配任何内存，在对指针间接访问之前，指针必须要初始化，如下图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法1：使指针指向现有的内存 */</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;　　<span class="comment">// 指针 p 被初始化，指向变量 x ，其中取地址符 &amp; 用于产生操作数内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法2：动态分配内存给指针 */</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);　　　　<span class="comment">// malloc 函数用于动态分配内存</span></span><br><span class="line"><span class="built_in">free</span>(p);　　　　<span class="comment">// free 函数用于释放一块已经分配的内存，常与 malloc 函数一起使用，要使用这两个函数需要头文件 stdlib.h</span></span><br></pre></td></tr></table></figure><p>未初始化指针的后果：如果一个指针没有被初始化，那么程序不知道它会指向哪里，可能指向一个非法地址，这样会报错，“运气好的话”，会指向一个合法地址，或许程序会正常运行，但是这个指针所指向的地址的变量的值会被恶意修改，到时候电脑可能就……</p><h2 id="NULL指针"><a href="#NULL指针" class="headerlink" title="NULL指针"></a>NULL指针</h2><p>NULL 指针是一个特殊的指针变量，本身是宏定义的，其本质上就是0，表示不指向任何内存的空指针。但是NULL在C和C++里的用法又是不一样的，就不多细说了。可参考这篇<a href="https://blog.csdn.net/qq_42957923/article/details/87867773?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">C&#x2F;C++中对NULL的理解与总结</a>。</p><h4 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h4><p>在这里就简略描述一下：指针的运算、指针与数组、指针与结构、指针与函数等…可参考：<a href="https://blog.csdn.net/qq_36243846/article/details/74929207?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">c语言常见的几种指针用法</a>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>指针在计算机里充当着一个很重要的角色，我们要了解它，要弄懂它，我们要做豪宅的主人，不要做豪宅的客人！</p><p>参考： <a href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a> <a href="https://www.cnblogs.com/lulipro/p/7460206.html">https://www.cnblogs.com/lulipro/p/7460206.html</a> <a href="https://www.cnblogs.com/tongye/p/9650573.html">https://www.cnblogs.com/tongye/p/9650573.html</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/17/pointer/">https://blog.jujimeizuo.cn/2020/05/17/pointer/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元的学习总结</title>
      <link href="/2020/05/15/mulinv/"/>
      <url>/2020/05/15/mulinv/</url>
      
        <content type="html"><![CDATA[<p>以下内容均为<a href="https://blog.csdn.net/oampamp1">牌王</a>(可点开链接哦)所教，此人无敌！！！感谢牌王的细心教导，嘿嘿嘿</p><h2 id="逆元的定义"><a href="#逆元的定义" class="headerlink" title="逆元的定义"></a>逆元的定义</h2><p>逆元可以说是倒数概念的推广，对于正整数a,p，若有ax≡1（mod p），则称x是a关于模p的逆元。例如：</p><p><img src="/images/2020/05/2020051521045445.png"></p><p>那么为什么要有逆元呢？逆元有什么作用？ 加减乘与模运算的顺序交换不会影响结果，即可用分配律，但是除法呢？答案是不行的，那么有什么办法可以完成除法与模运算之间的运算呢，这时候就是主角逆元登场了。 例如求解$(a &#x2F; b) mod p$ 先求出b关于p的逆元x，即$b*x≡1 \; (mod\; p)$，将其带入上式得 $(\frac{a}{b} * b * x)≡ 1 (mod p) -&gt; (a * x)≡1(mod\; p)$ 即可将除法转化成乘法，是不是很有趣？ 逆元存在的条件：<strong>a与p互质，即gcd(a,p)&#x3D;1</strong>。</p><h2 id="求解逆元的三种方法"><a href="#求解逆元的三种方法" class="headerlink" title="求解逆元的三种方法"></a>求解逆元的三种方法</h2><ol><li><p>=&#x3D;费马小定理&#x3D;&#x3D; 当p为素数时，则有</p><p><img src="/images/2020/05/20200515210155713.png"></p></li></ol><p>将其变形为</p><p><img src="/images/2020/05/20200515210313703.png"></p><p>由逆元定义可知，$a^{p-2}$就是逆元</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">FPM</span><span class="params">(ll x,ll power,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(power)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(power &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans * x) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>=&#x3D;扩展欧几里得算法&#x3D;&#x3D;</li></ol><p>ax≡1(mod p)-&gt;ax &#x3D; pk + 1 当a，p互质时，gcd(a,b)&#x3D;1，即将上式转化为</p><p><img src="/images/2020/05/2020051521071465.png"></p><p>当求解gcd(a,b)时，递归结束的条件为b&#x3D;0，得出a&#x3D;gcd(a,b)，进一步得出x&#x3D;1,所以对上式使用递归时，结束条件为b &#x3D; 0，并使x&#x3D;1，y&#x3D;0。 即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!b)</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着一直回朔，最后得出x的值，并且还可以求出a和b的最大公约数，是不是一举两得？</p><p>回朔过程的解析： $a*x1+b*y1&#x3D;gcd(a,b)$ $a*x2+b*y2&#x3D;gcd(a,b)$ 将第二个式子变化一下为 $bx2+(a-a&#x2F;b*b)*y2&#x3D;gcd(a,b)-&gt;ay2+b(x2-a&#x2F;b*y2)&#x3D;gcd(a,b)$ 则$x1&#x3D;y2, y1&#x3D;x2-a&#x2F;b*y2$ 那么不断回朔回去，即可得到x。</p><p>得出$x$后，如果为负数，则需要$(x\% mod + mod) \% mod$使其变为正</p><p>当然，可以将其推广则可求出任意二元一次方程的最小解，不过也是有条件的，例如 求ax+by&#x3D;c的解，当且仅当$c是gcd(a，b)$的倍数时，$x$有最小解。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> <span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ret = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    ll t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - a / b * x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> mod)</span>  <span class="comment">//求a在mod下的逆元，如果不存在返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(a, mod, x, y);</span><br><span class="line">    <span class="keyword">return</span> d ? (x % mod + mod) % mod : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>=&#x3D;线性递推&#x3D;&#x3D;</p><p>过程如下： <img src="https://img-blog.csdnimg.cn/20200515212401342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6dHNpbGx5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 这里就不再详细描述了……直接上代码！！！(打字太累了)</p></li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ll inv[<span class="number">3000005</span>] = &#123;<span class="number">0</span> , <span class="number">1</span>&#125;; <span class="comment">//n等于1时，关于mod的逆元就为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, mod;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i++) <span class="comment">// 从二开始，防止改变inv[1]的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = mod - (mod / i) * inv[mod % i] % mod;<span class="comment">// 这一步important // 加个mod是为了防止逆元为负</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,inv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="狙击美佐第一篇博客的感想"><a href="#狙击美佐第一篇博客的感想" class="headerlink" title="狙击美佐第一篇博客的感想"></a>狙击美佐第一篇博客的感想</h2><p>很早就想自己写点东西记录自己的学习过程，可以太懒了，而且语言组织也不好，不过，在数论方面，每次我遇到问题，牌王都会帮我解答，非常感谢牌王！！！那么这次我就将这篇博客写好，“送”给你来表达我对你的爱？</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2020/05/15/mulinv/">https://blog.jujimeizuo.cn/2020/05/15/mulinv/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
