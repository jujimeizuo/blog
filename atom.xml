<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jujimeizuo · Blog</title>
  
  
  <link href="https://blog.jujimeizuo.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.jujimeizuo.cn/"/>
  <updated>2024-05-27T12:00:01.052Z</updated>
  <id>https://blog.jujimeizuo.cn/</id>
  
  <author>
    <name>jujimeizuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Visual SLAM and SfM in Dynamic Environments: A Survey</title>
    <link href="https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/"/>
    <id>https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/</id>
    <published>2024-05-27T01:03:02.000Z</published>
    <updated>2024-05-27T12:00:01.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>本文介绍 <strong>VSLAM</strong> 和 <strong>SfM</strong> 在<strong>动态环境</strong>下目前所有技术相关的综述。</p></blockquote><p>回顾动态环境中的视觉定位和 3D 重建技术：</p><ul><li>涵盖三个主要问题：<ol><li>如何做好鲁棒 VSLAM</li><li>如何在 3D 中分割和跟踪动态物体</li><li>如何实现联合运动分割和重建</li></ol></li><li>从两个角度来看：<ol><li>作为一个鲁棒性问题：相机前的动态物体导致错误的对应关系（遮挡等），可以通过分割图像中静态和动态特征，将动态部分视为异常值来实现鲁棒性，只用静态部分计算姿态估计。</li><li>作为一个标准 VSLAM 在动态环境中的扩展：将跟踪的特征分割成不同的簇，可以重建每个物体结构（形状）并跟踪轨迹，甚至可以将动态物体插入静态地图中。</li></ol></li><li>现有大致三种思路（分别对应三个主要问题）：<ol><li>排除动态特征来构建静态地图</li><li>提取动态物体而忽略静态背景</li><li>试图同时处理世界中静态和动态的组成成分</li></ol></li></ul><h2 id="综述结构"><a href="#综述结构" class="headerlink" title="综述结构"></a>综述结构</h2><ul><li>鲁棒 VSLAM<ol><li>运动分割<ol><li>背景&#x2F;前景初始化</li><li>几何约束</li><li>光流</li><li>自我运动约束</li><li>深度学习</li></ol></li><li>定位与 3D 重建<ol><li>基于特征</li><li>深度学习</li></ol></li></ol></li><li>动态物体分割与 3D 跟踪<ol><li>动态物体分割<ol><li>统计模型选择</li><li>子空间聚类</li><li>几何</li><li>深度学习</li></ol></li><li>动态物体的 3D 跟踪<ol><li>轨迹三角测量</li><li>粒子滤波</li></ol></li></ol></li><li>联合运动分割与重建<ol><li>因子分解<ol><li>多体运动结构（MBSfM）</li><li>非刚性运动结构（NRSfM）</li></ol></li></ol></li></ul><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/VSLAM-SfM-Dynamic-1.jpg"></center><h2 id="鲁棒-VSLAM"><a href="#鲁棒-VSLAM" class="headerlink" title="鲁棒 VSLAM"></a>鲁棒 VSLAM</h2><blockquote><p>如果仅基于静态特征计算姿态估计，就可以在动态环境中实现 Robust VSLAM。</p></blockquote><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/VSLAM-SfM-Dynamic-2.jpg"></center><h3 id="运动分割"><a href="#运动分割" class="headerlink" title="运动分割"></a>运动分割</h3><blockquote><p>将特征分为两个不同的组，即静态特征和动态特征，来检测图像中的动态部分。</p></blockquote><p>标准的 VSLAM 使用 <strong>计算几何模型（基础&#x2F;单应矩阵）</strong>、<strong>RANSAC</strong>、<strong>辛普森距离</strong> 等去除动态特征点。</p><ul><li>如果静态特征占多数，效果会很好。</li><li>如果相机前的动态物体占据较大，效果不好，其他方法可以利用 <strong>IMU</strong> 估计相机的自我运动来解决。</li></ul><h4 id="背景-前景初始化"><a href="#背景-前景初始化" class="headerlink" title="背景&#x2F;前景初始化"></a>背景&#x2F;前景初始化</h4><p>假设系统对环境有<strong>先验知识</strong>，可以利用该信息来分割。这种先验知识可以附加到背景或前景对象上。如果信息是关于前景对象的，则系统知道在相机前移动的对象的类型或形状。</p><h4 id="几何约束"><a href="#几何约束" class="headerlink" title="几何约束"></a>几何约束</h4><p>利用对极几何特性来分割静态和动态特征。动态特征违反静态场景中在多视图几何中定义的约束，可以从<strong>对极方程</strong>、<strong>三角测量</strong>、<strong>基础矩阵</strong>估计或<strong>重投影误差</strong>中推导出。</p><h4 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h4><p>光流定义了从两个连续图像计算得出的亮度模式的表观运动，对应于图像中的运动场，利用图割算法基于该运动度量来分割动态物体。还有 <strong>3D 版本的场景流</strong>。</p><h4 id="自我运动约束"><a href="#自我运动约束" class="headerlink" title="自我运动约束"></a>自我运动约束</h4><p>标准的 SfM 和 VSLAM 通过<strong>八点法</strong>或<strong>五点法</strong>来计算相机运动。另一种方法假设相机根据给定的外部信息（e.g. 车轮里程计信息）按照特定的参数化进行移动。通过这种强制自我运动约束，可以拟合与相机运动约束相匹配的特征点来对静态特征进行分类。</p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>从基于特征的运动分割中，上述可以利用光流来分割动态物体。所以可以<strong>通过监督学习来估计光流</strong>。</p><ol><li><strong>FlowNetS</strong>：通过将两张连续图像堆叠作为 CNN 的输入</li><li><strong>FlowNetC</strong>：通过引入一个相关层来比较由两个相同 CNN 流得到的两个特征图</li><li><strong>FlowNet 2.0</strong>:将  <strong>FlowNetS</strong> 和 <strong>FlowNetC</strong> 堆叠成一个更深的网络，并添加一个新的并行网络来处理小位移</li><li>使用立体图像进行场景流估计的扩展，这种光流可以输入到一个更深的网络中以发现运动特征</li><li>在图像空间中明确分割动态物体，采用重建独立成分分析自编码器来学习时空特征。然而，由于时空特征无法学习运动的 3D 几何形状，因此仍然使用几何特征来帮助分割运动。几何和时空特征都被输入到 RNN 中，以进行最终的运动分割</li><li>通过回归给定的 RGB 图像和光流的目标性的粉来分割动态物体。构建两个类似 AlexNet 的并行 CNN，处理 RGB 图像和光流，然后输入到回归网络并生成运动</li><li><strong>R-FCN</strong>：从在线图像序列中分割前景运动时结合实践数据，<strong>FCN</strong> 用于学习空间特征并生成像素稠密预测，但在应用反卷积之前，使用 <strong>GRU</strong> 来建模时间特征。</li></ol><h3 id="定位与-3D-重建"><a href="#定位与-3D-重建" class="headerlink" title="定位与 3D 重建"></a>定位与 3D 重建</h3><blockquote><p>从多张图像中估计相对相机姿态（平移和旋转）以及所观察环境的 3D 结构。</p></blockquote><ul><li>基于特征</li><li>基于深度学习</li></ul><h4 id="基于特征"><a href="#基于特征" class="headerlink" title="基于特征"></a>基于特征</h4><p>在基于特征的 VSLAM 中，提取显著特征来解决图像对应问题。现有的特征提取技术：</p><ol><li>Harris</li><li>SIFT</li><li>SURF</li><li>FAST</li></ol><p>为找到对应关系，使用特征匹配。根据两个相机的光心之间的距离（基线&#x2F;视差）分开的程度来划分。</p><ul><li>基于短基线：可以用基于光流的技术进行匹配</li><li>对于长基线：需要有高度区分度的特征描述子，例如 <strong>SIFT</strong>、<strong>SURF</strong>、<strong>BRIEF</strong>、<strong>BRISK</strong> 等，通过计算这些描述子之间的不相似性来找到对应关系，当数据包含异常值时，需要使用 <strong>RANSAC</strong>、<strong>PROSAC</strong>、<strong>MLESAC</strong> 等排除异常值。</li></ul><p>当图像对应关系已知，2-3 张图像之间的相对位姿可以恢复到一个比例因子。通过对极约束，</p><ol><li>两个视图用八点法或五点法</li><li>三个视图用三角电张量</li><li>如果已经重建了场景的一些 3D 点，可以用 P3P</li></ol><p>当相机位姿被恢复时，通过<strong>三角测量</strong>对两条投影射线进行相交，得到重建场景的 3D 点，但是由于错误的对应关系射线并不总是相交，可以用<strong>中点法</strong>或<strong>最小二乘法</strong>估计交点。为了避免漂移问题，用 <strong>BA</strong> 通过最小化重投影误差来同时相机位姿和 3D 点。另一种高斯-牛顿方法的变体 <strong>LM</strong> 优化。是联合优化场景结构和相机运动的主流方法。</p><p>实际上，有人采用<strong>局部 BA</strong> 优化最后几张图像，比如 ORB-SLAM 中就用到了。</p><h4 id="用于姿态估计和-3D-重建的深度学习"><a href="#用于姿态估计和-3D-重建的深度学习" class="headerlink" title="用于姿态估计和 3D 重建的深度学习"></a>用于姿态估计和 3D 重建的深度学习</h4><p>两种主流的方法：</p><ol><li>有监督学习</li></ol><p>监督学习通过最小化与真实姿态相比在预测自我运动时的误差来训练 CNN。在早期工作中，姿态估计被视为在相机平移和旋转的离散空间上的<strong>分类问题</strong>。但近期姿态估计技术都采用基于<strong>回归</strong>的 CNN。由于预测的连续性，回归比分类更准确。</p><p>在回归视觉里程计问题中，目标检测和分类的预训练卷机曾不适用，后续转向基于光流的网络以在不同的环境中泛化学习到的参数。</p><ul><li><strong>Flowdometry</strong>：由两个连续的 CNN 组成，第一个用于预测光流，第二个估计相机运动</li><li>计算两个视图之间自我运动的端到端 CNN，堆叠两个具有具有权重共享的并行 CNN，随后是一个空间金字塔池化 SPP 层，以处理任意输入图像，同时在特征图中保持空间信息。回归层由两个全连接层组成，用于预测相机平移和旋转</li><li><strong>DeepVO</strong>：通过 <strong>RCNN</strong>，从图像序列中学习顺序运动动力学的端到端学习框架。在输出里程计方面效果较好。</li></ul><ol start="2"><li>无监督学习</li></ol><p>在无监督的情况下，CNN 没有真实数据进行训练。相反，该网络通过最小化类似于 <strong>LSD-SLAM</strong> 的光度误差来学习预测相机位姿。</p><ul><li>利用新颖视图合成原则（给定一个源图像合成具有不同位姿的目标图像的问题）。构建两个并行的 CNN 用于预测深度和估计相机位姿。来自源图像的预测深度用于在给定相机变换矩阵和源图像的情况下合成目标图像。通过最小化光度误差，共同训练深度和相机位姿。而不是从深度预测生成目标图像。</li><li>基于深度预测、相机运动以及卷积&#x2F;反卷积网络产生的动态对象分割构建了一个 3D 场景流。场景流通过相机运动进行变换，然后反投影到当前帧以评估光度误差。</li></ul><h2 id="动态物体分割与-3D-跟踪"><a href="#动态物体分割与-3D-跟踪" class="headerlink" title="动态物体分割与 3D 跟踪"></a>动态物体分割与 3D 跟踪</h2><blockquote><p>动态对象分割和 3D 跟踪将特征对应关系基于其运动聚类到不同组中，并在 3D 中跟踪它们的轨迹。</p></blockquote><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/VSLAM-SfM-Dynamic-3.jpg"></center>### 动态物体分割<blockquote><p>动态物体分割将所有特征对应关系聚类为 n 个不同对象运动。另一个挑战是处理<strong>退化运动</strong>（当一个物体与相机运动在同一平面上且具有相同的方向和速度时）或<strong>相关运动</strong>（两个人一起移动，关节运动）。</p></blockquote><h4 id="统计模型选择"><a href="#统计模型选择" class="headerlink" title="统计模型选择"></a>统计模型选择</h4><p>用 <strong>RANSAC</strong> 或<strong>蒙特卡罗采样迭代</strong>下对数据的子集进行采样，并将运动模型拟合到采样数据中。改运动模型用于构建内点集，并将剩余数据排除为该模型的异常值。然后，对剩余数据（前一个模型的异常值）在此进行采样，以找到并拟合最能描述剩余数据的另一个模型。</p><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/VSLAM-SfM-Dynamic-4.jpg"></center><h4 id="子空间聚类"><a href="#子空间聚类" class="headerlink" title="子空间聚类"></a>子空间聚类</h4><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/VSLAM-SfM-Dynamic-5.jpg"></center><h4 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h4><h4 id="深度学习-1"><a href="#深度学习-1" class="headerlink" title="深度学习"></a>深度学习</h4><p>当前用于解决动态物体分割问题的 DNN 依赖于预定义数量的刚体运动。用于生成稠密对象掩码的网络及其相关损失函数可能源自 3D 点云数据或光流。</p><ul><li><strong>SE3-Net</strong>：一种能够从 3D 点云中分割出预定义的 n 个动态对象的 DNN，在 SE(3) 变换中表示。</li><li><strong>SfM-Net</strong>：利用光流来分割动态对象。这是一个能够预测深度、相机运动和动态对象分割的具有几何感知能力的网络。</li></ul><h3 id="动态物体的-3D-跟踪"><a href="#动态物体的-3D-跟踪" class="headerlink" title="动态物体的 3D 跟踪"></a>动态物体的 3D 跟踪</h3><h4 id="轨迹三角测量"><a href="#轨迹三角测量" class="headerlink" title="轨迹三角测量"></a>轨迹三角测量</h4><h4 id="粒子滤波"><a href="#粒子滤波" class="headerlink" title="粒子滤波"></a>粒子滤波</h4><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cs.ox.ac.uk/files/9926/Visual%20Slam.pdf">cs.ox.ac.uk&#x2F;files&#x2F;9926&#x2F;Visual Slam.pdf</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/">https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文介绍 &lt;strong&gt;VSLAM&lt;/strong&gt; 和 &lt;strong&gt;SfM&lt;/strong&gt; 在&lt;stro</summary>
      
    
    
    
    
    <category term="3dCV" scheme="https://blog.jujimeizuo.cn/tags/3dCV/"/>
    
  </entry>
  
  <entry>
    <title>volatile 关键字</title>
    <link href="https://blog.jujimeizuo.cn/2024/05/25/volatile/"/>
    <id>https://blog.jujimeizuo.cn/2024/05/25/volatile/</id>
    <published>2024-05-25T11:33:34.000Z</published>
    <updated>2024-05-25T12:34:34.216Z</updated>
    
    <content type="html"><![CDATA[<p><strong>volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化.</strong></p><h2 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> _end;  <span class="comment">// _end是什么?</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p = &amp;_end;</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="number">0xff</span>);</span><br><span class="line">  *p = <span class="number">0x33</span>;</span><br><span class="line">  *p = <span class="number">0x34</span>;</span><br><span class="line">  *p = <span class="number">0x86</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>-O2</code> 编译代码. 尝试去掉代码中的 <code>volatile</code> 关键字, 重新使用 <code>-O2</code> 编译, 并对比去掉 <code>volatile</code> 前后反汇编结果的不同.</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><blockquote><p>如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?</p></blockquote><ol><li><strong>缓存不一致</strong>：现代计算机系统中，为了提高性能，会使用缓存来存储经常访问的数据。如果没有 <code>volatile</code> 关键字，编译器可能会将p所指向的寄存器值缓存到 CPU 的寄存器中，而不是每次都从内存中读取。这可能会导致其他线程或设备对该寄存器的修改无法及时被当前线程察觉，从而引发错误的结果。</li><li><strong>指令重排序</strong>：编译器和处理器为了提高性能，可能会对指令进行重排序。在单线程环境下，指令重排序通常不会影响程序的正确性。然而，在多线程或与设备交互的环境中，指令重排序可能会导致意外的结果。如果去掉 <code>volatile</code>，编译器可能会对与p相关的指令进行重排序，从而破坏了程序的预期行为。</li><li><strong>设备同步问题</strong>：设备寄存器通常与外部设备进行交互，这些设备可能有自己的时序 要求。如果没有 <code>volatile</code> 关键字，编译器可能会对与设备寄存器的访问进行优化，导致无法满足设备的同步要求。这可能会导致设备无法正常工作或产生错误的结果。</li></ol><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol><li>中断服务程序中修改的供其它程序检测的变量需要加 <code>volatile</code>；</li><li>多任务环境下各任务间共享的标志应该加 <code>volatile</code>；</li><li>存储器映射的硬件寄存器通常也要加 <code>volatile</code> 说明，因为每次对它的读写都可能由不同意义；</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/2.5.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">ics2023&#x2F;2.5</a></li><li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">C&#x2F;C++ 中 volatile 关键字详解</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/25/volatile/">https://blog.jujimeizuo.cn/2024/05/25/volatile/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;e-g&quot;&gt;&lt;a href=&quot;#e-g&quot; class=&quot;headerlink&quot; title=&quot;e.g.&quot;&gt;&lt;/a&gt;e.g.&lt;/h2&gt;&lt;f</summary>
      
    
    
    
    
    <category term="C++" scheme="https://blog.jujimeizuo.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>nvidia-smi 无法加载驱动</title>
    <link href="https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/"/>
    <id>https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/</id>
    <published>2024-05-17T06:44:50.000Z</published>
    <updated>2024-05-17T07:08:08.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>以下方法，不需要重装驱动，简单快捷。适用于Ubuntu系统下，之前已经安装过驱动，但驱动失效的问题。</li><li>否则需要重新安装驱动，参考<a href="https://blog.csdn.net/wjinjie/article/details/108512153">Ubuntu下安装nvidia显卡驱动</a>。</li></ul></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当使用 <code>nvidia-smi</code> 命令时，出现以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVIDIA-SMI has failed because it couldn&#x27;t communicate with the NVIDIA driver. </span><br><span class="line">Make sure that the latest NVIDIA driver is installed and running.</span><br></pre></td></tr></table></figure><p>估计问题出现原因是 ubuntu 系统更新了，但是 nvidia 驱动无法连接。</p><h2 id="检查驱动是否存在"><a href="#检查驱动是否存在" class="headerlink" title="检查驱动是否存在"></a>检查驱动是否存在</h2><ul><li>使用 <code>nvcc -V</code> 检查驱动和 cuda。</li></ul><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/ns-1.jpg" width="50%"></center><p>发现驱动是存在的。</p><h2 id="查看已安装驱动的版本信息"><a href="#查看已安装驱动的版本信息" class="headerlink" title="查看已安装驱动的版本信息"></a>查看已安装驱动的版本信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/src | grep nvidia</span><br></pre></td></tr></table></figure><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/ns-2.jpg" width="50%"></center><p>比如我这里的驱动版本为 nvidia-535.129.03。</p><h2 id="dkms"><a href="#dkms" class="headerlink" title="dkms"></a>dkms</h2><ul><li><code>dkms</code> 是一个框架，用于构建和安装内核模块。它允许你在系统中安装多个内核模块版本，并在内核升级时自动重新编译这些模块。</li><li><code>sudo apt-get install dkms</code></li><li><code>dkms install -m nvidia -v 535.129.03</code></li></ul><p>出现以下错误：</p><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/ns-3.jpg" width="50%"></center><p>说明这个版本的文件不存在，需要手动更新。</p><h2 id="更新驱动"><a href="#更新驱动" class="headerlink" title="更新驱动"></a>更新驱动</h2><p>打开软件&amp;更新，根据以下操作选择对应版本（535）。</p><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/ns-4.jpg" width="50%"></center><h2 id="重新-dkms"><a href="#重新-dkms" class="headerlink" title="重新 dkms"></a>重新 dkms</h2><center><img src="https://cdn.jujimeizuo.cn/blog/2024/05/ns-5.jpg" width="50%"></center><p>到这里为止，再次输入 <code>nvidia-smi</code> 就可以查看 GPU 使用状态。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/">https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;以下方法，不需要重装驱动，简单快捷。适用于Ubuntu系统下，之前已经安装过驱动，但驱动失效的问题。&lt;/li&gt;
&lt;li&gt;否则需要重新安装驱动，参考&lt;a href=&quot;https://blog.csdn.net/wjinjie/articl</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.jujimeizuo.cn/tags/Linux/"/>
    
    <category term="CUDA" scheme="https://blog.jujimeizuo.cn/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>曼哈顿距离与切比雪夫距离</title>
    <link href="https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/"/>
    <id>https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/</id>
    <published>2024-04-01T13:33:31.000Z</published>
    <updated>2024-04-02T00:41:14.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的曼哈顿距离为：</p><p>$$<br>d(A, B) &#x3D; |x_1 - x_2| + |y_1 - y_2|<br>$$</p><blockquote><p>性质</p><ol><li>对称性：$d(A,B)&#x3D;d(B,A)$</li><li>三角不等式：$d(A,C) \le d(A,B)+d(B,C)$</li></ol></blockquote><p><strong>距离原点的曼哈顿距离为 1 组成的点：</strong></p><center><img src="https://cdn.jujimeizuo.cn/blog/2024/04/manhattan.png" alt="曼哈顿"></center><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><p>定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的切比雪夫距离为：</p><p>$$<br>d(A, B) &#x3D; \max ( |x_1 - x_2|, |y_1 - y_2| )<br>$$</p><p><strong>距离原点的切比雪夫距离为 1 组成的点：</strong></p><center><img src="https://cdn.jujimeizuo.cn/blog/2024/04/chebyshev.png" alt="切比雪夫"></center><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="曼哈顿转切比雪夫"><a href="#曼哈顿转切比雪夫" class="headerlink" title="曼哈顿转切比雪夫"></a>曼哈顿转切比雪夫</h3><p>将代表曼哈顿距离的正方形绕原点逆时针旋转 $\frac{\pi}{4}$，发现两个正方形是相似的，只需要把代表曼哈顿距离的正方形扩大 $\sqrt{2}$ 倍。</p><p>发现原来在代表曼哈顿距离的正方形的四条边上的点 $A(x,y)$ 的坐标由旋转之后变为了<br>$$(x * \cos{\frac{\pi}{4}}-y * \sin{\frac{\pi}{4}}, y * \cos{\frac{\pi}{4}} + x * \sin{\frac{\pi}{4}})$$<br>然后扩大后变为<br>$$A^\prime(\sqrt{2}(x * \cos{\frac{\pi}{4}}-y * \sin{\frac{\pi}{4}}), \sqrt{2}(y * \cos{\frac{\pi}{4}} + x * \sin{\frac{\pi}{4}})) \to A^\prime (x-y, x+y)$$<br>这里的旋转事实上可以理解为坐标轴的旋转。</p><h3 id="切比雪夫转曼哈顿"><a href="#切比雪夫转曼哈顿" class="headerlink" title="切比雪夫转曼哈顿"></a>切比雪夫转曼哈顿</h3><p>通过图形旋转，原来的点 $A(x,y) \to A^\prime(\frac{x+y}{2}, \frac{x-y}{2})$。（由上述逆变换证明）</p><h3 id="恒等式"><a href="#恒等式" class="headerlink" title="恒等式"></a>恒等式</h3><p>$$<br>|x_1 - x_2| + |y_1 - y_2| &#x3D; \max(|x_1^\prime - x_2^\prime|, |y_1^\prime - y_2^\prime|)<br>$$</p><p>其中等式左侧为 $(x_1,y_1)$ 和 $(x_2, y_2)$ 的<strong>曼哈顿距离</strong>，等式右侧 $(x^\prime - y^\prime)&#x3D;(x+y,y-x)$，计算的是 $(x_1^\prime - y_1^\prime)$ 和 $(x_2^\prime - y_2^\prime)$ 两点的曼哈顿距离投影到 $x^\prime$ 轴和 $y^\prime$  轴的线段长度的最大值，即<strong>切比雪夫距离</strong>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">3102. 最小化曼哈顿距离</a></li><li><a href="https://zhuanlan.zhihu.com/p/32878257">曼哈顿距离与切比雪夫距离的转换 - 知乎</a></li><li><a href="https://tom0727.github.io/post/063-%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/">曼哈顿距离 和 切比雪夫距离 - tom0727’s blog</a></li><li><a href="https://www.luogu.com/article/hxr7p6po">常用距离算法详解 - 洛谷专栏</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/">https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;曼哈顿距离&quot;&gt;&lt;a href=&quot;#曼哈顿距离&quot; class=&quot;headerlink&quot; title=&quot;曼哈顿距离&quot;&gt;&lt;/a&gt;曼哈顿距离&lt;/h2&gt;&lt;p&gt;定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的曼哈顿距离为：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>基于 LangChain 自定义 Embeddings</title>
    <link href="https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/"/>
    <id>https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/</id>
    <published>2024-01-29T00:39:02.000Z</published>
    <updated>2024-04-01T11:19:01.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-LangChain-自定义-Embeddings"><a href="#基于-LangChain-自定义-Embeddings" class="headerlink" title="基于 LangChain 自定义 Embeddings"></a>基于 LangChain 自定义 Embeddings</h2><blockquote><p>在 LangChain 中支持 OpenAI、LLAMA 等大模型 Embeddings 的调用接口，不过没有内置所有大模型，但是允许用户自定义 Embeddings 类型。 接下来以 ZhipuAI 为例，基于 LangChain 自定义 Embeddings。</p></blockquote><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul><li>要实现自定义 Embeddings，需要定义一个自定义类继承自 LangChain 的 Embeddings 基类，然后定义三个函数<ul><li><code>_embed</code>: 接受一个字符串，并返回一个存放 Embeddings 的 List[float]，即模型的核心调用</li><li><code>embed_query</code>: 用于对单个字符串 (query) 进行 embedding</li><li><code>embed_documents</code>: 用于对字符串列表 (documents) 进行 embedding</li></ul></li></ul><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, <span class="type">Dict</span>, <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.base <span class="keyword">import</span> Embeddings</span><br><span class="line"><span class="keyword">from</span> langchain.pydantic_v1 <span class="keyword">import</span> BaseModel, root_validator</span><br><span class="line"><span class="keyword">from</span> langchain.utils <span class="keyword">import</span> get_from_dict_or_env</span><br></pre></td></tr></table></figure><h3 id="自定义-Embedding"><a href="#自定义-Embedding" class="headerlink" title="自定义 Embedding"></a>自定义 Embedding</h3><h3 id="ZhipuAIEmbeddings"><a href="#ZhipuAIEmbeddings" class="headerlink" title="ZhipuAIEmbeddings"></a>ZhipuAIEmbeddings</h3><p>定义一个继承自 Embeddings 类的自定义 Embeddings 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZhipuAIEmbeddings</span>(BaseModel, Embeddings):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;`Zhipuai Embeddings` embedding models.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    zhipuai_api_key: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Zhipuai application apikey&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>root_validator</code> 接收一个函数作为参数，该函数包含需要校验的逻辑。函数应该返回一个字典，其中包含经过校验的数据。如果校验失败，则抛出一个 <code>ValueError</code> 异常。</p><p>装饰器 <code>root_validator</code> 确保导入了相关的包和并配置了相关的 API_Key 这里取巧，在确保导入 zhipuai model 后直接将 <code>zhipuai.model_api</code> 绑定到 client 上，减少和其他 Embeddings 类的差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@root_validator()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate_environment</span>(<span class="params">cls, values: <span class="type">Dict</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    验证环境变量或配置文件中的zhipuai_api_key是否可用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        values (Dict): 包含配置信息的字典，必须包含 zhipuai_api_key 的字段</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        values (Dict): 包含配置信息的字典。如果环境变量或配置文件中未提供 zhipuai_api_key，则将返回原始值；否则将返回包含 zhipuai_api_key 的值。</span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ValueError: zhipuai package not found, please install it with `pip install</span></span><br><span class="line"><span class="string">        zhipuai`</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    values[<span class="string">&quot;zhipuai_api_key&quot;</span>] = get_from_dict_or_env(</span><br><span class="line">        values,</span><br><span class="line">        <span class="string">&quot;zhipuai_api_key&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ZHIPUAI_API_KEY&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> zhipuai</span><br><span class="line">        zhipuai.api_key = values[<span class="string">&quot;zhipuai_api_key&quot;</span>]</span><br><span class="line">        values[<span class="string">&quot;client&quot;</span>] = zhipuai.model_api</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Zhipuai package not found, please install it with &quot;</span></span><br><span class="line">            <span class="string">&quot;`pip install zhipuai`&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h3 id="Override-embed"><a href="#Override-embed" class="headerlink" title="Override _embed"></a>Override _embed</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_embed</span>(<span class="params">self, texts: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本的 embedding。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        texts (str): 要生成 embedding 的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        embeddings (List[float]): 输入文本的 embedding，一个浮点数值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.client.invoke(</span><br><span class="line">            model=<span class="string">&quot;text_embedding&quot;</span>,</span><br><span class="line">            prompt=texts</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Error raised by inference endpoint: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp[<span class="string">&quot;code&quot;</span>] != <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Error raised by inference API HTTP code: %s, %s&quot;</span></span><br><span class="line">            % (resp[<span class="string">&quot;code&quot;</span>], resp[<span class="string">&quot;msg&quot;</span>])</span><br><span class="line">        )</span><br><span class="line">    embeddings = resp[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;embedding&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> embeddings</span><br></pre></td></tr></table></figure><h3 id="Override-embed-documents"><a href="#Override-embed-documents" class="headerlink" title="Override embed_documents"></a>Override embed_documents</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">embed_documents</span>(<span class="params">self, texts: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本列表的 embedding。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        texts (List[str]): 要生成 embedding 的文本列表.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List[List[float]]: 输入列表中每个文档的 embedding 列表。每个 embedding 都表示为一个浮点值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [self._embed(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br></pre></td></tr></table></figure><h3 id="Override-embed-query"><a href="#Override-embed-query" class="headerlink" title="Override embed_query"></a>Override embed_query</h3><p><code>embed_query</code> 是对单个文本计算 embedding 的方法，因为我们已经定义好对文档列表计算 embedding 的方法 <code>embed_documents</code> 了，这里可以直接将单个文本组装成 list 的形式传给 <code>embed_documents</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">embed_query</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本的 embedding。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        text (str): 要生成 embedding 的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        List [float]: 输入文本的 embedding，一个浮点数值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    resp = self.embed_documents([text])</span><br><span class="line">    <span class="keyword">return</span> resp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/">https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于-LangChain-自定义-Embeddings&quot;&gt;&lt;a href=&quot;#基于-LangChain-自定义-Embeddings&quot; class=&quot;headerlink&quot; title=&quot;基于 LangChain 自定义 Embeddings&quot;&gt;&lt;/a&gt;基于 La</summary>
      
    
    
    
    
    <category term="LLM" scheme="https://blog.jujimeizuo.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 5383. 收集饰品</title>
    <link href="https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/"/>
    <id>https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/</id>
    <published>2024-01-06T13:12:49.000Z</published>
    <updated>2024-04-01T11:19:02.092Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.acwing.com/problem/content/5386/">5383. 收集饰品</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>背包dp + 状压dp，非常巧妙的做法</p><p>现按照 k 从小到达排序，将每个饰品看成一个二进制位，每个宝箱可以让几个二进制位为 1，现在问题变成，选择若干宝箱，让每个二进制位变成 1 的最小花费，这是个典型的背包。</p><p>状态转移方程：</p><p>$$ dp[j | mask[i]] &#x3D; std::min(dp[j | mask[i]], dp[j] + x[i]); $$</p><p>复杂度：$O(n2^m)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2024-01-06 20:35:26</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, b;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span>, <span class="title">k</span><span class="params">(n)</span>, <span class="title">mask</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        std::cin &gt;&gt; x[i] &gt;&gt; k[i] &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            std::cin &gt;&gt; id;</span><br><span class="line">            mask[i] = <span class="number">1</span> &lt;&lt; (id - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> k[i] &lt; k[j];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int64_t</span> inf = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">max</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int64_t</span> ans = inf;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int64_t</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; m, inf)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j += <span class="number">1</span>) &#123;</span><br><span class="line">            dp[j | mask[order[i]]] = std::<span class="built_in">min</span>(dp[j | mask[order[i]]], dp[j] + x[order[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] + <span class="built_in">int64_t</span>(<span class="number">1</span>) * k[order[i]] * b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == inf) &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/">https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/5386/&quot;&gt;5383. 收集饰品&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Gosper&#39;s Hack 优化</title>
    <link href="https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/"/>
    <id>https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/</id>
    <published>2024-01-04T03:22:47.000Z</published>
    <updated>2024-04-01T11:19:02.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们在n个数中选择m个数字，通常的做法是回溯法、状态压缩（二进制枚举）等等。这样的复杂度是 $O(2^n)$，而 Gosper’s Hack 可以在O(1)的时间内找到下一个枚举状态。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>从后往前找到第一个降序（即”01”），然后将其变为”10”，</li><li>最后将该”10”后面的序列逆转即可。</li></ol><p>假设当前状态 cur 为 0110(01)1000，那么下一个状态为 0110(10)0001</p><ol><li>cur + lowbit &#x3D; r, 前半部分，0110(10)xxxx</li><li>r ^ cur，记录变化的位数（例如一位就是0001，两位就是0011），移除”01”变为”10”的2次。”10”后面就是变化次数-2。xxxxxx(10)0001</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">next_status</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lowbit = cur &amp; -cur;</span><br><span class="line">    <span class="type">int</span> r = cur + lowbit;</span><br><span class="line">    <span class="keyword">return</span> (((r ^ cur) &gt;&gt; <span class="number">2</span>) / lowbit)  r;</span><br><span class="line">    <span class="comment">// return ((r ^ cur) &gt;&gt; __builtin_ctz(lowbit) + 2)  r;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_status</span>(<span class="params">cur: <span class="built_in">int</span></span>):</span><br><span class="line">    lowbit = cur &amp; -cur</span><br><span class="line">    r = cur + lowbit</span><br><span class="line">    <span class="keyword">return</span> (((r ^ cur) &gt;&gt; <span class="number">2</span>) // lowbit)  r</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    def count_trailing_zeros(x):</span></span><br><span class="line"><span class="string">        return (x &amp; -x).bit_length() - 1</span></span><br><span class="line"><span class="string">    return ((r ^ cur) &gt;&gt; count_trailing_zeros(lowbit) + 2)  r</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://programmingforinsomniacs.blogspot.com/2018/03/gospers-hack-explained.html">ProgrammingForInsomniacs</a></li><li><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/?envType=daily-question&envId=2024-01-04">2397. 被列覆盖的最多行数</a></li><li><a href="https://leetcode.cn/problems/next-permutation/description/">31. 下一个排列</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/">https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当我们在n个数中选择m个数字，通常的做法是回溯法、状态压缩（二进制枚举）等等。这样的复杂度是 $O(2^n)$，而 Gosper’s Hac</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>clash for linux</title>
    <link href="https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/"/>
    <id>https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/</id>
    <published>2023-11-24T01:36:57.000Z</published>
    <updated>2024-04-01T11:44:47.273Z</updated>
    
    <content type="html"><![CDATA[<p>由于作者已经跑路，所以使用下面的备份仓库：</p><center><div class="github-card" data-github="Elegybackup/clash-for-linux-backup" data-width="400" data-height="" data-theme="default"></div><script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></center><h2 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h2><ul><li>运行本项目建议使用root用户，或者使用 sudo 提权。</li><li>使用过程中如遇到问题，请优先查已有的 <a href="https://github.com/Elegybackup/clash-for-linux-backup/issues">issues</a>。</li><li>在进行issues提交前，请替换提交内容中是敏感信息（例如：订阅地址）。</li><li>本项目是基于 <a href="https://github.com/Dreamacro/clash">clash（已跑路）</a> 、<a href="https://github.com/haishanh/yacd">yacd</a> 进行的配置整合，关于clash、yacd的详细配置请去原项目查看。</li><li>此项目不提供任何订阅信息，请自行准备Clash订阅地址。</li><li>运行前请手动更改<code>.env</code>文件中的<code>CLASH_URL</code>变量值，否则无法正常运行。</li><li>当前在RHEL系列和Debian,Kali Linux,ubuntu以及Linux系统中测试过，其他系列可能需要适当修改脚本。</li><li>支持 x86_64&#x2F;aarch64 平台</li><li>【注意：kali Linux需要在浏览器设置代理！否则有可能无法使用！】</li></ul><blockquote><p><strong>注意</strong>：当你在使用此项目时，遇到任何无法独自解决的问题请优先前往 <a href="https://github.com/wanhebin/clash-for-linux/issues">Issues</a> 寻找解决方法。由于空闲时间有限，后续将不再对Issues中 “已经解答”、“已有解决方案” 的问题进行重复性的回答。</p></blockquote><br><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><p>下载项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Elegybackup/clash-for-linux-backup.git</span><br></pre></td></tr></table></figure><p>进入到项目目录，编辑<code>.env</code>文件，修改变量<code>CLASH_URL</code>的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br><span class="line">$ vim .<span class="built_in">env</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> <code>.env</code> 文件中的变量 <code>CLASH_SECRET</code> 为自定义 Clash Secret，值为空时，脚本将自动生成随机字符串。</p></blockquote><br><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><p>直接运行脚本文件<code>start.sh</code></p><ul><li>进入项目目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure><ul><li>运行启动脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash start.sh</span><br><span class="line"></span><br><span class="line">正在检测订阅地址...</span><br><span class="line">Clash订阅地址可访问！                                      [  OK  ]</span><br><span class="line"></span><br><span class="line">正在下载Clash配置文件...</span><br><span class="line">配置文件config.yaml下载成功！                              [  OK  ]</span><br><span class="line"></span><br><span class="line">正在启动Clash服务...</span><br><span class="line">服务启动成功！                                             [  OK  ]</span><br><span class="line"></span><br><span class="line">Clash Dashboard 访问地址：http://&lt;ip&gt;:9090/ui</span><br><span class="line">Secret：xxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">请执行以下命令加载环境变量: <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line"></span><br><span class="line">请执行以下命令开启系统代理: proxy_on</span><br><span class="line"></span><br><span class="line">若要临时关闭系统代理，请执行: proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line">$ proxy_on</span><br></pre></td></tr></table></figure><ul><li>检查服务端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -tln | grep -E <span class="string">&#x27;9090|789.&#x27;</span></span><br><span class="line">tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 :::7890                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7891                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7892                 :::*                    LISTEN</span><br></pre></td></tr></table></figure><ul><li>检查环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">env</span> | grep -E <span class="string">&#x27;http_proxy|https_proxy&#x27;</span></span><br><span class="line">http_proxy=http://127.0.0.1:7890</span><br><span class="line">https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>以上步鄹如果正常，说明服务clash程序启动成功，现在就可以体验高速下载github资源了。</p><br><h2 id="重启程序"><a href="#重启程序" class="headerlink" title="重启程序"></a>重启程序</h2><p>如果需要对Clash配置进行修改，请修改 <code>conf/config.yaml</code> 文件。然后运行 <code>restart.sh</code> 脚本进行重启。</p><blockquote><p><strong>注意：</strong><br>重启脚本 <code>restart.sh</code> 不会更新订阅信息。</p></blockquote><br><h3 id="停止程序"><a href="#停止程序" class="headerlink" title="停止程序"></a>停止程序</h3><ul><li>进入项目目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure><ul><li>关闭服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash shutdown.sh</span><br><span class="line"></span><br><span class="line">服务关闭成功，请执行以下命令关闭系统代理：proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ proxy_off</span><br></pre></td></tr></table></figure><p>然后检查程序端口、进程以及环境变量<code>http_proxy|https_proxy</code>，若都没则说明服务正常关闭。</p><br><h3 id="Clash-Dashboard"><a href="#Clash-Dashboard" class="headerlink" title="Clash Dashboard"></a>Clash Dashboard</h3><ul><li>访问 Clash Dashboard</li></ul><p>通过浏览器访问 <code>start.sh</code> 执行成功后输出的地址，例如：<a href="http://192.168.0.1:9090/ui">http://192.168.0.1:9090/ui</a></p><ul><li>登录管理界面</li></ul><p>在<code>API Base URL</code>一栏中输入：http:&#x2F;&#x2F;&lt;ip&gt;:9090 ，在<code>Secret(optional)</code>一栏中输入启动成功后输出的Secret。</p><p>点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置。</p><ul><li>更多教程</li></ul><p>此 Clash Dashboard 使用的是<a href="https://github.com/haishanh/yacd">yacd</a>项目，详细使用方法请移步到yacd上查询。</p><br><h3 id="终端界面选择代理节点"><a href="#终端界面选择代理节点" class="headerlink" title="终端界面选择代理节点"></a>终端界面选择代理节点</h3><p>部分用户无法通过浏览器使用 Clash Dashboard 进行节点选择、代理模式修改等操作，为了方便用户可以在Linux终端进行操作，下面提供了一个功能简单的脚本以便用户可以临时通过终端界面进行配置。</p><p>脚本存放位置：<code>scripts/clash_proxy-selector.sh</code></p><blockquote><p><strong>注意：</strong></p><p>使用脚本前，需要修改脚本中的 <strong>Secret</strong> 变量值为上述启动脚本输出的值，或者与 <code>.env</code> 文件中定义的 <strong>CLASH_SECRET</strong> 变量值保持一致。</p></blockquote><br><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/">https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于作者已经跑路，所以使用下面的备份仓库：&lt;/p&gt;
&lt;center&gt;
&lt;div class=&quot;github-card&quot; data-github=&quot;Elegybackup/clash-for-linux-backup&quot; data-width=&quot;400&quot; data-height</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>利用 iOS 的快捷指令配合 GitHub Actions 实现自动化</title>
    <link href="https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/"/>
    <id>https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/</id>
    <published>2023-10-06T15:25:27.000Z</published>
    <updated>2024-04-01T11:19:01.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要通过快捷指令实现自动化"><a href="#为什么需要通过快捷指令实现自动化" class="headerlink" title="为什么需要通过快捷指令实现自动化"></a>为什么需要通过快捷指令实现自动化</h2><ul><li>最初的 Github Actions 需要 crontab 来定时进行自动化，这样做不仅消耗过多资源，而且在完成某个任务时不会立即获取新生成的数据。</li><li>如果我可以完成某个特定动作，例如关闭闹钟、充电、关闭 APP 时自动进行 Actions时，这样做非常高效，方法是可以利用快捷指令触发 Actions 同步数据</li><li>下面拿跑步举例，一般会用 app（我用的是 keep）来记录跑步数据，实现的操作是当关闭 keep 时会自动进行 Actions，更新数据</li></ul><h2 id="如何触发-Actions"><a href="#如何触发-Actions" class="headerlink" title="如何触发 Actions"></a>如何触发 Actions</h2><ul><li><p>首先在 yml 文件中增加 <code>workflow_dispatch</code>: 可以手动触发</p><p><img src="https://cdn.jujimeizuo.cn/blog/2023/10/workflow_dispatch.jpg" alt="srcworkflow_dispatch"></p></li><li><p>先拿到这个项目的 actions id (需要自行申请 token)</p><ul><li><p>在个人的 settings 中申请 项目的token，然后在项目里的 Secrets and variables 里的 Actions 设置密钥，内容为刚刚申请的 token</p></li><li><p>执行下面代码获取 actionid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.github.com/repos/jujimeizuo/running_page/actions/workflows -H &quot;Authorization: token d8xxxxxxxxxx&quot; ## change to your config</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2023/10/get-action-id.jpg" alt="get-action-id"></p></li><li><p>拿到 action id 就可以利用 api post 触发 action 啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;inputs&quot;: &#123;&#125;, &quot;ref&quot;:&quot;master&quot;&#125;&#x27; https://api.github.com/repos/jujimeizu/running_page/actions/workflows/: $&#123;actionid&#125;/dispatches -H &quot;Authorization: token d8e03d6xxxxxxxxxxxx&quot;  ## change to your config</span><br></pre></td></tr></table></figure></li></ul><h2 id="结合快捷指令"><a href="#结合快捷指令" class="headerlink" title="结合快捷指令"></a>结合快捷指令</h2><h3 id="快捷指令"><a href="#快捷指令" class="headerlink" title="快捷指令"></a>快捷指令</h3><ul><li>通过 icloud 获取 <a href="https://www.icloud.com/shortcuts/4a5807a98b9a4e359815ff179c62bacb">running-page-template</a></li><li>修改下面图片中字典的值即可</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2023/10/running-page-template.jpg" alt="running-page-template"></p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><img src="https://cdn.jujimeizuo.cn/blog/2023/10/new-automation.png" alt="new-automation"> <img src="https://cdn.jujimeizuo.cn/blog/2023/10/select-close.png" alt="select-close"></p><p><img src="https://cdn.jujimeizuo.cn/blog/2023/10/select-shortcut.png" alt="select-shortcut"> <img src="https://cdn.jujimeizuo.cn/blog/2023/10/finish-automation.png" alt="finish-automation"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>可以通过关闭闹钟来同步自己的起床记录——这也是 yihong 大神写的</li><li>可以利用一个 action 触发另一个项目的 action，实现另一个 repo 的更新</li><li>…</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/yihong0618/gitblog/issues/198">yihong0618 大神</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/">https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么需要通过快捷指令实现自动化&quot;&gt;&lt;a href=&quot;#为什么需要通过快捷指令实现自动化&quot; class=&quot;headerlink&quot; title=&quot;为什么需要通过快捷指令实现自动化&quot;&gt;&lt;/a&gt;为什么需要通过快捷指令实现自动化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最初的 Gith</summary>
      
    
    
    
    
    <category term="utils" scheme="https://blog.jujimeizuo.cn/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>Macos通过SSH连接显示docker容器的GUI界面（ROS1小乌龟为例）</title>
    <link href="https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/"/>
    <id>https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/</id>
    <published>2023-07-28T14:06:08.000Z</published>
    <updated>2024-04-01T11:17:17.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-软硬件设置"><a href="#1-软硬件设置" class="headerlink" title="1 软硬件设置"></a>1 软硬件设置</h2><ul><li>Macbook M1 pro</li><li>docker - ubuntu18.04</li></ul><h2 id="2-配置远程服务器（ubuntu18-04）"><a href="#2-配置远程服务器（ubuntu18-04）" class="headerlink" title="2 配置远程服务器（ubuntu18.04）"></a>2 配置远程服务器（ubuntu18.04）</h2><h3 id="2-1-安装工具包"><a href="#2-1-安装工具包" class="headerlink" title="2.1 安装工具包"></a>2.1 安装工具包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器名称 /bin/sh</span><br><span class="line">apt update</span><br><span class="line">apt install openssh-server</span><br><span class="line">apt install x11-apps</span><br><span class="line">apt install vim</span><br><span class="line">passwd   <span class="comment"># 给root账号赋予密码</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置SSH服务端"><a href="#2-2-配置SSH服务端" class="headerlink" title="2.2 配置SSH服务端"></a>2.2 配置SSH服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">## 修改以下内容，端口可以自己设置，默认是22，和启动容器的映射端口对应</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line">X11Forwarding <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h3 id="2-3-重启服务"><a href="#2-3-重启服务" class="headerlink" title="2.3 重启服务"></a>2.3 重启服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><h3 id="2-4-连接docker测试"><a href="#2-4-连接docker测试" class="headerlink" title="2.4 连接docker测试"></a>2.4 连接docker测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p docker端口 root@远程IP</span><br></pre></td></tr></table></figure><h2 id="3-本地Macos配置"><a href="#3-本地Macos配置" class="headerlink" title="3 本地Macos配置"></a>3 本地Macos配置</h2><h3 id="3-1-安装Xquartz"><a href="#3-1-安装Xquartz" class="headerlink" title="3.1 安装Xquartz"></a>3.1 安装Xquartz</h3><p><a href="https://www.xquartz.org/">Xquartz官网</a></p><h3 id="3-2-Xquartz设置"><a href="#3-2-Xquartz设置" class="headerlink" title="3.2 Xquartz设置"></a>3.2 Xquartz设置</h3><ol><li>XQuartz -&gt; 偏好设置 -&gt; 安全性 -&gt; 勾选“允许从网络客户端连接” -&gt; 退出程序；</li><li>终端键入 xhost + ip（注意两者之间的空格）重新启动 XQuartz；为远程主机添加权限 或者xhost +为所有IP添加权限</li><li>ssh -XY <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#x40;&#48;&#46;&#48;&#46;&#x30;&#46;&#48;">&#x72;&#x6f;&#x6f;&#116;&#x40;&#48;&#46;&#48;&#46;&#x30;&#46;&#48;</a> -p 6100</li><li>netstat -an grep -F 6100 查看</li></ol><p>xquartz操作后需要重启。</p><h3 id="3-3-docker进入"><a href="#3-3-docker进入" class="headerlink" title="3.3 docker进入"></a>3.3 docker进入</h3><p>在 run 或 exec 容器时加入-e DISPLAY&#x3D;host.docker.internal:0参数，比如我这里通过对一个现有的，已经安装过 xarclock 时钟小程序的容器 toyOS 执行docker exec -ite DISPLAY&#x3D;host.docker.internal:0 toyOS &#x2F;usr&#x2F;bin&#x2F;xarclock，就会在我的本地出现一个小时钟的GUI程序；</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ite DISPLAY=host.docker.internal:0 ub18.04-orb-slam2 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="3-4-测试ros小乌龟"><a href="#3-4-测试ros小乌龟" class="headerlink" title="3.4 测试ros小乌龟"></a>3.4 测试ros小乌龟</h3><p>tmux设置三个终端</p><p>如下图所示：</p><p><img src="https://cdn.jujimeizuo.cn/blog/2023/07/image-1690552905696.png" alt="file"></p><p>也可以在docker内部执行，设置环境变量指定显示端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=host.docker.internal:0  </span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/">https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-软硬件设置&quot;&gt;&lt;a href=&quot;#1-软硬件设置&quot; class=&quot;headerlink&quot; title=&quot;1 软硬件设置&quot;&gt;&lt;/a&gt;1 软硬件设置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Macbook M1 pro&lt;/li&gt;
&lt;li&gt;docker - ubuntu18.04</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
    <category term="Docker" scheme="https://blog.jujimeizuo.cn/tags/Docker/"/>
    
    <category term="ros" scheme="https://blog.jujimeizuo.cn/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>Titanic数据集预测</title>
    <link href="https://blog.jujimeizuo.cn/2023/07/13/dl-titanic/"/>
    <id>https://blog.jujimeizuo.cn/2023/07/13/dl-titanic/</id>
    <published>2023-07-13T09:38:34.000Z</published>
    <updated>2024-04-01T11:20:21.712Z</updated>
    
    <content type="html"><![CDATA[<p>学习自@<a href="https://blog.csdn.net/csdn_xmj/article/details/122172552">双木的木</a>。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在kaggle官网上有<a href="https://www.kaggle.com/c/titanic/data">Titanic</a>有关的数据集，有以下features，现要求对Suvrived特征进行预测。</p><p><img src="https://cdn.jujimeizuo.cn/blog/2023/07/image-1689229188640.png" alt="file"></p><h2 id="数据集分析"><a href="#数据集分析" class="headerlink" title="数据集分析"></a>数据集分析</h2><p>数据集被划分为训练集和测试集：</p><ul><li>training set (train.csv)</li><li>test set (test.csv)</li></ul><p>训练集应该被用来建立你的深度学习模型。对于训练集，我们为每个乘客提供结果(也称为“ground truth”)。你的模型将基于乘客的性别和阶级等“特征”。您还可以使用特征工程来创建新的特征。</p><p>测试集应该用来查看您的模型在不可见数据上的性能。对于测试集，我们不为每个乘客提供基本真相。你的工作就是预测这些结果。对于测试中的每一位乘客，使用你训练的模型来预测他们是否在泰坦尼克号沉没时幸存下来。</p><p>还包括gender_submit .csv，这是一组假设所有且只有女性乘客能够存活的预测，作为提交文件的示例。</p><p><img src="https://cdn.jujimeizuo.cn/blog/2023/07/image-1689229530750.png" alt="file"></p><p>选取[“Pclass”, “Sex”, “SibSp”, “Parch”, “Fare”]五个特征进行训练。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><h4 id="TitanicDataset"><a href="#TitanicDataset" class="headerlink" title="TitanicDataset"></a>TitanicDataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TitanicDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filepath</span>):</span><br><span class="line">        features = [<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;Fare&quot;</span>]</span><br><span class="line">        xy = pd.read_csv(filepath)</span><br><span class="line">        self.<span class="built_in">len</span> = xy.shape[<span class="number">0</span>] <span class="comment">## [0]代表行数，[1]代表列数</span></span><br><span class="line">        <span class="comment">## dummies相当于one-hot编码</span></span><br><span class="line">        self.x_data = torch.from_numpy(np.array(pd.get_dummies(xy[features], dtype=np.float32))).<span class="built_in">float</span>()</span><br><span class="line">        <span class="comment">## np.array(data[&#x27;survived&#x27;])是对data[&#x27;survived&#x27;]创建一个矩阵</span></span><br><span class="line">        <span class="comment">## torch.from_numpy()是将括号内的矩阵形式转换为张量形式，方便torch处理</span></span><br><span class="line">        self.y_data = torch.from_numpy(np.array(xy[<span class="string">&#x27;Survived&#x27;</span>], dtype=np.float32)).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x_data[index], self.y_data[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">titanic_train = TitanicDataset(<span class="string">r&#x27;./titanic/train.csv&#x27;</span>)</span><br><span class="line">train_loader = DataLoader(dataset=titanic_train, batch_size=<span class="number">16</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="构造模型"><a href="#构造模型" class="headerlink" title="构造模型"></a>构造模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">## 对继承于torch.nn的父模块类进行初始化</span></span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        <span class="comment">## 这里包括2个线性层，每一个线性层输出都用激活函数激活</span></span><br><span class="line">        self.linear1 = torch.nn.Linear(<span class="number">6</span>, <span class="number">3</span>) <span class="comment">## 五个特征转化为了6维，因为get_dummies将性别这一个特征用两个维度来表示，即男性[1,0],女性[0，1]</span></span><br><span class="line">        self.linear2 = torch.nn.Linear(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">## 激活函数从Sigmoid这一大类激活函数中选取sigmoid这一种激活函数</span></span><br><span class="line">        self.sigmoid = torch.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.sigmoid(self.linear1(x))</span><br><span class="line">        x = self.sigmoid(self.linear2(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self</span>):</span><br><span class="line">        val_correct, total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">                inputs, label = data</span><br><span class="line">                predicted = model.predict(inputs)</span><br><span class="line">                total += label.size(<span class="number">0</span>)</span><br><span class="line">                val_correct += (predicted == np.array(label)).<span class="built_in">sum</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Accuracy: %d&#x27;</span> %(val_correct / total * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment">## 该函数用在测试集过程，因此只有前馈，没有什么</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            x = self.sigmoid(self.linear1(x))</span><br><span class="line">            x = self.sigmoid(self.linear2(x))</span><br><span class="line">            y = []</span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> result &gt; <span class="number">0.5</span>:</span><br><span class="line">                    y.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = Model()</span><br></pre></td></tr></table></figure><h3 id="损失函数和优化器"><a href="#损失函数和优化器" class="headerlink" title="损失函数和优化器"></a>损失函数和优化器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.BCELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">            inputs, label = data</span><br><span class="line">            y_pred = model(inputs)</span><br><span class="line">            y_pred = y_pred.squeeze(-<span class="number">1</span>) <span class="comment">## 将维度降至1维并输出出来</span></span><br><span class="line">            loss = criterion(y_pred, label) <span class="comment">## 将预测的值与标签进行比较，并求解出误差值</span></span><br><span class="line">            <span class="built_in">print</span>(epoch, i, loss.item())</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad() <span class="comment">## 之前的梯度进行清零，否则梯度会累加起来</span></span><br><span class="line">            loss.backward() <span class="comment">## 反向传播</span></span><br><span class="line">            optimizer.step() <span class="comment">## 更新</span></span><br></pre></td></tr></table></figure><h3 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self</span>):</span><br><span class="line">        val_correct, total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, <span class="number">0</span>):</span><br><span class="line">                inputs, label = data</span><br><span class="line">                predicted = model(inputs)</span><br><span class="line">                total += label.size(<span class="number">0</span>)</span><br><span class="line">                val_correct += (predicted == label).<span class="built_in">sum</span>().item()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Accuracy: %d %%&#x27;</span> %(val_correct / total * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">model.verify()</span><br></pre></td></tr></table></figure><h3 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment">## 该函数用在测试集过程，因此只有前馈，没有什么</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            x = self.sigmoid(self.linear1(x))</span><br><span class="line">            x = self.sigmoid(self.linear2(x))</span><br><span class="line">            y = []</span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> result &gt; <span class="number">0.5</span>:</span><br><span class="line">                    y.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(<span class="string">r&#x27;./titanic/test.csv&#x27;</span>)</span><br><span class="line">features = [<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;Fare&quot;</span>]</span><br><span class="line">test = torch.from_numpy(np.array(pd.get_dummies(test_data[features]), dtype=np.float32))</span><br><span class="line"></span><br><span class="line">result = model.predict(test)</span><br><span class="line"></span><br><span class="line">submission = pd.read_csv(<span class="string">r&#x27;./titanic/gender_submission.csv&#x27;</span>)</span><br><span class="line">submission[<span class="string">&#x27;Survived&#x27;</span>] = result</span><br><span class="line">submission.to_csv(<span class="string">r&#x27;./titanic/gender_submission_result_1.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/07/13/dl-titanic/">https://blog.jujimeizuo.cn/2023/07/13/dl-titanic/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习自@&lt;a href=&quot;https://blog.csdn.net/csdn_xmj/article/details/122172552&quot;&gt;双木的木&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="deep-learning" scheme="https://blog.jujimeizuo.cn/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>利用时钟周期评测性能</title>
    <link href="https://blog.jujimeizuo.cn/2023/04/23/rdtsc/"/>
    <id>https://blog.jujimeizuo.cn/2023/04/23/rdtsc/</id>
    <published>2023-04-23T06:53:08.000Z</published>
    <updated>2024-04-01T11:19:02.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rdtsc指令"><a href="#rdtsc指令" class="headerlink" title="rdtsc指令"></a>rdtsc指令</h2><p>rdtsc指令, 该指令返回CPU自启动以来的时钟周期数；该时钟周期数，即处理器的时间戳。</p><p>在CPU通电启动后，首先会重置EDX和EAX，在每个时钟周期上升或下降沿到来时，会自动累计周期数，并被记录到EDX和EAX寄存器中，EDX是高位，EAX是低位。</p><p>rdtsc指令就是从该寄存器中进行获取的。</p><p>周期和频率的关系公式：T（周期）&#x3D;1&#x2F;f（频率）</p><p>如CPU频率f为1GHz，则其时钟周期T&#x3D;1&#x2F;1GHz秒，意味着每隔T秒，CPU完成一个最基本的动作，并在寄存器中，对周期数加1。</p><p>故，假设当前时钟周期数为m，则可计算出CPU自启动后，累计运行时间X&#x3D;m*T.</p><p>$$CPU累计运行时间&#x3D;时钟周期数&#x2F;CPU频率$$</p><h2 id="固定CPU频率"><a href="#固定CPU频率" class="headerlink" title="固定CPU频率"></a>固定CPU频率</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cpufrequtils</span><br><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors</span><br><span class="line">sudo cpufreq-set -g performance</span><br><span class="line"></span><br><span class="line"><span class="comment">## 不能一次性设置，需要手动一个一个设置</span></span><br><span class="line">cpufreq-set -c 0 -f 2.4G</span><br><span class="line">cpufreq-set -c 1 -f 2.4G</span><br><span class="line">cpufreq-set -c 2 -f 2.4G</span><br><span class="line">cpufreq-set -c 3 -f 2.4G</span><br><span class="line">cpufreq-set -c 4 -f 2.4G</span><br><span class="line">cpufreq-set -c 5 -f 2.4G</span><br><span class="line">cpufreq-set -c 6 -f 2.4G</span><br><span class="line">cpufreq-set -c 7 -f 2.4G</span><br><span class="line">cpufreq-set -c 8 -f 2.4G</span><br><span class="line">cpufreq-set -c 9 -f 2.4G</span><br><span class="line">cpufreq-set -c 10 -f 2.4G</span><br><span class="line">cpufreq-set -c 11 -f 2.4G</span><br><span class="line">cpufreq-set -c 12 -f 2.4G</span><br><span class="line">cpufreq-set -c 13 -f 2.4G</span><br><span class="line">cpufreq-set -c 14 -f 2.4G</span><br><span class="line">cpufreq-set -c 15 -f 2.4G</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo  grep MHz</span><br></pre></td></tr></table></figure><h2 id="绑定CPU核"><a href="#绑定CPU核" class="headerlink" title="绑定CPU核"></a>绑定CPU核</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">bind_to_core</span><span class="params">(<span class="type">int</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return;</span></span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(tid, &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(mask), &amp;mask) != <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to set affinity (core: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定第15个CPU核。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind_to_core</span>(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><h2 id="获取时钟周期"><a href="#获取时钟周期" class="headerlink" title="获取时钟周期"></a>获取时钟周期</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">rdtsc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lo, hi;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span> (lo), <span class="string">&quot;=d&quot;</span> (hi));</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)hi &lt;&lt; <span class="number">32</span>)  lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/04/23/rdtsc/">https://blog.jujimeizuo.cn/2023/04/23/rdtsc/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rdtsc指令&quot;&gt;&lt;a href=&quot;#rdtsc指令&quot; class=&quot;headerlink&quot; title=&quot;rdtsc指令&quot;&gt;&lt;/a&gt;rdtsc指令&lt;/h2&gt;&lt;p&gt;rdtsc指令, 该指令返回CPU自启动以来的时钟周期数；该时钟周期数，即处理器的时间戳。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="hpc" scheme="https://blog.jujimeizuo.cn/tags/hpc/"/>
    
  </entry>
  
  <entry>
    <title>基础算法算子库 - KD-Tree</title>
    <link href="https://blog.jujimeizuo.cn/2023/04/03/kdtree/"/>
    <id>https://blog.jujimeizuo.cn/2023/04/03/kdtree/</id>
    <published>2023-04-03T07:42:30.000Z</published>
    <updated>2024-04-01T11:19:02.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libnabo"><a href="#libnabo" class="headerlink" title="libnabo"></a>libnabo</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>libnabo 是一个用于低维空间的快速 K 最近邻库。得益于 C++ 模板，它提供了一个干净、无遗留问题、与标量类型无关的 API。它当前的 CPU 实现受到ANN的强烈启发，但具有更紧凑的数据类型。平均而言，libnabo 比ANN快 5% 到 20% 。</p><p>libnabo 依赖于Eigen，一个现代 C++ 矩阵和线性代数库。libnabo 适用于 Eigen 的版本 2 或 3。libnabo 还可以选择依赖Boost，这是一个用于 Python 绑定的 C++ 通用库。</p><h3 id="installion"><a href="#installion" class="headerlink" title="installion"></a>installion</h3><h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:ethz-asl/libnabo.git</span><br></pre></td></tr></table></figure><h4 id="prerequisites"><a href="#prerequisites" class="headerlink" title="prerequisites"></a>prerequisites</h4><ul><li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" title="Eigen">Eigen</a></li><li><a href="https://www.boost.org/users/download/">Boost</a> （Option)</li></ul><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIR=<span class="built_in">pwd</span></span><br><span class="line">BUILD_DIR=<span class="variable">$&#123;SRC_DIR&#125;</span>/build</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;BUILD_DIR&#125;</span> &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;BUILD_DIR&#125;</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo <span class="variable">$&#123;SRC_DIR&#125;</span></span><br><span class="line"><span class="comment"># if Eigen or Boost are not available system-wide, run at that point:</span></span><br><span class="line"><span class="comment">#   cmake-gui .</span></span><br><span class="line"><span class="comment"># cmake-gui allows you to tell the location of Eigen or Boost</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------</span></span><br><span class="line"><span class="comment"># DEPENDENCY: nabo</span></span><br><span class="line"><span class="comment">#--------------------</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">TARGET</span> nabo)</span><br><span class="line">  <span class="comment"># Find libnabo:</span></span><br><span class="line">  <span class="keyword">find_package</span>(libnabo REQUIRED PATHS <span class="variable">$&#123;LIBNABO_INSTALL_DIR&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;libnabo found, version $&#123;libnabo_VERSION&#125; (include=$&#123;libnabo_INCLUDE_DIRS&#125; libs=$&#123;libnabo_LIBRARIES&#125;)&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="comment"># libnabo already part of this project (e.g. as a git submodule)</span></span><br><span class="line">  <span class="comment"># (This, plus the use of cmake target properties in libnabo, will also</span></span><br><span class="line">  <span class="comment"># introduce the required include directories, flags, etc.)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="comment"># This cmake target alias will be defined by either: </span></span><br><span class="line"><span class="comment"># a) libnabo sources if built as a git submodule in the same project than this library, or</span></span><br><span class="line"><span class="comment"># b) by libnabo-targets.cmake, included by find_package(libnabo) above.</span></span><br><span class="line"><span class="keyword">set</span>(libnabo_LIBRARIES libnabo::nabo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target_link_libraries THIRD_PARTY_LIBS is ok</span></span><br><span class="line"><span class="keyword">set</span>(THIRD_PARTY_LIBS</span><br><span class="line">        <span class="variable">$&#123;libnabo_LIBRARIES&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># ####### dependencies ########</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;EIGEN3_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;NABO_INCLUDE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="flann"><a href="#flann" class="headerlink" title="flann"></a>flann</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>FLANN（近似近邻快速库）是一个用于执行快速近似近邻搜索的库。FLANN是用C++编写的，该库提供的C、MATLAB和Python接口。</p><h3 id="Installion"><a href="#Installion" class="headerlink" title="Installion"></a>Installion</h3><h4 id="download-1"><a href="#download-1" class="headerlink" title="download"></a>download</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/flann-lib/flann.git </span><br></pre></td></tr></table></figure><h4 id="install-1"><a href="#install-1" class="headerlink" title="install"></a>install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> flann</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_PYTHON_BINDINGS=OFF -DBUILD_MATLAB_BINDINGS=OFF -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF -DBUILD_D</span><br><span class="line">OC=OFF ..</span><br><span class="line">make -j5</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(flann REQUIRED)</span><br><span class="line"><span class="keyword">set</span>(THIRD_PARTY_LIBS</span><br><span class="line">        <span class="variable">$&#123;libflann_LIBRARIES&#125;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/04/03/kdtree/">https://blog.jujimeizuo.cn/2023/04/03/kdtree/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;libnabo&quot;&gt;&lt;a href=&quot;#libnabo&quot; class=&quot;headerlink&quot; title=&quot;libnabo&quot;&gt;&lt;/a&gt;libnabo&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    
    <category term="基础算法算子库" scheme="https://blog.jujimeizuo.cn/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AE%97%E5%AD%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>解决__FILE__ 宏绝对路径的问题(相对路径)</title>
    <link href="https://blog.jujimeizuo.cn/2023/02/27/cmake-file/"/>
    <id>https://blog.jujimeizuo.cn/2023/02/27/cmake-file/</id>
    <published>2023-02-27T08:42:26.000Z</published>
    <updated>2024-04-01T11:19:02.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><p>通过cmake编译的代码，在代码中输出FILE就代码文件的绝对路径。在大多数使用FILE这宏的，一般都是用于日志输出，首先使用绝对路径会使日志量膨胀，其次我们最终的程序执行的环境，可能与编译的环境不一样，输出绝对路径并没有多大的参考意义</p><p>例如：&#x2F;home&#x2F;dell&#x2F;workspace&#x2F;….</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>既然FILE宏是gcc定义的，默认等于gcc命令中的文件路径，我们可以通过重新定义该宏来达到我们的目的，如下方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ tests/test.cc -D__FILE__=<span class="string">&quot;\&quot;tests/test.cc\&quot;&quot;</span> -o test</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：hello __FILE__=tests/test.cc</span></span><br></pre></td></tr></table></figure><h2 id="在cmake里解决"><a href="#在cmake里解决" class="headerlink" title="在cmake里解决"></a>在cmake里解决</h2><p>如果需要在每个源文件的编译上面都带上对应的定义(-D<strong>FILE</strong>=”\”tests&#x2F;test.cc\””),那么CMakeLists.txt里面就比较混乱了。我们可以把这种定义，封装到一个cmake函数里面，当需要使用这个功能的时候，就执行一下这个函数，这样就可以优雅的解决FILE绝对路径的问题，将绝对路径变成相对路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## utils.cmake</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##重新定义当前目标的源文件的__FILE__宏</span></span><br><span class="line"><span class="keyword">function</span>(redefine_file_macro targetname)</span><br><span class="line">    <span class="comment">##获取当前目标的所有源文件</span></span><br><span class="line">    <span class="keyword">get_target_property</span>(source_files <span class="string">&quot;$&#123;targetname&#125;&quot;</span> SOURCES)</span><br><span class="line">    <span class="comment">##遍历源文件</span></span><br><span class="line">    <span class="keyword">foreach</span>(sourcefile <span class="variable">$&#123;source_files&#125;</span>)</span><br><span class="line">        <span class="comment">##获取当前源文件的编译参数</span></span><br><span class="line">        <span class="keyword">get_property</span>(defs SOURCE <span class="string">&quot;$&#123;sourcefile&#125;&quot;</span></span><br><span class="line">            PROPERTY COMPILE_DEFINITIONS)</span><br><span class="line">        <span class="comment">##获取当前文件的绝对路径</span></span><br><span class="line">        <span class="keyword">get_filename_component</span>(filepath <span class="string">&quot;$&#123;sourcefile&#125;&quot;</span> ABSOLUTE)</span><br><span class="line">        <span class="comment">##将绝对路径中的项目路径替换成空,得到源文件相对于项目路径的相对路径</span></span><br><span class="line">        <span class="keyword">string</span>(REPLACE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/ <span class="string">&quot;&quot;</span> relpath <span class="variable">$&#123;filepath&#125;</span>)</span><br><span class="line">        <span class="comment">##将我们要加的编译参数(__FILE__定义)添加到原来的编译参数里面</span></span><br><span class="line">        <span class="keyword">list</span>(APPEND defs <span class="string">&quot;__FILE__=\&quot;$&#123;relpath&#125;\&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">##重新设置源文件的编译参数</span></span><br><span class="line">        <span class="keyword">set_property</span>(</span><br><span class="line">            SOURCE <span class="string">&quot;$&#123;sourcefile&#125;&quot;</span></span><br><span class="line">            PROPERTY COMPILE_DEFINITIONS <span class="variable">$&#123;defs&#125;</span></span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure><p>我们将上面的代码，写入到utils.cmake文件里面，然后去修改我们的CMakeLists.txt，让我们的代码支持FILE输出相对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">project(server)</span><br><span class="line"></span><br><span class="line">include (utils.cmake)</span><br><span class="line"></span><br><span class="line">add_definitions(-Wno-builtin-macro-redefined)</span><br><span class="line"></span><br><span class="line">add_executable(test tests/test.cc)</span><br><span class="line">redefine_file_macro(test)</span><br></pre></td></tr></table></figure><p>redefine_file_macro(test), 为我们的输出目标添加FILE宏重定义功能 当我们冲定义了FILE宏，编译器会告警 “:0:0: warning: “FILE” redefined [-Wbuiltin-macro-redefined]”, 为了解决这个警告，我们需要在CMakeLists.txt里面加上add_definitions(-Wno-builtin-macro-redefined)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结 cmake编译的FILE虽然是绝对路径，我们可以通过冲定义FILE的方式来解决。cmake支持自定义函数，自定义宏的方式，我们利用自定义函数，将我们经常使用的特性封装到函数里面，写到一个单独的cmake文件里面，当我们需要使用的时候，只需要include xxx.cmake文件就可以了。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/02/27/cmake-file/">https://blog.jujimeizuo.cn/2023/02/27/cmake-file/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题表现&quot;&gt;&lt;a href=&quot;#问题表现&quot; class=&quot;headerlink&quot; title=&quot;问题表现&quot;&gt;&lt;/a&gt;问题表现&lt;/h2&gt;&lt;p&gt;通过cmake编译的代码，在代码中输出FILE就代码文件的绝对路径。在大多数使用FILE这宏的，一般都是用于日志输出，首先使</summary>
      
    
    
    
    
    <category term="C++" scheme="https://blog.jujimeizuo.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用-epoll</title>
    <link href="https://blog.jujimeizuo.cn/2023/01/27/epoll/"/>
    <id>https://blog.jujimeizuo.cn/2023/01/27/epoll/</id>
    <published>2023-01-27T11:28:34.000Z</published>
    <updated>2024-04-01T11:19:01.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="叙述"><a href="#叙述" class="headerlink" title="叙述"></a>叙述</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>epoll（eventpoll）是一种I&#x2F;O事件通知机制，是linux内核实现IO多路复用的实现。</p><p>IO多路复用指在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用时返回，然后对其进行读写操作。</p><p>epoll时select和poll的升级版，改进了工作方式会更加高效。</p><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>通知机制就是当事件发生时会主动通知，反面就是轮询机制。</p><h4 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h4><p>epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制</p><h4 id="对比select和poll"><a href="#对比select和poll" class="headerlink" title="对比select和poll"></a>对比select和poll</h4><p>select&#x2F;poll 低效的原因之一是将 “添加 &#x2F; 维护待检测任务” 和 “阻塞进程 &#x2F; 线程” 两个步骤合二为一。每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 个数相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl() 维护等待队列，再调用 epoll_wait() 阻塞进程（解耦）。通过下图的对比显而易见，epoll 的效率得到了提升。</p><p><img src="https://subingwen.cn/linux/epoll/image-20210403181746358.png"></p><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h4 id="epoll-size"><a href="#epoll-size" class="headerlink" title="epoll_size()"></a>epoll_size()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_size</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>内核会产生一个epoll 实例数据结构并返回一个文件描述符，这个特殊的描述符就是epoll实例的句柄，后面的两个接口都以它为中心（即epfd形参）。</p><ul><li>函数参数<ul><li>size：在 Linux 内核 2.6.8 版本以后，这个参数是被忽略的，只需要指定一个大于 0 的数值就可以了。</li></ul></li><li>函数返回值：<ul><li>失败：返回 - 1</li><li>成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的 epoll 实例了</li></ul></li></ul><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl()"></a>epoll_ctl()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理红黑树上的文件描述符（添加、修改、删除）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line"><span class="type">void</span> *ptr; <span class="comment">/* 指向用户自定义数据 */</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 注册的文件描述符 */</span></span><br><span class="line"><span class="type">uint32_t</span> u32; <span class="comment">/* 32-bit integer */</span></span><br><span class="line"><span class="type">uint64_t</span> u64; <span class="comment">/* 64-bit integer */</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span> events; <span class="comment">/* 描述epoll事件 */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* 见上面的结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数参数：<ul><li>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例</li><li>op：这是一个枚举值，控制通过该函数执行什么操作<ul><li>EPOLL_CTL_ADD：往 epoll 模型中添加新的节点</li><li>EPOLL_CTL_MOD：修改 epoll 模型中已经存在的节点</li><li>EPOLL_CTL_DEL：删除 epoll 模型中的指定的节点</li></ul></li><li>fd：文件描述符，即要添加 &#x2F; 修改 &#x2F; 删除的文件描述符</li><li>event：epoll 事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件<ul><li>events：委托 epoll 检测的事件<ul><li>EPOLLIN：读事件，接收数据，检测读缓冲区，如果有数据该文件描述符就绪</li><li>EPOLLOUT：写事件，发送数据，检测写缓冲区，如果可写该文件描述符就绪</li><li>EPOLLERR：异常事件</li></ul></li></ul></li><li>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd 成员，用于存储待检测的文件描述符的值，在调用 epoll_wait() 函数的时候这个值会被传出。</li></ul></li><li>函数返回值：<ul><li>失败：返回 -1</li><li>成功：返回 0</li></ul></li></ul><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait()"></a>epoll_wait()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测epoll树中是否有就绪的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中。</p><ul><li>函数参数：<ul><li>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例</li><li>events：传出参数，这是一个结构体数组的地址，里边存储了已就绪的文件描述符的信息</li><li>maxevents：修饰第二个参数，结构体数组的容量（元素个数）</li><li>timeout：如果检测的 epoll 实例中没有已就绪的文件描述符，该函数阻塞的时长，单位 ms 毫秒<ul><li>0：函数不阻塞，不管 epoll 实例中有没有就绪的文件描述符，函数被调用后都直接返回</li><li>大于 0：如果 epoll 实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回</li><li>-1：函数一直阻塞，直到 epoll 实例中有已就绪的文件描述符之后才解除阻塞</li></ul></li></ul></li><li>函数返回值：<ul><li>成功：<ul><li>等于 0：函数是阻塞被强制解除了，没有检测到满足条件的文件描述符</li><li>大于 0：检测到的已就绪的文件描述符的总个数</li></ul></li><li>失败：返回 - 1</li></ul></li></ul><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>epoll监控多个文件描述符的I&#x2F;O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通过epoll_wait等待I&#x2F;O事件，如果当前没有可用的事件则阻塞调用线程。 select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。</p><h4 id="水平触发-LT"><a href="#水平触发-LT" class="headerlink" title="水平触发(LT)"></a>水平触发(LT)</h4><p>水平模式可以简称为 LT 模式，LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行 IO 操作了。如果我们不作任何操作，内核还是会继续通知使用者。</p><ul><li>读事件：如果文件描述符对应的读缓冲区还有数据，读事件就会被触发，epoll_wait () 解除阻塞<ul><li>当读事件被触发，epoll_wait () 解除阻塞，之后就可以接收数据了</li><li>如果接收数据的 buf 很小，不能全部将缓冲区数据读出，那么读事件会继续被触发，直到数据被全部读出，如果接收数据的内存相对较大，读数据的效率也会相对较高（减少了读数据的次数）</li><li>因为读数据是被动的，必须要通过读事件才能知道有数据到达了，因此对于读事件的检测是必须的</li></ul></li><li>写事件：如果文件描述符对应的写缓冲区可写，写事件就会被触发，epoll_wait () 解除阻塞<ul><li>当写事件被触发，epoll_wait () 解除阻塞，之后就可以将数据写入到写缓冲区了</li><li>写事件的触发发生在写数据之前而不是之后，被写入到写缓冲区中的数据是由内核自动发送出去的</li><li>如果写缓冲区没有被写满，写事件会一直被触发</li><li>因为写数据是主动的，并且写缓冲区一般情况下都是可写的（缓冲区不满），因此对于写事件的检测不是必须的</li></ul></li></ul><h4 id="边缘触发-ET"><a href="#边缘触发-ET" class="headerlink" title="边缘触发(ET)"></a>边缘触发(ET)</h4><p>边沿模式可以简称为 ET 模式，ET（edge-triggered）是高速工作方式，只支持no-block socket。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）。如果我们对这个文件描述符做 IO 操作，从而导致它再次变成未就绪，当这个未就绪的文件描述符再次变成就绪状态，内核会再次进行通知，并且还是只通知一次。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</p><ul><li>读事件：当读缓冲区有新的数据进入，读事件被触发一次，没有新数据不会触发该事件<ul><li>如果有新数据进入到读缓冲区，读事件被触发，epoll_wait () 解除阻塞</li><li>读事件被触发，可以通过调用 read ()&#x2F;recv () 函数将缓冲区数据读出</li><li>如果数据没有被全部读走，并且没有新数据进入，读事件不会再次触发，只通知一次</li><li>如果数据被全部读走或者只读走一部分，此时有新数据进入，读事件被触发，并且只通知一次</li></ul></li><li>写事件：当写缓冲区状态可写，写事件只会触发一次<ul><li>如果写缓冲区被检测到可写，写事件被触发，epoll_wait () 解除阻塞</li><li>写事件被触发，就可以通过调用 write ()&#x2F;send () 函数，将数据写入到写缓冲区中</li><li>写缓冲区从不满到被写满，期间写事件只会被触发一次</li><li>写缓冲区从满到不满，状态变为可写，写事件只会被触发一次</li></ul></li></ul><p>综上所述：epoll 的边沿模式下 epoll_wait () 检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。 <strong>ET模式的设置：</strong> 边沿模式不是默认的 epoll 模式，需要额外进行设置。epoll 设置边沿模式是非常简单的，epoll 管理的红黑树示例中每个节点都是 struct epoll_event 类型，只需要将 EPOLLET 添加到结构体的 events 成员中即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN  EPOLLET;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://zhuanlan.zhihu.com/p/159135478">https://zhuanlan.zhihu.com/p/159135478</a> <a href="https://blog.csdn.net/baidu_41388533/article/details/110134366">https://blog.csdn.net/baidu_41388533&#x2F;article&#x2F;details&#x2F;110134366</a> <a href="https://subingwen.cn/linux/epoll/##2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">https://subingwen.cn/linux/epoll/##2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0</a></p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/27/epoll/">https://blog.jujimeizuo.cn/2023/01/27/epoll/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;叙述&quot;&gt;&lt;a href=&quot;#叙述&quot; class=&quot;headerlink&quot; title=&quot;叙述&quot;&gt;&lt;/a&gt;叙述&lt;/h2&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;epo</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Gitbook 入门</title>
    <link href="https://blog.jujimeizuo.cn/2023/01/18/gitbook-introduction/"/>
    <id>https://blog.jujimeizuo.cn/2023/01/18/gitbook-introduction/</id>
    <published>2023-01-18T09:23:58.000Z</published>
    <updated>2024-04-01T11:19:02.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><p>高版本可能不兼容，需要版本在v10左右。 <a href="https://nodejs.org/download/release/v10.21.0/"></a><a href="https://nodejs.org/download/release/v10.21.0/">https://nodejs.org/download/release/v10.21.0/</a></p><h4 id="更换镜像"><a href="#更换镜像" class="headerlink" title="更换镜像"></a>更换镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g gitbook-cli</span><br></pre></td></tr></table></figure><p>安装完之后用<code>gitbook -V</code>查看版本，自动install gitbook。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitbook -V      查看版本号</span><br><span class="line">gitbook init    初始化</span><br><span class="line">gitbook serve   预览</span><br><span class="line">gitbook build   生成</span><br><span class="line">gitbook build --gitbook=2.6.7 生成时指定gitbook的版本, 本地没有会先下载</span><br><span class="line">gitbook uninstall 2.6.7   卸载指定版本号的gitbook</span><br><span class="line">gitbook fetch [version]      获取[版本]下载并安装&lt;版本&gt;</span><br><span class="line">gitbook --<span class="built_in">help</span>   显示帮助文档</span><br><span class="line">gitbook ls-remote  列出NPM上的可用版本：</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/18/gitbook-introduction/">https://blog.jujimeizuo.cn/2023/01/18/gitbook-introduction/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前置要求&quot;&gt;&lt;a href=&quot;#前置要求&quot; class=&quot;headerlink&quot; title=&quot;前置要求&quot;&gt;&lt;/a&gt;前置要求&lt;/h2&gt;&lt;h4 id=&quot;nodejs&quot;&gt;&lt;a href=&quot;#nodejs&quot; class=&quot;headerlink&quot; title=&quot;nodej</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Codestudio Weekend Contest 56 - Ninja And The Challenge</title>
    <link href="https://blog.jujimeizuo.cn/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/"/>
    <id>https://blog.jujimeizuo.cn/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/</id>
    <published>2023-01-14T04:53:57.000Z</published>
    <updated>2024-04-01T11:19:02.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给一个序列，一次操作可以使得任意元素+1&#x2F;-1，问最少多少次操作可以使得整个序列递增或递减？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>能否只构造成递增来解决？</p><blockquote><p>当然可以，如果想要构造成递减，只需要把序列逆序，然后构造成递增。</p></blockquote><p>假设我们只有 2 个数字 [10, 6]，那么我们可以将 6 向上移动 4 步或 10 向下移动 4 步；无论哪种方式，成本都是 4。同时，以同样的成本，我们还可以制作 [7, 7] 或 [8, 8] 或 [9, 9] 或 [10, 10]。</p><p>假设我们支付了 4 的成本并使其成为 [10, 6] → [6, 6]，并且由于我们已经支付了成本，以后如果我们改变主意，我们可以自由地向上移动 [6, 6]到 [7, 7], [8, 8], …, 无需额外费用，因为 [7, 7], [8, 8],[9, 9]… 都需要我们已经支付的 4 个步骤. 数字 [6, 6] 现在向上自由。</p><p>一个向上的自由数字可以自由上升直到它之前的最大数字，并作为它的最低值存储。对于每个数字，我们找到它的向上空闲数并制作向上空闲数组。保证我们总是可以使用这个更新的空闲数组来增加数组。</p><p>例如，如果向上自由数组是 [1, 7, 6, 3]，我们可以创建一个零成本的递增数组 [1, 7, 7, 7]，因为最后 6, 3 是向上自由的。</p><p>如果下一个数是5，那么我们以2为代价减少7→5，新的向上自由数组变为[1,7,6,3]→[1,5,6,3,5]，而这个数组可以成为零成本的递增序列 [1, 5, 6, 6, 6]。</p><p>总之，如果新数字大于迄今为止最大的向上自由数字，则追加它，因为序列已经在增加。但如果不是，则以差值为代价，将最大的向上自由数减少到与新数相同；这两个数字现在都向上免费了。第二大数字现在成为新的高度。</p><p>我们使用最大堆来存储这些向上的空闲数，以在 O(log(n)) 时间内找到最大的一个。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() &gt; x) &#123;</span><br><span class="line">            ans += pq.<span class="built_in">top</span>() - x;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            pq.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumMovesToSort</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.rbegin(), a.rend())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="built_in">solve</span>(a), <span class="built_in">solve</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main() &#123;</span></span><br><span class="line"><span class="comment">    std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">    std::cin.tie(nullptr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/">https://blog.jujimeizuo.cn/2023/01/14/codestudio-weekend-contest-56-ninja-and-the-challenge/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;给一个序列，一次操作可以使得任意元素+1&amp;#x2F;-1，问最少多少次操作可以使得整个序列递增或递减</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>C++模版 - 偏特化与全特化</title>
    <link href="https://blog.jujimeizuo.cn/2023/01/11/c-template-specialization/"/>
    <id>https://blog.jujimeizuo.cn/2023/01/11/c-template-specialization/</id>
    <published>2023-01-11T11:08:38.000Z</published>
    <updated>2024-04-01T11:19:02.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数，从而实现了真正的代码可重用性。 模版可以分为两类，一个是函数模版，另外一个是类模版。</p><blockquote><p>C++的模板机制被证明是图灵完备的，即可以通过<a href="https://harttle.land/2015/09/16/effective-cpp-48.html" title="模板元编程（template meta programming）">模板元编程（template meta programming）</a>的方式在编译期做任何计算。</p></blockquote><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译。 用户提供不同的类型参数，就会实例化出不同的代码。</p><h2 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h2><p>类模板描述了一组相关的类或数据类型，它们只能通过类型来区分：整数值、指向（或引用）具有全局链接的变量的指针、其他的组合。 类模板尤其适用于描述通用但类型安全的数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型形式参数&gt;</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//类声明体;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;类型形式参数&gt;</span><br><span class="line">返回类型 类名 &lt;类型&gt; :: 成员函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员函数定义体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>所谓模板全特化限定死模板实现的具体类型；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&#123;</span><br><span class="line">    <span class="type">int</span> data1;</span><br><span class="line">    <span class="type">double</span> data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>偏特化是指提供另一份template定义式，而其本身仍为templatized，这是针对于template参数更进一步的条件限制所设计出来的一个特化版本。 也就是如果这个模板有多个类型，那么只限定其中的一部分;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>, T2&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型形式参数&gt;      <span class="comment">//类型形式参数即此格式：&lt;typename  形式参数&gt;  或 &lt;class 形式参数&gt;</span></span><br><span class="line">返回类型  函数名 （形式参数）</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//函数定义体;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全特化-1"><a href="#全特化-1" class="headerlink" title="全特化"></a>全特化</h4><p>函数模板全特化和类模板全特化本质是一样的，是对模板参数的特殊化处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> lhs, <span class="type">const</span> <span class="type">int</span> rhs)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> lhs &gt; rhs ? lhs : rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特化的歧义"><a href="#特化的歧义" class="headerlink" title="特化的歧义"></a>特化的歧义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; T d; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="type">int</span> d; &#125;</span><br></pre></td></tr></table></figure><p>此时编译器不知道f()是从f\()特化来的，编译时会有错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: no <span class="keyword">function</span> template matches <span class="keyword">function</span> template specialization <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure><p>这时我们便需要显式指定”模板实参”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">void <span class="function"><span class="title">f</span></span>()&#123; T d; &#125;</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">void f&lt;int&gt;()&#123; int d; &#125;</span><br></pre></td></tr></table></figure><h4 id="偏特化-1"><a href="#偏特化-1" class="headerlink" title="偏特化"></a>偏特化</h4><p>函数模版没有偏特化。</p><p>例如下面代码会编译出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">int</span>, T2&gt;()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>但函数允许重载，声明另一个函数模板即可替代偏特化的需要：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;              <span class="comment">// 注意：这里没有&quot;模板实参&quot;</span></span><br></pre></td></tr></table></figure><p>多数情况下函数模板重载就可以完成函数偏特化的需要，一个例外便是std命名空间。 std是一个特殊的命名空间，用户可以特化其中的模板，但不允许添加模板（其实任何内容都是禁止添加的）。 因此在std中添加重载函数是不允许的，在<a href="https://harttle.land/2015/08/23/effective-cpp-25.html" title="Effective C++: Item 25">Effective C++: Item 25</a>中给出了一个更详细的案例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>函数模板只有全特化，没有偏特化；</li><li>模板、模板的特化和模板的偏特化都存在的情况下，编译器在编译阶段进行匹配，优先特殊的；</li><li>模板函数不能是虚函数；因为每个包含虚函数的类具有一个virtual table,包含该类的所有虚函数的地址，因此vtable的大小是确定的。模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定。所以，成员函数模板不能为虚函数。</li></ol><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/11/c-template-specialization/">https://blog.jujimeizuo.cn/2023/01/11/c-template-specialization/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模版&quot;&gt;&lt;a href=&quot;#模版&quot; class=&quot;headerlink&quot; title=&quot;模版&quot;&gt;&lt;/a&gt;模版&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;模板就</summary>
      
    
    
    
    
    <category term="C++" scheme="https://blog.jujimeizuo.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CodeChef Starters 72 div2 - No sequence</title>
    <link href="https://blog.jujimeizuo.cn/2023/01/05/codechef-starters-72-div2-no-sequence/"/>
    <id>https://blog.jujimeizuo.cn/2023/01/05/codechef-starters-72-div2-no-sequence/</id>
    <published>2023-01-05T13:07:57.000Z</published>
    <updated>2024-04-01T11:19:02.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>三个数字N，K，S，构造一个长度为N的序列B，要求如下：</p><ul><li>$B_i \in {-1,0,1}$</li><li>$\sum_{i&#x3D;1}^N B_i * K^{i-1}&#x3D;S$</li></ul><p>输出任意一种序列，如果没有输出-2。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过观察$\sum_{i&#x3D;1}^N B_i * K^{i-1}&#x3D;S $</p><p>可以得到$ S &#x3D; B1 + \sum_{i&#x3D;2}^N B_i * K^{i-1} $，即</p><p>$$ S\equiv B_1 \quad (mod \ K) $$</p><p>所以通过S可以确定B1的值，然后通过一些简单的代数可以得到</p><p>$$ \frac{S-B1}{K} &#x3D; B2+\sum_{i&#x3D;3}^N B_i * K^{i-2} $$</p><p>即</p><p>$$\frac{S-B_1}{K} \equiv B_2 \quad (mod \ K) $$</p><p>所以可以确定B2的值，以此类推可以得到所有B的值，如果中途出现越界情况，直接返-2即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2023-01-04 22:39:48</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, K;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> S;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; K &gt;&gt; S;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S % K == <span class="number">0</span>) &#123;</span><br><span class="line">            S /= K;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((S - <span class="number">1</span>) % K == <span class="number">0</span>) &#123;</span><br><span class="line">            S = (S - <span class="number">1</span>) / K;</span><br><span class="line">            B[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((S + <span class="number">1</span>) % K == <span class="number">0</span>) &#123;</span><br><span class="line">            S = (S + <span class="number">1</span>) / K;</span><br><span class="line">            B[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ok  S != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="number">-2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; B[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    std::cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span> (_--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/01/05/codechef-starters-72-div2-no-sequence/">https://blog.jujimeizuo.cn/2023/01/05/codechef-starters-72-div2-no-sequence/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;三个数字N，K，S，构造一个长度为N的序列B，要求如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$B_i &#92;in {-1,0,1}$&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Linux GDB调试</title>
    <link href="https://blog.jujimeizuo.cn/2022/12/31/linux-gdb-debug/"/>
    <id>https://blog.jujimeizuo.cn/2022/12/31/linux-gdb-debug/</id>
    <published>2022-12-31T05:04:47.000Z</published>
    <updated>2024-04-01T11:19:01.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是GDB"><a href="#1-什么是GDB" class="headerlink" title="1. 什么是GDB"></a>1. 什么是GDB</h2><ul><li>GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</li><li>一般来说，GDB 主要帮助你完成下面四个方面的功能：<ol><li>启动程序，可以按照自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时程序中所发生的事</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG</li></ol></li></ul><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><p>通常，在为调试而编译时，我们会关掉编译器的优化选项（<code>-O</code>）， 并打开调试选项（<code>-g</code>）。另外，<code>-Wall</code>在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG。 例如： <code>gcc -g -Wall program.c -o program</code> <code>-g</code> 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机 器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调 试时必须保证 gdb 能找到源文件。 调试下列程序前要做准备工作，在shell中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -Wall test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#test.c</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="number">30</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        b = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="comment">// 函数调用</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">test</span>(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;res value: %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;THE END !!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="3-GDB-命令-：-启动、退出、查看代码"><a href="#3-GDB-命令-：-启动、退出、查看代码" class="headerlink" title="3. GDB 命令 ： 启动、退出、查看代码"></a>3. GDB 命令 ： 启动、退出、查看代码</h2><h4 id="启动和退出"><a href="#启动和退出" class="headerlink" title="启动和退出"></a>启动和退出</h4><ul><li><code>gdb</code> 可执行程序</li><li><code>quit</code>或<code>q</code>退出 注意：在进行准备工作之后才可以期待调试。</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462308255.png" alt="file"></p><p>在调试命令行输入quit就可退出调试。</p><h4 id="给程序设置参数-获取设置参数"><a href="#给程序设置参数-获取设置参数" class="headerlink" title="给程序设置参数 &#x2F; 获取设置参数"></a>给程序设置参数 &#x2F; 获取设置参数</h4><ul><li><code>set args 10 20</code></li><li><code>show args</code> 注意：有一些程序需要设置参数，例如上述的test.c程序，main函数需要指定参数。</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462408961.png" alt="file"></p><h4 id="GDB-使用帮助"><a href="#GDB-使用帮助" class="headerlink" title="GDB 使用帮助"></a>GDB 使用帮助</h4><ul><li><code>help</code> <code>help</code> 具体命令 用来查看调试帮助或具体指令的相关信息</li></ul><h4 id="查看当前文件代码"><a href="#查看当前文件代码" class="headerlink" title="查看当前文件代码"></a>查看当前文件代码</h4><ul><li><code>list/l</code> （从默认位置显示）</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462449889.png" alt="file"></p><ul><li><code>list/l 行号</code> （从指定的行显示）注意是把行号内容放在中间显示。</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462538567.png" alt="file"></p><h4 id="查看非当前文件代码"><a href="#查看非当前文件代码" class="headerlink" title="查看非当前文件代码"></a>查看非当前文件代码</h4><ul><li><code>list/l 文件名 : 行号</code></li><li><code>list/l 文件名 : 函数名</code> 一个程序有好几个文件组成，当我们调试主函数所在程序时，其他文件的代码也需要查看，就可以使用上述命令。一个项目中含bubble，select.cpp，main.cpp</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462611599.png" alt="file"> <img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462633560.png" alt="file"></p><h4 id="设置显示的行数"><a href="#设置显示的行数" class="headerlink" title="设置显示的行数"></a>设置显示的行数</h4><ul><li><code>show list/listsize</code></li><li><code>set list/listsize 行数</code></li></ul><h2 id="4-GDB命令：断点操作"><a href="#4-GDB命令：断点操作" class="headerlink" title="4. GDB命令：断点操作"></a>4. GDB命令：断点操作</h2><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><ul><li><code>b/break 行号</code></li><li><code>b/break 函数名</code></li><li><code>b/break 文件名 : 行号</code></li><li><code>b/break 文件名 : 函数</code></li></ul><p>如下图 在第6行设置断点：</p><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462743491.png" alt="file"></p><p>其它断点设置方法类似list&#x2F;l操作。</p><h4 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h4><ul><li><code>i/info b/break</code> 查看断点信息：</li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462775358.png" alt="file"></p><p>其中num代表断点编号，Type下的breakpoint说明该点为断点，Disp为断点状态，Enb是yes代表为有效断点，adress为断点地址，What说明断点的在那个文件的第几行。</p><h4 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h4><ul><li><code>d/del/delete 断点编号</code> 如下图所示删除断点编号为1的断点。 <img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462817833.png" alt="file"></li></ul><h4 id="设置断点无效"><a href="#设置断点无效" class="headerlink" title="设置断点无效"></a>设置断点无效</h4><ul><li><code>dis/disable 断点编号</code></li></ul><h4 id="设置断点生效"><a href="#设置断点生效" class="headerlink" title="设置断点生效"></a>设置断点生效</h4><ul><li><code>ena/enable 断点编号</code></li></ul><h4 id="设置条件断点（一般用在循环的位置）"><a href="#设置条件断点（一般用在循环的位置）" class="headerlink" title="设置条件断点（一般用在循环的位置）"></a>设置条件断点（一般用在循环的位置）</h4><ul><li><code>b/break 13 if i==3</code></li></ul><p><img src="https://cdn.jujimeizuo.cn/blog/2022/12/image-1672462898795.png" alt="file"></p><h2 id="5-GDB-命令-：-调试命令"><a href="#5-GDB-命令-：-调试命令" class="headerlink" title="5. GDB 命令 ： 调试命令"></a>5. GDB 命令 ： 调试命令</h2><h4 id="运行-GDB-程序"><a href="#运行-GDB-程序" class="headerlink" title="运行 GDB 程序"></a>运行 GDB 程序</h4><ul><li><code>start</code>（程序停在第一行）</li><li><code>run</code>（遇到断点才停）</li><li>使用<code>run</code>指令和<code>c</code>(继续指令）</li></ul><h4 id="继续运行，到下一个断点停"><a href="#继续运行，到下一个断点停" class="headerlink" title="继续运行，到下一个断点停"></a>继续运行，到下一个断点停</h4><ul><li><p><code>c/continue</code></p><h4 id="向下执行一行代码（不会进入函数体）"><a href="#向下执行一行代码（不会进入函数体）" class="headerlink" title="向下执行一行代码（不会进入函数体）"></a>向下执行一行代码（不会进入函数体）</h4></li><li><p><code>n/next</code></p></li></ul><h4 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h4><ul><li><code>p/print 变量名</code>（打印变量值）</li><li><code>ptype 变量名</code>（打印变量类型）</li></ul><h4 id="向下单步调试（遇到函数进入函数体）"><a href="#向下单步调试（遇到函数进入函数体）" class="headerlink" title="向下单步调试（遇到函数进入函数体）"></a>向下单步调试（遇到函数进入函数体）</h4><ul><li><code>s/step</code></li><li><code>finish</code>（跳出函数体）</li></ul><h4 id="自动变量操作"><a href="#自动变量操作" class="headerlink" title="自动变量操作"></a>自动变量操作</h4><ul><li><code>display 变量名</code>（自动打印指定变量的值）</li><li><code>i/info display</code></li><li><code>undisplay 编号</code></li></ul><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><ul><li><code>set var 变量名 = 变量值</code> （循环中用的较多）</li><li><code>until</code>（跳出循环）</li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2022/12/31/linux-gdb-debug/">https://blog.jujimeizuo.cn/2022/12/31/linux-gdb-debug/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0协议 。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是GDB&quot;&gt;&lt;a href=&quot;#1-什么是GDB&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是GDB&quot;&gt;&lt;/a&gt;1. 什么是GDB&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
    <category term="C++" scheme="https://blog.jujimeizuo.cn/tags/C/"/>
    
  </entry>
  
</feed>
