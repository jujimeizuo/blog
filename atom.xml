<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jujimeizuo · Blog</title>
  
  
  <link href="https://blog.jujimeizuo.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.jujimeizuo.cn/"/>
  <updated>2025-05-09T07:08:03.111Z</updated>
  <id>https://blog.jujimeizuo.cn/</id>
  
  <author>
    <name>jujimeizuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Update Error on libc and libcrypt</title>
    <link href="https://blog.jujimeizuo.cn/2025/04/16/update-error-on-libc-and-libcrypt/"/>
    <id>https://blog.jujimeizuo.cn/2025/04/16/update-error-on-libc-and-libcrypt/</id>
    <published>2025-04-16T10:58:23.000Z</published>
    <updated>2025-05-09T07:08:03.111Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>因为最近有需求需要更新 libc 到 2.35，但是我的 Ubuntu 系统是 20.04，最高版本是 2.31（当时我以为是 22.04，所以可以升级到 2.35），然后就从源码中更新 libc，编译、安装，<code>make install</code> 之后，不仅发生错误，而且系统直接崩溃，命令都无法使用！！！</li><li>当我修复好系统之后，又手贱更新了 <code>libc-bin</code>，导致 libcrypt 出错，再次崩溃！！！</li><li>系统：Ubuntu 20.04，系统架构： x86_64</li></ol></blockquote><h2 id="1-系统崩溃时如何操作"><a href="#1-系统崩溃时如何操作" class="headerlink" title="1. 系统崩溃时如何操作"></a>1. 系统崩溃时如何操作</h2><p>当系统故障时，输入所有命令都无效，系统无法正常启动，此时有以下两种方法：</p><h3 id="1-1-救援模式"><a href="#1-1-救援模式" class="headerlink" title="1.1 救援模式"></a>1.1 救援模式</h3><p>开机时，按下 <code>SHIFT + ESC</code> 进入 GRUB 引导加载器页面</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------</span><br><span class="line">|*Ubuntu                    |</span><br><span class="line">|Advanced options for Ubuntu|</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure><p>下面有两种方式进入救援模式：</p><h4 id="1-1-1-Ubuntu"><a href="#1-1-1-Ubuntu" class="headerlink" title="1.1.1 Ubuntu"></a>1.1.1 Ubuntu</h4><ul><li>选择第一个选项并按 e 键进入编辑模式</li><li>在以 linux 开头的一行末尾，删除字符串 <code>$vt_handoff</code> 并添加字符串 <code>systemd.unit=rescue.target</code></li><li>修改完之后，按 <code>Ctrl + x</code> 或 <code>F10</code> 进入救援模式</li></ul><h4 id="1-1-2-Advanced-options-for-Ubuntu"><a href="#1-1-2-Advanced-options-for-Ubuntu" class="headerlink" title="1.1.2 Advanced options for Ubuntu"></a>1.1.2 Advanced options for Ubuntu</h4><p>选择第二个选项后继续选择内核的 <code>recover mode</code>，并选择 root 进入救援模式</p><h3 id="1-2-USB-启动盘"><a href="#1-2-USB-启动盘" class="headerlink" title="1.2 USB 启动盘"></a>1.2 USB 启动盘</h3><p>当救援模式也无法进入系统，可以使用 USB 启动盘来修复系统，制作方法如下：</p><ol><li>准备一个 U 盘，建议 8G 以上，U 盘中的文件会被格式化，确保 U 盘中的文件已备份。</li><li>下载 <a href="http://mirrors.163.com/ubuntu-releases/20.04/">Ubuntu 20.04</a> 系统镜像文件</li><li>使用 <a href="https://rufus.akeo.ie/">Rufus</a> 工具制作启动盘</li></ol><center><img src="/images/2025/04/rufus.png" width="20%"></center><ol start="4"><li>选择 Ubuntu 的 iso 文件。</li><li>然后点击开始，等待完成即可。</li><li>开机时，一直按 F2 进入 BIOS 界面，找到 USB 启动盘启动选项， 调整优先级后保存并启动。</li><li>进入 Ubuntu 系统后，选择 Try Ubuntu 进入系统。</li></ol><h3 id="1-3-挂载崩溃系统"><a href="#1-3-挂载崩溃系统" class="headerlink" title="1.3 挂载崩溃系统"></a>1.3 挂载崩溃系统</h3><p>此时通过前两种方法可以使用命令行或者图形界面进入系统，此时需要先挂载崩溃系统，然后再修复系统。</p><ol><li><p>查看崩溃系统的分区</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p> 根据自己之前分区的情况，找到崩溃系统的分区，例如我的崩溃系统是 <code>/dev/nveme0n1p7</code></p></li><li><p>挂载崩溃系统</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/nveme0n1p7 /mnt</span><br></pre></td></tr></table></figure></li><li><p>修复系统 ……</p></li><li><p>查看是否修复成功</p><p> 通过更换到崩溃系统的分区，如果没有<strong>核心已转储</strong>，能够正常进入，即修复成功。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chroot</span> /mnt</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-libc-引起的系统崩溃"><a href="#2-libc-引起的系统崩溃" class="headerlink" title="2. libc 引起的系统崩溃"></a>2. libc 引起的系统崩溃</h2><ul><li><p>当我弄一些东西的时，从源码更新 libc 到 2.35，编译、安装，<code>make install</code> 之后，系统直接崩溃，命令都无法使用！！！</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make[2]: *** [Makefile:84: da.mo] Segmentation fault (core dumped)</span><br><span class="line">make[2]: Leaving directory &#x27;/root/glibc-2.35/po&#x27;</span><br><span class="line">make[1]: *** [Makefile:215: po/subdir_install] Error 2</span><br><span class="line">make[1]: Leaving directory &#x27;/root/glibc-2.35&#x27;</span><br><span class="line">make: *** [Makefile:12: install] Error 2</span><br></pre></td></tr></table></figure></li><li><p>崩溃原因：</p><ul><li>libc.so.6 是 C 运行时库 glibc 的软链接，程序启动和运行时，是根据 libc.so.6 软链接找到glibc库</li><li>lib64&#x2F;libc.so.6 是一个软链接，指向 &#x2F;lib64&#x2F;libc.so-2.1x，2.1x 表示其对应版本，去兼容相应 Ubuntu 版本</li><li>很多基本命命令依赖 glibc，libc.so.6 链接对应版本不一致将导致系统的几乎所有程序不能工作</li></ul></li></ul><h3 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h3><ul><li><p>此时不要重启服务器，不要关闭当前终端，还有救！！！（仅限于系统中存在版本正确的 libc.so.6，不然就直接跳转到下面，）</p></li><li><p>如果系统中还有 glibc-2.31.so（<strong>此时备份的重要性</strong>），则创建软连接即可</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/lib64/libc-2.31.so /lib64/libc.so.6</span><br><span class="line"><span class="built_in">ln</span> -s /usr/lib64/ld-2.31.so /lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure></li><li><p>并且删除 2.35 相关文件</p></li></ul><h3 id="2-2-方法二"><a href="#2-2-方法二" class="headerlink" title="2.2 方法二"></a>2.2 方法二</h3><ol><li><p>进入救援模式，挂载崩溃系统</p></li><li><p>查看系统适配的 glibc 版本</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><p> 输出结果如下：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldd (Ubuntu EGLIBC 2.31-0ubuntu6.6) 2.31</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure></li><li><p>查看 libc 中 GLIBC 的版本</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep -E <span class="string">&quot;^GLIBC&quot;</span> | <span class="built_in">sort</span> -V -r | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure><p> 输出结果如下：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GLIBC_2.35</span><br><span class="line">GLIBC_2.34</span><br><span class="line">GLIBC_2.33</span><br><span class="line">GLIBC_2.32</span><br><span class="line">GLIBC_2.31</span><br><span class="line">GLIBC_2.30</span><br><span class="line">GLIBC_2.29</span><br><span class="line">GLIBC_2.28</span><br><span class="line">GLIBC_2.27</span><br><span class="line">GLIBC_2.26</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>发现 glibc 还是 2.35 版本，需要降级到 2.31 版本，此时崩溃系统中没有 libc-2.31.so 文件，我发现 USB 启动盘中有这个文件（所以制作启动盘时最好和崩溃系统的版本相同），此时需要将其复制到崩溃系统中</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/libc-2.31.so /mnt/lib64/</span><br><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-linux-gnu/ld-2.31.so /mnt/lib64/</span><br></pre></td></tr></table></figure></li><li><p>然后创建软链接</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /lib64/libc-2.31.so /mnt/lib64/libc.so.6</span><br><span class="line"><span class="built_in">ln</span> -s /lib64/ld-2.31.so /mnt/lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure></li><li><p><code>chroot /mnt</code> 查看是否能正常进入，到此修复成功！！！</p></li></ol><h2 id="3-libcrypt-引起的系统崩溃"><a href="#3-libcrypt-引起的系统崩溃" class="headerlink" title="3. libcrypt 引起的系统崩溃"></a>3. libcrypt 引起的系统崩溃</h2><ul><li><p>当我修复好系统之后，又手贱更新了 <code>libc-bin</code>，导致 libcrypt 出错，再次崩溃！！！</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/init: /lib/libcrypt.so.1: version `XCRYPT_2.0` not found (required by lib/systemd/lib/systemd-shared-245.so)</span><br></pre></td></tr></table></figure></li><li><p>崩溃原因：</p><ul><li>程序运行需要 libcrypt.so.1 库中的 XCRYPT_2.0 版本，但系统当前的 libcrypt.so.1 版本不支持 XCRYPT_2.0，由于库版本不兼容导致</li></ul></li><li><p>进入救援模式，挂载崩溃系统</p></li><li><p>查看 libsystemd-shared-245.so 依赖的 libcrypt.so.1 版本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd /lib/systemd/libsystemd-shared-245.so | grep libcrypt.so.1</span><br></pre></td></tr></table></figure><p>  输出结果如下：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lib/systemd/libsystemd-shared-245.so:/lib64/libcrypt.so.1:version ‘XCRYPT_2.0’ not found(required by /lib/systemd/libsystemd-shared-245.so)</span><br><span class="line">libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0x00007f2636167000)</span><br></pre></td></tr></table></figure><p>  表示依赖的 libcrypt.so.1 链接于 &#x2F;lib&#x2F;libcrypt.so.1</p></li><li><p>查看 libcrypt.so.1 版本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /lib/libcrypt.so.1 | grep <span class="string">&quot;XCRYPT_2.0&quot;</span></span><br></pre></td></tr></table></figure><p>  没有输出，说明 &#x2F;liblibcrypt.so.1 中没有 XCRYPT_2.0 版本</p></li><li><p>发现 &#x2F;liblibcrypt.so.1 中确实没有 XCRYPT_2.0 版本，此时需要一个正确的 libcrypt.so.1 文件。</p></li></ul><h3 id="3-1-下载兼容的-libcrypt1"><a href="#3-1-下载兼容的-libcrypt1" class="headerlink" title="3.1 下载兼容的 libcrypt1"></a>3.1 下载兼容的 libcrypt1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt 可用</span></span><br><span class="line">apt download libcrypt1</span><br><span class="line"></span><br><span class="line"><span class="comment"># apt 不可用</span></span><br><span class="line">wget http://deb.debian.org/debian/pool/main/libx/libxcrypt/libcrypt1_4.4.33-2_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i libcrypt1_4.4.33-2_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复依赖关系</span></span><br><span class="line">apt install -f</span><br></pre></td></tr></table></figure><h3 id="3-2-创建软连接"><a href="#3-2-创建软连接" class="headerlink" title="3.2 创建软连接"></a>3.2 创建软连接</h3><p>若系统存在包含 XCRYPT_2.0 版本的 libcrypt.so.1 文件（用 strings 查看），则创建软连接即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/lib/x86_64-linux-gnu/libcrypt.so.1 /lib/libcrypt.so.1</span><br></pre></td></tr></table></figure><p>此时使用 perl 命令查看是否修复（崩溃时 perl 也错误），即可大功告成！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>对于系统的库文件，一定不要轻易去修改，特别是在 root 权限下！！！<ol><li>内核级 <code>/lib64</code></li><li>系统级 <code>/usr/lib64</code></li><li>root 用户级 <code>/usr/local/lib64</code></li></ol></li><li>任何重要或不确定的文件改动不要轻易执行删除，一定要先<strong>备份</strong>，以备出现故障后能尽快恢复。</li><li>可以使用救援模式或 USB 启动盘来启动第二个系统作为备份和修复已崩溃系统的平台。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.zzstudio.net/uncategory/article_1514.html">centos7 升级 glibc2.25 踩坑记录</a></li><li><a href="https://yellowko.com/about-libc-so-6.html">关于libc.so.6</a></li><li><a href="https://www.cnblogs.com/benjamin77/p/8961037.html">安装glibc错误链接导致系统崩溃，u盘启动紧急救援模式下修复系统。</a></li><li><a href="https://blog.csdn.net/heqiang1995/article/details/133643785">升级glibc导致系统开不了机 系统文件损坏挂载u盘拷入文件 进入救援模式</a></li><li><a href="https://www.antute.com.cn/index.php?id=192">【案例分享】误删lib库导致系统崩溃的恢复</a></li><li><a href="https://developer.aliyun.com/article/1277450">覆盖libc.so.6的惨痛教训</a></li><li><a href="https://www.cnblogs.com/apanly/p/15395786.html">&#x2F;lib64&#x2F;libc.so.6 错误导致的系统崩溃</a></li><li><a href="https://blog.csdn.net/u013553529/article/details/78307520">【笔记】在 Windows 中制作 Ubuntu 系统的USB启动盘</a></li><li><a href="https://zhuanlan.zhihu.com/p/533121821">如何启动 Ubuntu 22.04 进入救援&#x2F;紧急模式 | Linux 中国</a></li><li><a href="https://blog.csdn.net/weixin_43252751/article/details/130305175">ubuntu系统崩溃，甚至Recovery模式和tty都无法进入，这个方法可以救援！</a></li><li><a href="https://blog.csdn.net/eggxo/article/details/136465370?depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-136465370-blog-103188777.235%5Ev43%5Econtrol">强行升级glibc导致Centos8崩溃6小时惊险修复</a></li><li><a href="https://blog.csdn.net/sharksmell/article/details/103188777">Ubuntu 手动更新glibc导致内核崩溃（无法正常关机&#x2F;开机启动失败）</a></li><li><a href="https://weiyan.cc/yuque/%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4/%E9%9B%86%E7%BE%A4/2019-07-13-hpc-experience-glibc/#21-rescue-%E6%A8%A1%E5%BC%8F%E6%AD%A5%E9%AA%A4">一次误删 GLIBC 后的系统恢复经历</a></li><li><a href="https://cloud.tencent.com/developer/ask/sof/116454423">从19.10升级到20.04失败</a></li><li><a href="https://blog.csdn.net/xibeichengf/article/details/48290297">Ubuntu下查看glibc版本</a></li><li><a href="https://unix.stackexchange.com/questions/779871/version-xcrypt-2-0-not-found-after-update-debian-10-to-debian-12">version XCRYPT_2.0 not found after Update Debian 10 to Debian 12</a></li><li><a href="https://github.com/raspberrypi/Raspberry-Pi-OS-64bit/issues/123">libcrypt.so.1: version XCRYPT_2.0 not found#123</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/04/16/update-error-on-libc-and-libcrypt/">https://blog.jujimeizuo.cn/2025/04/16/update-error-on-libc-and-libcrypt/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;因为最近有需求需要更新 libc 到 2.35，但是我的 Ubuntu 系统是 20.04，最高版本是 2.31（当时我以为是 22.04，所以可以升级到 2.35），然后就从源码中更新 libc，编译、安装，&lt;code&gt;make in</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.jujimeizuo.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Batch vs. Layer vs. Group Normalization</title>
    <link href="https://blog.jujimeizuo.cn/2025/03/17/BN-LN-GN/"/>
    <id>https://blog.jujimeizuo.cn/2025/03/17/BN-LN-GN/</id>
    <published>2025-03-17T02:27:41.000Z</published>
    <updated>2025-03-17T06:21:18.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h2><ul><li>在图像预处理过程中通常会对图像进行标准化处理，这样能加速网络的收敛。</li></ul><p>$$<br>\text{image} \overset{\text{preprocess}}{\rightarrow} \text{Conv1} -&gt; \text{feature map} -&gt; \text{Conv2}<br>$$</p><ul><li>上述过程中，对于 Conv1 的输入就是满足某一分布的特征矩阵，但对于 Conv2 而言输入的 feature map 就不一定满足某一分布规律了（<strong>注意这里所说满足某一分布规律并不是指某一个 feature map 的数据要满足分布规律，理论上是指整个训练样本集所对应 feature map 的数据要满足分布规律</strong>）。</li></ul><blockquote><ul><li>Batch Normalization 的目的就是使 feature map 满足均值为 0，方差为 1 的分布规律。</li><li>让 feature map 满足某一分布规律，理论上是指整个训练样本集所对应 feature map 的数据要满足分布规律，即计算整个训练集的 feature map 然后再进行标准化处理，对于大型数据集显然不可能，所以需要使用 Batch Normalization，计算一个 Batch 数据的 feature map 然后再标准化（batch 越大越接近整个数据集的分布）。</li></ul></blockquote><ol><li>训练时要将 traning 参数设置为 True，在验证时将 trainning 参数设置为 False。在pytorch中可通过创建模型的 model.train() 和 model.eval() 方法控制。</li><li>batch size 尽可能设置大点，设置小后表现可能很糟糕，设置的越大求的均值和方差越接近整个训练集的均值和方差。</li><li>建议将 bn 层放在卷积层（Conv）和激活层（例如Relu）之间，且卷积层不要使用偏置 bias，即使使用了偏置 bias 求出的结果也是一样。</li></ol><figure class="highlight python"><figcaption><span>Batch Normalization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bn_process</span>(<span class="params">feature, mean, var</span>):</span><br><span class="line">    feature_shape = feature.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(feature_shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># [batch, channel, height, width]</span></span><br><span class="line">        feature_t = feature[:, i, :, :]</span><br><span class="line">        mean_t = feature_t.mean()</span><br><span class="line">        <span class="comment"># 总体标准差</span></span><br><span class="line">        std_t1 = feature_t.std()</span><br><span class="line">        <span class="comment"># 样本标准差</span></span><br><span class="line">        std_t2 = feature_t.std(ddof=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># bn process</span></span><br><span class="line">        <span class="comment"># 这里记得加上eps和pytorch保持一致</span></span><br><span class="line">        feature[:, i, :, :] = (feature[:, i, :, :] - mean_t) / np.sqrt(std_t1 ** <span class="number">2</span> + <span class="number">1e-5</span>)</span><br><span class="line">        <span class="comment"># update calculating mean and var</span></span><br><span class="line">        mean[i] = mean[i] * <span class="number">0.9</span> + mean_t * <span class="number">0.1</span></span><br><span class="line">        var[i] = var[i] * <span class="number">0.9</span> + (std_t2 ** <span class="number">2</span>) * <span class="number">0.1</span></span><br><span class="line">    <span class="built_in">print</span>(feature)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成一个batch为2，channel为4，height=width=2的特征向量</span></span><br><span class="line"><span class="comment"># [batch, channel, height, width]</span></span><br><span class="line">feature1 = torch.randn(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 初始化统计均值和方差</span></span><br><span class="line">calculate_mean = [<span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">calculate_var = [<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line"><span class="comment"># print(feature1.numpy())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意要使用copy()深拷贝</span></span><br><span class="line">bn_process(feature1.numpy().copy(), calculate_mean, calculate_var)</span><br><span class="line"></span><br><span class="line">bn = nn.BatchNorm2d(<span class="number">2</span>, eps=<span class="number">1e-5</span>)</span><br><span class="line">output = bn(feature1)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><h2 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h2><ul><li>Layer Normalization 针对 NLP，例如 RNN，不使用 Batch Normalization 的原因是：在 RNN 这类时序网络中，时序的长度不是一个定值，比如每句话的长短不同，很难使用 BN，所以需要使用 LN。（但 ViT 还是会涉及到 LN）</li><li>Layer Normalization 与 Batch Normalization 的区别在于：<strong>BN 是对于一个 batch 数据的每个 channel 进行 Norm，但 LN 是对单个数据的指定维度进行 Norm 处理，与 batch 无关</strong>。</li><li>LN 指定要 Norm 的维度必须从最后一维开始。</li></ul><figure class="highlight python"><figcaption><span>Layer Normalization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">layer_norm_process</span>(<span class="params">feature: torch.Tensor, beta=<span class="number">0.</span>, gamma=<span class="number">1.</span>, eps=<span class="number">1e-5</span></span>):</span><br><span class="line">    var_mean = torch.var_mean(feature, dim=[<span class="number">1</span>, <span class="number">2</span>], unbiased=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 均值</span></span><br><span class="line">    mean = var_mean[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 方差</span></span><br><span class="line">    var = var_mean[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># layer norm process</span></span><br><span class="line">    feature = (feature - mean[..., <span class="literal">None</span>]) / torch.sqrt(var[..., <span class="literal">None</span>] + eps)</span><br><span class="line">    feature = feature * gamma + beta</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> feature</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    t = torch.rand(<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br><span class="line">    <span class="comment"># 仅在最后一个维度上做norm处理</span></span><br><span class="line">    norm = nn.LayerNorm(normalized_shape=t.shape[-<span class="number">1</span>], eps=<span class="number">1e-5</span>)</span><br><span class="line">    <span class="comment"># 官方layer norm处理</span></span><br><span class="line">    t1 = norm(t)</span><br><span class="line">    <span class="comment"># 自己实现的layer norm处理</span></span><br><span class="line">    t2 = layer_norm_process(t, eps=<span class="number">1e-5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;t1:\n&quot;</span>, t1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;t2:\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Group-Normalization"><a href="#Group-Normalization" class="headerlink" title="Group Normalization"></a>Group Normalization</h2><ul><li>最常用的 BN 有一个缺点，Batch Size 通常较大，当 batch size 小于 16 后 error 明显升高，对于大型网络或 GPU 显存不够的情况下，可以使用 Group Normalization。</li><li>batch size 的大小对 GN 并没有影响，当 batch size 设置较小时，可以采用 GN。</li><li><strong>对于 GN，假设 num_groups &#x3D; 2（原论文默认为 32），假设某层的输出得到 x，根据 num_groups 沿 channel 方向均分成 num_groups 份，然后对每一份求均值和方差</strong>。</li></ul><figure class="highlight python"><figcaption><span>Group Normalization</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">group_norm</span>(<span class="params">x: torch.Tensor,</span></span><br><span class="line"><span class="params">               num_groups: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">               num_channels: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">               eps: <span class="built_in">float</span> = <span class="number">1e-5</span>,</span></span><br><span class="line"><span class="params">               gamma: <span class="built_in">float</span> = <span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">               beta: <span class="built_in">float</span> = <span class="number">0.</span></span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">divmod</span>(num_channels, num_groups)[<span class="number">1</span>] == <span class="number">0</span></span><br><span class="line">    channels_per_group = num_channels // num_groups</span><br><span class="line"></span><br><span class="line">    new_tensor = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> x.split(channels_per_group, dim=<span class="number">1</span>):</span><br><span class="line">        var_mean = torch.var_mean(t, dim=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], unbiased=<span class="literal">False</span>)</span><br><span class="line">        var = var_mean[<span class="number">0</span>]</span><br><span class="line">        mean = var_mean[<span class="number">1</span>]</span><br><span class="line">        t = (t - mean[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]) / torch.sqrt(var[:, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>] + eps)</span><br><span class="line">        t = t * gamma + beta</span><br><span class="line">        new_tensor.append(t)</span><br><span class="line"></span><br><span class="line">    new_tensor = torch.cat(new_tensor, dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> new_tensor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    num_groups = <span class="number">2</span></span><br><span class="line">    num_channels = <span class="number">4</span></span><br><span class="line">    eps = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">    img = torch.rand(<span class="number">2</span>, num_channels, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line">    gn = nn.GroupNorm(num_groups=num_groups, num_channels=num_channels, eps=eps)</span><br><span class="line">    r1 = gn(img)</span><br><span class="line">    <span class="built_in">print</span>(r1)</span><br><span class="line"></span><br><span class="line">    r2 = group_norm(img, num_groups, num_channels, eps)</span><br><span class="line">    <span class="built_in">print</span>(r2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.csdn.net/qq_47233366/article/details/126005692">Batch_Normalization 、Layer_Normalization 、Group_Normalization你分的清楚吗</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/104434557?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165880395216781683913421%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165880395216781683913421&biz_id=0">Batch Normalization详解</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/117653177?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165880395216781683913421%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165880395216781683913421&biz_id=0">Layer Normalization解析</a></li><li><a href="https://blog.csdn.net/qq_37541097/article/details/118016048?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165880395216781683913421%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165880395216781683913421&biz_id=0">Group Normalization详解</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/03/17/BN-LN-GN/">https://blog.jujimeizuo.cn/2025/03/17/BN-LN-GN/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Batch-Normalization&quot;&gt;&lt;a href=&quot;#Batch-Normalization&quot; class=&quot;headerlink&quot; title=&quot;Batch Normalization&quot;&gt;&lt;/a&gt;Batch Normalization&lt;/h2&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="Deep Learning" scheme="https://blog.jujimeizuo.cn/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>RGBD Camera on Astra-S</title>
    <link href="https://blog.jujimeizuo.cn/2025/01/06/RGBD-Camera-on-Astra-S/"/>
    <id>https://blog.jujimeizuo.cn/2025/01/06/RGBD-Camera-on-Astra-S/</id>
    <published>2025-01-06T00:42:35.000Z</published>
    <updated>2025-05-09T07:08:03.118Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>最近被导师派任务，需要自己采集数据并恢复出三维结构，所以向师兄借用了一个 Astra-S 深度相机，这里记录一下初始使用过程，包括如何安装驱动，如何使用 SDK，如何将数据转换。</li><li>我使用 Ubuntu22.04，Win11 我试过，但是出现问题，找不到驱动，估计是 Win11 的问题，Win10 应该没问题。具体可以看：<a href="https://www.bilibili.com/video/BV1QG411R7JQ/?vd_source=5e048b202705330980eefcc9a56cc5d0">https://www.bilibili.com/video/BV1QG411R7JQ/?vd_source=5e048b202705330980eefcc9a56cc5d0</a></li></ul></blockquote><h2 id="Install-SDK"><a href="#Install-SDK" class="headerlink" title="Install SDK"></a>Install SDK</h2><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><ul><li><a href="https://vcp.developer.orbbec.com.cn/documentation">3D视觉AI开放平台 Document</a></li><li><a href="https://vcp.developer.orbbec.com.cn/resourceCenter?defaultSelectedKeys=68">OpenNI2 SDK</a></li><li><a href="https://vcp.developer.orbbec.com.cn/resourceCenter?defaultSelectedKeys=72">OpenNI2 SDK Viewer</a></li></ul><p>不过 2025.01.10 之后平台下线了？？？</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>这里不要用 OrbbecSDK Viewer，使用彩色和 IR 没问题，但是深度图像卡顿严重，或许是我的 Ubuntu 出现问题，但我使用 OpenNI2Viewer 没有任何问题。</li><li>如果不需要对其开发，只是用测量图像，可以直接使用 OpenNI2Viewer，不需要安装 SDK。</li></ul><h2 id="Save-RGB-D"><a href="#Save-RGB-D" class="headerlink" title="Save RGB-D"></a>Save RGB-D</h2><ul><li>当我们打开 OpenNI2Viewer 时，可以看到如下界面：</li></ul><img src="/images/2025/01/OpenNI2Viewer.jpeg"><ul><li>然后可以按右键，选择对应的功能，比如设置分辨率、截图、录制等。</li></ul><h3 id="Raw2Png"><a href="#Raw2Png" class="headerlink" title="Raw2Png"></a>Raw2Png</h3><ul><li>在 Linux 中有大量的工具可以打开 Raw，但是这些大量的工具我尝试过好多，从 apt 中安装的 ufraw，找不到，估计是不维护了，还有从源码安装的很多，还有 gimp，太大了，最后选择 ImageJ，小巧轻便，符合我的需求。</li><li>这里使用 ImageJ 进行处理，<a href="http://imagej.net/Fiji/Downloads">http://imagej.net/Fiji/Downloads</a></li><li><code>File-&gt;Import-&gt;Raw...</code><ul><li>对于深度图：<code>Image Type</code>: <code>16-bit unsigned</code></li><li>对于彩色图：<code>Image Type</code>: <code>24-bit RGB</code></li><li>宽度和高度一定要设置正确</li></ul></li><li><code>File-&gt;Save As-&gt;PNG...</code>，得到以下图像：</li></ul><table><thead><tr><th align="center">深度图</th><th align="center">彩色图</th></tr></thead><tbody><tr><td align="center"><img src="/images/2025/01/depth.jpeg"></td><td align="center"><img src="/images/2025/01/rgb.jpeg"></td></tr></tbody></table><ul><li>这只是针对单帧图像，对于大量图片如果单帧处理效率太低，可以通过 ImageJ 批量操作，具体看参考中链接。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.yahboom.com/public/upload/upload-html/1640400269/Astra%E7%9B%B8%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html">https://www.yahboom.com/public/upload/upload-html/1640400269/Astra%E7%9B%B8%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</a></li><li><a href="https://developer.orbbec.com.cn/module.html?id=4">https://developer.orbbec.com.cn/module.html?id=4</a></li><li><a href="https://blog.csdn.net/qianchuohuan3821/article/details/89498146">https://blog.csdn.net/qianchuohuan3821/article/details/89498146</a></li><li><a href="https://www.bilibili.com/opus/591919202890504930">https://www.bilibili.com/opus/591919202890504930</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/01/06/RGBD-Camera-on-Astra-S/">https://blog.jujimeizuo.cn/2025/01/06/RGBD-Camera-on-Astra-S/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;最近被导师派任务，需要自己采集数据并恢复出三维结构，所以向师兄借用了一个 Astra-S 深度相机，这里记录一下初始使用过程，包括如何安装驱动，如何使用 SDK，如何将数据转换。&lt;/li&gt;
&lt;li&gt;我使用 Ubuntu22.04，Win</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Install OpenCV in Ubuntu via Source</title>
    <link href="https://blog.jujimeizuo.cn/2025/01/06/install-opencv-in-ubuntu-via-source/"/>
    <id>https://blog.jujimeizuo.cn/2025/01/06/install-opencv-in-ubuntu-via-source/</id>
    <published>2025-01-06T00:34:26.000Z</published>
    <updated>2025-04-17T01:05:45.415Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当我在 ubuntu 22.04 中安装 OrbeecSDK 时，需要用到 OpenCV 库，而且是 C++ Version，如果是 Python Version 的话，可以直接通过 pip 安装，但是 C++ Version 的话，会比较麻烦。<br>这篇 <a href="https://zhuanlan.zhihu.com/p/392751819">在 Linux 系统中编译安装 OpenCV</a> 写得非常详细。</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>安装前需要先安装一些依赖库，根据需要安装</li><li>安装过程中会在 make 中卡住，需要等待一大段时间</li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/01/06/install-opencv-in-ubuntu-via-source/">https://blog.jujimeizuo.cn/2025/01/06/install-opencv-in-ubuntu-via-source/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;当我在 ubuntu 22.04 中安装 OrbeecSDK 时，需要用到 OpenCV 库，而且是 C++ Version，如果是 Python Version 的话，可以直接通过 pip 安装，但是 C++ Version 的话，会比较麻烦。&lt;</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
    <category term="opencv" scheme="https://blog.jujimeizuo.cn/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Activate-MathType</title>
    <link href="https://blog.jujimeizuo.cn/2025/01/03/activate-mathtype/"/>
    <id>https://blog.jujimeizuo.cn/2025/01/03/activate-mathtype/</id>
    <published>2025-01-03T00:21:14.000Z</published>
    <updated>2025-05-09T07:08:03.118Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Win 中通过删除注册表项来重置 MathType 的试用期</p></blockquote><h2 id="打开注册表"><a href="#打开注册表" class="headerlink" title="打开注册表"></a>打开注册表</h2><ol><li><code>Win + R</code> -&gt; <code>regedit</code></li></ol><h2 id="删除注册表项"><a href="#删除注册表项" class="headerlink" title="删除注册表项"></a>删除注册表项</h2><ol><li>删除 <code>HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\wiris\editor\license</code></li></ol><img src="/images/2025/03/delete-mathtype-in-regedit.png" width="50%"><ol start="2"><li>删除 <code>HKEY_CURRENT_USER\Software\Install Options</code> 下的 <code>Options 7.8</code></li></ol><img src="/images/2025/01/delete-mathtype-in-regedit.png" width="50%"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.changchenghao.cn/n/725494.html">https://www.changchenghao.cn/n/725494.html</a></li><li><a href="https://www.cnblogs.com/JasonCeng/p/15710426.html">https://www.cnblogs.com/JasonCeng/p/15710426.html</a></li><li><a href="https://blog.csdn.net/m0_46667062/article/details/134808661">https://blog.csdn.net/m0_46667062/article/details/134808661</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2025/01/03/activate-mathtype/">https://blog.jujimeizuo.cn/2025/01/03/activate-mathtype/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在 Win 中通过删除注册表项来重置 MathType 的试用期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;打开注册表&quot;&gt;&lt;a href=&quot;#打开注册表&quot; class=&quot;headerlink&quot; title=&quot;打开注册表&quot;&gt;&lt;/a&gt;打开注册</summary>
      
    
    
    
    
    <category term="utils" scheme="https://blog.jujimeizuo.cn/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>The Big Bug in Python</title>
    <link href="https://blog.jujimeizuo.cn/2024/10/15/code-way-in-python/"/>
    <id>https://blog.jujimeizuo.cn/2024/10/15/code-way-in-python/</id>
    <published>2024-10-15T13:53:10.000Z</published>
    <updated>2025-04-17T01:04:55.789Z</updated>
    
    <content type="html"><![CDATA[<p>找了一下午的 Bug，结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wandb.log</span><br><span class="line">(</span><br><span class="line">    &#123;</span><br><span class="line">        key=value,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>python 不是 C++，wandb.log 单独成为一行代码！！！应该写成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wandb.log(</span><br><span class="line">    &#123;</span><br><span class="line">        key=value,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/10/15/code-way-in-python/">https://blog.jujimeizuo.cn/2024/10/15/code-way-in-python/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;找了一下午的 Bug，结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    
    <category term="utils" scheme="https://blog.jujimeizuo.cn/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>Root-Partition Filled</title>
    <link href="https://blog.jujimeizuo.cn/2024/10/07/root-partition-filled/"/>
    <id>https://blog.jujimeizuo.cn/2024/10/07/root-partition-filled/</id>
    <published>2024-10-07T13:30:46.000Z</published>
    <updated>2024-10-07T13:35:17.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>当我在 docker 容器内 apt install 时，提示根分区即将爆满，所以查询相关内容解决问题。</li><li>以下都是在 ubuntu20.04 下实验。</li></ul></blockquote><h2 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h2><p>关于 linux 的磁盘命令，都会使用 <code>dh</code> 或 <code>df</code> 命令，如果要找导致磁盘空间满的目录或文件，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/* 2&gt;/dev/null | <span class="built_in">sort</span> -hr | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure><ol><li>发现 <code>/var</code> 的占空间太大，查询 <code>/var</code> 后，发现它是<strong>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</strong>，再次使用命令，查询 <code>var</code> 目录下的较大目录或文件</li><li>发现有几个目录占比非常大，<code>lib</code>, <code>cache</code>, <code>log</code>, <code>tmp</code> 等等，<code>cache</code> 可以直接删除，<code>log</code> 可以使用命令 <code>journalctl --vacuum - time=7d</code>，删除超过 7 天的旧日志，现在具体来看 <code>/var/lib</code> 目录</li><li>发现 <code>/var/lib/docker</code> 占 40 多个 G，原来镜像的位置保存在这个目录，当然很大，具体查看 <code>overlay2</code> 的性质。现在针对这个目录做一些操作。一般 <code>/home</code> 目录非常大，所以如果把 docker 里的镜像位置都放在 <code>/home</code> 目录，那么会大大减少根分区的磁盘空间，那么开始操作！</li></ol><h2 id="修改-Docker-镜像默认存储位置"><a href="#修改-Docker-镜像默认存储位置" class="headerlink" title="修改 Docker 镜像默认存储位置"></a>修改 Docker 镜像默认存储位置</h2><blockquote><p>由于系统初始分区的原因，导致操作系统中对应根分区不会太大，通过 &#x2F;var 目录不会单独分区。而 docker 镜像默认存储位置是在 <code>/var/lib/docker</code> 下，是使根分区爆炸。<br>查看 docker 容器存放位置：<code>sudo docker info | grep &quot;Docker Root Dir&quot;</code></p></blockquote><h3 id="使用软链接"><a href="#使用软链接" class="headerlink" title="使用软链接"></a>使用软链接</h3><p>解决默认存储容量不足的情况，最直接且最有效的方法就是挂载新的分区到该目录。但是在原有系统空间不变的情况下，所以采用软链接的方式，修改镜像和容器的存放路径达到同样的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /var/lib/docker /path/to/docker</span><br><span class="line"><span class="built_in">ln</span> -sf /path/to/docker /var/lib/docker</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="指定容器启动参数"><a href="#指定容器启动参数" class="headerlink" title="指定容器启动参数"></a>指定容器启动参数</h3><p>在配置文件中指定容器启动的参数 –graph&#x3D;&#x2F;var&#x2F;lib&#x2F;docker 来指定镜像和容器存放路径。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1835999">https://cloud.tencent.com/developer/article/1835999</a></li><li><a href="https://blog.csdn.net/BigData_Mining/article/details/104921479">https://blog.csdn.net/BigData_Mining/article/details/104921479</a></li><li><a href="https://blog.csdn.net/wjciayf/article/details/50717773">https://blog.csdn.net/wjciayf/article/details/50717773</a></li><li><a href="https://www.51cto.com/article/707120.html">https://www.51cto.com/article/707120.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1870764">https://cloud.tencent.com/developer/article/1870764</a></li><li><a href="https://www.cnblogs.com/loveer/p/11615627.html">https://www.cnblogs.com/loveer/p/11615627.html</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/10/07/root-partition-filled/">https://blog.jujimeizuo.cn/2024/10/07/root-partition-filled/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当我在 docker 容器内 apt install 时，提示根分区即将爆满，所以查询相关内容解决问题。&lt;/li&gt;
&lt;li&gt;以下都是在 ubuntu20.04 下实验。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Arc Sync</title>
    <link href="https://blog.jujimeizuo.cn/2024/09/23/Arc-Sync/"/>
    <id>https://blog.jujimeizuo.cn/2024/09/23/Arc-Sync/</id>
    <published>2024-09-23T11:59:56.000Z</published>
    <updated>2025-05-09T07:08:03.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Arc 已经快 1 年，最近才发现有 Arc Sync 有在 MacOS、PC、IOS 上的同步问题（目前仅同步 SideBar，遥看未来）。<br>有什么好处？如果你在 work 的时候，突然要离开工位，如果想要在 iPhone 上继续查看电脑上的网页，那么一般情况下你会重新搜索 URL，但是 Arc Sync，可以将电脑上打开的网页直接同步到 iPhone 上，快捷方便！</p></blockquote><h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><ol><li>下载 Arc Desktop (MacOS)、ClashX Pro</li><li>Clash pro 中开启<strong>增强模式 TUN Mode</strong>，ClashX 里没有增强模式</li></ol><center><img src="/images/2024/09/arc-sync-mac-clashpro.jpg" width="20%"></center><ol start="3"><li>在 Arc Desktop 中登录账号，<code>Preferences</code> -&gt; <code>Sync SideBar</code></li></ol><center><table><tr><td><img src="/images/2024/09/arc-sync-mac.jpg"></td><td><img src="/images/2024/09/arc-sync-mac-sidebar.jpg" width="70%"></td></tr></table></center><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><ol><li>下载 Arc Desktop (Windows)、Clash for Windows</li><li>Clash for Windows 中开启<strong>增强模式 TUN Mode</strong><ol><li>Windows 无法顺利登陆，进行以下操作</li><li>旁边有一个叹号❗️，提示安装 service mode，<code>service mode</code> -&gt; <code>Manage</code> -&gt; <code>Install</code></li><li>点击 TUN Node 右边的齿轮 ⚙️，点击 DNS IPv6，Save</li><li>重启 Arc</li></ol></li><li>在 Arc Desktop 中登录账号，<code>Settings</code> -&gt; <code>SideBar Sync</code></li></ol><center><img src="/images/2024/09/arc-sync-windows.jpg" width="70%"></center><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><ol><li>从 App Store 下载 Arc Search</li><li>点击右下角 Settings，选择 <code>Sync with Arc Desktop</code>，输入账号密码即可</li><li>点击左下角即可看到同步的 SideBar，包括同时打开的标签页</li><li>记得开魔法</li></ol><center><img src="/images/2024/09/arc-sync-ios.png" width="20%"></center><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/09/23/Arc-Sync/">https://blog.jujimeizuo.cn/2024/09/23/Arc-Sync/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用 Arc 已经快 1 年，最近才发现有 Arc Sync 有在 MacOS、PC、IOS 上的同步问题（目前仅同步 SideBar，遥看未来）。&lt;br&gt;有什么好处？如果你在 work 的时候，突然要离开工位，如果想要在 iPhone 上继续查看</summary>
      
    
    
    
    
    <category term="utils" scheme="https://blog.jujimeizuo.cn/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode BitWeek 139</title>
    <link href="https://blog.jujimeizuo.cn/2024/09/15/LeetCode-BitWeek-139/"/>
    <id>https://blog.jujimeizuo.cn/2024/09/15/LeetCode-BitWeek-139/</id>
    <published>2024-09-15T00:17:12.000Z</published>
    <updated>2024-09-15T00:58:52.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3285-找到稳定山的下标"><a href="#3285-找到稳定山的下标" class="headerlink" title="3285. 找到稳定山的下标"></a>3285. 找到稳定山的下标</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stableMountains</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stable = []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> height[i - <span class="number">1</span>] &gt; threshold:</span><br><span class="line">                stable.append(i)</span><br><span class="line">        <span class="keyword">return</span> stable</span><br></pre></td></tr></table></figure><h2 id="3286-穿越网格图的安全路径"><a href="#3286-穿越网格图的安全路径" class="headerlink" title="3286. 穿越网格图的安全路径"></a>3286. 穿越网格图的安全路径</h2><p>经典 BFS + dp，设 dp[x][y][h] 表示到达 (x, y) 时剩余 h 血量<strong>是否被走过</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findSafeWalk</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> health)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(grid.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; dx &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">const</span> <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; dy &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;std::vector&lt;std::vector&lt;<span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">visited</span>(n, std::vector&lt;std::vector&lt;<span class="type">bool</span>&gt;&gt;(m, std::<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(health + <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">        std::queue&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, health - grid[<span class="number">0</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>][health] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y, h] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == n - <span class="number">1</span> <span class="keyword">and</span> y == m - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt;= m <span class="keyword">or</span> h - grid[nx][ny] &lt;= <span class="number">0</span> <span class="keyword">or</span> visited[nx][ny][h - grid[nx][ny]]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;nx, ny, h - grid[nx][ny]&#125;);</span><br><span class="line">                visited[nx][ny][h - grid[nx][ny]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3287-求出数组中最大序列值"><a href="#3287-求出数组中最大序列值" class="headerlink" title="3287. 求出数组中最大序列值"></a>3287. 求出数组中最大序列值</h2><ul><li>前后缀分解 + dp</li><li>设 prefix_or[i][j][mask] 表示 1-i 个数中选 j 个数，使得这 j 个数的或值为 mask。</li><li>设 suffix_or[i][j][mask] 表示 i-n 个数中选 j 个数，使得这 j 个数的或值为 mask。</li><li>if (prefix_or[i][k][mask1] &amp;&amp; suffix_or[i + 1][k][mask2]) ans &#x3D; std::max(ans, mask1 ^ mask2)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> STATE = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"><span class="type">bool</span> prefix_or[<span class="number">402</span>][<span class="number">201</span>][STATE];</span><br><span class="line"><span class="type">bool</span> suffix_or[<span class="number">402</span>][<span class="number">201</span>][STATE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; STATE; mask += <span class="number">1</span>) &#123;</span><br><span class="line">        prefix_or[i][j][mask] = suffix_or[i][j][mask] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        prefix_or[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        suffix_or[n + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - k; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(i, k); j += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; STATE; mask += <span class="number">1</span>) &#123;</span><br><span class="line">    prefix_or[i][j][mask] = prefix_or[i][j][mask] | prefix_or[i - <span class="number">1</span>][j][mask];</span><br><span class="line">        <span class="keyword">if</span> (j)</span><br><span class="line">        prefix_or[i][j][mask | a[i - <span class="number">1</span>]] = prefix_or[i][j][mask | a[i - <span class="number">1</span>]] | prefix_or[i - <span class="number">1</span>][j - <span class="number">1</span>][mask];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= k + <span class="number">1</span>; i -= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">min</span>(n - i + <span class="number">1</span>, k); j += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; STATE; mask += <span class="number">1</span>) &#123;</span><br><span class="line">        suffix_or[i][j][mask] = suffix_or[i][j][mask] | suffix_or[i + <span class="number">1</span>][j][mask];</span><br><span class="line">        <span class="keyword">if</span> (j)</span><br><span class="line">        suffix_or[i][j][mask | a[i - <span class="number">1</span>]] = suffix_or[i][j][mask | a[i - <span class="number">1</span>]] | suffix_or[i + <span class="number">1</span>][j - <span class="number">1</span>][mask];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i + k &lt;= n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask1 = <span class="number">0</span>; mask1 &lt; STATE; mask1 += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prefix_or[i][k][mask1]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask2 = <span class="number">0</span>; mask2 &lt; STATE; mask2 += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!suffix_or[i + <span class="number">1</span>][k][mask2]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, mask1 ^ mask2);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3288-最长上升路径的长度"><a href="#3288-最长上升路径的长度" class="headerlink" title="3288. 最长上升路径的长度"></a>3288. 最长上升路径的长度</h2><ul><li>二维 LIS，先按照 x 从小到大排序，对于 x 相同的点，按照 y 从大到小排序，保证计算 y 的 LIS 时，相同的 x 最多选一个 y。</li><li>选择 x &lt; kx &amp;&amp; y &lt; ky 或 x &gt; kx &amp;&amp; y &gt; ky 的点，计算 LIS。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathLength</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; coordinates, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(coordinates.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">sort</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (coordinates[i][<span class="number">0</span>] == coordinates[j][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> coordinates[i][<span class="number">1</span>] &gt; coordinates[j][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coordinates[i][<span class="number">0</span>] &lt; coordinates[j][<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((coordinates[order[i]][<span class="number">0</span>] &lt; coordinates[k][<span class="number">0</span>] <span class="keyword">and</span> coordinates[order[i]][<span class="number">1</span>] &lt; coordinates[k][<span class="number">1</span>]) </span><br><span class="line">        <span class="built_in">or</span> (coordinates[order[i]][<span class="number">0</span>] &gt; coordinates[k][<span class="number">0</span>] <span class="keyword">and</span> coordinates[order[i]][<span class="number">1</span>] &gt; coordinates[k][<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), coordinates[order[i]][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (it == u.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        u.<span class="built_in">push_back</span>(coordinates[order[i]][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *it = coordinates[order[i]][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) u.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/09/15/LeetCode-BitWeek-139/">https://blog.jujimeizuo.cn/2024/09/15/LeetCode-BitWeek-139/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3285-找到稳定山的下标&quot;&gt;&lt;a href=&quot;#3285-找到稳定山的下标&quot; class=&quot;headerlink&quot; title=&quot;3285. 找到稳定山的下标&quot;&gt;&lt;/a&gt;3285. 找到稳定山的下标&lt;/h2&gt;&lt;figure class=&quot;highlight py</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Linux Permissions</title>
    <link href="https://blog.jujimeizuo.cn/2024/06/05/Linux-Permissions/"/>
    <id>https://blog.jujimeizuo.cn/2024/06/05/Linux-Permissions/</id>
    <published>2024-06-05T07:02:08.000Z</published>
    <updated>2025-04-17T01:07:06.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>Linux 系统上对文件的权限有着严格的控制，如果想对某个文件执行某种操作，必须具有对应的权限方可执行成功。</li><li>Linux 下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。</li><li>Linux 下权限的粒度有<strong>拥有者</strong>、<strong>群组</strong>、<strong>其它组</strong>三种。每个文件都可以针对三个粒度，设置不同的 rwx (读写执行)权限。通常情况下，一个文件只能归属于一个用户和组，如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li><li>Linux 上通常使用 chmod 命令对文件的权限进行设置和更改。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><blockquote><p>更改文件权限，<code>chmod [Option] &lt;mode&gt; &lt;file...&gt;</code></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line"> </span><br><span class="line">[Option]</span><br><span class="line">  -c, --changes          like verbose but report only when a change is made (若该档案权限确实已经更改，才显示其更改动作)</span><br><span class="line">  -f, --silent, --quiet  suppress most error messages  （若该档案权限无法被更改也不要显示错误讯息）</span><br><span class="line">  -v, --verbose          output a diagnostic for every file processed（显示权限变更的详细资料）</span><br><span class="line">       --no-preserve-root  do not treat &#x27;/&#x27; specially (the default)</span><br><span class="line">       --preserve-root    fail to operate recursively on &#x27;/&#x27;</span><br><span class="line">       --reference=RFILE  use RFILE&#x27;s mode instead of MODE values</span><br><span class="line">  -R, --recursive        change files and directories recursively （以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更)</span><br><span class="line">       --help显示此帮助信息</span><br><span class="line">       --version显示版本信息</span><br><span class="line">[mode] </span><br><span class="line">    权限设定字串，详细格式如下 ：</span><br><span class="line">    [ugoa...][[+-=][rwxX]...][,...]，</span><br><span class="line">    其中</span><br><span class="line">    [ugoa...]</span><br><span class="line">    u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示所有（包含上面三者）。</span><br><span class="line">    [+-=]</span><br><span class="line">    + 表示增加权限，- 表示取消权限，= 表示唯一设定权限。</span><br><span class="line">    [rwxX]</span><br><span class="line">    r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</span><br><span class="line"> </span><br><span class="line">[file...]</span><br><span class="line">    文件列表（单个或者多个文件、文件夹）</span><br></pre></td></tr></table></figure><h3 id="rwx"><a href="#rwx" class="headerlink" title="rwx"></a>rwx</h3><p>数字可以表示权限，规定数字 4、2、1 分别表示读、写、执行权限，即 r&#x3D;4，w&#x3D;2，x&#x3D;1。例如经常看到的 777 就是 rwxrwxrwx。</p><p>用数字权限更改格式：<code>chmod &lt;abc&gt; file...</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中</span><br><span class="line">a,b,c各为一个数字，分别代表User、Group、及Other的权限。</span><br><span class="line">相当于简化版的</span><br><span class="line">chmod u=权限,g=权限,o=权限 file...</span><br><span class="line">而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限</span><br></pre></td></tr></table></figure><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw------- (600)    只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700)    只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666)    所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777)    所有用户都有读、写、执行权限。</span><br></pre></td></tr></table></figure><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><blockquote><p>更改文件拥有者，<code>chown [Option] user[:group] file...</code></p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用权限：root</span><br><span class="line"> </span><br><span class="line">说明：</span><br><span class="line">[Option] : 同上文chmod</span><br><span class="line">user : 新的文件拥有者的使用者 </span><br><span class="line">group : 新的文件拥有者的使用者群体(group)</span><br></pre></td></tr></table></figure><p>例如在普通用户下会经常看到某些文件夹&#x2F;文件“<strong>上锁</strong>”。</p><p>如果用 <code>sudo chmod -R 777</code>，递归将所有文件更改权限，当然能解锁，但是会有很大危险。<br>这个时候就可以用 chown，将文件&#x2F;文件夹的拥有者更改为任意用户，即可解锁🔓。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/u013197629/article/details/73608613">Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）</a></li><li><a href="https://www.cnblogs.com/guojiaxue/p/13084253.html">去除Ubuntu文件夹有锁标志的方法（包含目录下所有文件解锁）</a></li><li><a href="https://blog.csdn.net/weixin_44260459/article/details/122713532">Ubuntu系统下文件带小锁如何解决</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/06/05/Linux-Permissions/">https://blog.jujimeizuo.cn/2024/06/05/Linux-Permissions/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Linux 系统上对文件的权限有着严格的控制，如</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.jujimeizuo.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Visual SLAM and SfM in Dynamic Environments: A Survey</title>
    <link href="https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/"/>
    <id>https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/</id>
    <published>2024-05-27T01:03:02.000Z</published>
    <updated>2025-05-09T07:08:03.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>本文介绍 <strong>VSLAM</strong> 和 <strong>SfM</strong> 在<strong>动态环境</strong>下目前所有技术相关的综述。</p></blockquote><p>回顾动态环境中的视觉定位和 3D 重建技术：</p><ul><li>涵盖三个主要问题：<ol><li>如何做好鲁棒 VSLAM</li><li>如何在 3D 中分割和跟踪动态物体</li><li>如何实现联合运动分割和重建</li></ol></li><li>从两个角度来看：<ol><li>作为一个鲁棒性问题：相机前的动态物体导致错误的对应关系（遮挡等），可以通过分割图像中静态和动态特征，将动态部分视为异常值来实现鲁棒性，只用静态部分计算姿态估计。</li><li>作为一个标准 VSLAM 在动态环境中的扩展：将跟踪的特征分割成不同的簇，可以重建每个物体结构（形状）并跟踪轨迹，甚至可以将动态物体插入静态地图中。</li></ol></li><li>现有大致三种思路（分别对应三个主要问题）：<ol><li>排除动态特征来构建静态地图</li><li>提取动态物体而忽略静态背景</li><li>试图同时处理世界中静态和动态的组成成分</li></ol></li></ul><h2 id="综述结构"><a href="#综述结构" class="headerlink" title="综述结构"></a>综述结构</h2><ul><li>鲁棒 VSLAM<ol><li>运动分割<ol><li>背景&#x2F;前景初始化</li><li>几何约束</li><li>光流</li><li>自我运动约束</li><li>深度学习</li></ol></li><li>定位与 3D 重建<ol><li>基于特征</li><li>深度学习</li></ol></li></ol></li><li>动态物体分割与 3D 跟踪<ol><li>动态物体分割<ol><li>统计模型选择</li><li>子空间聚类</li><li>几何</li><li>深度学习</li></ol></li><li>动态物体的 3D 跟踪<ol><li>轨迹三角测量</li><li>粒子滤波</li></ol></li></ol></li><li>联合运动分割与重建<ol><li>因子分解<ol><li>多刚体运动结构（MBSfM）</li><li>非刚性运动结构（NRSfM）</li></ol></li></ol></li></ul><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-1.jpg"></center><h2 id="鲁棒-VSLAM"><a href="#鲁棒-VSLAM" class="headerlink" title="鲁棒 VSLAM"></a>鲁棒 VSLAM</h2><blockquote><p>如果仅基于静态特征计算姿态估计，就可以在动态环境中实现 Robust VSLAM。</p></blockquote><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-2.jpg"></center><h3 id="运动分割"><a href="#运动分割" class="headerlink" title="运动分割"></a>运动分割</h3><blockquote><p>将特征分为两个不同的组，即静态特征和动态特征，来检测图像中的动态部分。</p></blockquote><p>标准的 VSLAM 使用 <strong>计算几何模型（基础&#x2F;单应矩阵）</strong>、<strong>RANSAC</strong>、<strong>辛普森距离</strong> 等去除动态特征点。</p><ul><li>如果静态特征占多数，效果会很好。</li><li>如果相机前的动态物体占据较大，效果不好，其他方法可以利用 <strong>IMU</strong> 估计相机的自我运动来解决。</li></ul><h4 id="背景-前景初始化"><a href="#背景-前景初始化" class="headerlink" title="背景&#x2F;前景初始化"></a>背景&#x2F;前景初始化</h4><p>假设系统对环境有<strong>先验知识</strong>，可以利用该信息来分割。这种先验知识可以附加到背景或前景对象上。如果信息是关于前景对象的，则系统知道在相机前移动的对象的类型或形状。</p><h4 id="几何约束"><a href="#几何约束" class="headerlink" title="几何约束"></a>几何约束</h4><p>利用对极几何特性来分割静态和动态特征。动态特征违反静态场景中在多视图几何中定义的约束，可以从<strong>对极方程</strong>、<strong>三角测量</strong>、<strong>基础矩阵</strong>估计或<strong>重投影误差</strong>中推导出。</p><h4 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h4><p>光流定义了从两个连续图像计算得出的亮度模式的表观运动，对应于图像中的运动场，利用图割算法基于该运动度量来分割动态物体。还有 <strong>3D 版本的场景流</strong>。</p><h4 id="自我运动约束"><a href="#自我运动约束" class="headerlink" title="自我运动约束"></a>自我运动约束</h4><p>标准的 SfM 和 VSLAM 通过<strong>八点法</strong>或<strong>五点法</strong>来计算相机运动。另一种方法假设相机根据给定的外部信息（e.g. 车轮里程计信息）按照特定的参数化进行移动。通过这种强制自我运动约束，可以拟合与相机运动约束相匹配的特征点来对静态特征进行分类。</p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>从基于特征的运动分割中，上述可以利用光流来分割动态物体。所以可以<strong>通过监督学习来估计光流</strong>。</p><ol><li><strong>FlowNetS</strong>：通过将两张连续图像堆叠作为 CNN 的输入</li><li><strong>FlowNetC</strong>：通过引入一个相关层来比较由两个相同 CNN 流得到的两个特征图</li><li><strong>FlowNet 2.0</strong>:将  <strong>FlowNetS</strong> 和 <strong>FlowNetC</strong> 堆叠成一个更深的网络，并添加一个新的并行网络来处理小位移</li><li>使用立体图像进行场景流估计的扩展，这种光流可以输入到一个更深的网络中以发现运动特征</li><li>在图像空间中明确分割动态物体，采用重建独立成分分析自编码器来学习时空特征。然而，由于时空特征无法学习运动的 3D 几何形状，因此仍然使用几何特征来帮助分割运动。几何和时空特征都被输入到 RNN 中，以进行最终的运动分割</li><li>通过回归给定的 RGB 图像和光流的目标性的粉来分割动态物体。构建两个类似 AlexNet 的并行 CNN，处理 RGB 图像和光流，然后输入到回归网络并生成运动</li><li><strong>R-FCN</strong>：从在线图像序列中分割前景运动时结合实践数据，<strong>FCN</strong> 用于学习空间特征并生成像素稠密预测，但在应用反卷积之前，使用 <strong>GRU</strong> 来建模时间特征。</li></ol><h3 id="定位与-3D-重建"><a href="#定位与-3D-重建" class="headerlink" title="定位与 3D 重建"></a>定位与 3D 重建</h3><blockquote><p>从多张图像中估计相对相机姿态（平移和旋转）以及所观察环境的 3D 结构。</p></blockquote><ul><li>基于特征</li><li>基于深度学习</li></ul><h4 id="基于特征"><a href="#基于特征" class="headerlink" title="基于特征"></a>基于特征</h4><p>在基于特征的 VSLAM 中，提取显著特征来解决图像对应问题。现有的特征提取技术：</p><ol><li>Harris</li><li>SIFT</li><li>SURF</li><li>FAST</li></ol><p>为找到对应关系，使用特征匹配。根据两个相机的光心之间的距离（基线&#x2F;视差）分开的程度来划分。</p><ul><li>基于短基线：可以用基于光流的技术进行匹配</li><li>对于长基线：需要有高度区分度的特征描述子，例如 <strong>SIFT</strong>、<strong>SURF</strong>、<strong>BRIEF</strong>、<strong>BRISK</strong> 等，通过计算这些描述子之间的不相似性来找到对应关系，当数据包含异常值时，需要使用 <strong>RANSAC</strong>、<strong>PROSAC</strong>、<strong>MLESAC</strong> 等排除异常值。</li></ul><p>当图像对应关系已知，2-3 张图像之间的相对位姿可以恢复到一个比例因子。通过对极约束，</p><ol><li>两个视图用八点法或五点法</li><li>三个视图用三交点张量</li><li>如果已经重建了场景的一些 3D 点，可以用 P3P</li></ol><p>当相机位姿被恢复时，通过<strong>三角测量</strong>对两条投影射线进行相交，得到重建场景的 3D 点，但是由于错误的对应关系射线并不总是相交，可以用<strong>中点法</strong>或<strong>最小二乘法</strong>估计交点。为了避免漂移问题，用 <strong>BA</strong> 通过最小化重投影误差来同时相机位姿和 3D 点。另一种高斯-牛顿方法的变体 <strong>LM</strong> 优化。是联合优化场景结构和相机运动的主流方法。</p><p>实际上，有人采用<strong>局部 BA</strong> 优化最后几张图像，比如 ORB-SLAM 中就用到了。</p><h4 id="基于深度学习"><a href="#基于深度学习" class="headerlink" title="基于深度学习"></a>基于深度学习</h4><p>两种主流的方法：</p><ol><li>有监督学习</li></ol><p>监督学习通过最小化与真实姿态相比在预测自我运动时的误差来训练 CNN。在早期工作中，姿态估计被视为在相机平移和旋转的离散空间上的<strong>分类问题</strong>。但近期姿态估计技术都采用基于<strong>回归</strong>的 CNN。由于预测的连续性，回归比分类更准确。</p><p>在回归视觉里程计问题中，目标检测和分类的预训练卷机曾不适用，后续转向基于光流的网络以在不同的环境中泛化学习到的参数。</p><ul><li><strong>Flowdometry</strong>：由两个连续的 CNN 组成，第一个用于预测光流，第二个估计相机运动</li><li>计算两个视图之间自我运动的端到端 CNN，堆叠两个具有具有权重共享的并行 CNN，随后是一个空间金字塔池化 SPP 层，以处理任意输入图像，同时在特征图中保持空间信息。回归层由两个全连接层组成，用于预测相机平移和旋转</li><li><strong>DeepVO</strong>：通过 <strong>RCNN</strong>，从图像序列中学习顺序运动动力学的端到端学习框架。在输出里程计方面效果较好。</li></ul><ol start="2"><li>无监督学习</li></ol><p>在无监督的情况下，CNN 没有真实数据进行训练。相反，该网络通过最小化类似于 <strong>LSD-SLAM</strong> 的光度误差来学习预测相机位姿。</p><ul><li>利用新颖视图合成原则（给定一个源图像合成具有不同位姿的目标图像的问题）。构建两个并行的 CNN 用于预测深度和估计相机位姿。来自源图像的预测深度用于在给定相机变换矩阵和源图像的情况下合成目标图像。通过最小化光度误差，共同训练深度和相机位姿。而不是从深度预测生成目标图像。</li><li>基于深度预测、相机运动以及卷积&#x2F;反卷积网络产生的动态对象分割构建了一个 3D 场景流。场景流通过相机运动进行变换，然后反投影到当前帧以评估光度误差。</li></ul><h2 id="动态物体分割与-3D-跟踪"><a href="#动态物体分割与-3D-跟踪" class="headerlink" title="动态物体分割与 3D 跟踪"></a>动态物体分割与 3D 跟踪</h2><blockquote><p>动态对象分割和 3D 跟踪将特征对应关系基于其运动聚类到不同组中，并在 3D 中跟踪它们的轨迹。</p></blockquote><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-3.jpg"></center><h3 id="动态物体分割"><a href="#动态物体分割" class="headerlink" title="动态物体分割"></a>动态物体分割</h3><blockquote><p>动态物体分割将所有特征对应关系聚类为 n 个不同对象运动。另一个挑战是处理<strong>退化运动</strong>（当一个物体与相机运动在同一平面上且具有相同的方向和速度时）或<strong>相关运动</strong>（两个人一起移动，关节运动）。</p></blockquote><h4 id="统计模型选择"><a href="#统计模型选择" class="headerlink" title="统计模型选择"></a>统计模型选择</h4><p>用 <strong>RANSAC</strong> 或<strong>蒙特卡罗采样迭代</strong>下对数据的子集进行采样，并将运动模型拟合到采样数据中。改运动模型用于构建内点集，并将剩余数据排除为该模型的异常值。然后，对剩余数据（前一个模型的异常值）在此进行采样，以找到并拟合最能描述剩余数据的另一个模型。</p><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-4.jpg"></center><h4 id="子空间聚类"><a href="#子空间聚类" class="headerlink" title="子空间聚类"></a>子空间聚类</h4><p>许多高维数据可以用低维子空间的并集来表示。数据点的一个子空间可以由基向量和低维数据来表示。在子空间聚类框架下的 3D 运动分割问题基本上是找到与每个刚体运动相关联的每个单独子空间，并将数据拟合到这些子空间中。</p><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-5.jpg"></center><h4 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h4><p>几何方法将多视图几何的标准公式从静态场景扩展到包含独立运动物体的动态场景。虽然有一个基本矩阵描述相机相对于静态场景的一般运动，但在动态环境中，将会有 n 个基本矩阵来描述 n 个物体的运动，其中包括一个用于静态特征。</p><ul><li>通过引入多体三线性约束和多体三焦点张量，将多体运动恢复从两个视图扩展到三个视图。将静态场景中的三线性约束和三焦点张量推广到包含多个物体的动态场景。</li></ul><h4 id="深度学习-1"><a href="#深度学习-1" class="headerlink" title="深度学习"></a>深度学习</h4><p>当前用于解决动态物体分割问题的 DNN 依赖于预定义数量的刚体运动。用于生成稠密对象掩码的网络及其相关损失函数可能源自 3D 点云数据或光流。</p><ul><li><strong>SE3-Net</strong>：一种能够从 3D 点云中分割出预定义的 n 个动态对象的 DNN，在 SE(3) 变换中表示。</li><li><strong>SfM-Net</strong>：利用光流来分割动态对象。这是一个能够预测深度、相机运动和动态对象分割的具有几何感知能力的网络。</li></ul><h3 id="动态物体的-3D-跟踪"><a href="#动态物体的-3D-跟踪" class="headerlink" title="动态物体的 3D 跟踪"></a>动态物体的 3D 跟踪</h3><blockquote><p>在 3D 中跟踪动态物体，需要知道动态物体在三维的坐标位置（包括深度信息）。</p></blockquote><h4 id="轨迹三角测量"><a href="#轨迹三角测量" class="headerlink" title="轨迹三角测量"></a>轨迹三角测量</h4><p>标准三角测量，对动态物体并不起作用，因为从相应特征点反向投影的光线并不相交。<br><strong>轨迹三角测量</strong>，作为一种当物体轨迹已知或满足一个参数形式时重建运动物体三维点的技术。</p><ul><li>假设三维点沿着一条未知的三维直线移动。然后重建问题就会变成寻找一条与来自 t 个视图的投影光线相交的三维直线的问题。t 至少是 5。因为来自三个视图的相交直线集会形成一个二次曲面，使得来自第四个视图的光线在两个点相交，此时第五个视图会得出唯一解。</li><li>假设物体不是沿一条直线运动，而是在一个圆锥曲面上运动，则需要 9 个视图得到唯一解。如果圆锥类型已知，则只需要 7 个视图。</li></ul><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-6.jpg"></center><h4 id="粒子滤波"><a href="#粒子滤波" class="headerlink" title="粒子滤波"></a>粒子滤波</h4><p>由于可观测性问题（观测者与目标之间的距离无法被观测到），使用单目相机在三维中跟踪运动物体的问题可以被视为仅方位跟踪（BOT）问题。单目相机可以被视为一个仅方位跟踪传感器，因为它只能提供关于运动物体上被跟踪特征点的方位信息（例如，前一帧和当前帧中观测到的特征相对于相机中心的角度）。对于仅方位跟踪问题，基于滤波器的方法是更可取的，因为它可以对观测者和目标的位置和速度的不确定性进行建模，并且作为目标运动分析问题。</p><h2 id="联合运动分割与重建"><a href="#联合运动分割与重建" class="headerlink" title="联合运动分割与重建"></a>联合运动分割与重建</h2><blockquote><p>不是将多刚体运动分割和动态物体的三维结构重建作为单独且顺序的任务来执行，因式分解可以同时完成。给定特征对应关系，动态物体分割和重建会产生分割特征的运动以及它们的三维结构。</p></blockquote><center><img src="/images/2024/05/VSLAM-SfM-Dynamic-7.jpg"></center><h3 id="因式分解"><a href="#因式分解" class="headerlink" title="因式分解"></a>因式分解</h3><blockquote><p>因式分解是 SfM 最突出的技术之一，可以同时解决分割和重建问题。定理：<strong>在静态场景的短序列中，一个测量矩阵，即包含所有通过所有帧跟踪的特征点的矩阵，最多为四阶（如果在欧式空间使用正交投影模型则为三阶）。</strong></p></blockquote><h4 id="多刚体运动结构（MBSfM）"><a href="#多刚体运动结构（MBSfM）" class="headerlink" title="多刚体运动结构（MBSfM）"></a>多刚体运动结构（MBSfM）</h4><p>将刚体相机运动的 SfM 推广到 n 个刚体运动。</p><h4 id="非刚性运动结构（NRSfM）"><a href="#非刚性运动结构（NRSfM）" class="headerlink" title="非刚性运动结构（NRSfM）"></a>非刚性运动结构（NRSfM）</h4><p>基于因式分解在缩放正投影相机模型下的非刚性运动。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="运动分割-1"><a href="#运动分割-1" class="headerlink" title="运动分割"></a>运动分割</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>背景&#x2F;前景初始化</td><td>当移动对象暂时静止时能够跟踪它们，无需进行新的分割。还可以处理退化运动。</td><td>1. 与背景或物体相关的信息需要事先定义<br>2. 基于检测的跟踪方案可能会阻碍实时能力</td></tr><tr><td>几何约束</td><td>不需要关于背景或动态对象的先验知识。</td><td>1. 不具备处理暂时停止的能力<br>2. 无法区分由动态对象引起的剩余误差还是由错误对应（异常值）引起的，无法处理退化运动</td></tr><tr><td>光流</td><td>不需要关于环境的先验知识，可以实时。</td><td>1. 基于亮度恒定假设，对照明条件变化很敏感<br>2. 处理退化运动困难，当物体在停止后开始移动时需要新的分割</td></tr><tr><td>自我运动约束</td><td>通过拟合符合定义的自我运动的特征，轻松地将静态特征与动态特征分割开来，可以实时，能处理退化运动</td><td>需要相机运动的先验知识，当物体暂时静止时，被视为静态场景的一部分</td></tr></tbody></table><h3 id="动态物体分割-1"><a href="#动态物体分割-1" class="headerlink" title="动态物体分割"></a>动态物体分割</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>统计模型选择</td><td>1. 只要系统允许计算低维或低自由度运动，就可以处理退化运动<br>2. 不需要关于环境的先验知识<br>3. 基于统计的方法根据内点集的基数来拟合模型，噪声和异常值会自动得到处理</td><td>从随机采样数据中拟合运动模型在计算上复杂度大。（RANSAC 的迭代次数太大）</td></tr><tr><td>子空间聚类</td><td>时间复杂度低，主要基于代数方法</td><td>1. 不能顺序&#x2F;实时运行<br>2. 需要场景中运动数量或子空间所在维度的信息<br>3. 大多数方法使用仿射相机模型，如果场景包含主要的透视效果，该模型会失败<br>4. 对长序列的实施很困难</td></tr><tr><td>几何</td><td>可以处理非线性流形中的数据</td><td>1. 仅支持基本矩阵作为运动模型，无法处理退化运动<br>2. 计算基本矩阵所需的图像相对于运动数量呈指数增长</td></tr></tbody></table><h3 id="动态物体-3D-跟踪"><a href="#动态物体-3D-跟踪" class="headerlink" title="动态物体 3D 跟踪"></a>动态物体 3D 跟踪</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>轨迹三角测量</td><td>可以逐步进行工作，尽管每次迭代需要几帧，不需要相机运动的先验知识</td><td>1. 限制是物体轨迹应该已知，或应该遵循特定的参数形式（限制了轨迹三角测量在任意物体运动中的应用）<br>2. 处理异常和缺失数据困难，需要几个图像序列才能有唯一解</td></tr><tr><td>粒子滤波</td><td>能够进行动态物体的 3D 重建和跟踪且能实时工作（严格限于少量动态物体），不需要关于物体轨迹的知识</td><td>很难扩展到非刚性重建，不符合恒定速度运动模型</td></tr></tbody></table><h3 id="联合运动分割与重建-1"><a href="#联合运动分割与重建-1" class="headerlink" title="联合运动分割与重建"></a>联合运动分割与重建</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>因式分解</td><td>1. 运动分割和重建问题可以同时解决<br>2. 不需要关于相机运动的知识<br>3. 可以扩展到非刚性重建</td><td>1. 大多数方法基于正投影或仿射相机模型工作，阻止了它在具有大透视效果条件下的实现<br>2. 不能实时，因为所有特征点轨迹必须事先可用，其次大多数方法基于 SVD，复杂度过高<br>3. 可能需要先验知识（场景中动态对象的数量、测量矩阵的秩或物体的维度）<br>4. 对噪声和异常值敏感<br>5. 缺失数据也是一个问题</td></tr></tbody></table><h3 id="深度学习-2"><a href="#深度学习-2" class="headerlink" title="深度学习"></a>深度学习</h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 不需要手动特征提取，会使得特征对应问题的减少（噪声、异常值、跟踪丢失、遮挡导致的缺失数据）<br>2. 不需要指定相机模型<br>3. 学习数据非线性表示的能力提供了不同环境中良好泛化的机会，不需要针对不同环境手动微调算法参数的标准基于特征的方法</td><td>1. 动态物体分割和重建技术涉及几何计算，构建一个能理解这种几何并与标准基于特征的技术相比效果更好的 DNN 架构更难<br>2. 提取的时空特征不精确，并且不理解动态对象的几何形状</td></tr></tbody></table><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cs.ox.ac.uk/files/9926/Visual%20Slam.pdf">cs.ox.ac.uk&#x2F;files&#x2F;9926&#x2F;Visual Slam.pdf</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/">https://blog.jujimeizuo.cn/2024/05/27/Visual-SLAM-and-SfM-in-Dynamic-Environments-A-Survey/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文介绍 &lt;strong&gt;VSLAM&lt;/strong&gt; 和 &lt;strong&gt;SfM&lt;/strong&gt; 在&lt;stro</summary>
      
    
    
    
    
    <category term="3dCV" scheme="https://blog.jujimeizuo.cn/tags/3dCV/"/>
    
  </entry>
  
  <entry>
    <title>volatile in C++</title>
    <link href="https://blog.jujimeizuo.cn/2024/05/25/volatile/"/>
    <id>https://blog.jujimeizuo.cn/2024/05/25/volatile/</id>
    <published>2024-05-25T11:33:34.000Z</published>
    <updated>2025-04-17T01:10:00.019Z</updated>
    
    <content type="html"><![CDATA[<p><strong>volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化.</strong></p><h2 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> _end;  <span class="comment">// _end是什么?</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p = &amp;_end;</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(*p != <span class="number">0xff</span>);</span><br><span class="line">  *p = <span class="number">0x33</span>;</span><br><span class="line">  *p = <span class="number">0x34</span>;</span><br><span class="line">  *p = <span class="number">0x86</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>-O2</code> 编译代码. 尝试去掉代码中的 <code>volatile</code> 关键字, 重新使用 <code>-O2</code> 编译, 并对比去掉 <code>volatile</code> 前后反汇编结果的不同.</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><blockquote><p>如果代码中p指向的地址最终被映射到一个设备寄存器, 去掉volatile可能会带来什么问题?</p></blockquote><ol><li><strong>缓存不一致</strong>：现代计算机系统中，为了提高性能，会使用缓存来存储经常访问的数据。如果没有 <code>volatile</code> 关键字，编译器可能会将p所指向的寄存器值缓存到 CPU 的寄存器中，而不是每次都从内存中读取。这可能会导致其他线程或设备对该寄存器的修改无法及时被当前线程察觉，从而引发错误的结果。</li><li><strong>指令重排序</strong>：编译器和处理器为了提高性能，可能会对指令进行重排序。在单线程环境下，指令重排序通常不会影响程序的正确性。然而，在多线程或与设备交互的环境中，指令重排序可能会导致意外的结果。如果去掉 <code>volatile</code>，编译器可能会对与p相关的指令进行重排序，从而破坏了程序的预期行为。</li><li><strong>设备同步问题</strong>：设备寄存器通常与外部设备进行交互，这些设备可能有自己的时序 要求。如果没有 <code>volatile</code> 关键字，编译器可能会对与设备寄存器的访问进行优化，导致无法满足设备的同步要求。这可能会导致设备无法正常工作或产生错误的结果。</li></ol><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol><li>中断服务程序中修改的供其它程序检测的变量需要加 <code>volatile</code>；</li><li>多任务环境下各任务间共享的标志应该加 <code>volatile</code>；</li><li>存储器映射的硬件寄存器通常也要加 <code>volatile</code> 说明，因为每次对它的读写都可能由不同意义；</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/2.5.html#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">ics2023&#x2F;2.5</a></li><li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">C&#x2F;C++ 中 volatile 关键字详解</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/25/volatile/">https://blog.jujimeizuo.cn/2024/05/25/volatile/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;volatile关键字的作用十分特别, 它的作用是避免编译器对相应代码进行优化.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;e-g&quot;&gt;&lt;a href=&quot;#e-g&quot; class=&quot;headerlink&quot; title=&quot;e.g.&quot;&gt;&lt;/a&gt;e.g.&lt;/h2&gt;&lt;f</summary>
      
    
    
    
    
    <category term="C++" scheme="https://blog.jujimeizuo.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>nvidia-smi unable to load driver</title>
    <link href="https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/"/>
    <id>https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/</id>
    <published>2024-05-17T06:44:50.000Z</published>
    <updated>2025-05-09T07:08:02.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>以下方法，不需要重装驱动，简单快捷。适用于Ubuntu系统下，之前已经安装过驱动，但驱动失效的问题。</li><li>否则需要重新安装驱动，参考<a href="https://blog.csdn.net/wjinjie/article/details/108512153">Ubuntu下安装nvidia显卡驱动</a>。</li></ul></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当使用 <code>nvidia-smi</code> 命令时，出现以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NVIDIA-SMI has failed because it couldn&#x27;t communicate with the NVIDIA driver. </span><br><span class="line">Make sure that the latest NVIDIA driver is installed and running.</span><br></pre></td></tr></table></figure><p>估计问题出现原因是 ubuntu 系统更新了，但是 nvidia 驱动无法连接。</p><h2 id="检查驱动是否存在"><a href="#检查驱动是否存在" class="headerlink" title="检查驱动是否存在"></a>检查驱动是否存在</h2><ul><li>使用 <code>nvcc -V</code> 检查驱动和 cuda。</li></ul><center><img src="/images/2024/05/ns-1.jpg" width="50%"></center><p>发现驱动是存在的。</p><h2 id="查看已安装驱动的版本信息"><a href="#查看已安装驱动的版本信息" class="headerlink" title="查看已安装驱动的版本信息"></a>查看已安装驱动的版本信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/src | grep nvidia</span><br></pre></td></tr></table></figure><center><img src="/images/2024/05/ns-2.jpg" width="50%"></center><p>比如我这里的驱动版本为 nvidia-535.129.03。</p><h2 id="dkms"><a href="#dkms" class="headerlink" title="dkms"></a>dkms</h2><ul><li><code>dkms</code> 是一个框架，用于构建和安装内核模块。它允许你在系统中安装多个内核模块版本，并在内核升级时自动重新编译这些模块。</li><li><code>sudo apt-get install dkms</code></li><li><code>dkms install -m nvidia -v 535.129.03</code></li></ul><p>出现以下错误：</p><center><img src="/images/2024/05/ns-3.jpg" width="50%"></center><p>说明这个版本的文件不存在，需要手动更新。</p><h2 id="更新驱动"><a href="#更新驱动" class="headerlink" title="更新驱动"></a>更新驱动</h2><p>打开软件&amp;更新，根据以下操作选择对应版本（535）。</p><center><img src="/images/2024/05/ns-4.jpg" width="50%"></center><h2 id="重新-dkms"><a href="#重新-dkms" class="headerlink" title="重新 dkms"></a>重新 dkms</h2><center><img src="/images/2024/05/ns-5.jpg" width="50%"></center><p>到这里为止，再次输入 <code>nvidia-smi</code> 就可以查看 GPU 使用状态。</p><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/">https://blog.jujimeizuo.cn/2024/05/17/nvidia-smi-error/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;以下方法，不需要重装驱动，简单快捷。适用于Ubuntu系统下，之前已经安装过驱动，但驱动失效的问题。&lt;/li&gt;
&lt;li&gt;否则需要重新安装驱动，参考&lt;a href=&quot;https://blog.csdn.net/wjinjie/articl</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://blog.jujimeizuo.cn/tags/Linux/"/>
    
    <category term="CUDA" scheme="https://blog.jujimeizuo.cn/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>Manhattan and Chebyshev</title>
    <link href="https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/"/>
    <id>https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/</id>
    <published>2024-04-01T13:33:31.000Z</published>
    <updated>2025-05-09T07:08:02.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的曼哈顿距离为：</p><p>$$<br>d(A, B) &#x3D; |x_1 - x_2| + |y_1 - y_2|<br>$$</p><blockquote><p>性质</p><ol><li>对称性：$d(A,B)&#x3D;d(B,A)$</li><li>三角不等式：$d(A,C) \le d(A,B)+d(B,C)$</li></ol></blockquote><p><strong>距离原点的曼哈顿距离为 1 组成的点：</strong></p><center><img src="/images/2024/04/manhattan.png" alt="曼哈顿"></center><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><p>定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的切比雪夫距离为：</p><p>$$<br>d(A, B) &#x3D; \max ( |x_1 - x_2|, |y_1 - y_2| )<br>$$</p><p><strong>距离原点的切比雪夫距离为 1 组成的点：</strong></p><center><img src="/images/2024/04/chebyshev.png" alt="切比雪夫"></center><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="曼哈顿转切比雪夫"><a href="#曼哈顿转切比雪夫" class="headerlink" title="曼哈顿转切比雪夫"></a>曼哈顿转切比雪夫</h3><p>将代表曼哈顿距离的正方形绕原点逆时针旋转 $\frac{\pi}{4}$，发现两个正方形是相似的，只需要把代表曼哈顿距离的正方形扩大 $\sqrt{2}$ 倍。</p><p>发现原来在代表曼哈顿距离的正方形的四条边上的点 $A(x,y)$ 的坐标由旋转之后变为了<br>$$(x * \cos{\frac{\pi}{4}}-y * \sin{\frac{\pi}{4}}, y * \cos{\frac{\pi}{4}} + x * \sin{\frac{\pi}{4}})$$<br>然后扩大后变为<br>$$A^\prime(\sqrt{2}(x * \cos{\frac{\pi}{4}}-y * \sin{\frac{\pi}{4}}), \sqrt{2}(y * \cos{\frac{\pi}{4}} + x * \sin{\frac{\pi}{4}})) \to A^\prime (x-y, x+y)$$<br>这里的旋转事实上可以理解为坐标轴的旋转。</p><h3 id="切比雪夫转曼哈顿"><a href="#切比雪夫转曼哈顿" class="headerlink" title="切比雪夫转曼哈顿"></a>切比雪夫转曼哈顿</h3><p>通过图形旋转，原来的点 $A(x,y) \to A^\prime(\frac{x+y}{2}, \frac{x-y}{2})$。（由上述逆变换证明）</p><h3 id="恒等式"><a href="#恒等式" class="headerlink" title="恒等式"></a>恒等式</h3><p>$$<br>|x_1 - x_2| + |y_1 - y_2| &#x3D; \max(|x_1^\prime - x_2^\prime|, |y_1^\prime - y_2^\prime|)<br>$$</p><p>其中等式左侧为 $(x_1,y_1)$ 和 $(x_2, y_2)$ 的<strong>曼哈顿距离</strong>，等式右侧 $(x^\prime - y^\prime)&#x3D;(x+y,y-x)$，计算的是 $(x_1^\prime - y_1^\prime)$ 和 $(x_2^\prime - y_2^\prime)$ 两点的曼哈顿距离投影到 $x^\prime$ 轴和 $y^\prime$  轴的线段长度的最大值，即<strong>切比雪夫距离</strong>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://leetcode.cn/problems/minimize-manhattan-distances/description/">3102. 最小化曼哈顿距离</a></li><li><a href="https://zhuanlan.zhihu.com/p/32878257">曼哈顿距离与切比雪夫距离的转换 - 知乎</a></li><li><a href="https://tom0727.github.io/post/063-%E6%9B%BC%E5%93%88%E9%A1%BF-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/">曼哈顿距离 和 切比雪夫距离 - tom0727’s blog</a></li><li><a href="https://www.luogu.com/article/hxr7p6po">常用距离算法详解 - 洛谷专栏</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/">https://blog.jujimeizuo.cn/2024/04/01/Manhattan-and-Chebyshev-switch/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;曼哈顿距离&quot;&gt;&lt;a href=&quot;#曼哈顿距离&quot; class=&quot;headerlink&quot; title=&quot;曼哈顿距离&quot;&gt;&lt;/a&gt;曼哈顿距离&lt;/h2&gt;&lt;p&gt;定义两个点 $A(x_1, y_1), B(x_2, y_2)$，则 $A, B$ 之间的曼哈顿距离为：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Custom Embeddings based on LangChain</title>
    <link href="https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/"/>
    <id>https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/</id>
    <published>2024-01-29T00:39:02.000Z</published>
    <updated>2025-04-17T01:11:37.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-LangChain-自定义-Embeddings"><a href="#基于-LangChain-自定义-Embeddings" class="headerlink" title="基于 LangChain 自定义 Embeddings"></a>基于 LangChain 自定义 Embeddings</h2><blockquote><p>在 LangChain 中支持 OpenAI、LLAMA 等大模型 Embeddings 的调用接口，不过没有内置所有大模型，但是允许用户自定义 Embeddings 类型。 接下来以 ZhipuAI 为例，基于 LangChain 自定义 Embeddings。</p></blockquote><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ul><li>要实现自定义 Embeddings，需要定义一个自定义类继承自 LangChain 的 Embeddings 基类，然后定义三个函数<ul><li><code>_embed</code>: 接受一个字符串，并返回一个存放 Embeddings 的 List[float]，即模型的核心调用</li><li><code>embed_query</code>: 用于对单个字符串 (query) 进行 embedding</li><li><code>embed_documents</code>: 用于对字符串列表 (documents) 进行 embedding</li></ul></li></ul><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span>, <span class="type">Dict</span>, <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.base <span class="keyword">import</span> Embeddings</span><br><span class="line"><span class="keyword">from</span> langchain.pydantic_v1 <span class="keyword">import</span> BaseModel, root_validator</span><br><span class="line"><span class="keyword">from</span> langchain.utils <span class="keyword">import</span> get_from_dict_or_env</span><br></pre></td></tr></table></figure><h3 id="自定义-Embedding"><a href="#自定义-Embedding" class="headerlink" title="自定义 Embedding"></a>自定义 Embedding</h3><h3 id="ZhipuAIEmbeddings"><a href="#ZhipuAIEmbeddings" class="headerlink" title="ZhipuAIEmbeddings"></a>ZhipuAIEmbeddings</h3><p>定义一个继承自 Embeddings 类的自定义 Embeddings 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZhipuAIEmbeddings</span>(BaseModel, Embeddings):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;`Zhipuai Embeddings` embedding models.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    zhipuai_api_key: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Zhipuai application apikey&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><code>root_validator</code> 接收一个函数作为参数，该函数包含需要校验的逻辑。函数应该返回一个字典，其中包含经过校验的数据。如果校验失败，则抛出一个 <code>ValueError</code> 异常。</p><p>装饰器 <code>root_validator</code> 确保导入了相关的包和并配置了相关的 API_Key 这里取巧，在确保导入 zhipuai model 后直接将 <code>zhipuai.model_api</code> 绑定到 client 上，减少和其他 Embeddings 类的差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@root_validator()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate_environment</span>(<span class="params">cls, values: <span class="type">Dict</span></span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    验证环境变量或配置文件中的zhipuai_api_key是否可用。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        values (Dict): 包含配置信息的字典，必须包含 zhipuai_api_key 的字段</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        values (Dict): 包含配置信息的字典。如果环境变量或配置文件中未提供 zhipuai_api_key，则将返回原始值；否则将返回包含 zhipuai_api_key 的值。</span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ValueError: zhipuai package not found, please install it with `pip install</span></span><br><span class="line"><span class="string">        zhipuai`</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    values[<span class="string">&quot;zhipuai_api_key&quot;</span>] = get_from_dict_or_env(</span><br><span class="line">        values,</span><br><span class="line">        <span class="string">&quot;zhipuai_api_key&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ZHIPUAI_API_KEY&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> zhipuai</span><br><span class="line">        zhipuai.api_key = values[<span class="string">&quot;zhipuai_api_key&quot;</span>]</span><br><span class="line">        values[<span class="string">&quot;client&quot;</span>] = zhipuai.model_api</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Zhipuai package not found, please install it with &quot;</span></span><br><span class="line">            <span class="string">&quot;`pip install zhipuai`&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h3 id="Override-embed"><a href="#Override-embed" class="headerlink" title="Override _embed"></a>Override _embed</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_embed</span>(<span class="params">self, texts: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本的 embedding。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        texts (str): 要生成 embedding 的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        embeddings (List[float]): 输入文本的 embedding，一个浮点数值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = self.client.invoke(</span><br><span class="line">            model=<span class="string">&quot;text_embedding&quot;</span>,</span><br><span class="line">            prompt=texts</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Error raised by inference endpoint: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp[<span class="string">&quot;code&quot;</span>] != <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">&quot;Error raised by inference API HTTP code: %s, %s&quot;</span></span><br><span class="line">            % (resp[<span class="string">&quot;code&quot;</span>], resp[<span class="string">&quot;msg&quot;</span>])</span><br><span class="line">        )</span><br><span class="line">    embeddings = resp[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;embedding&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> embeddings</span><br></pre></td></tr></table></figure><h3 id="Override-embed-documents"><a href="#Override-embed-documents" class="headerlink" title="Override embed_documents"></a>Override embed_documents</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">embed_documents</span>(<span class="params">self, texts: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本列表的 embedding。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        texts (List[str]): 要生成 embedding 的文本列表.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List[List[float]]: 输入列表中每个文档的 embedding 列表。每个 embedding 都表示为一个浮点值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [self._embed(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br></pre></td></tr></table></figure><h3 id="Override-embed-query"><a href="#Override-embed-query" class="headerlink" title="Override embed_query"></a>Override embed_query</h3><p><code>embed_query</code> 是对单个文本计算 embedding 的方法，因为我们已经定义好对文档列表计算 embedding 的方法 <code>embed_documents</code> 了，这里可以直接将单个文本组装成 list 的形式传给 <code>embed_documents</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">embed_query</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成输入文本的 embedding。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        text (str): 要生成 embedding 的文本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        List [float]: 输入文本的 embedding，一个浮点数值列表。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    resp = self.embed_documents([text])</span><br><span class="line">    <span class="keyword">return</span> resp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/">https://blog.jujimeizuo.cn/2024/01/29/custom-embeddings-based-on-langchain/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于-LangChain-自定义-Embeddings&quot;&gt;&lt;a href=&quot;#基于-LangChain-自定义-Embeddings&quot; class=&quot;headerlink&quot; title=&quot;基于 LangChain 自定义 Embeddings&quot;&gt;&lt;/a&gt;基于 La</summary>
      
    
    
    
    
    <category term="LLM" scheme="https://blog.jujimeizuo.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>AcWing 5383. 收集饰品</title>
    <link href="https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/"/>
    <id>https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/</id>
    <published>2024-01-06T13:12:49.000Z</published>
    <updated>2024-04-01T11:19:02.092Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.acwing.com/problem/content/5386/">5383. 收集饰品</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>背包dp + 状压dp，非常巧妙的做法</p><p>现按照 k 从小到达排序，将每个饰品看成一个二进制位，每个宝箱可以让几个二进制位为 1，现在问题变成，选择若干宝箱，让每个二进制位变成 1 的最小花费，这是个典型的背包。</p><p>状态转移方程：</p><p>$$ dp[j | mask[i]] &#x3D; std::min(dp[j | mask[i]], dp[j] + x[i]); $$</p><p>复杂度：$O(n2^m)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    author:  jujimeizuo</span></span><br><span class="line"><span class="comment"> *    created: 2024-01-06 20:35:26</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algo/debug.h&quot;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> debug(...) 42</span></span><br><span class="line">#<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, b;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; b;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(n)</span>, <span class="title">k</span><span class="params">(n)</span>, <span class="title">mask</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        std::cin &gt;&gt; x[i] &gt;&gt; k[i] &gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            std::cin &gt;&gt; id;</span><br><span class="line">            mask[i] = <span class="number">1</span> &lt;&lt; (id - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(order.<span class="built_in">begin</span>(), order.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> k[i] &lt; k[j];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int64_t</span> inf = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">max</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int64_t</span> ans = inf;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int64_t</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; m, inf)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j += <span class="number">1</span>) &#123;</span><br><span class="line">            dp[j | mask[order[i]]] = std::<span class="built_in">min</span>(dp[j | mask[order[i]]], dp[j] + x[order[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] + <span class="built_in">int64_t</span>(<span class="number">1</span>) * k[order[i]] * b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == inf) &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/">https://blog.jujimeizuo.cn/2024/01/06/acwing-5383/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;传送门：&lt;a href=&quot;https://www.acwing.com/problem/content/5386/&quot;&gt;5383. 收集饰品&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Gosper&#39;s Hack Optimization</title>
    <link href="https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/"/>
    <id>https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/</id>
    <published>2024-01-04T03:22:47.000Z</published>
    <updated>2025-04-17T01:12:09.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们在n个数中选择m个数字，通常的做法是回溯法、状态压缩（二进制枚举）等等。这样的复杂度是 $O(2^n)$，而 Gosper’s Hack 可以在O(1)的时间内找到下一个枚举状态。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>从后往前找到第一个降序（即”01”），然后将其变为”10”，</li><li>最后将该”10”后面的序列逆转即可。</li></ol><p>假设当前状态 cur 为 0110(01)1000，那么下一个状态为 0110(10)0001</p><ol><li>cur + lowbit &#x3D; r, 前半部分，0110(10)xxxx</li><li>r ^ cur，记录变化的位数（例如一位就是0001，两位就是0011），移除”01”变为”10”的2次。”10”后面就是变化次数-2。xxxxxx(10)0001</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">next_status</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lowbit = cur &amp; -cur;</span><br><span class="line">    <span class="type">int</span> r = cur + lowbit;</span><br><span class="line">    <span class="keyword">return</span> (((r ^ cur) &gt;&gt; <span class="number">2</span>) / lowbit)  r;</span><br><span class="line">    <span class="comment">// return ((r ^ cur) &gt;&gt; __builtin_ctz(lowbit) + 2)  r;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">next_status</span>(<span class="params">cur: <span class="built_in">int</span></span>):</span><br><span class="line">    lowbit = cur &amp; -cur</span><br><span class="line">    r = cur + lowbit</span><br><span class="line">    <span class="keyword">return</span> (((r ^ cur) &gt;&gt; <span class="number">2</span>) // lowbit)  r</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    def count_trailing_zeros(x):</span></span><br><span class="line"><span class="string">        return (x &amp; -x).bit_length() - 1</span></span><br><span class="line"><span class="string">    return ((r ^ cur) &gt;&gt; count_trailing_zeros(lowbit) + 2)  r</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://programmingforinsomniacs.blogspot.com/2018/03/gospers-hack-explained.html">ProgrammingForInsomniacs</a></li><li><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/?envType=daily-question&envId=2024-01-04">2397. 被列覆盖的最多行数</a></li><li><a href="https://leetcode.cn/problems/next-permutation/description/">31. 下一个排列</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/">https://blog.jujimeizuo.cn/2024/01/04/gospers-hack/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当我们在n个数中选择m个数字，通常的做法是回溯法、状态压缩（二进制枚举）等等。这样的复杂度是 $O(2^n)$，而 Gosper’s Hac</summary>
      
    
    
    
    
    <category term="ACM" scheme="https://blog.jujimeizuo.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>clash for linux</title>
    <link href="https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/"/>
    <id>https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/</id>
    <published>2023-11-24T01:36:57.000Z</published>
    <updated>2024-04-01T11:44:47.273Z</updated>
    
    <content type="html"><![CDATA[<p>由于作者已经跑路，所以使用下面的备份仓库：</p><center><div class="github-card" data-github="Elegybackup/clash-for-linux-backup" data-width="400" data-height="" data-theme="default"></div><script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></center><h2 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h2><ul><li>运行本项目建议使用root用户，或者使用 sudo 提权。</li><li>使用过程中如遇到问题，请优先查已有的 <a href="https://github.com/Elegybackup/clash-for-linux-backup/issues">issues</a>。</li><li>在进行issues提交前，请替换提交内容中是敏感信息（例如：订阅地址）。</li><li>本项目是基于 <a href="https://github.com/Dreamacro/clash">clash（已跑路）</a> 、<a href="https://github.com/haishanh/yacd">yacd</a> 进行的配置整合，关于clash、yacd的详细配置请去原项目查看。</li><li>此项目不提供任何订阅信息，请自行准备Clash订阅地址。</li><li>运行前请手动更改<code>.env</code>文件中的<code>CLASH_URL</code>变量值，否则无法正常运行。</li><li>当前在RHEL系列和Debian,Kali Linux,ubuntu以及Linux系统中测试过，其他系列可能需要适当修改脚本。</li><li>支持 x86_64&#x2F;aarch64 平台</li><li>【注意：kali Linux需要在浏览器设置代理！否则有可能无法使用！】</li></ul><blockquote><p><strong>注意</strong>：当你在使用此项目时，遇到任何无法独自解决的问题请优先前往 <a href="https://github.com/wanhebin/clash-for-linux/issues">Issues</a> 寻找解决方法。由于空闲时间有限，后续将不再对Issues中 “已经解答”、“已有解决方案” 的问题进行重复性的回答。</p></blockquote><br><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><p>下载项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Elegybackup/clash-for-linux-backup.git</span><br></pre></td></tr></table></figure><p>进入到项目目录，编辑<code>.env</code>文件，修改变量<code>CLASH_URL</code>的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br><span class="line">$ vim .<span class="built_in">env</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> <code>.env</code> 文件中的变量 <code>CLASH_SECRET</code> 为自定义 Clash Secret，值为空时，脚本将自动生成随机字符串。</p></blockquote><br><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><p>直接运行脚本文件<code>start.sh</code></p><ul><li>进入项目目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure><ul><li>运行启动脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash start.sh</span><br><span class="line"></span><br><span class="line">正在检测订阅地址...</span><br><span class="line">Clash订阅地址可访问！                                      [  OK  ]</span><br><span class="line"></span><br><span class="line">正在下载Clash配置文件...</span><br><span class="line">配置文件config.yaml下载成功！                              [  OK  ]</span><br><span class="line"></span><br><span class="line">正在启动Clash服务...</span><br><span class="line">服务启动成功！                                             [  OK  ]</span><br><span class="line"></span><br><span class="line">Clash Dashboard 访问地址：http://&lt;ip&gt;:9090/ui</span><br><span class="line">Secret：xxxxxxxxxxxxx</span><br><span class="line"></span><br><span class="line">请执行以下命令加载环境变量: <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line"></span><br><span class="line">请执行以下命令开启系统代理: proxy_on</span><br><span class="line"></span><br><span class="line">若要临时关闭系统代理，请执行: proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line">$ proxy_on</span><br></pre></td></tr></table></figure><ul><li>检查服务端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -tln | grep -E <span class="string">&#x27;9090|789.&#x27;</span></span><br><span class="line">tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 :::7890                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7891                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::7892                 :::*                    LISTEN</span><br></pre></td></tr></table></figure><ul><li>检查环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">env</span> | grep -E <span class="string">&#x27;http_proxy|https_proxy&#x27;</span></span><br><span class="line">http_proxy=http://127.0.0.1:7890</span><br><span class="line">https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>以上步鄹如果正常，说明服务clash程序启动成功，现在就可以体验高速下载github资源了。</p><br><h2 id="重启程序"><a href="#重启程序" class="headerlink" title="重启程序"></a>重启程序</h2><p>如果需要对Clash配置进行修改，请修改 <code>conf/config.yaml</code> 文件。然后运行 <code>restart.sh</code> 脚本进行重启。</p><blockquote><p><strong>注意：</strong><br>重启脚本 <code>restart.sh</code> 不会更新订阅信息。</p></blockquote><br><h3 id="停止程序"><a href="#停止程序" class="headerlink" title="停止程序"></a>停止程序</h3><ul><li>进入项目目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> clash-for-linux</span><br></pre></td></tr></table></figure><ul><li>关闭服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo bash shutdown.sh</span><br><span class="line"></span><br><span class="line">服务关闭成功，请执行以下命令关闭系统代理：proxy_off</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ proxy_off</span><br></pre></td></tr></table></figure><p>然后检查程序端口、进程以及环境变量<code>http_proxy|https_proxy</code>，若都没则说明服务正常关闭。</p><br><h3 id="Clash-Dashboard"><a href="#Clash-Dashboard" class="headerlink" title="Clash Dashboard"></a>Clash Dashboard</h3><ul><li>访问 Clash Dashboard</li></ul><p>通过浏览器访问 <code>start.sh</code> 执行成功后输出的地址，例如：<a href="http://192.168.0.1:9090/ui">http://192.168.0.1:9090/ui</a></p><ul><li>登录管理界面</li></ul><p>在<code>API Base URL</code>一栏中输入：http:&#x2F;&#x2F;&lt;ip&gt;:9090 ，在<code>Secret(optional)</code>一栏中输入启动成功后输出的Secret。</p><p>点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置。</p><ul><li>更多教程</li></ul><p>此 Clash Dashboard 使用的是<a href="https://github.com/haishanh/yacd">yacd</a>项目，详细使用方法请移步到yacd上查询。</p><br><h3 id="终端界面选择代理节点"><a href="#终端界面选择代理节点" class="headerlink" title="终端界面选择代理节点"></a>终端界面选择代理节点</h3><p>部分用户无法通过浏览器使用 Clash Dashboard 进行节点选择、代理模式修改等操作，为了方便用户可以在Linux终端进行操作，下面提供了一个功能简单的脚本以便用户可以临时通过终端界面进行配置。</p><p>脚本存放位置：<code>scripts/clash_proxy-selector.sh</code></p><blockquote><p><strong>注意：</strong></p><p>使用脚本前，需要修改脚本中的 <strong>Secret</strong> 变量值为上述启动脚本输出的值，或者与 <code>.env</code> 文件中定义的 <strong>CLASH_SECRET</strong> 变量值保持一致。</p></blockquote><br><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/">https://blog.jujimeizuo.cn/2023/11/24/clash-for-linux/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于作者已经跑路，所以使用下面的备份仓库：&lt;/p&gt;
&lt;center&gt;
&lt;div class=&quot;github-card&quot; data-github=&quot;Elegybackup/clash-for-linux-backup&quot; data-width=&quot;400&quot; data-height</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>利用 iOS 的快捷指令配合 GitHub Actions 实现自动化</title>
    <link href="https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/"/>
    <id>https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/</id>
    <published>2023-10-06T15:25:27.000Z</published>
    <updated>2025-05-09T07:08:03.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要通过快捷指令实现自动化"><a href="#为什么需要通过快捷指令实现自动化" class="headerlink" title="为什么需要通过快捷指令实现自动化"></a>为什么需要通过快捷指令实现自动化</h2><ul><li>最初的 Github Actions 需要 crontab 来定时进行自动化，这样做不仅消耗过多资源，而且在完成某个任务时不会立即获取新生成的数据。</li><li>如果我可以完成某个特定动作，例如关闭闹钟、充电、关闭 APP 时自动进行 Actions时，这样做非常高效，方法是可以利用快捷指令触发 Actions 同步数据</li><li>下面拿跑步举例，一般会用 app（我用的是 keep）来记录跑步数据，实现的操作是当关闭 keep 时会自动进行 Actions，更新数据</li></ul><h2 id="如何触发-Actions"><a href="#如何触发-Actions" class="headerlink" title="如何触发 Actions"></a>如何触发 Actions</h2><ul><li><p>首先在 yml 文件中增加 <code>workflow_dispatch</code>: 可以手动触发</p><p><img src="/images/2023/10/workflow_dispatch.jpg" alt="srcworkflow_dispatch"></p></li><li><p>先拿到这个项目的 actions id (需要自行申请 token)</p><ul><li><p>在个人的 settings 中申请 项目的token，然后在项目里的 Secrets and variables 里的 Actions 设置密钥，内容为刚刚申请的 token</p></li><li><p>执行下面代码获取 actionid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.github.com/repos/jujimeizuo/running_page/actions/workflows -H &quot;Authorization: token d8xxxxxxxxxx&quot; ## change to your config</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/2023/10/get-action-id.jpg" alt="get-action-id"></p></li><li><p>拿到 action id 就可以利用 api post 触发 action 啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;inputs&quot;: &#123;&#125;, &quot;ref&quot;:&quot;master&quot;&#125;&#x27; https://api.github.com/repos/jujimeizu/running_page/actions/workflows/: $&#123;actionid&#125;/dispatches -H &quot;Authorization: token d8e03d6xxxxxxxxxxxx&quot;  ## change to your config</span><br></pre></td></tr></table></figure></li></ul><h2 id="结合快捷指令"><a href="#结合快捷指令" class="headerlink" title="结合快捷指令"></a>结合快捷指令</h2><h3 id="快捷指令"><a href="#快捷指令" class="headerlink" title="快捷指令"></a>快捷指令</h3><ul><li>通过 icloud 获取 <a href="https://www.icloud.com/shortcuts/4a5807a98b9a4e359815ff179c62bacb">running-page-template</a></li><li>修改下面图片中字典的值即可</li></ul><p><img src="/images/2023/10/running-page-template.jpg" alt="running-page-template"></p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p><img src="/images/2023/10/new-automation.png" alt="new-automation"> <img src="/images/2023/10/select-close.png" alt="select-close"></p><p><img src="/images/2023/10/select-shortcut.png" alt="select-shortcut"> <img src="/images/2023/10/finish-automation.png" alt="finish-automation"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>可以通过关闭闹钟来同步自己的起床记录——这也是 yihong 大神写的</li><li>可以利用一个 action 触发另一个项目的 action，实现另一个 repo 的更新</li><li>…</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/yihong0618/gitblog/issues/198">yihong0618 大神</a></li></ul><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/">https://blog.jujimeizuo.cn/2023/10/06/shortcut-github-actions-automation/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么需要通过快捷指令实现自动化&quot;&gt;&lt;a href=&quot;#为什么需要通过快捷指令实现自动化&quot; class=&quot;headerlink&quot; title=&quot;为什么需要通过快捷指令实现自动化&quot;&gt;&lt;/a&gt;为什么需要通过快捷指令实现自动化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最初的 Gith</summary>
      
    
    
    
    
    <category term="utils" scheme="https://blog.jujimeizuo.cn/tags/utils/"/>
    
  </entry>
  
  <entry>
    <title>Macos通过SSH连接显示docker容器的GUI界面（ROS1小乌龟为例）</title>
    <link href="https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/"/>
    <id>https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/</id>
    <published>2023-07-28T14:06:08.000Z</published>
    <updated>2025-05-09T07:08:03.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-软硬件设置"><a href="#1-软硬件设置" class="headerlink" title="1 软硬件设置"></a>1 软硬件设置</h2><ul><li>Macbook M1 pro</li><li>docker - ubuntu18.04</li></ul><h2 id="2-配置远程服务器（ubuntu18-04）"><a href="#2-配置远程服务器（ubuntu18-04）" class="headerlink" title="2 配置远程服务器（ubuntu18.04）"></a>2 配置远程服务器（ubuntu18.04）</h2><h3 id="2-1-安装工具包"><a href="#2-1-安装工具包" class="headerlink" title="2.1 安装工具包"></a>2.1 安装工具包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器名称 /bin/sh</span><br><span class="line">apt update</span><br><span class="line">apt install openssh-server</span><br><span class="line">apt install x11-apps</span><br><span class="line">apt install vim</span><br><span class="line">passwd   <span class="comment"># 给root账号赋予密码</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置SSH服务端"><a href="#2-2-配置SSH服务端" class="headerlink" title="2.2 配置SSH服务端"></a>2.2 配置SSH服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">## 修改以下内容，端口可以自己设置，默认是22，和启动容器的映射端口对应</span></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line">X11Forwarding <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h3 id="2-3-重启服务"><a href="#2-3-重启服务" class="headerlink" title="2.3 重启服务"></a>2.3 重启服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><h3 id="2-4-连接docker测试"><a href="#2-4-连接docker测试" class="headerlink" title="2.4 连接docker测试"></a>2.4 连接docker测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p docker端口 root@远程IP</span><br></pre></td></tr></table></figure><h2 id="3-本地Macos配置"><a href="#3-本地Macos配置" class="headerlink" title="3 本地Macos配置"></a>3 本地Macos配置</h2><h3 id="3-1-安装Xquartz"><a href="#3-1-安装Xquartz" class="headerlink" title="3.1 安装Xquartz"></a>3.1 安装Xquartz</h3><p><a href="https://www.xquartz.org/">Xquartz官网</a></p><h3 id="3-2-Xquartz设置"><a href="#3-2-Xquartz设置" class="headerlink" title="3.2 Xquartz设置"></a>3.2 Xquartz设置</h3><ol><li>XQuartz -&gt; 偏好设置 -&gt; 安全性 -&gt; 勾选“允许从网络客户端连接” -&gt; 退出程序；</li><li>终端键入 xhost + ip（注意两者之间的空格）重新启动 XQuartz；为远程主机添加权限 或者xhost +为所有IP添加权限</li><li>ssh -XY <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#48;&#46;&#48;&#x2e;&#48;&#46;&#48;">&#x72;&#111;&#111;&#116;&#x40;&#48;&#46;&#48;&#x2e;&#48;&#46;&#48;</a> -p 6100</li><li>netstat -an grep -F 6100 查看</li></ol><p>xquartz操作后需要重启。</p><h3 id="3-3-docker进入"><a href="#3-3-docker进入" class="headerlink" title="3.3 docker进入"></a>3.3 docker进入</h3><p>在 run 或 exec 容器时加入-e DISPLAY&#x3D;host.docker.internal:0参数，比如我这里通过对一个现有的，已经安装过 xarclock 时钟小程序的容器 toyOS 执行docker exec -ite DISPLAY&#x3D;host.docker.internal:0 toyOS &#x2F;usr&#x2F;bin&#x2F;xarclock，就会在我的本地出现一个小时钟的GUI程序；</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ite DISPLAY=host.docker.internal:0 ub18.04-orb-slam2 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="3-4-测试ros小乌龟"><a href="#3-4-测试ros小乌龟" class="headerlink" title="3.4 测试ros小乌龟"></a>3.4 测试ros小乌龟</h3><p>tmux设置三个终端</p><p>如下图所示：</p><p><img src="/images/2023/07/image-1690552905696.png" alt="file"></p><p>也可以在docker内部执行，设置环境变量指定显示端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=host.docker.internal:0  </span><br></pre></td></tr></table></figure><p><b>本文作者：jujimeizuo</b><br /><b>本文地址<b/>： <a href="https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/">https://blog.jujimeizuo.cn/2023/07/28/macos-connect-to-docker-to-using-gui-by-ssh/</a> <br /><b>本博客所有文章除特别声明外，均采用 CC BY-SA 3.0 协议。转载请注明出处！</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-软硬件设置&quot;&gt;&lt;a href=&quot;#1-软硬件设置&quot; class=&quot;headerlink&quot; title=&quot;1 软硬件设置&quot;&gt;&lt;/a&gt;1 软硬件设置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Macbook M1 pro&lt;/li&gt;
&lt;li&gt;docker - ubuntu18.04</summary>
      
    
    
    
    
    <category term="linux" scheme="https://blog.jujimeizuo.cn/tags/linux/"/>
    
    <category term="Docker" scheme="https://blog.jujimeizuo.cn/tags/Docker/"/>
    
    <category term="ros" scheme="https://blog.jujimeizuo.cn/tags/ros/"/>
    
  </entry>
  
</feed>
